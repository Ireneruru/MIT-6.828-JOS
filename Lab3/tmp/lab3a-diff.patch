diff --git a/COPYRIGHT b/COPYRIGHT
new file mode 100644
index 0000000..6a0270c
--- /dev/null
+++ b/COPYRIGHT
@@ -0,0 +1,155 @@
+Most of the source files in this directory are derived from the Exokernel,
+which is:
+
+/*
+ * Copyright (C) 1997 Massachusetts Institute of Technology 
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ * The name and trademarks of copyright holders may NOT be used in
+ * advertising or publicity pertaining to the software without specific,
+ * written prior permission. Title to copyright in this software and any
+ * associated documentation will at all times remain with copyright
+ * holders. See the file AUTHORS which should have accompanied this software
+ * for a list of all copyright holders.
+ *
+ * This file may be derived from previously copyrighted software. This
+ * copyright applies only to those changes made by the copyright
+ * holders listed in the AUTHORS file. The rest of this file is covered by
+ * the copyright notices, if any, listed below.
+ */
+
+Console.c was created consulting the NetBSD pccons driver which is:
+
+/*-
+ * Copyright (c) 1993, 1994, 1995 Charles Hannum.  All rights reserved.
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * William Jolitz and Don Ahn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+Kclock.h, sched.h, and printf.h are copyright:
+
+/*
+ * Copyright (C) 1998 Exotec, Inc.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ * The name and trademarks of copyright holders may NOT be used in
+ * advertising or publicity pertaining to the software without specific,
+ * written prior permission. Title to copyright in this software and any
+ * associated documentation will at all times remain with Exotec, Inc..
+ *
+ * This file may be derived from previously copyrighted software. This
+ * copyright applies only to those changes made by Exotec, Inc. The rest
+ * of this file is covered by the copyright notices, if any, listed below.
+ */
+
+Printf.c is copyright:
+
+/*-
+ * Copyright (c) 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
+ */
+
diff --git a/GNUmakefile b/GNUmakefile
index 0f336f3..9366ac2 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -83,10 +83,12 @@ PERL	:= perl
 # Compiler flags
 # -fno-builtin is required to avoid refs to undefined functions in the kernel.
 # Only optimize to -O1 to discourage inlining, which complicates backtraces.
-CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MD
+#CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MD
+CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -fno-builtin -I$(TOP) -MD
 CFLAGS += -fno-omit-frame-pointer
 CFLAGS += -std=gnu99
 CFLAGS += -static
+
 CFLAGS += -Wall -Wno-format -Wno-unused -Werror -gstabs -m32
 # -fno-tree-ch prevented gcc from sometimes reordering read_ebp() before
 # mon_backtrace()'s function prologue on gcc version: (Debian 4.7.2-5) 4.7.2
diff --git a/Makefrag b/Makefrag
new file mode 100644
index 0000000..3b2982e
--- /dev/null
+++ b/Makefrag
@@ -0,0 +1,89 @@
+#
+# Makefile fragment for JOS kernel.
+# This is NOT a complete makefile;
+# you must run GNU make in the top-level directory
+# where the GNUmakefile is located.
+#
+
+OBJDIRS += kern
+
+KERN_LDFLAGS := $(LDFLAGS) -T kern/kernel.ld -nostdlib
+
+# entry.S must be first, so that it's the first code in the text segment!!!
+#
+# We also snatch the use of a couple handy source files
+# from the lib directory, to avoid gratuitous code duplication.
+KERN_SRCFILES :=	kern/entry.S \
+			kern/entrypgdir.c \
+			kern/init.c \
+			kern/console.c \
+			kern/monitor.c \
+			kern/pmap.c \
+			kern/env.c \
+			kern/kclock.c \
+			kern/picirq.c \
+			kern/printf.c \
+			kern/trap.c \
+			kern/trapentry.S \
+			kern/sched.c \
+			kern/syscall.c \
+			kern/kdebug.c \
+			lib/printfmt.c \
+			lib/readline.c \
+			lib/string.c
+
+# Only build files if they exist.
+KERN_SRCFILES := $(wildcard $(KERN_SRCFILES))
+
+# Binary program images to embed within the kernel.
+KERN_BINFILES := 
+
+KERN_OBJFILES := $(patsubst %.c, $(OBJDIR)/%.o, $(KERN_SRCFILES))
+KERN_OBJFILES := $(patsubst %.S, $(OBJDIR)/%.o, $(KERN_OBJFILES))
+KERN_OBJFILES := $(patsubst $(OBJDIR)/lib/%, $(OBJDIR)/kern/%, $(KERN_OBJFILES))
+
+KERN_BINFILES := $(patsubst %, $(OBJDIR)/%, $(KERN_BINFILES))
+
+# How to build kernel object files
+$(OBJDIR)/kern/%.o: kern/%.c $(OBJDIR)/.vars.KERN_CFLAGS
+	@echo + cc $<
+	@mkdir -p $(@D)
+	$(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $<
+
+$(OBJDIR)/kern/%.o: kern/%.S $(OBJDIR)/.vars.KERN_CFLAGS
+	@echo + as $<
+	@mkdir -p $(@D)
+	$(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $<
+
+$(OBJDIR)/kern/%.o: lib/%.c $(OBJDIR)/.vars.KERN_CFLAGS
+	@echo + cc $<
+	@mkdir -p $(@D)
+	$(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $<
+
+# Special flags for kern/init
+$(OBJDIR)/kern/init.o: override KERN_CFLAGS+=$(INIT_CFLAGS)
+$(OBJDIR)/kern/init.o: $(OBJDIR)/.vars.INIT_CFLAGS
+
+# How to build the kernel itself
+$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) kern/kernel.ld \
+	  $(OBJDIR)/.vars.KERN_LDFLAGS
+	@echo + ld $@
+	$(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES)
+	$(V)$(OBJDUMP) -S $@ > $@.asm
+	$(V)$(NM) -n $@ > $@.sym
+
+# How to build the kernel disk image
+$(OBJDIR)/kern/kernel.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot
+	@echo + mk $@
+	$(V)dd if=/dev/zero of=$(OBJDIR)/kern/kernel.img~ count=10000 2>/dev/null
+	$(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/kernel.img~ conv=notrunc 2>/dev/null
+	$(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/kernel.img~ seek=1 conv=notrunc 2>/dev/null
+	$(V)mv $(OBJDIR)/kern/kernel.img~ $(OBJDIR)/kern/kernel.img
+
+all: $(OBJDIR)/kern/kernel.img
+
+grub: $(OBJDIR)/jos-grub
+
+$(OBJDIR)/jos-grub: $(OBJDIR)/kern/kernel
+	@echo + oc $@
+	$(V)$(OBJCOPY) --adjust-vma=0x10000000 $^ $@
diff --git a/gradelib.pyc b/gradelib.pyc
new file mode 100644
index 0000000..f31811f
Binary files /dev/null and b/gradelib.pyc differ
diff --git a/inc/.mmu.h.swp b/inc/.mmu.h.swp
new file mode 100644
index 0000000..4afdd8f
Binary files /dev/null and b/inc/.mmu.h.swp differ
diff --git a/inc/.trap.h.swp b/inc/.trap.h.swp
new file mode 100644
index 0000000..f99c660
Binary files /dev/null and b/inc/.trap.h.swp differ
diff --git a/inc/color.h b/inc/color.h
new file mode 100644
index 0000000..ed09ec1
--- /dev/null
+++ b/inc/color.h
@@ -0,0 +1,3 @@
+int FG_COLOR;
+int BG_COLOR;
+int COLOR;
diff --git a/inc/memlayout.h b/inc/memlayout.h
index a537b15..7ebe333 100644
--- a/inc/memlayout.h
+++ b/inc/memlayout.h
@@ -47,7 +47,7 @@
  *                     |       Memory-mapped I/O      | RW/--  PTSIZE
  * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
  *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
- *    UVPT      ---->  +------------------------------+ 0xef400000
+ *    UVPT      ---->  +------------------------------+ show
  *                     |          RO PAGES            | R-/R-  PTSIZE
  *    UPAGES    ---->  +------------------------------+ 0xef000000
  *                     |           RO ENVS            | R-/R-  PTSIZE
@@ -56,7 +56,7 @@
  *                     +------------------------------+ 0xeebff000
  *                     |       Empty Memory (*)       | --/--  PGSIZE
  *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
- *                     |      Normal User Stack       | RW/RW  PGSIZE
+ *                     |      Normal x Stack       | RW/RW  PGSIZE
  *                     +------------------------------+ 0xeebfd000
  *                     |                              |
  *                     |                              |
diff --git a/inc/memlayout.h~ b/inc/memlayout.h~
new file mode 100644
index 0000000..a90a638
--- /dev/null
+++ b/inc/memlayout.h~
@@ -0,0 +1,188 @@
+#ifndef JOS_INC_MEMLAYOUT_H
+#define JOS_INC_MEMLAYOUT_H
+
+#ifndef __ASSEMBLER__
+#include <inc/types.h>
+#include <inc/mmu.h>
+#endif /* not __ASSEMBLER__ */
+
+/*
+ * This file contains definitions for memory management in our OS,
+ * which are relevant to both the kernel and user-mode software.
+ */
+
+// Global descriptor numbers
+#define GD_KT     0x08     // kernel text
+#define GD_KD     0x10     // kernel data
+#define GD_UT     0x18     // user text
+#define GD_UD     0x20     // user data
+#define GD_TSS0   0x28     // Task segment selector for CPU 0
+
+/*
+ * Virtual memory map:                                Permissions
+ *                                                    kernel/user
+ *
+ *    4 Gig -------->  +------------------------------+
+ *                     |                              | RW/--
+ *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                     :              .               :
+ *                     :              .               :
+ *                     :              .               :
+ *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
+ *                     |                              | RW/--
+ *                     |   Remapped Physical Memory   | RW/--
+ *                     |                              | RW/--
+ *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
+ *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
+ *                     | - - - - - - - - - - - - - - -|                   |
+ *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
+ *                     +------------------------------+                   |
+ *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
+ *                     | - - - - - - - - - - - - - - -|                 PTSIZE
+ *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
+ *                     +------------------------------+                   |
+ *                     :              .               :                   |
+ *                     :              .               :                   |
+ *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
+ *                     |       Memory-mapped I/O      | RW/--  PTSIZE
+ * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
+ *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
+ *    UVPT      ---->  +------------------------------+ show
+ *                     |          RO PAGES            | R-/R-  PTSIZE
+ *    UPAGES    ---->  +------------------------------+ 0xef000000
+ *                     |           RO ENVS            | R-/R-  PTSIZE
+ * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
+ * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
+ *                     +------------------------------+ 0xeebff000
+ *                     |       Empty Memory (*)       | --/--  PGSIZE
+ *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
+ *                     |      Normal User Stack       | RW/RW  PGSIZE
+ *                     +------------------------------+ 0xeebfd000
+ *                     |                              |
+ *                     |                              |
+ *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                     .                              .
+ *                     .                              .
+ *                     .                              .
+ *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
+ *                     |     Program Data & Heap      |
+ *    UTEXT -------->  +------------------------------+ 0x00800000
+ *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
+ *                     |                              |
+ *    UTEMP -------->  +------------------------------+ 0x00400000      --+
+ *                     |       Empty Memory (*)       |                   |
+ *                     | - - - - - - - - - - - - - - -|                   |
+ *                     |  User STAB Data (optional)   |                 PTSIZE
+ *    USTABDATA ---->  +------------------------------+ 0x00200000        |
+ *                     |       Empty Memory (*)       |                   |
+ *    0 ------------>  +------------------------------+                 --+
+ *
+ * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
+ *     "Empty Memory" is normally unmapped, but user programs may map pages
+ *     there if desired.  JOS user programs map pages temporarily at UTEMP.
+ */
+
+
+// All physical memory mapped at this address
+#define	KERNBASE	0xF0000000
+
+// At IOPHYSMEM (640K) there is a 384K hole for I/O.  From the kernel,
+// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM.  The hole ends
+// at physical address EXTPHYSMEM.
+#define IOPHYSMEM	0x0A0000
+#define EXTPHYSMEM	0x100000
+
+// Kernel stack.
+#define KSTACKTOP	KERNBASE
+#define KSTKSIZE	(8*PGSIZE)   		// size of a kernel stack
+#define KSTKGAP		(8*PGSIZE)   		// size of a kernel stack guard
+
+// Memory-mapped IO.
+#define MMIOLIM		(KSTACKTOP - PTSIZE)
+#define MMIOBASE	(MMIOLIM - PTSIZE)
+
+#define ULIM		(MMIOBASE)
+
+/*
+ * User read-only mappings! Anything below here til UTOP are readonly to user.
+ * They are global pages mapped in at env allocation time.
+ */
+
+// User read-only virtual page table (see 'uvpt' below)
+#define UVPT		(ULIM - PTSIZE)
+// Read-only copies of the Page structures
+#define UPAGES		(UVPT - PTSIZE)
+// Read-only copies of the global env structures
+#define UENVS		(UPAGES - PTSIZE)
+
+/*
+ * Top of user VM. User can manipulate VA from UTOP-1 and down!
+ */
+
+// Top of user-accessible VM
+#define UTOP		UENVS
+// Top of one-page user exception stack
+#define UXSTACKTOP	UTOP
+// Next page left invalid to guard against exception stack overflow; then:
+// Top of normal user stack
+#define USTACKTOP	(UTOP - 2*PGSIZE)
+
+// Where user programs generally begin
+#define UTEXT		(2*PTSIZE)
+
+// Used for temporary page mappings.  Typed 'void*' for convenience
+#define UTEMP		((void*) PTSIZE)
+// Used for temporary page mappings for the user page-fault handler
+// (should not conflict with other temporary page mappings)
+#define PFTEMP		(UTEMP + PTSIZE - PGSIZE)
+// The location of the user-level STABS data structure
+#define USTABDATA	(PTSIZE / 2)
+
+#ifndef __ASSEMBLER__
+
+typedef uint32_t pte_t;
+typedef uint32_t pde_t;
+
+#if JOS_USER
+/*
+ * The page directory entry corresponding to the virtual address range
+ * [UVPT, UVPT + PTSIZE) points to the page directory itself.  Thus, the page
+ * directory is treated as a page table as well as a page directory.
+ *
+ * One result of treating the page directory as a page table is that all PTEs
+ * can be accessed through a "virtual page table" at virtual address UVPT (to
+ * which uvpt is set in lib/entry.S).  The PTE for page number N is stored in
+ * uvpt[N].  (It's worth drawing a diagram of this!)
+ *
+ * A second consequence is that the contents of the current page directory
+ * will always be available at virtual address (UVPT + (UVPT >> PGSHIFT)), to
+ * which uvpd is set in lib/entry.S.
+ */
+extern volatile pte_t uvpt[];     // VA of "virtual page table"
+extern volatile pde_t uvpd[];     // VA of current page directory
+#endif
+
+/*
+ * Page descriptor structures, mapped at UPAGES.
+ * Read/write to the kernel, read-only to user programs.
+ *
+ * Each struct PageInfo stores metadata for one physical page.
+ * Is it NOT the physical page itself, but there is a one-to-one
+ * correspondence between physical pages and struct PageInfo's.
+ * You can map a struct PageInfo * to the corresponding physical address
+ * with page2pa() in kern/pmap.h.
+ */
+struct PageInfo {
+	// Next page on the free list.
+	struct PageInfo *pp_link;
+
+	// pp_ref is the count of pointers (usually in page table entries)
+	// to this page, for pages allocated using page_alloc.
+	// Pages allocated at boot time using pmap.c's
+	// boot_alloc do not have valid reference count fields.
+
+	uint16_t pp_ref;
+};
+
+#endif /* !__ASSEMBLER__ */
+#endif /* !JOS_INC_MEMLAYOUT_H */
diff --git a/inc/trap.h~ b/inc/trap.h~
new file mode 100644
index 0000000..c3437af
--- /dev/null
+++ b/inc/trap.h~
@@ -0,0 +1,80 @@
+#ifndef JOS_INC_TRAP_H
+#define JOS_INC_TRAP_H
+
+// Trap numbers
+// These are processor defined:
+#define T_DIVIDE     0		// divide error
+#define T_DEBUG      1		// debug exception
+#define T_NMI        2		// non-maskable interrupt
+#define T_BRKPT      3		// breakpoint
+#define T_OFLOW      4		// overflow
+#define T_BOUND      5		// bounds check
+#define T_ILLOP      6		// illegal opcode
+#define T_DEVICE     7		// device not available
+#define T_DBLFLT     8		// double fault
+/* #define T_COPROC  9 */	// reserved (not generated by recent processors)
+#define T_TSS       10		// invalid task switch segment
+#define T_SEGNP     11		// segment not present
+#define T_STACK     12		// stack exception
+#define T_GPFLT     13		// general protection fault
+#define T_PGFLT     14		// page fault
+/* #define T_RES    15 */	// reserved
+#define T_FPERR     16		// floating point error
+#define T_ALIGN     17		// aligment check
+#define T_MCHK      18		// machine check
+#define T_SIMDERR   19		// SIMD floating point error
+
+// These are arbitrarily chosen, but with care not to overlap
+// processor defined exceptions or interrupt vectors.
+#define T_SYSCALL   48		// system call
+#define T_DEFAULT   500		// catchall
+
+#define IRQ_OFFSET	32	// IRQ 0 corresponds to int IRQ_OFFSET
+
+// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)
+#define IRQ_TIMER        0
+#define IRQ_KBD          1
+#define IRQ_SERIAL       4
+#define IRQ_SPURIOUS     7
+#define IRQ_IDE         14
+#define IRQ_ERROR       19
+
+#ifndef __ASSEMBLER__
+
+#include <inc/types.h>
+
+struct PushRegs {
+	/* registers as pushed by pusha */
+	uint32_t reg_edi;
+	uint32_t reg_esi;
+	uint32_t reg_ebp;
+	uint32_t reg_oesp;		/* Useless */
+	uint32_t reg_ebx;
+	uint32_t reg_edx;
+	uint32_t reg_ecx;
+	uint32_t reg_eax;
+} __attribute__((packed));
+
+struct Trapframe {
+	struct PushRegs tf_regs;
+	uint16_t tf_es;
+	uint16_t tf_padding1;
+	uint16_t tf_ds;
+	uint16_t tf_padding2;
+	uint32_t tf_trapno;
+	/* below here defined by x86 hardware */
+	uint32_t tf_err;
+	uintptr_t tf_eip;
+	uint16_t tf_cs;
+	uint16_t tf_padding3;
+	uint32_t tf_eflags;
+	/* below here only when crossing rings, such as from user to kernel */
+	uintptr_t tf_esp;
+	uint16_t tf_ss;
+	uint16_t tf_padding4;
+} __attribute__((packed));
+
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* !JOS_INC_TRAP_H */
diff --git a/jos.out b/jos.out
new file mode 100644
index 0000000..910fa8d
--- /dev/null
+++ b/jos.out
@@ -0,0 +1,17 @@
++ ld obj/kern/kernel
++ mk obj/kern/kernel.img
+6828 decimal is 15254 octal!
+Physical memory: 131072K available, base = 640K, extended = 130432K
+check_page_alloc() succeeded!
+check_page() succeeded!
+check_kern_pgdir() succeeded!
+check_page_installed_pgdir() succeeded!
+[00000000] new env 00001000
+Incoming TRAP frame at 0xefffffbc
+Incoming TRAP frame at 0xefffffbc
+[00001000] user_mem_check assertion failure for va f010000c
+[00001000] free env 00001000
+Destroyed the only environment - nothing more to do!
+Welcome to the JOS kernel monitor!
+Type 'help' for a list of commands.
+qemu: terminating on signal 15 from pid 15056
diff --git a/kern/console.c b/kern/console.c
index 7d312a7..aba428e 100644
--- a/kern/console.c
+++ b/kern/console.c
@@ -5,6 +5,7 @@
 #include <inc/kbdreg.h>
 #include <inc/string.h>
 #include <inc/assert.h>
+#include <inc/color.h>
 
 #include <kern/console.h>
 
@@ -164,8 +165,7 @@ cga_putc(int c)
 {
 	// if no attribute given, then use black on white
 	if (!(c & ~0xFF))
-		c |= 0x0700;
-
+	   	c |= COLOR;
 	switch (c & 0xff) {
 	case '\b':
 		if (crt_pos > 0) {
diff --git a/kern/env.c b/kern/env.c
index 9e6d8d6..12424bf 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -15,7 +15,7 @@
 struct Env *envs = NULL;		// All environments
 struct Env *curenv = NULL;		// The current env
 static struct Env *env_free_list;	// Free environment list
-					// (linked by Env->env_link)
+// (linked by Env->env_link)
 
 #define ENVGENSHIFT	12		// >= LOGNENV
 
@@ -36,27 +36,27 @@ static struct Env *env_free_list;	// Free environment list
 //
 struct Segdesc gdt[] =
 {
-	// 0x0 - unused (always faults -- for trapping NULL far pointers)
-	SEG_NULL,
+    // 0x0 - unused (always faults -- for trapping NULL far pointers)
+    SEG_NULL,
 
-	// 0x8 - kernel code segment
-	[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),
+    // 0x8 - kernel code segment
+    [GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),
 
-	// 0x10 - kernel data segment
-	[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),
+    // 0x10 - kernel data segment
+    [GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),
 
-	// 0x18 - user code segment
-	[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),
+    // 0x18 - user code segment
+    [GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),
 
-	// 0x20 - user data segment
-	[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),
+    // 0x20 - user data segment
+    [GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),
 
-	// 0x28 - tss, initialized in trap_init_percpu()
-	[GD_TSS0 >> 3] = SEG_NULL
+    // 0x28 - tss, initialized in trap_init_percpu()
+    [GD_TSS0 >> 3] = SEG_NULL
 };
 
 struct Pseudodesc gdt_pd = {
-	sizeof(gdt) - 1, (unsigned long) gdt
+    sizeof(gdt) - 1, (unsigned long) gdt
 };
 
 //
@@ -69,40 +69,40 @@ struct Pseudodesc gdt_pd = {
 //   On success, sets *env_store to the environment.
 //   On error, sets *env_store to NULL.
 //
-int
+    int
 envid2env(envid_t envid, struct Env **env_store, bool checkperm)
 {
-	struct Env *e;
+    struct Env *e;
 
-	// If envid is zero, return the current environment.
-	if (envid == 0) {
-		*env_store = curenv;
-		return 0;
-	}
-
-	// Look up the Env structure via the index part of the envid,
-	// then check the env_id field in that struct Env
-	// to ensure that the envid is not stale
-	// (i.e., does not refer to a _previous_ environment
-	// that used the same slot in the envs[] array).
-	e = &envs[ENVX(envid)];
-	if (e->env_status == ENV_FREE || e->env_id != envid) {
-		*env_store = 0;
-		return -E_BAD_ENV;
-	}
-
-	// Check that the calling environment has legitimate permission
-	// to manipulate the specified environment.
-	// If checkperm is set, the specified environment
-	// must be either the current environment
-	// or an immediate child of the current environment.
-	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
-		*env_store = 0;
-		return -E_BAD_ENV;
-	}
-
-	*env_store = e;
+    // If envid is zero, return the current environment.
+    if (envid == 0) {
+	*env_store = curenv;
 	return 0;
+    }
+
+    // Look up the Env structure via the index part of the envid,
+    // then check the env_id field in that struct Env
+    // to ensure that the envid is not stale
+    // (i.e., does not refer to a _previous_ environment
+    // that used the same slot in the envs[] array).
+    e = &envs[ENVX(envid)];
+    if (e->env_status == ENV_FREE || e->env_id != envid) {
+	*env_store = 0;
+	return -E_BAD_ENV;
+    }
+
+    // Check that the calling environment has legitimate permission
+    // to manipulate the specified environment.
+    // If checkperm is set, the specified environment
+    // must be either the current environment
+    // or an immediate child of the current environment.
+    if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
+	*env_store = 0;
+	return -E_BAD_ENV;
+    }
+
+    *env_store = e;
+    return 0;
 }
 
 // Mark all environments in 'envs' as free, set their env_ids to 0,
@@ -111,37 +111,57 @@ envid2env(envid_t envid, struct Env **env_store, bool checkperm)
 // they are in the envs array (i.e., so that the first call to
 // env_alloc() returns envs[0]).
 //
-void
+    void
 env_init(void)
 {
-	// Set up envs array
-	// LAB 3: Your code here.
-
-	// Per-CPU part of the initialization
-	env_init_percpu();
+    // Set up envs array
+    // LAB 3: Your code here.
+    int i;
+    env_free_list = NULL;
+    for (i = NENV - 1; i >= 0; i--) {
+	envs[i].env_id = 0;
+	envs[i].env_link = env_free_list;
+	env_free_list = &(envs[i]);
+    }
+
+    // Per-CPU part of the initialization
+    env_init_percpu();
 }
 
 // Load GDT and segment descriptors.
-void
+    void
 env_init_percpu(void)
 {
-	lgdt(&gdt_pd);
-	// The kernel never uses GS or FS, so we leave those set to
-	// the user data segment.
-	asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
-	asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
-	// The kernel does use ES, DS, and SS.  We'll change between
-	// the kernel and user data segments as needed.
-	asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
-	asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
-	asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
-	// Load the kernel text segment into CS.
-	asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
-	// For good measure, clear the local descriptor table (LDT),
-	// since we don't use it.
-	lldt(0);
+    lgdt(&gdt_pd);
+    // The kernel never uses GS or FS, so we leave those set to
+    // the user data segment.
+    asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
+    asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
+    // The kernel does use ES, DS, and SS.  We'll change between
+    // the kernel and user data segments as needed.
+    asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
+    asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
+    asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
+    // Load the kernel text segment into CS.
+    asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
+    // For good measure, clear the local descriptor table (LDT),
+    // since we don't use it.
+    lldt(0);
 }
 
+
+
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+
+
 //
 // Initialize the kernel virtual memory layout for environment e.
 // Allocate a page directory, set e->env_pgdir accordingly,
@@ -152,39 +172,45 @@ env_init_percpu(void)
 // Returns 0 on success, < 0 on error.  Errors include:
 //	-E_NO_MEM if page directory or table could not be allocated.
 //
-static int
+    static int
 env_setup_vm(struct Env *e)
 {
-	int i;
-	struct PageInfo *p = NULL;
-
-	// Allocate a page for the page directory
-	if (!(p = page_alloc(ALLOC_ZERO)))
-		return -E_NO_MEM;
-
-	// Now, set e->env_pgdir and initialize the page directory.
-	//
-	// Hint:
-	//    - The VA space of all envs is identical above UTOP
-	//	(except at UVPT, which we've set below).
-	//	See inc/memlayout.h for permissions and layout.
-	//	Can you use kern_pgdir as a template?  Hint: Yes.
-	//	(Make sure you got the permissions right in Lab 2.)
-	//    - The initial VA below UTOP is empty.
-	//    - You do not need to make any more calls to page_alloc.
-	//    - Note: In general, pp_ref is not maintained for
-	//	physical pages mapped only above UTOP, but env_pgdir
-	//	is an exception -- you need to increment env_pgdir's
-	//	pp_ref for env_free to work correctly.
-	//    - The functions in kern/pmap.h are handy.
-
-	// LAB 3: Your code here.
-
-	// UVPT maps the env's own page table read-only.
-	// Permissions: kernel R, user R
-	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
-
-	return 0;
+    int i;
+    struct PageInfo *p = NULL;
+
+    // Allocate a page for the page directory
+    if (!(p = page_alloc(ALLOC_ZERO)))
+	return -E_NO_MEM;
+
+    // Now, set e->env_pgdir and initialize the page directory.
+    //
+    // Hint:
+    //    - The VA space of all envs is identical above UTOP
+    //	(except at UVPT, which we've set below).
+    //	See inc/memlayout.h for permissions and layout.
+    //	Can you use kern_pgdir as a template?  Hint: Yes.
+    //	(Make sure you got the permissions right in Lab 2.)
+    //    - The initial VA below UTOP is empty.
+    //    - You do not need to make any more calls to page_alloc.
+    //    - Note: In general, pp_ref is not maintained for
+    //	physical pages mapped only above UTOP, but env_pgdir
+    //	is an exception -- you need to increment env_pgdir's
+    //	pp_ref for env_free to work correctly.
+    //    - The functions in kern/pmap.h are handy.
+
+    // LAB 3: Your code here.
+    p->pp_ref++;
+    e->env_pgdir = (pde_t*)page2kva(p);
+    boot_map_region(e->env_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo) * npages, PGSIZE), PADDR(pages), PTE_U);
+    boot_map_region(e->env_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);
+    boot_map_region(e->env_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+    boot_map_region(e->env_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+    // UVPT maps the env's own page table read-only.
+    // Permissions: kernel R, user R
+    e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+
+    return 0;
 }
 
 //
@@ -195,59 +221,59 @@ env_setup_vm(struct Env *e)
 //	-E_NO_FREE_ENV if all NENVS environments are allocated
 //	-E_NO_MEM on memory exhaustion
 //
-int
+    int
 env_alloc(struct Env **newenv_store, envid_t parent_id)
 {
-	int32_t generation;
-	int r;
-	struct Env *e;
-
-	if (!(e = env_free_list))
-		return -E_NO_FREE_ENV;
-
-	// Allocate and set up the page directory for this environment.
-	if ((r = env_setup_vm(e)) < 0)
-		return r;
-
-	// Generate an env_id for this environment.
-	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
-	if (generation <= 0)	// Don't create a negative env_id.
-		generation = 1 << ENVGENSHIFT;
-	e->env_id = generation | (e - envs);
-
-	// Set the basic status variables.
-	e->env_parent_id = parent_id;
-	e->env_type = ENV_TYPE_USER;
-	e->env_status = ENV_RUNNABLE;
-	e->env_runs = 0;
-
-	// Clear out all the saved register state,
-	// to prevent the register values
-	// of a prior environment inhabiting this Env structure
-	// from "leaking" into our new environment.
-	memset(&e->env_tf, 0, sizeof(e->env_tf));
-
-	// Set up appropriate initial values for the segment registers.
-	// GD_UD is the user data segment selector in the GDT, and
-	// GD_UT is the user text segment selector (see inc/memlayout.h).
-	// The low 2 bits of each segment register contains the
-	// Requestor Privilege Level (RPL); 3 means user mode.  When
-	// we switch privilege levels, the hardware does various
-	// checks involving the RPL and the Descriptor Privilege Level
-	// (DPL) stored in the descriptors themselves.
-	e->env_tf.tf_ds = GD_UD | 3;
-	e->env_tf.tf_es = GD_UD | 3;
-	e->env_tf.tf_ss = GD_UD | 3;
-	e->env_tf.tf_esp = USTACKTOP;
-	e->env_tf.tf_cs = GD_UT | 3;
-	// You will set e->env_tf.tf_eip later.
-
-	// commit the allocation
-	env_free_list = e->env_link;
-	*newenv_store = e;
-
-	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
-	return 0;
+    int32_t generation;
+    int r;
+    struct Env *e;
+
+    if (!(e = env_free_list))
+	return -E_NO_FREE_ENV;
+
+    // Allocate and set up the page directory for this environment.
+    if ((r = env_setup_vm(e)) < 0)
+	return r;
+
+    // Generate an env_id for this environment.
+    generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+    if (generation <= 0)	// Don't create a negative env_id.
+	generation = 1 << ENVGENSHIFT;
+    e->env_id = generation | (e - envs);
+
+    // Set the basic status variables.
+    e->env_parent_id = parent_id;
+    e->env_type = ENV_TYPE_USER;
+    e->env_status = ENV_RUNNABLE;
+    e->env_runs = 0;
+
+    // Clear out all the saved register state,
+    // to prevent the register values
+    // of a prior environment inhabiting this Env structure
+    // from "leaking" into our new environment.
+    memset(&e->env_tf, 0, sizeof(e->env_tf));
+
+    // Set up appropriate initial values for the segment registers.
+    // GD_UD is the user data segment selector in the GDT, and
+    // GD_UT is the user text segment selector (see inc/memlayout.h).
+    // The low 2 bits of each segment register contains the
+    // Requestor Privilege Level (RPL); 3 means user mode.  When
+    // we switch privilege levels, the hardware does various
+    // checks involving the RPL and the Descriptor Privilege Level
+    // (DPL) stored in the descriptors themselves.
+    e->env_tf.tf_ds = GD_UD | 3;
+    e->env_tf.tf_es = GD_UD | 3;
+    e->env_tf.tf_ss = GD_UD | 3;
+    e->env_tf.tf_esp = USTACKTOP;
+    e->env_tf.tf_cs = GD_UT | 3;
+    // You will set e->env_tf.tf_eip later.
+
+    // commit the allocation
+    env_free_list = e->env_link;
+    *newenv_store = e;
+
+    cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+    return 0;
 }
 
 //
@@ -257,16 +283,26 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 // Pages should be writable by user and kernel.
 // Panic if any allocation attempt fails.
 //
-static void
+    static void
 region_alloc(struct Env *e, void *va, size_t len)
 {
-	// LAB 3: Your code here.
-	// (But only if you need it for load_icode.)
-	//
-	// Hint: It is easier to use region_alloc if the caller can pass
-	//   'va' and 'len' values that are not page-aligned.
-	//   You should round va down, and round (va + len) up.
-	//   (Watch out for corner-cases!)
+    // LAB 3: Your code here.
+    // (But only if you need it for load_icode.)
+    //
+    // Hint: It is easier to use region_alloc if the caller can pass
+    //   'va' and 'len' values that are not page-aligned.
+    //   You should round va down, and round (va + len) up.
+    //   (Watch out for corner-cases!)
+    int l = 0, va_ = (uintptr_t)va;
+    struct PageInfo *p;
+    va = (void*)ROUNDDOWN(va_, PGSIZE);
+    len = ROUNDUP(va_ + len, PGSIZE) - (uintptr_t)va;
+    for (; l < len; l += PGSIZE) {
+	p = page_alloc(0);
+	if (!p) panic("Panic: region_alloc()\n");
+	if (page_insert(e->env_pgdir, p, va + l, PTE_U | PTE_W))
+	    panic("Panic: region_alloc()\n");
+    }
 }
 
 //
@@ -291,43 +327,62 @@ region_alloc(struct Env *e, void *va, size_t len)
 // load_icode panics if it encounters problems.
 //  - How might load_icode fail?  What might be wrong with the given input?
 //
-static void
+    static void
 load_icode(struct Env *e, uint8_t *binary)
 {
-	// Hints:
-	//  Load each program segment into virtual memory
-	//  at the address specified in the ELF section header.
-	//  You should only load segments with ph->p_type == ELF_PROG_LOAD.
-	//  Each segment's virtual address can be found in ph->p_va
-	//  and its size in memory can be found in ph->p_memsz.
-	//  The ph->p_filesz bytes from the ELF binary, starting at
-	//  'binary + ph->p_offset', should be copied to virtual address
-	//  ph->p_va.  Any remaining memory bytes should be cleared to zero.
-	//  (The ELF header should have ph->p_filesz <= ph->p_memsz.)
-	//  Use functions from the previous lab to allocate and map pages.
-	//
-	//  All page protection bits should be user read/write for now.
-	//  ELF segments are not necessarily page-aligned, but you can
-	//  assume for this function that no two segments will touch
-	//  the same virtual page.
-	//
-	//  You may find a function like region_alloc useful.
-	//
-	//  Loading the segments is much simpler if you can move data
-	//  directly into the virtual addresses stored in the ELF binary.
-	//  So which page directory should be in force during
-	//  this function?
-	//
-	//  You must also do something with the program's entry point,
-	//  to make sure that the environment starts executing there.
-	//  What?  (See env_run() and env_pop_tf() below.)
-
-	// LAB 3: Your code here.
-
-	// Now map one page for the program's initial stack
-	// at virtual address USTACKTOP - PGSIZE.
-
-	// LAB 3: Your code here.
+    // Hints:
+    //  Load each program segment into virtual memory
+    //  at the address specified in the ELF section header.
+    //  You should only load segments with ph->p_type == ELF_PROG_LOAD.
+    //  Each segment's virtual address can be found in ph->p_va
+    //  and its size in memory can be found in ph->p_memsz.
+    //  The ph->p_filesz bytes from the ELF binary, starting at
+    //  'binary + ph->p_offset', should be copied to virtual address
+    //  ph->p_va.  Any remaining memory bytes should be cleared to zero.
+    //  (The ELF header should have ph->p_filesz <= ph->p_memsz.)
+    //  Use functions from the previous lab to allocate and map pages.
+    //
+    //  All page protection bits should be user read/write for now.
+    //  ELF segments are not necessarily page-aligned, but you can
+    //  assume for this function that no two segments will touch
+    //  the same virtual page.
+    //
+    //  You may find a function like region_alloc useful.
+    //
+    //  Loading the segments is much simpler if you can move data
+    //  directly into the virtual addresses stored in the ELF binary.
+    //  So which page directory should be in force during
+    //  this function?
+    //
+    //  You must also do something with the program's entry point,
+    //  to make sure that the environment starts executing there.
+    //  What?  (See env_run() and env_pop_tf() below.)
+
+    // LAB 3: Your code here.
+    struct Elf *elf = (struct Elf*)binary;
+    struct Proghdr *ph, *eph;
+    struct PageInfo *pp;
+    unsigned i, va, sz, delta;
+
+    if (elf->e_magic != ELF_MAGIC) 
+	panic("Panic: load_icode() ELF_MAGIC\n");
+    ph = (struct Proghdr*)(binary + elf->e_phoff);
+    eph = ph + elf->e_phnum;
+    lcr3(PADDR(e->env_pgdir));
+    for (; ph < eph; ph++) {
+	if (ph->p_type != ELF_PROG_LOAD) continue;
+	region_alloc(e, (void*)ph->p_va, ph->p_memsz);
+	memset((void*)ph->p_va, 0, ph->p_memsz);
+	memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+    }
+    lcr3(PADDR(kern_pgdir));
+    e->env_tf.tf_eip = elf->e_entry;
+
+    // Now map one page for the program's initial stack
+    // at virtual address USTACKTOP - PGSIZE.
+
+    // LAB 3: Your code here.
+    region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
 }
 
 //
@@ -337,76 +392,80 @@ load_icode(struct Env *e, uint8_t *binary)
 // before running the first user-mode environment.
 // The new env's parent ID is set to 0.
 //
-void
+    void
 env_create(uint8_t *binary, enum EnvType type)
 {
-	// LAB 3: Your code here.
+    // LAB 3: Your code here.
+    struct Env *e;
+    env_alloc(&e, 0);
+    load_icode(e, binary);
+    e->env_type = type;
 }
 
 //
 // Frees env e and all memory it uses.
 //
-void
+    void
 env_free(struct Env *e)
 {
-	pte_t *pt;
-	uint32_t pdeno, pteno;
-	physaddr_t pa;
-
-	// If freeing the current environment, switch to kern_pgdir
-	// before freeing the page directory, just in case the page
-	// gets reused.
-	if (e == curenv)
-		lcr3(PADDR(kern_pgdir));
-
-	// Note the environment's demise.
-	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
-
-	// Flush all mapped pages in the user portion of the address space
-	static_assert(UTOP % PTSIZE == 0);
-	for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
-
-		// only look at mapped page tables
-		if (!(e->env_pgdir[pdeno] & PTE_P))
-			continue;
-
-		// find the pa and va of the page table
-		pa = PTE_ADDR(e->env_pgdir[pdeno]);
-		pt = (pte_t*) KADDR(pa);
-
-		// unmap all PTEs in this page table
-		for (pteno = 0; pteno <= PTX(~0); pteno++) {
-			if (pt[pteno] & PTE_P)
-				page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
-		}
-
-		// free the page table itself
-		e->env_pgdir[pdeno] = 0;
-		page_decref(pa2page(pa));
+    pte_t *pt;
+    uint32_t pdeno, pteno;
+    physaddr_t pa;
+
+    // If freeing the current environment, switch to kern_pgdir
+    // before freeing the page directory, just in case the page
+    // gets reused.
+    if (e == curenv)
+	lcr3(PADDR(kern_pgdir));
+
+    // Note the environment's demise.
+    cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+
+    // Flush all mapped pages in the user portion of the address space
+    static_assert(UTOP % PTSIZE == 0);
+    for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
+
+	// only look at mapped page tables
+	if (!(e->env_pgdir[pdeno] & PTE_P))
+	    continue;
+
+	// find the pa and va of the page table
+	pa = PTE_ADDR(e->env_pgdir[pdeno]);
+	pt = (pte_t*) KADDR(pa);
+
+	// unmap all PTEs in this page table
+	for (pteno = 0; pteno <= PTX(~0); pteno++) {
+	    if (pt[pteno] & PTE_P)
+		page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
 	}
 
-	// free the page directory
-	pa = PADDR(e->env_pgdir);
-	e->env_pgdir = 0;
+	// free the page table itself
+	e->env_pgdir[pdeno] = 0;
 	page_decref(pa2page(pa));
+    }
+
+    // free the page directory
+    pa = PADDR(e->env_pgdir);
+    e->env_pgdir = 0;
+    page_decref(pa2page(pa));
 
-	// return the environment to the free list
-	e->env_status = ENV_FREE;
-	e->env_link = env_free_list;
-	env_free_list = e;
+    // return the environment to the free list
+    e->env_status = ENV_FREE;
+    e->env_link = env_free_list;
+    env_free_list = e;
 }
 
 //
 // Frees environment e.
 //
-void
+    void
 env_destroy(struct Env *e)
 {
-	env_free(e);
+    env_free(e);
 
-	cprintf("Destroyed the only environment - nothing more to do!\n");
-	while (1)
-		monitor(NULL);
+    cprintf("Destroyed the only environment - nothing more to do!\n");
+    while (1)
+	monitor(NULL);
 }
 
 
@@ -416,18 +475,18 @@ env_destroy(struct Env *e)
 //
 // This function does not return.
 //
-void
+    void
 env_pop_tf(struct Trapframe *tf)
 {
-	asm volatile(
-		"\tmovl %0,%%esp\n"
-		"\tpopal\n"
-		"\tpopl %%es\n"
-		"\tpopl %%ds\n"
-		"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
-		"\tiret\n"
-		: : "g" (tf) : "memory");
-	panic("iret failed");  /* mostly to placate the compiler */
+    asm volatile(
+	    "\tmovl %0,%%esp\n"
+	    "\tpopal\n"
+	    "\tpopl %%es\n"
+	    "\tpopl %%ds\n"
+	    "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
+	    "\tiret\n"
+	    : : "g" (tf) : "memory");
+    panic("iret failed");  /* mostly to placate the compiler */
 }
 
 //
@@ -436,28 +495,36 @@ env_pop_tf(struct Trapframe *tf)
 //
 // This function does not return.
 //
-void
+    void
 env_run(struct Env *e)
 {
-	// Step 1: If this is a context switch (a new environment is running):
-	//	   1. Set the current environment (if any) back to
-	//	      ENV_RUNNABLE if it is ENV_RUNNING (think about
-	//	      what other states it can be in),
-	//	   2. Set 'curenv' to the new environment,
-	//	   3. Set its status to ENV_RUNNING,
-	//	   4. Update its 'env_runs' counter,
-	//	   5. Use lcr3() to switch to its address space.
-	// Step 2: Use env_pop_tf() to restore the environment's
-	//	   registers and drop into user mode in the
-	//	   environment.
-
-	// Hint: This function loads the new environment's state from
-	//	e->env_tf.  Go back through the code you wrote above
-	//	and make sure you have set the relevant parts of
-	//	e->env_tf to sensible values.
-
-	// LAB 3: Your code here.
-
-	panic("env_run not yet implemented");
+    // Step 1: If this is a context switch (a new environment is running):
+    //	   1. Set the current environment (if any) back to
+    //	      ENV_RUNNABLE if it is ENV_RUNNING (think about
+    //	      what other states it can be in),
+    //	   2. Set 'curenv' to the new environment,
+    //	   3. Set its status to ENV_RUNNING,
+    //	   4. Update its 'env_runs' counter,
+    //	   5. Use lcr3() to switch to its address space.
+    // Step 2: Use env_pop_tf() to restore the environment's
+    //	   registers and drop into user mode in the
+    //	   environment.
+
+    // Hint: This function loads the new environment's state from
+    //	e->env_tf.  Go back through the code you wrote above
+    //	and make sure you have set the relevant parts of
+    //	e->env_tf to sensible values.
+
+    // LAB 3: Your code here.
+    if (curenv) {
+	if (curenv->env_status == ENV_RUNNING)
+	    curenv->env_status = ENV_RUNNABLE;
+    }
+    curenv = e;
+    curenv->env_status = ENV_RUNNING;
+    curenv->env_runs++;
+    lcr3(PADDR(e->env_pgdir));
+
+    env_pop_tf(&e->env_tf);
 }
 
diff --git a/kern/env.c~ b/kern/env.c~
new file mode 100644
index 0000000..1e454ab
--- /dev/null
+++ b/kern/env.c~
@@ -0,0 +1,530 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/x86.h>
+#include <inc/mmu.h>
+#include <inc/error.h>
+#include <inc/string.h>
+#include <inc/assert.h>
+#include <inc/elf.h>
+
+#include <kern/env.h>
+#include <kern/pmap.h>
+#include <kern/trap.h>
+#include <kern/monitor.h>
+
+struct Env *envs = NULL;		// All environments
+struct Env *curenv = NULL;		// The current env
+static struct Env *env_free_list;	// Free environment list
+					// (linked by Env->env_link)
+
+#define ENVGENSHIFT	12		// >= LOGNENV
+
+// Global descriptor table.
+//
+// Set up global descriptor table (GDT) with separate segments for
+// kernel mode and user mode.  Segments serve many purposes on the x86.
+// We don't use any of their memory-mapping capabilities, but we need
+// them to switch privilege levels. 
+//
+// The kernel and user segments are identical except for the DPL.
+// To load the SS register, the CPL must equal the DPL.  Thus,
+// we must duplicate the segments for the user and the kernel.
+//
+// In particular, the last argument to the SEG macro used in the
+// definition of gdt specifies the Descriptor Privilege Level (DPL)
+// of that descriptor: 0 for kernel and 3 for user.
+//
+struct Segdesc gdt[] =
+{
+	// 0x0 - unused (always faults -- for trapping NULL far pointers)
+	SEG_NULL,
+
+	// 0x8 - kernel code segment
+	[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),
+
+	// 0x10 - kernel data segment
+	[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),
+
+	// 0x18 - user code segment
+	[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),
+
+	// 0x20 - user data segment
+	[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),
+
+	// 0x28 - tss, initialized in trap_init_percpu()
+	[GD_TSS0 >> 3] = SEG_NULL
+};
+
+struct Pseudodesc gdt_pd = {
+	sizeof(gdt) - 1, (unsigned long) gdt
+};
+
+//
+// Converts an envid to an env pointer.
+// If checkperm is set, the specified environment must be either the
+// current environment or an immediate child of the current environment.
+//
+// RETURNS
+//   0 on success, -E_BAD_ENV on error.
+//   On success, sets *env_store to the environment.
+//   On error, sets *env_store to NULL.
+//
+int
+envid2env(envid_t envid, struct Env **env_store, bool checkperm)
+{
+	struct Env *e;
+
+	// If envid is zero, return the current environment.
+	if (envid == 0) {
+		*env_store = curenv;
+		return 0;
+	}
+
+	// Look up the Env structure via the index part of the envid,
+	// then check the env_id field in that struct Env
+	// to ensure that the envid is not stale
+	// (i.e., does not refer to a _previous_ environment
+	// that used the same slot in the envs[] array).
+	e = &envs[ENVX(envid)];
+	if (e->env_status == ENV_FREE || e->env_id != envid) {
+		*env_store = 0;
+		return -E_BAD_ENV;
+	}
+
+	// Check that the calling environment has legitimate permission
+	// to manipulate the specified environment.
+	// If checkperm is set, the specified environment
+	// must be either the current environment
+	// or an immediate child of the current environment.
+	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
+		*env_store = 0;
+		return -E_BAD_ENV;
+	}
+
+	*env_store = e;
+	return 0;
+}
+
+// Mark all environments in 'envs' as free, set their env_ids to 0,
+// and insert them into the env_free_list.
+// Make sure the environments are in the free list in the same order
+// they are in the envs array (i.e., so that the first call to
+// env_alloc() returns envs[0]).
+//
+void
+env_init(void)
+{
+	// Set up envs array
+	// LAB 3: Your code here.
+	int i;
+    env_free_list = NULL;
+    for (i = NENV - 1; i >= 0; i--) {
+	envs[i].env_id = 0;
+	envs[i].env_link = env_free_list;
+	env_free_list = &(envs[i]);
+    }
+
+	// Per-CPU part of the initialization
+	env_init_percpu();
+}
+
+// Load GDT and segment descriptors.
+void
+env_init_percpu(void)
+{
+	lgdt(&gdt_pd);
+	// The kernel never uses GS or FS, so we leave those set to
+	// the user data segment.
+	asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
+	asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
+	// The kernel does use ES, DS, and SS.  We'll change between
+	// the kernel and user data segments as needed.
+	asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
+	asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
+	asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
+	// Load the kernel text segment into CS.
+	asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
+	// For good measure, clear the local descriptor table (LDT),
+	// since we don't use it.
+	lldt(0);
+}
+
+
+
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+
+
+//
+// Initialize the kernel virtual memory layout for environment e.
+// Allocate a page directory, set e->env_pgdir accordingly,
+// and initialize the kernel portion of the new environment's address space.
+// Do NOT (yet) map anything into the user portion
+// of the environment's virtual address space.
+//
+// Returns 0 on success, < 0 on error.  Errors include:
+//	-E_NO_MEM if page directory or table could not be allocated.
+//
+static int
+env_setup_vm(struct Env *e)
+{
+	int i;
+	struct PageInfo *p = NULL;
+
+	// Allocate a page for the page directory
+	if (!(p = page_alloc(ALLOC_ZERO)))
+		return -E_NO_MEM;
+
+	// Now, set e->env_pgdir and initialize the page directory.
+	//
+	// Hint:
+	//    - The VA space of all envs is identical above UTOP
+	//	(except at UVPT, which we've set below).
+	//	See inc/memlayout.h for permissions and layout.
+	//	Can you use kern_pgdir as a template?  Hint: Yes.
+	//	(Make sure you got the permissions right in Lab 2.)
+	//    - The initial VA below UTOP is empty.
+	//    - You do not need to make any more calls to page_alloc.
+	//    - Note: In general, pp_ref is not maintained for
+	//	physical pages mapped only above UTOP, but env_pgdir
+	//	is an exception -- you need to increment env_pgdir's
+	//	pp_ref for env_free to work correctly.
+	//    - The functions in kern/pmap.h are handy.
+
+	// LAB 3: Your code here.
+	p->pp_ref++;
+    e->env_pgdir = (pde_t*)page2kva(p);
+    boot_map_region(e->env_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo) * npages, PGSIZE), PADDR(pages), PTE_U);
+    boot_map_region(e->env_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);
+    boot_map_region(e->env_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+    boot_map_region(e->env_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+	// UVPT maps the env's own page table read-only.
+	// Permissions: kernel R, user R
+	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+
+	return 0;
+}
+
+//
+// Allocates and initializes a new environment.
+// On success, the new environment is stored in *newenv_store.
+//
+// Returns 0 on success, < 0 on failure.  Errors include:
+//	-E_NO_FREE_ENV if all NENVS environments are allocated
+//	-E_NO_MEM on memory exhaustion
+//
+int
+env_alloc(struct Env **newenv_store, envid_t parent_id)
+{
+	int32_t generation;
+	int r;
+	struct Env *e;
+
+	if (!(e = env_free_list))
+		return -E_NO_FREE_ENV;
+
+	// Allocate and set up the page directory for this environment.
+	if ((r = env_setup_vm(e)) < 0)
+		return r;
+
+	// Generate an env_id for this environment.
+	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+	if (generation <= 0)	// Don't create a negative env_id.
+		generation = 1 << ENVGENSHIFT;
+	e->env_id = generation | (e - envs);
+
+	// Set the basic status variables.
+	e->env_parent_id = parent_id;
+	e->env_type = ENV_TYPE_USER;
+	e->env_status = ENV_RUNNABLE;
+	e->env_runs = 0;
+
+	// Clear out all the saved register state,
+	// to prevent the register values
+	// of a prior environment inhabiting this Env structure
+	// from "leaking" into our new environment.
+	memset(&e->env_tf, 0, sizeof(e->env_tf));
+
+	// Set up appropriate initial values for the segment registers.
+	// GD_UD is the user data segment selector in the GDT, and
+	// GD_UT is the user text segment selector (see inc/memlayout.h).
+	// The low 2 bits of each segment register contains the
+	// Requestor Privilege Level (RPL); 3 means user mode.  When
+	// we switch privilege levels, the hardware does various
+	// checks involving the RPL and the Descriptor Privilege Level
+	// (DPL) stored in the descriptors themselves.
+	e->env_tf.tf_ds = GD_UD | 3;
+	e->env_tf.tf_es = GD_UD | 3;
+	e->env_tf.tf_ss = GD_UD | 3;
+	e->env_tf.tf_esp = USTACKTOP;
+	e->env_tf.tf_cs = GD_UT | 3;
+	// You will set e->env_tf.tf_eip later.
+
+	// commit the allocation
+	env_free_list = e->env_link;
+	*newenv_store = e;
+
+	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+	return 0;
+}
+
+//
+// Allocate len bytes of physical memory for environment env,
+// and map it at virtual address va in the environment's address space.
+// Does not zero or otherwise initialize the mapped pages in any way.
+// Pages should be writable by user and kernel.
+// Panic if any allocation attempt fails.
+//
+static void
+region_alloc(struct Env *e, void *va, size_t len)
+{
+	// LAB 3: Your code here.
+	// (But only if you need it for load_icode.)
+	//
+	// Hint: It is easier to use region_alloc if the caller can pass
+	//   'va' and 'len' values that are not page-aligned.
+	//   You should round va down, and round (va + len) up.
+	//   (Watch out for corner-cases!)
+	 int l = 0, va_ = (uintptr_t)va;
+    struct PageInfo *p;
+    va = (void*)ROUNDDOWN(va_, PGSIZE);
+    len = ROUNDUP(va_ + len, PGSIZE) - (uintptr_t)va;
+    for (; l < len; l += PGSIZE) {
+		p = page_alloc(0);
+		if (!p) panic("Panic: region_alloc()\n");
+		if (page_insert(e->env_pgdir, p, va + l, PTE_U | PTE_W))
+			panic("Panic: region_alloc()\n");
+	}
+}
+
+//
+// Set up the initial program binary, stack, and processor flags
+// for a user process.
+// This function is ONLY called during kernel initialization,
+// before running the first user-mode environment.
+//
+// This function loads all loadable segments from the ELF binary image
+// into the environment's user memory, starting at the appropriate
+// virtual addresses indicated in the ELF program header.
+// At the same time it clears to zero any portions of these segments
+// that are marked in the program header as being mapped
+// but not actually present in the ELF file - i.e., the program's bss section.
+//
+// All this is very similar to what our boot loader does, except the boot
+// loader also needs to read the code from disk.  Take a look at
+// boot/main.c to get ideas.
+//
+// Finally, this function maps one page for the program's initial stack.
+//
+// load_icode panics if it encounters problems.
+//  - How might load_icode fail?  What might be wrong with the given input?
+//
+static void
+load_icode(struct Env *e, uint8_t *binary)
+{
+	// Hints:
+	//  Load each program segment into virtual memory
+	//  at the address specified in the ELF section header.
+	//  You should only load segments with ph->p_type == ELF_PROG_LOAD.
+	//  Each segment's virtual address can be found in ph->p_va
+	//  and its size in memory can be found in ph->p_memsz.
+	//  The ph->p_filesz bytes from the ELF binary, starting at
+	//  'binary + ph->p_offset', should be copied to virtual address
+	//  ph->p_va.  Any remaining memory bytes should be cleared to zero.
+	//  (The ELF header should have ph->p_filesz <= ph->p_memsz.)
+	//  Use functions from the previous lab to allocate and map pages.
+	//
+	//  All page protection bits should be user read/write for now.
+	//  ELF segments are not necessarily page-aligned, but you can
+	//  assume for this function that no two segments will touch
+	//  the same virtual page.
+	//
+	//  You may find a function like region_alloc useful.
+	//
+	//  Loading the segments is much simpler if you can move data
+	//  directly into the virtual addresses stored in the ELF binary.
+	//  So which page directory should be in force during
+	//  this function?
+	//
+	//  You must also do something with the program's entry point,
+	//  to make sure that the environment starts executing there.
+	//  What?  (See env_run() and env_pop_tf() below.)
+
+	// LAB 3: Your code here.
+	struct Elf *elf = (struct Elf*)binary;
+    struct Proghdr *ph, *eph;
+    struct PageInfo *pp;
+    unsigned i, va, sz, delta;
+
+    if (elf->e_magic != ELF_MAGIC) 
+	panic("Panic: load_icode() ELF_MAGIC\n");
+    ph = (struct Proghdr*)(binary + elf->e_phoff);
+    eph = ph + elf->e_phnum;
+    lcr3(PADDR(e->env_pgdir));
+    for (; ph < eph; ph++) {
+	if (ph->p_type != ELF_PROG_LOAD) continue;
+	region_alloc(e, (void*)ph->p_va, ph->p_memsz);
+	memset((void*)ph->p_va, 0, ph->p_memsz);
+	memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+	    }
+    lcr3(PADDR(kern_pgdir));
+    e->env_tf.tf_eip = elf->e_entry;
+
+	// Now map one page for the program's initial stack
+	// at virtual address USTACKTOP - PGSIZE.
+
+	// LAB 3: Your code here.
+    region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
+}
+
+//
+// Allocates a new env with env_alloc, loads the named elf
+// binary into it with load_icode, and sets its env_type.
+// This function is ONLY called during kernel initialization,
+// before running the first user-mode environment.
+// The new env's parent ID is set to 0.
+//
+void
+env_create(uint8_t *binary, enum EnvType type)
+{
+	// LAB 3: Your code here.
+	 struct Env *e;
+    env_alloc(&e, 0);
+    load_icode(e, binary, size);
+    e->env_type = type;
+}
+
+//
+// Frees env e and all memory it uses.
+//
+void
+env_free(struct Env *e)
+{
+	pte_t *pt;
+	uint32_t pdeno, pteno;
+	physaddr_t pa;
+
+	// If freeing the current environment, switch to kern_pgdir
+	// before freeing the page directory, just in case the page
+	// gets reused.
+	if (e == curenv)
+		lcr3(PADDR(kern_pgdir));
+
+	// Note the environment's demise.
+	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+
+	// Flush all mapped pages in the user portion of the address space
+	static_assert(UTOP % PTSIZE == 0);
+	for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
+
+		// only look at mapped page tables
+		if (!(e->env_pgdir[pdeno] & PTE_P))
+			continue;
+
+		// find the pa and va of the page table
+		pa = PTE_ADDR(e->env_pgdir[pdeno]);
+		pt = (pte_t*) KADDR(pa);
+
+		// unmap all PTEs in this page table
+		for (pteno = 0; pteno <= PTX(~0); pteno++) {
+			if (pt[pteno] & PTE_P)
+				page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
+		}
+
+		// free the page table itself
+		e->env_pgdir[pdeno] = 0;
+		page_decref(pa2page(pa));
+	}
+
+	// free the page directory
+	pa = PADDR(e->env_pgdir);
+	e->env_pgdir = 0;
+	page_decref(pa2page(pa));
+
+	// return the environment to the free list
+	e->env_status = ENV_FREE;
+	e->env_link = env_free_list;
+	env_free_list = e;
+}
+
+//
+// Frees environment e.
+//
+void
+env_destroy(struct Env *e)
+{
+	env_free(e);
+
+	cprintf("Destroyed the only environment - nothing more to do!\n");
+	while (1)
+		monitor(NULL);
+}
+
+
+//
+// Restores the register values in the Trapframe with the 'iret' instruction.
+// This exits the kernel and starts executing some environment's code.
+//
+// This function does not return.
+//
+void
+env_pop_tf(struct Trapframe *tf)
+{
+	asm volatile(
+		"\tmovl %0,%%esp\n"
+		"\tpopal\n"
+		"\tpopl %%es\n"
+		"\tpopl %%ds\n"
+		"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
+		"\tiret\n"
+		: : "g" (tf) : "memory");
+	panic("iret failed");  /* mostly to placate the compiler */
+}
+
+//
+// Context switch from curenv to env e.
+// Note: if this is the first call to env_run, curenv is NULL.
+//
+// This function does not return.
+//
+void
+env_run(struct Env *e)
+{
+	// Step 1: If this is a context switch (a new environment is running):
+	//	   1. Set the current environment (if any) back to
+	//	      ENV_RUNNABLE if it is ENV_RUNNING (think about
+	//	      what other states it can be in),
+	//	   2. Set 'curenv' to the new environment,
+	//	   3. Set its status to ENV_RUNNING,
+	//	   4. Update its 'env_runs' counter,
+	//	   5. Use lcr3() to switch to its address space.
+	// Step 2: Use env_pop_tf() to restore the environment's
+	//	   registers and drop into user mode in the
+	//	   environment.
+
+	// Hint: This function loads the new environment's state from
+	//	e->env_tf.  Go back through the code you wrote above
+	//	and make sure you have set the relevant parts of
+	//	e->env_tf to sensible values.
+
+	// LAB 3: Your code here.
+	if (curenv) {
+		if (curenv->env_status == ENV_RUNNING)
+			curenv->env_status = ENV_RUNNABLE;
+    }
+    curenv = e;
+    curenv->env_status = ENV_RUNNING;
+    curenv->env_runs++;
+    lcr3(PADDR(e->env_pgdir));
+	
+    env_pop_tf(&e->env_tf);
+}
+
diff --git a/kern/grade-lab1 b/kern/grade-lab1
new file mode 100755
index 0000000..94bcb0f
--- /dev/null
+++ b/kern/grade-lab1
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+
+import re
+from gradelib import *
+
+r = Runner(save("jos.out"),
+           stop_breakpoint("readline"))
+
+@test(0, "running JOS")
+def test_jos():
+    r.run_qemu()
+
+@test(20, parent=test_jos)
+def test_printf():
+    r.match("6828 decimal is 15254 octal!")
+
+BACKTRACE_RE = r"^ *ebp +f01[0-9a-z]{5} +eip +f0100[0-9a-z]{3} +args +([0-9a-z]+)"
+
+@test(10, parent=test_jos)
+def test_backtrace_count():
+    matches = re.findall(BACKTRACE_RE, r.qemu.output, re.MULTILINE)
+    assert_equal(len(matches), 8)
+
+@test(10, parent=test_jos)
+def test_backtrace_arguments():
+    matches = re.findall(BACKTRACE_RE, r.qemu.output, re.MULTILINE)
+    assert_equal("\n".join(matches[:7]),
+                 "\n".join("%08x" % n for n in [0,0,1,2,3,4,5]))
+
+@test(5, parent=test_jos)
+def test_backtrace_symbols():
+    matches = re.findall(r"kern/init.c:[0-9]+: +([^+]*)\+", r.qemu.output)
+    assert_equal("\n".join(matches[:7]),
+                 "\n".join(["test_backtrace"] * 6 + ["i386_init"]))
+
+@test(5, parent=test_jos)
+def test_backtrace_lines():
+    matches = re.findall(r"([^ ]*init.c:([0-9]+):) +test_backtrace\+", r.qemu.output)
+    assert matches, "No line numbers"
+    if any(int(m[1]) < 5 or int(m[1]) > 50 for m in matches):
+        assert_equal("\n".join(m[0] for m in matches),
+                     "Line numbers between 5 and 50")
+
+run_tests()
diff --git a/kern/kdebug.c b/kern/kdebug.c
index f4ee8ee..b721c0b 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -13,10 +13,10 @@ extern const char __STABSTR_BEGIN__[];		// Beginning of string table
 extern const char __STABSTR_END__[];		// End of string table
 
 struct UserStabData {
-	const struct Stab *stabs;
-	const struct Stab *stab_end;
-	const char *stabstr;
-	const char *stabstr_end;
+    const struct Stab *stabs;
+    const struct Stab *stab_end;
+    const char *stabstr;
+    const char *stabstr_end;
 };
 
 
@@ -56,50 +56,50 @@ struct UserStabData {
 //		stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
 //	will exit setting left = 118, right = 554.
 //
-static void
+    static void
 stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
-	       int type, uintptr_t addr)
+	int type, uintptr_t addr)
 {
-	int l = *region_left, r = *region_right, any_matches = 0;
-
-	while (l <= r) {
-		int true_m = (l + r) / 2, m = true_m;
-
-		// search for earliest stab with right type
-		while (m >= l && stabs[m].n_type != type)
-			m--;
-		if (m < l) {	// no match in [l, m]
-			l = true_m + 1;
-			continue;
-		}
-
-		// actual binary search
-		any_matches = 1;
-		if (stabs[m].n_value < addr) {
-			*region_left = m;
-			l = true_m + 1;
-		} else if (stabs[m].n_value > addr) {
-			*region_right = m - 1;
-			r = m - 1;
-		} else {
-			// exact match for 'addr', but continue loop to find
-			// *region_right
-			*region_left = m;
-			l = m;
-			addr++;
-		}
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+	int true_m = (l + r) / 2, m = true_m;
+
+	// search for earliest stab with right type
+	while (m >= l && stabs[m].n_type != type)
+	    m--;
+	if (m < l) {	// no match in [l, m]
+	    l = true_m + 1;
+	    continue;
 	}
 
-	if (!any_matches)
-		*region_right = *region_left - 1;
-	else {
-		// find rightmost region containing 'addr'
-		for (l = *region_right;
-		     l > *region_left && stabs[l].n_type != type;
-		     l--)
-			/* do nothing */;
-		*region_left = l;
+	// actual binary search
+	any_matches = 1;
+	if (stabs[m].n_value < addr) {
+	    *region_left = m;
+	    l = true_m + 1;
+	} else if (stabs[m].n_value > addr) {
+	    *region_right = m - 1;
+	    r = m - 1;
+	} else {
+	    // exact match for 'addr', but continue loop to find
+	    // *region_right
+	    *region_left = m;
+	    l = m;
+	    addr++;
 	}
+    }
+
+    if (!any_matches)
+	*region_right = *region_left - 1;
+    else {
+	// find rightmost region containing 'addr'
+	for (l = *region_right;
+		l > *region_left && stabs[l].n_type != type;
+		l--)
+	    /* do nothing */;
+	*region_left = l;
+    }
 }
 
 
@@ -110,122 +110,129 @@ stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
 //	negative if not.  But even if it returns negative it has stored some
 //	information into '*info'.
 //
-int
+    int
 debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 {
-	const struct Stab *stabs, *stab_end;
-	const char *stabstr, *stabstr_end;
-	int lfile, rfile, lfun, rfun, lline, rline;
-
-	// Initialize *info
-	info->eip_file = "<unknown>";
-	info->eip_line = 0;
-	info->eip_fn_name = "<unknown>";
-	info->eip_fn_namelen = 9;
+    const struct Stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+    int lfile, rfile, lfun, rfun, lline, rline;
+
+    // Initialize *info
+    info->eip_file = "<unknown>";
+    info->eip_line = 0;
+    info->eip_fn_name = "<unknown>";
+    info->eip_fn_namelen = 9;
+    info->eip_fn_addr = addr;
+    info->eip_fn_narg = 0;
+
+    // Find the relevant set of stabs
+    if (addr >= ULIM) {
+	stabs = __STAB_BEGIN__;
+	stab_end = __STAB_END__;
+	stabstr = __STABSTR_BEGIN__;
+	stabstr_end = __STABSTR_END__;
+    } else {
+	// The user-application linker script, user/user.ld,
+	// puts information about the application's stabs (equivalent
+	// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
+	// __STABSTR_END__) in a structure located at virtual address
+	// USTABDATA.
+	const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
+
+	// Make sure this memory is valid.
+	// Return -1 if it is not.  Hint: Call user_mem_check.
+	// LAB 3: Your code here.
+	if (user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U) < 0)
+	    return -1;
+
+	stabs = usd->stabs;
+	stab_end = usd->stab_end;
+	stabstr = usd->stabstr;
+	stabstr_end = usd->stabstr_end;
+
+	// Make sure the STABS and string table memory is valid.
+	// LAB 3: Your code here.
+	if (user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) < 0) return -1;
+	if (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) < 0) return -1;
+    }
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
+	return -1;
+
+    // Now we find the right stabs that define the function containing
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    lfile = 0;
+    rfile = (stab_end - stabs) - 1;
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+    if (lfile == 0)
+	return -1;
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    lfun = lfile;
+    rfun = rfile;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+
+    if (lfun <= rfun) {
+	// stabs[lfun] points to the function name
+	// in the string table, but check bounds just in case.
+	if (stabs[lfun].n_strx < stabstr_end - stabstr)
+	    info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+	info->eip_fn_addr = stabs[lfun].n_value;
+	addr -= info->eip_fn_addr;
+	// Search within the function definition for the line number.
+	lline = lfun;
+	rline = rfun;
+    } else {
+	// Couldn't find function stab!  Maybe we're in an assembly
+	// file.  Search the whole file for the line number.
 	info->eip_fn_addr = addr;
-	info->eip_fn_narg = 0;
-
-	// Find the relevant set of stabs
-	if (addr >= ULIM) {
-		stabs = __STAB_BEGIN__;
-		stab_end = __STAB_END__;
-		stabstr = __STABSTR_BEGIN__;
-		stabstr_end = __STABSTR_END__;
-	} else {
-		// The user-application linker script, user/user.ld,
-		// puts information about the application's stabs (equivalent
-		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
-		// __STABSTR_END__) in a structure located at virtual address
-		// USTABDATA.
-		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
-
-		// Make sure this memory is valid.
-		// Return -1 if it is not.  Hint: Call user_mem_check.
-		// LAB 3: Your code here.
-
-		stabs = usd->stabs;
-		stab_end = usd->stab_end;
-		stabstr = usd->stabstr;
-		stabstr_end = usd->stabstr_end;
-
-		// Make sure the STABS and string table memory is valid.
-		// LAB 3: Your code here.
-	}
-
-	// String table validity checks
-	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
-		return -1;
-
-	// Now we find the right stabs that define the function containing
-	// 'eip'.  First, we find the basic source file containing 'eip'.
-	// Then, we look in that source file for the function.  Then we look
-	// for the line number.
-
-	// Search the entire set of stabs for the source file (type N_SO).
-	lfile = 0;
-	rfile = (stab_end - stabs) - 1;
-	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
-	if (lfile == 0)
-		return -1;
-
-	// Search within that file's stabs for the function definition
-	// (N_FUN).
-	lfun = lfile;
-	rfun = rfile;
-	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
-
-	if (lfun <= rfun) {
-		// stabs[lfun] points to the function name
-		// in the string table, but check bounds just in case.
-		if (stabs[lfun].n_strx < stabstr_end - stabstr)
-			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
-		info->eip_fn_addr = stabs[lfun].n_value;
-		addr -= info->eip_fn_addr;
-		// Search within the function definition for the line number.
-		lline = lfun;
-		rline = rfun;
-	} else {
-		// Couldn't find function stab!  Maybe we're in an assembly
-		// file.  Search the whole file for the line number.
-		info->eip_fn_addr = addr;
-		lline = lfile;
-		rline = rfile;
-	}
-	// Ignore stuff after the colon.
-	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
-
-
-	// Search within [lline, rline] for the line number stab.
-	// If found, set info->eip_line to the right line number.
-	// If not found, return -1.
-	//
-	// Hint:
-	//	There's a particular stabs type used for line numbers.
-	//	Look at the STABS documentation and <inc/stab.h> to find
-	//	which one.
-	// Your code here.
-
-
-	// Search backwards from the line number for the relevant filename
-	// stab.
-	// We can't just use the "lfile" stab because inlined functions
-	// can interpolate code from a different file!
-	// Such included source files use the N_SOL stab type.
-	while (lline >= lfile
-	       && stabs[lline].n_type != N_SOL
-	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
-		lline--;
-	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
-		info->eip_file = stabstr + stabs[lline].n_strx;
-
-
-	// Set eip_fn_narg to the number of arguments taken by the function,
-	// or 0 if there was no containing function.
-	if (lfun < rfun)
-		for (lline = lfun + 1;
-		     lline < rfun && stabs[lline].n_type == N_PSYM;
-		     lline++)
-			info->eip_fn_narg++;
-
-	return 0;
+	lline = lfile;
+	rline = rfile;
+    }
+    // Ignore stuff after the colon.
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    //
+    // Hint:
+    //	There's a particular stabs type used for line numbers.
+    //	Look at the STABS documentation and <inc/stab.h> to find
+    //	which one.
+    // Your code here.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) info->eip_line = lline - lfun;
+    else return -1;
+
+
+    // Search backwards from the line number for the relevant filename
+    // stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+	    && stabs[lline].n_type != N_SOL
+	    && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
+	lline--;
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
+	info->eip_file = stabstr + stabs[lline].n_strx;
+
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun)
+	for (lline = lfun + 1;
+		lline < rfun && stabs[lline].n_type == N_PSYM;
+		lline++)
+	    info->eip_fn_narg++;
+
+    return 0;
 }
diff --git a/kern/mergedep.pl b/kern/mergedep.pl
new file mode 100644
index 0000000..1730d53
--- /dev/null
+++ b/kern/mergedep.pl
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+# Copyright 2003 Bryan Ford
+# Distributed under the GNU General Public License.
+#
+# Usage: mergedep <main-depfile> [<new-depfiles> ...]
+#
+# This script merges the contents of all <new-depfiles> specified
+# on the command line into the single file <main-depfile>,
+# which may or may not previously exist.
+# Dependencies in the <new-depfiles> will override
+# any existing dependencies for the same targets in <main-depfile>.
+# The <new-depfiles> are deleted after <main-depfile> is updated.
+#
+# The <new-depfiles> are typically generated by GCC with the -MD option,
+# and the <main-depfile> is typically included from a Makefile,
+# as shown here for GNU 'make':
+#
+#	.deps: $(wildcard *.d)
+#		perl mergedep $@ $^
+#	-include .deps
+#
+# This script properly handles multiple dependencies per <new-depfile>,
+# including dependencies having no target,
+# so it is compatible with GCC3's -MP option.
+#
+
+sub readdeps {
+	my $filename = shift;
+
+	open(DEPFILE, $filename) or return 0;
+	while (<DEPFILE>) {
+		if (/([^:]*):([^\\:]*)([\\]?)$/) {
+			my $target = $1;
+			my $deplines = $2;
+			my $slash = $3;
+			while ($slash ne '') {
+				$_ = <DEPFILE>;
+				defined($_) or die
+					"Unterminated dependency in $filename";
+				/(^[ \t][^\\]*)([\\]?)$/ or die
+					"Bad continuation line in $filename";
+				$deplines = "$deplines\\\n$1";
+				$slash = $2;
+			}
+			#print "DEPENDENCY [[$target]]: [[$deplines]]\n";
+			$dephash{$target} = $deplines;
+		} elsif (/^[#]?[ \t]*$/) {
+			# ignore blank lines and comments
+		} else {
+			die "Bad dependency line in $filename: $_";
+		}
+	}
+	close DEPFILE;
+	return 1;
+}
+
+
+if ($#ARGV < 0) {
+	print "Usage: mergedep <main-depfile> [<new-depfiles> ..]\n";
+	exit(1);
+}
+
+%dephash = ();
+
+# Read the main dependency file
+$maindeps = $ARGV[0];
+readdeps($maindeps);
+
+# Read and merge in the new dependency files
+foreach $i (1 .. $#ARGV) {
+	readdeps($ARGV[$i]) or die "Can't open $ARGV[$i]";
+}
+
+# Update the main dependency file
+open(DEPFILE, ">$maindeps.tmp") or die "Can't open output file $maindeps.tmp";
+foreach $target (keys %dephash) {
+	print DEPFILE "$target:$dephash{$target}";
+}
+close DEPFILE;
+rename("$maindeps.tmp", "$maindeps") or die "Can't overwrite $maindeps";
+
+# Finally, delete the new dependency files
+foreach $i (1 .. $#ARGV) {
+	unlink($ARGV[$i]) or print "Error removing $ARGV[$i]\n";
+}
+
diff --git a/kern/monitor.c b/kern/monitor.c
index 4e00796..4f6b18b 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -11,57 +11,183 @@
 #include <kern/monitor.h>
 #include <kern/kdebug.h>
 #include <kern/trap.h>
+#include <kern/pmap.h>
+
 
 #define CMDBUF_SIZE	80	// enough for one VGA text line
 
+int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf);
+int
+mon_memdump(int argc, char **argv, struct Trapframe *tf);
+int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf);
+int
+mon_continue(int argc, char **argv, struct Trapframe *tf);
+int
+mon_stepins(int argc, char **argv, struct Trapframe *tf);
+
+
 
 struct Command {
-	const char *name;
-	const char *desc;
-	// return -1 to force monitor to exit
-	int (*func)(int argc, char** argv, struct Trapframe* tf);
+    const char *name;
+    const char *desc;
+    // return -1 to force monitor to exit
+    int (*func)(int argc, char** argv, struct Trapframe* tf);
 };
 
 static struct Command commands[] = {
-	{ "help", "Display this list of commands", mon_help },
-	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
+    { "help", "Display this list of commands", mon_help },
+    { "kerninfo", "Display information about the kernel", mon_kerninfo },
+    { "pgmap", "Display the physical page mappings", mon_pgmap },
+    { "pgperm", "set, clear, or change the permissions", mon_pgperm },
+    { "memdump", "Dump the contents of a range of memory", mon_memdump },
+    { "backtrace", "Backtrace", mon_backtrace },
+    { "si", "single-step one instruction at a time", mon_stepins },
+    { "c", "continue", mon_continue },
 };
 
+
 /***** Implementations of basic kernel monitor commands *****/
 
-int
+    int
 mon_help(int argc, char **argv, struct Trapframe *tf)
 {
-	int i;
+    int i;
 
-	for (i = 0; i < ARRAY_SIZE(commands); i++)
-		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
-	return 0;
+    for (i = 0; i < ARRAY_SIZE(commands); i++)
+	cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    return 0;
 }
 
-int
+    int
 mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
 {
-	extern char _start[], entry[], etext[], edata[], end[];
-
-	cprintf("Special kernel symbols:\n");
-	cprintf("  _start                  %08x (phys)\n", _start);
-	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
-	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
-	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
-	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
-	cprintf("Kernel executable memory footprint: %dKB\n",
-		ROUNDUP(end - entry, 1024) / 1024);
-	return 0;
+    extern char _start[], entry[], etext[], edata[], end[];
+
+    cprintf("Special kernel symbols:\n");
+    cprintf("  _start                  %08x (phys)\n", _start);
+    cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+    cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+    cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+    cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+    cprintf("Kernel executable memory footprint: %dKB\n",
+	    ROUNDUP(end - entry, 1024) / 1024);
+    return 0;
 }
 
-int
+    int
 mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 {
-	// Your code here.
+    int *ebp, eip, *old_ebp;
+    int ary[5]={};
+
+    cprintf("Stack backtrace:\n");
+
+    ebp=(int *)read_ebp();
+    while((int)ebp!=0)
+    {
+	old_ebp=(int *)*(ebp);
+	eip=*(ebp+1);
+	for(int i=0;i<5;++i)
+	{
+	    int j=i+2;
+	    ary[i]=*(ebp+j);
+	}
+	struct Eipdebuginfo eip_info;
+	debuginfo_eip((uintptr_t)eip, &eip_info);
+	cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
+	cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
+	cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
+	ebp=old_ebp;
+    }
+
+    return 0;
+}
+
+
+
+
+    int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va1, va2, va;
+    struct PageInfo *pg;
+    pte_t *pte;
+    if (argc != 3) {
+	cprintf("Usage: pgmap va1 va2\n Display physical memory mapping from virtual memory va1 to va2\nva1 and va2 are hex\n");
+	return 0;
+    }
+    else {
+	for (va1 = strtol(argv[1], 0, 16), va2 = strtol(argv[2], 0, 16); va1 < va2; va1 += PGSIZE) {
+	    va = va1 & ~0xfff;
+	    pg = page_lookup(kern_pgdir, (void*)va, 0);
+	    pte = pgdir_walk(kern_pgdir, (void* )va,0);
+	    if (pg){
+		cprintf("[%x, %x) ---> [%x, %x)    ", va, va + PGSIZE, page2pa(pg), page2pa(pg) + PGSIZE);
+		if(*pte & PTE_U)
+		    cprintf("user: ");
+		else 
+		    cprintf("kernel: ");
+
+		if(*pte &PTE_W)
+		    cprintf("read/write ");
+		else 
+		    cprintf("read only ");
+	    }else
+		cprintf("[%x, %x) ---> NULL    ", va, va + PGSIZE);
+
+	    cprintf("\n");                                                                                       
+	}
+    }
+    return 0;
+}
+
+
+    int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va, perm;
+    if (argc != 4) {
+	cprintf("Usage: pgperm +/-/= perm va\nset perm of page which contains va, va is hex\n");
 	return 0;
+    }
+    else {
+	va = strtol(argv[3], 0, 16);
+	perm = strtol(argv[2], 0, 16);
+	pte_t *pte = pgdir_walk(kern_pgdir, (void*)va, 0);
+	if (!pte) {
+	    cprintf("0x%x is not mapped\n", va);
+	}
+	else {
+	    if (argv[1][0] == '+') *pte |= perm;
+	    if (argv[1][0] == '0') *pte &= ~perm;
+	    if (argv[1][0] == '=') *pte = PTE_ADDR(*pte) | perm;
+	}
+    }
+    return 0;
 }
 
+    int
+mon_memdump(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t a1, a2, a;
+    struct PageInfo *pg;
+    if (argc != 4) {
+	cprintf("Usage: memdump p/v a1 a2\n Dump memory content via virtual or physical address\na1 and a2 are hex\n");
+	return 0;
+    }
+    else {
+	a1 = strtol(argv[2], 0, 16), a2 = strtol(argv[3], 0, 16);
+	if (argv[1][0] == 'p') a1 = (int)KADDR(a1), a2 = (int)KADDR(a2);
+	for (a = a1; a < a2 && a >= KERNBASE; a += 4) {
+	    if (!((a - a1) & 0xf)) cprintf("\n%x:\t", a);
+	    cprintf(" %x", *(int*)(a));
+	}
+	cprintf("\n");
+    }
+    return 0;
+}
 
 
 /***** Kernel monitor command interpreter *****/
@@ -69,60 +195,83 @@ mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 #define WHITESPACE "\t\r\n "
 #define MAXARGS 16
 
-static int
+    static int
 runcmd(char *buf, struct Trapframe *tf)
 {
-	int argc;
-	char *argv[MAXARGS];
-	int i;
-
-	// Parse the command buffer into whitespace-separated arguments
-	argc = 0;
-	argv[argc] = 0;
-	while (1) {
-		// gobble whitespace
-		while (*buf && strchr(WHITESPACE, *buf))
-			*buf++ = 0;
-		if (*buf == 0)
-			break;
-
-		// save and scan past next arg
-		if (argc == MAXARGS-1) {
-			cprintf("Too many arguments (max %d)\n", MAXARGS);
-			return 0;
-		}
-		argv[argc++] = buf;
-		while (*buf && !strchr(WHITESPACE, *buf))
-			buf++;
-	}
-	argv[argc] = 0;
-
-	// Lookup and invoke the command
-	if (argc == 0)
-		return 0;
-	for (i = 0; i < ARRAY_SIZE(commands); i++) {
-		if (strcmp(argv[0], commands[i].name) == 0)
-			return commands[i].func(argc, argv, tf);
+    int argc;
+    char *argv[MAXARGS];
+    int i;
+
+    // Parse the command buffer into whitespace-separated arguments
+    argc = 0;
+    argv[argc] = 0;
+    while (1) {
+	// gobble whitespace
+	while (*buf && strchr(WHITESPACE, *buf))
+	    *buf++ = 0;
+	if (*buf == 0)
+	    break;
+
+	// save and scan past next arg
+	if (argc == MAXARGS-1) {
+	    cprintf("Too many arguments (max %d)\n", MAXARGS);
+	    return 0;
 	}
-	cprintf("Unknown command '%s'\n", argv[0]);
+	argv[argc++] = buf;
+	while (*buf && !strchr(WHITESPACE, *buf))
+	    buf++;
+    }
+    argv[argc] = 0;
+
+    // Lookup and invoke the command
+    if (argc == 0)
 	return 0;
+    for (i = 0; i < ARRAY_SIZE(commands); i++) {
+	if (strcmp(argv[0], commands[i].name) == 0)
+	    return commands[i].func(argc, argv, tf);
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+    return 0;
 }
 
-void
+    void
 monitor(struct Trapframe *tf)
 {
-	char *buf;
+    char *buf;
 
-	cprintf("Welcome to the JOS kernel monitor!\n");
-	cprintf("Type 'help' for a list of commands.\n");
+    cprintf("Welcome to the JOS kernel monitor!\n");
+    cprintf("Type 'help' for a list of commands.\n");
 
-	if (tf != NULL)
-		print_trapframe(tf);
+    if (tf != NULL)
+	print_trapframe(tf);
 
-	while (1) {
-		buf = readline("K> ");
-		if (buf != NULL)
-			if (runcmd(buf, tf) < 0)
-				break;
-	}
+    while (1) {
+	buf = readline("K> ");
+	if (buf != NULL)
+	    if (runcmd(buf, tf) < 0)
+		break;
+    }
 }
+
+extern void env_pop_tf(struct Trapframe *tf);
+    int
+mon_continue(int argc, char **argv, struct Trapframe *tf)
+{
+    if (tf->tf_trapno == T_BRKPT || tf->tf_trapno == T_DEBUG) {
+	tf->tf_eflags &= ~FL_TF;
+	env_pop_tf(tf);
+    }
+    return 0;
+}
+
+    int
+mon_stepins(int argc, char **argv, struct Trapframe *tf)
+{
+    if (tf->tf_trapno == T_BRKPT || tf->tf_trapno == T_DEBUG) {
+	tf->tf_eflags |= FL_TF;
+	env_pop_tf(tf);
+    }
+    return 0;
+}
+
+
diff --git a/kern/monitor.c~ b/kern/monitor.c~
new file mode 100644
index 0000000..2c6f8fb
--- /dev/null
+++ b/kern/monitor.c~
@@ -0,0 +1,240 @@
+// Simple command-line kernel monitor useful for
+// controlling the kernel and exploring the system interactively.
+
+#include <inc/stdio.h>
+#include <inc/string.h>
+#include <inc/memlayout.h>
+#include <inc/assert.h>
+#include <inc/x86.h>
+
+#include <kern/console.h>
+#include <kern/monitor.h>
+#include <kern/kdebug.h>
+#include <kern/pmap.h>
+
+
+#define CMDBUF_SIZE	80	// enough for one VGA text line
+
+int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf);
+ int
+mon_memdump(int argc, char **argv, struct Trapframe *tf);
+ int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf);
+struct Command {
+	const char *name;
+	const char *desc;
+	// return -1 to force monitor to exit
+	int (*func)(int argc, char** argv, struct Trapframe* tf);
+};
+
+static struct Command commands[] = {
+	{ "help", "Display this list of commands", mon_help },
+	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
+	{ "pgmap", "Display the physical page mappings", mon_pgmap },
+	{ "pgperm", "set, clear, or change the permissions", mon_pgperm },
+	{ "memdump", "Dump the contents of a range of memory", mon_memdump },
+};
+
+/***** Implementations of basic kernel monitor commands *****/
+
+int
+mon_help(int argc, char **argv, struct Trapframe *tf)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(commands); i++)
+		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+	return 0;
+}
+
+int
+mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
+{
+	extern char _start[], entry[], etext[], edata[], end[];
+
+	cprintf("Special kernel symbols:\n");
+	cprintf("  _start                  %08x (phys)\n", _start);
+	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+	cprintf("Kernel executable memory footprint: %dKB\n",
+		ROUNDUP(end - entry, 1024) / 1024);
+	return 0;
+}
+
+int
+mon_backtrace(int argc, char **argv, struct Trapframe *tf)
+{
+	int *ebp, eip, *old_ebp;
+	int ary[5]={};
+
+	cprintf("Stack backtrace:\n");
+	
+	ebp=(int *)read_ebp();
+	while((int)ebp!=0)
+	{
+		old_ebp=(int *)*(ebp);
+		eip=*(ebp+1);
+		for(int i=0;i<5;++i)
+		{
+			int j=i+2;
+			ary[i]=*(ebp+j);
+		}
+		struct Eipdebuginfo eip_info;
+		debuginfo_eip((uintptr_t)eip, &eip_info);
+		cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
+		cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
+		cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
+		ebp=old_ebp;
+	}
+	
+	return 0;
+}
+
+
+
+
+    int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va1, va2, va;
+    struct PageInfo *pg;
+	pte_t *pte;
+    if (argc != 3) {
+	cprintf("Usage: pgmap va1 va2\n Display physical memory mapping from virtual memory va1 to va2\nva1 and va2 are hex\n");
+	return 0;
+    }
+    else {
+	for (va1 = strtol(argv[1], 0, 16), va2 = strtol(argv[2], 0, 16); va1 < va2; va1 += PGSIZE) {
+	    va = va1 & ~0xfff;
+	    pg = page_lookup(kern_pgdir, (void*)va, 0);
+		pte = pgdir_walk(kern_pgdir, (void* )va,0);
+	    if (pg){
+		cprintf("[%x, %x) ---> [%x, %x)    ", va, va + PGSIZE, page2pa(pg), page2pa(pg) + PGSIZE);
+		    if(*pte & PTE_U)
+			cprintf("user: ");
+		   else 
+			cprintf("kernel: ");
+
+		   if(*pte &PTE_W)
+			cprintf("read/write ");
+		   else 
+			cprintf("read only ");
+		}else
+		cprintf("[%x, %x) ---> NULL    ", va, va + PGSIZE);
+
+		cprintf("\n");                                                                                       
+	}
+    }
+    return 0;
+}
+
+
+    int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va, perm;
+    if (argc != 4) {
+		cprintf("Usage: pgperm +/-/= perm va\nset perm of page which contains va, va is hex\n");
+		return 0;
+    }
+    else {
+		va = strtol(argv[3], 0, 16);
+		perm = strtol(argv[2], 0, 16);
+		pte_t *pte = pgdir_walk(kern_pgdir, (void*)va, 0);
+		if (!pte) {
+			cprintf("0x%x is not mapped\n", va);
+		}
+		else {
+			if (argv[1][0] == '+') *pte |= perm;
+			if (argv[1][0] == '0') *pte &= ~perm;
+			if (argv[1][0] == '=') *pte = PTE_ADDR(*pte) | perm;
+		}
+    }
+    return 0;
+}
+
+    int
+mon_memdump(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t a1, a2, a;
+    struct PageInfo *pg;
+    if (argc != 4) {
+	cprintf("Usage: memdump p/v a1 a2\n Dump memory content via virtual or physical address\na1 and a2 are hex\n");
+	return 0;
+    }
+    else {
+	a1 = strtol(argv[2], 0, 16), a2 = strtol(argv[3], 0, 16);
+	if (argv[1][0] == 'p') a1 = (int)KADDR(a1), a2 = (int)KADDR(a2);
+	for (a = a1; a < a2 && a >= KERNBASE; a += 4) {
+	    if (!((a - a1) & 0xf)) cprintf("\n%x:\t", a);
+	    cprintf(" %x", *(int*)(a));
+	}
+	cprintf("\n");
+    }
+    return 0;
+}
+
+
+/***** Kernel monitor command interpreter *****/
+
+#define WHITESPACE "\t\r\n "
+#define MAXARGS 16
+
+static int
+runcmd(char *buf, struct Trapframe *tf)
+{
+	int argc;
+	char *argv[MAXARGS];
+	int i;
+
+	// Parse the command buffer into whitespace-separated arguments
+	argc = 0;
+	argv[argc] = 0;
+	while (1) {
+		// gobble whitespace
+		while (*buf && strchr(WHITESPACE, *buf))
+			*buf++ = 0;
+		if (*buf == 0)
+			break;
+
+		// save and scan past next arg
+		if (argc == MAXARGS-1) {
+			cprintf("Too many arguments (max %d)\n", MAXARGS);
+			return 0;
+		}
+		argv[argc++] = buf;
+		while (*buf && !strchr(WHITESPACE, *buf))
+			buf++;
+	}
+	argv[argc] = 0;
+
+	// Lookup and invoke the command
+	if (argc == 0)
+		return 0;
+	for (i = 0; i < ARRAY_SIZE(commands); i++) {
+		if (strcmp(argv[0], commands[i].name) == 0)
+			return commands[i].func(argc, argv, tf);
+	}
+	cprintf("Unknown command '%s'\n", argv[0]);
+	return 0;
+}
+
+void
+monitor(struct Trapframe *tf)
+{
+	char *buf;
+
+	cprintf("Welcome to the JOS kernel monitor!\n");
+	cprintf("Type 'help' for a list of commands.\n");
+
+
+	while (1) {
+		buf = readline("K> ");
+		if (buf != NULL)
+			if (runcmd(buf, tf) < 0)
+				break;
+	}
+}
diff --git a/kern/pmap.c b/kern/pmap.c
index f7e9b52..661b47a 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -19,42 +19,41 @@ pde_t *kern_pgdir;		// Kernel's initial page directory
 struct PageInfo *pages;		// Physical page state array
 static struct PageInfo *page_free_list;	// Free list of physical pages
 
-
 // --------------------------------------------------------------
 // Detect machine's physical memory setup.
 // --------------------------------------------------------------
 
-static int
+    static int
 nvram_read(int r)
 {
-	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
+    return mc146818_read(r) | (mc146818_read(r + 1) << 8);
 }
 
-static void
+    static void
 i386_detect_memory(void)
 {
-	size_t basemem, extmem, ext16mem, totalmem;
-
-	// Use CMOS calls to measure available base & extended memory.
-	// (CMOS calls return results in kilobytes.)
-	basemem = nvram_read(NVRAM_BASELO);
-	extmem = nvram_read(NVRAM_EXTLO);
-	ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
-
-	// Calculate the number of physical pages available in both base
-	// and extended memory.
-	if (ext16mem)
-		totalmem = 16 * 1024 + ext16mem;
-	else if (extmem)
-		totalmem = 1 * 1024 + extmem;
-	else
-		totalmem = basemem;
-
-	npages = totalmem / (PGSIZE / 1024);
-	npages_basemem = basemem / (PGSIZE / 1024);
-
-	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
-		totalmem, basemem, totalmem - basemem);
+    size_t basemem, extmem, ext16mem, totalmem;
+
+    // Use CMOS calls to measure available base & extended memory.
+    // (CMOS calls return results in kilobytes.)
+    basemem = nvram_read(NVRAM_BASELO);
+    extmem = nvram_read(NVRAM_EXTLO);
+    ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
+
+    // Calculate the number of physical pages available in both base
+    // and extended memory.
+    if (ext16mem)
+	totalmem = 16 * 1024 + ext16mem;
+    else if (extmem)
+	totalmem = 1 * 1024 + extmem;
+    else
+	totalmem = basemem;
+
+    npages = totalmem / (PGSIZE / 1024);
+    npages_basemem = basemem / (PGSIZE / 1024);
+
+    cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
+	    totalmem, basemem, totalmem - basemem);
 }
 
 
@@ -82,29 +81,35 @@ static void check_page_installed_pgdir(void);
 // If we're out of memory, boot_alloc should panic.
 // This function may ONLY be used during initialization,
 // before the page_free_list list has been set up.
-static void *
+    static void *
 boot_alloc(uint32_t n)
 {
-	static char *nextfree;	// virtual address of next byte of free memory
-	char *result;
-
-	// Initialize nextfree if this is the first time.
-	// 'end' is a magic symbol automatically generated by the linker,
-	// which points to the end of the kernel's bss segment:
-	// the first virtual address that the linker did *not* assign
-	// to any kernel code or global variables.
-	if (!nextfree) {
-		extern char end[];
-		nextfree = ROUNDUP((char *) end, PGSIZE);
-	}
-
-	// Allocate a chunk large enough to hold 'n' bytes, then update
-	// nextfree.  Make sure nextfree is kept aligned
-	// to a multiple of PGSIZE.
-	//
-	// LAB 2: Your code here.
-
+    static char *nextfree;	// virtual address of next byte of free memory
+    char *result;
+    // Initialize nextfree if this is the first time.
+    // 'end' is a magic symbol automatically generated by the linker,
+    // which points to the end of the kernel's bss segment:
+    // the first virtual address that the linker did *not* assign
+    // to any kernel code or global variables.
+    if (!nextfree) {
+	extern char end[];
+	nextfree = ROUNDUP((char *) end, PGSIZE);
+    }
+
+    // Allocate a chunk large enough to hold 'n' bytes, then update
+    // nextfree.  Make sure nextfree is kept aligned
+    // to a multiple of PGSIZE.
+    // LAB 2: Your code here.
+    if (n == 0) return (void*)nextfree;
+    n = ROUNDUP(n, PGSIZE);
+    if (PADDR(nextfree + n) > npages * PGSIZE)
+    {
+	panic("kern/pmap.c: boot_alloc()");
 	return NULL;
+    }
+    result = nextfree;
+    nextfree += n;
+    return result;
 }
 
 // Set up a two-level page table:
@@ -116,120 +121,128 @@ boot_alloc(uint32_t n)
 //
 // From UTOP to ULIM, the user is allowed to read but not write.
 // Above ULIM the user cannot read or write.
-void
+    void
 mem_init(void)
 {
-	uint32_t cr0;
-	size_t n;
-
-	// Find out how much memory the machine has (npages & npages_basemem).
-	i386_detect_memory();
-
-	// Remove this line when you're ready to test this function.
-	panic("mem_init: This function is not finished\n");
-
-	//////////////////////////////////////////////////////////////////////
-	// create initial page directory.
-	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
-	memset(kern_pgdir, 0, PGSIZE);
-
-	//////////////////////////////////////////////////////////////////////
-	// Recursively insert PD in itself as a page table, to form
-	// a virtual page table at virtual address UVPT.
-	// (For now, you don't have understand the greater purpose of the
-	// following line.)
-
-	// Permissions: kernel R, user R
-	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
-
-	//////////////////////////////////////////////////////////////////////
-	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
-	// The kernel uses this array to keep track of physical pages: for
-	// each physical page, there is a corresponding struct PageInfo in this
-	// array.  'npages' is the number of physical pages in memory.  Use memset
-	// to initialize all fields of each struct PageInfo to 0.
-	// Your code goes here:
-
-
-	//////////////////////////////////////////////////////////////////////
-	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
-	// LAB 3: Your code here.
-
-	//////////////////////////////////////////////////////////////////////
-	// Now that we've allocated the initial kernel data structures, we set
-	// up the list of free physical pages. Once we've done so, all further
-	// memory management will go through the page_* functions. In
-	// particular, we can now map memory using boot_map_region
-	// or page_insert
-	page_init();
-
-	check_page_free_list(1);
-	check_page_alloc();
-	check_page();
-
-	//////////////////////////////////////////////////////////////////////
-	// Now we set up virtual memory
-
-	//////////////////////////////////////////////////////////////////////
-	// Map 'pages' read-only by the user at linear address UPAGES
-	// Permissions:
-	//    - the new image at UPAGES -- kernel R, user R
-	//      (ie. perm = PTE_U | PTE_P)
-	//    - pages itself -- kernel RW, user NONE
-	// Your code goes here:
-
-	//////////////////////////////////////////////////////////////////////
-	// Map the 'envs' array read-only by the user at linear address UENVS
-	// (ie. perm = PTE_U | PTE_P).
-	// Permissions:
-	//    - the new image at UENVS  -- kernel R, user R
-	//    - envs itself -- kernel RW, user NONE
-	// LAB 3: Your code here.
-
-	//////////////////////////////////////////////////////////////////////
-	// Use the physical memory that 'bootstack' refers to as the kernel
-	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
-	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
-	// to be the kernel stack, but break this into two pieces:
-	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
-	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
-	//       the kernel overflows its stack, it will fault rather than
-	//       overwrite memory.  Known as a "guard page".
-	//     Permissions: kernel RW, user NONE
-	// Your code goes here:
-
-	//////////////////////////////////////////////////////////////////////
-	// Map all of physical memory at KERNBASE.
-	// Ie.  the VA range [KERNBASE, 2^32) should map to
-	//      the PA range [0, 2^32 - KERNBASE)
-	// We might not have 2^32 - KERNBASE bytes of physical memory, but
-	// we just set up the mapping anyway.
-	// Permissions: kernel RW, user NONE
-	// Your code goes here:
-
-	// Check that the initial page directory has been set up correctly.
-	check_kern_pgdir();
-
-	// Switch from the minimal entry page directory to the full kern_pgdir
-	// page table we just created.	Our instruction pointer should be
-	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
-	// mapped the same way by both page tables.
-	//
-	// If the machine reboots at this point, you've probably set up your
-	// kern_pgdir wrong.
-	lcr3(PADDR(kern_pgdir));
-
-	check_page_free_list(0);
-
-	// entry.S set the really important flags in cr0 (including enabling
-	// paging).  Here we configure the rest of the flags that we care about.
-	cr0 = rcr0();
-	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
-	cr0 &= ~(CR0_TS|CR0_EM);
-	lcr0(cr0);
-
-	// Some more checks, only possible after kern_pgdir is installed.
-	check_page_installed_pgdir();
+    uint32_t cr0;
+    size_t n;
+
+    // Find out how much memory the machine has (npages & npages_basemem).
+    i386_detect_memory();
+
+    // Remove this line when you're ready to test this function.
+    //panic("mem_init: This function is not finished\n");
+
+    //////////////////////////////////////////////////////////////////////
+    // create initial page directory.
+    kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
+    memset(kern_pgdir, 0, PGSIZE);
+
+    //////////////////////////////////////////////////////////////////////
+    // Recursively insert PD in itself as a page table, to form
+    // a virtual page table at virtual address UVPT.
+    // (For now, you don't have understand the greater purpose of the
+    // following line.)
+
+    // Permissions: kernel R, user R
+    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
+
+    //////////////////////////////////////////////////////////////////////
+    // Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
+    // The kernel uses this array to keep track of physical pages: for
+    // each physical page, there is a corresponding struct PageInfo in this
+    // array.  'npages' is the number of physical pages in memory.  Use memset
+    // to initialize all fields of each struct PageInfo to 0.
+    // Your code goes here:
+    pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
+    memset(pages, 0, npages * sizeof(struct PageInfo));
+
+    //////////////////////////////////////////////////////////////////////
+    // Make 'envs' point to an array of size 'NENV' of 'struct Env'.
+    // LAB 3: Your code here.
+    envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
+
+    //////////////////////////////////////////////////////////////////////
+    // Now that we've allocated the initial kernel data structures, we set
+    // up the list of free physical pages. Once we've done so, all further
+    // memory management will go through the page_* functions. In
+    // particular, we can now map memory using boot_map_region
+    // or page_insert
+    page_init();
+
+
+    check_page_free_list(1);
+    check_page_alloc();
+    check_page();
+
+    //////////////////////////////////////////////////////////////////////
+    // Now we set up virtual memory
+
+    //////////////////////////////////////////////////////////////////////
+    // Map 'pages' read-only by the user at linear address UPAGES
+    // Permissions:
+    //    - the new image at UPAGES -- kernel R, user R
+    //      (ie. perm = PTE_U | PTE_P)
+    //    - pages itself -- kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo)* npages, PGSIZE), PADDR(pages), PTE_U);
+
+    //////////////////////////////////////////////////////////////////////
+    // Map the 'envs' array read-only by the user at linear address UENVS
+    // (ie. perm = PTE_U | PTE_P).
+    // Permissions:
+    //    - the new image at UENVS  -- kernel R, user R
+    //    - envs itself -- kernel RW, user NONE
+    // LAB 3: Your code here.
+    boot_map_region(kern_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);	
+
+    //////////////////////////////////////////////////////////////////////
+    // Use the physical memory that 'bootstack' refers to as the kernel
+    // stack.  The kernel stack grows down from virtual address KSTACKTOP.
+    // We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
+    // to be the kernel stack, but break this into two pieces:
+    //     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
+    //     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
+    //       the kernel overflows its stack, it will fault rather than
+    //       overwrite memory.  Known as a "guard page".
+    //     Permissions: kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+
+    //////////////////////////////////////////////////////////////////////
+    // Map all of physical memory at KERNBASE.
+    // Ie.  the VA range [KERNBASE, 2^32) should map to
+    //      the PA range [0, 2^32 - KERNBASE)
+    // We might not have 2^32 - KERNBASE bytes of physical memory, but
+    // we just set up the mapping anyway.
+    // Permissions: kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+
+    // Check that the initial page directory has been set up correctly.
+    check_kern_pgdir();
+
+    // Switch from the minimal entry page directory to the full kern_pgdir
+    // page table we just created.	Our instruction pointer should be
+    // somewhere between KERNBASE and KERNBASE+4MB right now, which is
+    // mapped the same way by both page tables.
+    //
+    // If the machine reboots at this point, you've probably set up your
+    // kern_pgdir wrong.
+    lcr3(PADDR(kern_pgdir));
+
+    check_page_free_list(0);
+
+    // entry.S set the really important flags in cr0 (including enabling
+    // paging).  Here we configure the rest of the flags that we care about.
+    cr0 = rcr0();
+    cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
+    cr0 &= ~(CR0_TS|CR0_EM);
+    lcr0(cr0);
+
+    // Some more checks, only possible after kern_pgdir is installed.
+    check_page_installed_pgdir();
 }
 
 // --------------------------------------------------------------
@@ -244,32 +257,36 @@ mem_init(void)
 // allocator functions below to allocate and deallocate physical
 // memory via the page_free_list.
 //
-void
+    void
 page_init(void)
 {
-	// The example code here marks all physical pages as free.
-	// However this is not truly the case.  What memory is free?
-	//  1) Mark physical page 0 as in use.
-	//     This way we preserve the real-mode IDT and BIOS structures
-	//     in case we ever need them.  (Currently we don't, but...)
-	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
-	//     is free.
-	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
-	//     never be allocated.
-	//  4) Then extended memory [EXTPHYSMEM, ...).
-	//     Some of it is in use, some is free. Where is the kernel
-	//     in physical memory?  Which pages are already in use for
-	//     page tables and other data structures?
-	//
-	// Change the code to reflect this.
-	// NB: DO NOT actually touch the physical memory corresponding to
-	// free pages!
-	size_t i;
-	for (i = 0; i < npages; i++) {
-		pages[i].pp_ref = 0;
-		pages[i].pp_link = page_free_list;
-		page_free_list = &pages[i];
-	}
+    // The example code here marks all physical pages as free.
+    // However this is not truly the case.  What memory is free?
+    //  1) Mark physical page 0 as in use.
+    //     This way we preserve the real-mode IDT and BIOS structures
+    //     in case we ever need them.  (Currently we don't, but...)
+    //  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
+    //     is free.
+    //  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
+    //     never be allocated.
+    //  4) Then extended memory [EXTPHYSMEM, ...).
+    //     Some of it is in use, some is free. Where is the kernel
+    //     in physical memory?  Which pages are already in use for
+    //     page tables and other data structures?
+    //
+    // Change the code to reflect this.
+    // NB: DO NOT actually touch the physical memory corresponding to
+    // free pages!
+    size_t i;
+    assert(page_free_list == 0);
+    unsigned used_top = PADDR(boot_alloc(0));
+    for (i = 0; i < npages; i++) {
+	if (i == 0 || (page2pa(&pages[i]) >= IOPHYSMEM && page2pa(&pages[i]) < used_top))
+	    continue;
+	pages[i].pp_ref = 0;
+	pages[i].pp_link = page_free_list;
+	page_free_list = &pages[i];
+    }
 }
 
 //
@@ -284,34 +301,51 @@ page_init(void)
 // Returns NULL if out of free memory.
 //
 // Hint: use page2kva and memset
-struct PageInfo *
+    struct PageInfo *
 page_alloc(int alloc_flags)
 {
-	// Fill this function in
-	return 0;
+    // Fill this function in
+    if (page_free_list == NULL) return NULL;
+    struct PageInfo* ret = page_free_list;
+    page_free_list = ret->pp_link;
+    if (alloc_flags & ALLOC_ZERO) 
+	memset(page2kva(ret), 0, PGSIZE);
+    ret->pp_link = NULL;
+    return ret;
+
 }
 
 //
 // Return a page to the free list.
 // (This function should only be called when pp->pp_ref reaches 0.)
 //
-void
+    void
 page_free(struct PageInfo *pp)
 {
-	// Fill this function in
-	// Hint: You may want to panic if pp->pp_ref is nonzero or
-	// pp->pp_link is not NULL.
+    // Fill this function in
+    // Hint: You may want to panic if pp->pp_ref is nonzero or
+    // pp->pp_link is not NULL.
+
+    if(pp->pp_ref == 0){
+	pp->pp_link = page_free_list;
+	page_free_list = pp;
+    }
+    else
+    {
+	panic("pp->pp_ref is not zero. Wrong call of the page_free!!!");
+    }
 }
 
+
 //
 // Decrement the reference count on a page,
 // freeing it if there are no more refs.
 //
-void
+    void
 page_decref(struct PageInfo* pp)
 {
-	if (--pp->pp_ref == 0)
-		page_free(pp);
+    if (--pp->pp_ref == 0)
+	page_free(pp);
 }
 
 // Given 'pgdir', a pointer to a page directory, pgdir_walk returns
@@ -336,11 +370,18 @@ page_decref(struct PageInfo* pp)
 // Hint 3: look at inc/mmu.h for useful macros that mainipulate page
 // table and page directory entries.
 //
-pte_t *
+    pte_t *
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
-	// Fill this function in
-	return NULL;
+    // Fill this function in
+    if (!(pgdir[PDX(va)] & PTE_P)) {
+	if (!create) return NULL;
+	struct PageInfo *page = page_alloc(ALLOC_ZERO);
+	if (!page) return NULL;
+	page->pp_ref = 1;
+	pgdir[PDX(va)] = page2pa(page) | PTE_P | PTE_U | PTE_W;
+    }
+    return KADDR(PTE_ADDR(pgdir[PDX(va)])) + PTX(va) * sizeof(pte_t*);
 }
 
 //
@@ -354,12 +395,19 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 // mapped pages.
 //
 // Hint: the TA solution uses pgdir_walk
-static void
+//
+    static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
-	// Fill this function in
+    // Fill this function in
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
 }
 
+
 //
 // Map the physical page 'pp' at virtual address 'va'.
 // The permissions (the low 12 bits) of the page table entry
@@ -385,11 +433,24 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 // Hint: The TA solution is implemented using pgdir_walk, page_remove,
 // and page2pa.
 //
-int
+    int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
-	// Fill this function in
-	return 0;
+    // Fill this function in
+    pte_t *pte = pgdir_walk(pgdir, va, 1);
+    if (pte == NULL) return -E_NO_MEM;
+    if (*pte & PTE_P) {
+	if (PTE_ADDR(*pte) == page2pa(pp)) {
+	    pp->pp_ref--;
+	    tlb_invalidate(pgdir, va);
+	}
+	else {
+	    page_remove(pgdir, va);
+	}
+    }
+    *pte = page2pa(pp) | perm | PTE_P;
+    pp->pp_ref++;
+    return 0;
 }
 
 //
@@ -403,17 +464,20 @@ page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 //
 // Hint: the TA solution uses pgdir_walk and pa2page.
 //
-struct PageInfo *
+    struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 {
-	// Fill this function in
-	return NULL;
+    // Fill this function in
+    pte_t *pte = pgdir_walk(pgdir, va, 0);
+    if (pte_store != NULL) *pte_store = pte;
+    if (pte == NULL || !(*pte & PTE_P)) return NULL;
+    return pa2page(PTE_ADDR(*pte));
 }
 
 //
 // Unmaps the physical page at virtual address 'va'.
 // If there is no physical page at that address, silently does nothing.
-//
+// 
 // Details:
 //   - The ref count on the physical page should decrement.
 //   - The physical page should be freed if the refcount reaches 0.
@@ -425,22 +489,29 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 // Hint: The TA solution is implemented using page_lookup,
 // 	tlb_invalidate, and page_decref.
 //
-void
+    void
 page_remove(pde_t *pgdir, void *va)
 {
-	// Fill this function in
+    // Fill this function in
+    struct PageInfo *page = page_lookup(pgdir, va, 0);
+    pte_t *pte = pgdir_walk(pgdir, va, 0);
+    if (page != NULL) page_decref(page);
+    if (pte != NULL) {
+	*pte = 0;
+	tlb_invalidate(pgdir, va);
+    }
 }
 
 //
 // Invalidate a TLB entry, but only if the page tables being
 // edited are the ones currently in use by the processor.
 //
-void
+    void
 tlb_invalidate(pde_t *pgdir, void *va)
 {
-	// Flush the entry only if we're modifying the current address space.
-	// For now, there is only one address space, so always invalidate.
-	invlpg(va);
+    // Flush the entry only if we're modifying the current address space.
+    // For now, there is only one address space, so always invalidate.
+    invlpg(va);
 }
 
 static uintptr_t user_mem_check_addr;
@@ -463,12 +534,25 @@ static uintptr_t user_mem_check_addr;
 // Returns 0 if the user program can access this range of addresses,
 // and -E_FAULT otherwise.
 //
-int
+    int
 user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 {
-	// LAB 3: Your code here.
-
-	return 0;
+    // LAB 3: Your code here.
+
+    uintptr_t va1 = (uintptr_t)va, va2 = va1 + len;
+    pte_t *pte;
+    for (; va1 < va2; va1 = ROUNDDOWN(va1 + PGSIZE, PGSIZE)) {
+	if (va1 >= ULIM) {
+	    user_mem_check_addr = va1;
+	    return -E_FAULT;
+	}
+	pte = pgdir_walk(env->env_pgdir, (void*)va1, 0);
+	if ((*pte & (perm | PTE_P)) != (perm | PTE_P)) {
+	    user_mem_check_addr = va1;
+	    return -E_FAULT;
+	}
+    }
+    return 0;
 }
 
 //
@@ -478,14 +562,14 @@ user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 // If it cannot, 'env' is destroyed and, if env is the current
 // environment, this function will not return.
 //
-void
+    void
 user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
 {
-	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
-		cprintf("[%08x] user_mem_check assertion failure for "
-			"va %08x\n", env->env_id, user_mem_check_addr);
-		env_destroy(env);	// may not return
-	}
+    if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
+	cprintf("[%08x] user_mem_check assertion failure for "
+		"va %08x\n", env->env_id, user_mem_check_addr);
+	env_destroy(env);	// may not return
+    }
 }
 
 
@@ -496,138 +580,138 @@ user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
 //
 // Check that the pages on the page_free_list are reasonable.
 //
-static void
+    static void
 check_page_free_list(bool only_low_memory)
 {
-	struct PageInfo *pp;
-	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
-	int nfree_basemem = 0, nfree_extmem = 0;
-	char *first_free_page;
-
-	if (!page_free_list)
-		panic("'page_free_list' is a null pointer!");
-
-	if (only_low_memory) {
-		// Move pages with lower addresses first in the free
-		// list, since entry_pgdir does not map all pages.
-		struct PageInfo *pp1, *pp2;
-		struct PageInfo **tp[2] = { &pp1, &pp2 };
-		for (pp = page_free_list; pp; pp = pp->pp_link) {
-			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
-			*tp[pagetype] = pp;
-			tp[pagetype] = &pp->pp_link;
-		}
-		*tp[1] = 0;
-		*tp[0] = pp2;
-		page_free_list = pp1;
-	}
-
-	// if there's a page that shouldn't be on the free list,
-	// try to make sure it eventually causes trouble.
-	for (pp = page_free_list; pp; pp = pp->pp_link)
-		if (PDX(page2pa(pp)) < pdx_limit)
-			memset(page2kva(pp), 0x97, 128);
-
-	first_free_page = (char *) boot_alloc(0);
+    struct PageInfo *pp;
+    unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
+    int nfree_basemem = 0, nfree_extmem = 0;
+    char *first_free_page;
+
+    if (!page_free_list)
+	panic("'page_free_list' is a null pointer!");
+
+    if (only_low_memory) {
+	// Move pages with lower addresses first in the free
+	// list, since entry_pgdir does not map all pages.
+	struct PageInfo *pp1, *pp2;
+	struct PageInfo **tp[2] = { &pp1, &pp2 };
 	for (pp = page_free_list; pp; pp = pp->pp_link) {
-		// check that we didn't corrupt the free list itself
-		assert(pp >= pages);
-		assert(pp < pages + npages);
-		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
-
-		// check a few pages that shouldn't be on the free list
-		assert(page2pa(pp) != 0);
-		assert(page2pa(pp) != IOPHYSMEM);
-		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
-		assert(page2pa(pp) != EXTPHYSMEM);
-		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
-
-		if (page2pa(pp) < EXTPHYSMEM)
-			++nfree_basemem;
-		else
-			++nfree_extmem;
+	    int pagetype = PDX(page2pa(pp)) >= pdx_limit;
+	    *tp[pagetype] = pp;
+	    tp[pagetype] = &pp->pp_link;
 	}
+	*tp[1] = 0;
+	*tp[0] = pp2;
+	page_free_list = pp1;
+    }
+
+    // if there's a page that shouldn't be on the free list,
+    // try to make sure it eventually causes trouble.
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+	if (PDX(page2pa(pp)) < pdx_limit)
+	    memset(page2kva(pp), 0x97, 128);
+
+    first_free_page = (char *) boot_alloc(0);
+    for (pp = page_free_list; pp; pp = pp->pp_link) {
+	// check that we didn't corrupt the free list itself
+	assert(pp >= pages);
+	assert(pp < pages + npages);
+	assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
+
+	// check a few pages that shouldn't be on the free list
+	assert(page2pa(pp) != 0);
+	assert(page2pa(pp) != IOPHYSMEM);
+	assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
+	assert(page2pa(pp) != EXTPHYSMEM);
+	assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
+
+	if (page2pa(pp) < EXTPHYSMEM)
+	    ++nfree_basemem;
+	else
+	    ++nfree_extmem;
+    }
 
-	assert(nfree_basemem > 0);
-	assert(nfree_extmem > 0);
+    assert(nfree_basemem > 0);
+    assert(nfree_extmem > 0);
 }
 
 //
 // Check the physical page allocator (page_alloc(), page_free(),
 // and page_init()).
 //
-static void
+    static void
 check_page_alloc(void)
 {
-	struct PageInfo *pp, *pp0, *pp1, *pp2;
-	int nfree;
-	struct PageInfo *fl;
-	char *c;
-	int i;
-
-	if (!pages)
-		panic("'pages' is a null pointer!");
-
-	// check number of free pages
-	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
-		++nfree;
-
-	// should be able to allocate three pages
-	pp0 = pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-
-	assert(pp0);
-	assert(pp1 && pp1 != pp0);
-	assert(pp2 && pp2 != pp1 && pp2 != pp0);
-	assert(page2pa(pp0) < npages*PGSIZE);
-	assert(page2pa(pp1) < npages*PGSIZE);
-	assert(page2pa(pp2) < npages*PGSIZE);
-
-	// temporarily steal the rest of the free pages
-	fl = page_free_list;
-	page_free_list = 0;
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// free and re-allocate?
-	page_free(pp0);
-	page_free(pp1);
-	page_free(pp2);
-	pp0 = pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-	assert(pp0);
-	assert(pp1 && pp1 != pp0);
-	assert(pp2 && pp2 != pp1 && pp2 != pp0);
-	assert(!page_alloc(0));
-
-	// test flags
-	memset(page2kva(pp0), 1, PGSIZE);
-	page_free(pp0);
-	assert((pp = page_alloc(ALLOC_ZERO)));
-	assert(pp && pp0 == pp);
-	c = page2kva(pp);
-	for (i = 0; i < PGSIZE; i++)
-		assert(c[i] == 0);
-
-	// give free list back
-	page_free_list = fl;
-
-	// free the pages we took
-	page_free(pp0);
-	page_free(pp1);
-	page_free(pp2);
-
-	// number of free pages should be the same
-	for (pp = page_free_list; pp; pp = pp->pp_link)
-		--nfree;
-	assert(nfree == 0);
-
-	cprintf("check_page_alloc() succeeded!\n");
+    struct PageInfo *pp, *pp0, *pp1, *pp2;
+    int nfree;
+    struct PageInfo *fl;
+    char *c;
+    int i;
+
+    if (!pages)
+	panic("'pages' is a null pointer!");
+
+    // check number of free pages
+    for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
+	++nfree;
+
+    // should be able to allocate three pages
+    pp0 = pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+
+    assert(pp0);
+    assert(pp1 && pp1 != pp0);
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+    assert(page2pa(pp0) < npages*PGSIZE);
+    assert(page2pa(pp1) < npages*PGSIZE);
+    assert(page2pa(pp2) < npages*PGSIZE);
+
+    // temporarily steal the rest of the free pages
+    fl = page_free_list;
+    page_free_list = 0;
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // free and re-allocate?
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+    pp0 = pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+    assert(pp0);
+    assert(pp1 && pp1 != pp0);
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+    assert(!page_alloc(0));
+
+    // test flags
+    memset(page2kva(pp0), 1, PGSIZE);
+    page_free(pp0);
+    assert((pp = page_alloc(ALLOC_ZERO)));
+    assert(pp && pp0 == pp);
+    c = page2kva(pp);
+    for (i = 0; i < PGSIZE; i++)
+	assert(c[i] == 0);
+
+    // give free list back
+    page_free_list = fl;
+
+    // free the pages we took
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+
+    // number of free pages should be the same
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+	--nfree;
+    assert(nfree == 0);
+
+    cprintf("check_page_alloc() succeeded!\n");
 }
 
 //
@@ -638,52 +722,52 @@ check_page_alloc(void)
 // but it is a pretty good sanity check.
 //
 
-static void
+    static void
 check_kern_pgdir(void)
 {
-	uint32_t i, n;
-	pde_t *pgdir;
-
-	pgdir = kern_pgdir;
-
-	// check pages array
-	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
-	for (i = 0; i < n; i += PGSIZE)
-		assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
-
-	// check envs array (new test for lab 3)
-	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
-	for (i = 0; i < n; i += PGSIZE)
-		assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
-
-	// check phys mem
-	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
-		assert(check_va2pa(pgdir, KERNBASE + i) == i);
-
-	// check kernel stack
-	for (i = 0; i < KSTKSIZE; i += PGSIZE)
-		assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
-	assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);
-
-	// check PDE permissions
-	for (i = 0; i < NPDENTRIES; i++) {
-		switch (i) {
-		case PDX(UVPT):
-		case PDX(KSTACKTOP-1):
-		case PDX(UPAGES):
-		case PDX(UENVS):
-			assert(pgdir[i] & PTE_P);
-			break;
-		default:
-			if (i >= PDX(KERNBASE)) {
-				assert(pgdir[i] & PTE_P);
-				assert(pgdir[i] & PTE_W);
-			} else
-				assert(pgdir[i] == 0);
-			break;
-		}
+    uint32_t i, n;
+    pde_t *pgdir;
+
+    pgdir = kern_pgdir;
+
+    // check pages array
+    n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+	assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+
+    // check envs array (new test for lab 3)
+    n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+	assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+
+    // check phys mem
+    for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+	assert(check_va2pa(pgdir, KERNBASE + i) == i);
+
+    // check kernel stack
+    for (i = 0; i < KSTKSIZE; i += PGSIZE)
+	assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
+    assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);
+
+    // check PDE permissions
+    for (i = 0; i < NPDENTRIES; i++) {
+	switch (i) {
+	    case PDX(UVPT):
+	    case PDX(KSTACKTOP-1):
+	    case PDX(UPAGES):
+	    case PDX(UENVS):
+		assert(pgdir[i] & PTE_P);
+		break;
+	    default:
+		if (i >= PDX(KERNBASE)) {
+		    assert(pgdir[i] & PTE_P);
+		    assert(pgdir[i] & PTE_W);
+		} else
+		    assert(pgdir[i] == 0);
+		break;
 	}
-	cprintf("check_kern_pgdir() succeeded!\n");
+    }
+    cprintf("check_kern_pgdir() succeeded!\n");
 }
 
 // This function returns the physical address of the page containing 'va',
@@ -691,212 +775,212 @@ check_kern_pgdir(void)
 // this functionality for us!  We define our own version to help check
 // the check_kern_pgdir() function; it shouldn't be used elsewhere.
 
-static physaddr_t
+    static physaddr_t
 check_va2pa(pde_t *pgdir, uintptr_t va)
 {
-	pte_t *p;
-
-	pgdir = &pgdir[PDX(va)];
-	if (!(*pgdir & PTE_P))
-		return ~0;
-	p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
-	if (!(p[PTX(va)] & PTE_P))
-		return ~0;
-	return PTE_ADDR(p[PTX(va)]);
+    pte_t *p;
+
+    pgdir = &pgdir[PDX(va)];
+    if (!(*pgdir & PTE_P))
+	return ~0;
+    p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
+    if (!(p[PTX(va)] & PTE_P))
+	return ~0;
+    return PTE_ADDR(p[PTX(va)]);
 }
 
 
 // check page_insert, page_remove, &c
-static void
+    static void
 check_page(void)
 {
-	struct PageInfo *pp, *pp0, *pp1, *pp2;
-	struct PageInfo *fl;
-	pte_t *ptep, *ptep1;
-	void *va;
-	int i;
-	extern pde_t entry_pgdir[];
-
-	// should be able to allocate three pages
-	pp0 = pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-
-	assert(pp0);
-	assert(pp1 && pp1 != pp0);
-	assert(pp2 && pp2 != pp1 && pp2 != pp0);
-
-	// temporarily steal the rest of the free pages
-	fl = page_free_list;
-	page_free_list = 0;
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// there is no page allocated at address 0
-	assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
-
-	// there is no free memory, so we can't allocate a page table
-	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
-
-	// free pp0 and try again: pp0 should be used for page table
-	page_free(pp0);
-	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
-	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
-	assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
-	assert(pp1->pp_ref == 1);
-	assert(pp0->pp_ref == 1);
-
-	// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
-	assert(pp2->pp_ref == 1);
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// should be able to map pp2 at PGSIZE because it's already there
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
-	assert(pp2->pp_ref == 1);
-
-	// pp2 should NOT be on the free list
-	// could happen in ref counts are handled sloppily in page_insert
-	assert(!page_alloc(0));
-
-	// check that pgdir_walk returns a pointer to the pte
-	ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
-	assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
-
-	// should be able to change permissions too.
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
-	assert(pp2->pp_ref == 1);
-	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
-	assert(kern_pgdir[0] & PTE_U);
-
-	// should be able to remap with fewer permissions
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
-	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
-	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
-
-	// should not be able to map at PTSIZE because need free page for page table
-	assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
-
-	// insert pp1 at PGSIZE (replacing pp2)
-	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
-	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
-
-	// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
-	assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
-	// ... and ref counts should reflect this
-	assert(pp1->pp_ref == 2);
-	assert(pp2->pp_ref == 0);
-
-	// pp2 should be returned by page_alloc
-	assert((pp = page_alloc(0)) && pp == pp2);
-
-	// unmapping pp1 at 0 should keep pp1 at PGSIZE
-	page_remove(kern_pgdir, 0x0);
-	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
-	assert(pp1->pp_ref == 1);
-	assert(pp2->pp_ref == 0);
-
-	// test re-inserting pp1 at PGSIZE
-	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
-	assert(pp1->pp_ref);
-	assert(pp1->pp_link == NULL);
-
-	// unmapping pp1 at PGSIZE should free it
-	page_remove(kern_pgdir, (void*) PGSIZE);
-	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
-	assert(pp1->pp_ref == 0);
-	assert(pp2->pp_ref == 0);
-
-	// so it should be returned by page_alloc
-	assert((pp = page_alloc(0)) && pp == pp1);
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// forcibly take pp0 back
-	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
-	kern_pgdir[0] = 0;
-	assert(pp0->pp_ref == 1);
-	pp0->pp_ref = 0;
-
-	// check pointer arithmetic in pgdir_walk
-	page_free(pp0);
-	va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
-	ptep = pgdir_walk(kern_pgdir, va, 1);
-	ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
-	assert(ptep == ptep1 + PTX(va));
-	kern_pgdir[PDX(va)] = 0;
-	pp0->pp_ref = 0;
-
-	// check that new page tables get cleared
-	memset(page2kva(pp0), 0xFF, PGSIZE);
-	page_free(pp0);
-	pgdir_walk(kern_pgdir, 0x0, 1);
-	ptep = (pte_t *) page2kva(pp0);
-	for(i=0; i<NPTENTRIES; i++)
-		assert((ptep[i] & PTE_P) == 0);
-	kern_pgdir[0] = 0;
-	pp0->pp_ref = 0;
-
-	// give free list back
-	page_free_list = fl;
-
-	// free the pages we took
-	page_free(pp0);
-	page_free(pp1);
-	page_free(pp2);
-
-	cprintf("check_page() succeeded!\n");
+    struct PageInfo *pp, *pp0, *pp1, *pp2;
+    struct PageInfo *fl;
+    pte_t *ptep, *ptep1;
+    void *va;
+    int i;
+    extern pde_t entry_pgdir[];
+
+    // should be able to allocate three pages
+    pp0 = pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+
+    assert(pp0);
+    assert(pp1 && pp1 != pp0);
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+
+    // temporarily steal the rest of the free pages
+    fl = page_free_list;
+    page_free_list = 0;
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // there is no page allocated at address 0
+    assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
+
+    // there is no free memory, so we can't allocate a page table
+    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
+
+    // free pp0 and try again: pp0 should be used for page table
+    page_free(pp0);
+    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+    assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
+    assert(pp1->pp_ref == 1);
+    assert(pp0->pp_ref == 1);
+
+    // should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+    assert(pp2->pp_ref == 1);
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // should be able to map pp2 at PGSIZE because it's already there
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+    assert(pp2->pp_ref == 1);
+
+    // pp2 should NOT be on the free list
+    // could happen in ref counts are handled sloppily in page_insert
+    assert(!page_alloc(0));
+
+    // check that pgdir_walk returns a pointer to the pte
+    ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
+    assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
+
+    // should be able to change permissions too.
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+    assert(pp2->pp_ref == 1);
+    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
+    assert(kern_pgdir[0] & PTE_U);
+
+    // should be able to remap with fewer permissions
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
+    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+    // should not be able to map at PTSIZE because need free page for page table
+    assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
+
+    // insert pp1 at PGSIZE (replacing pp2)
+    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
+    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+    // should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
+    assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+    // ... and ref counts should reflect this
+    assert(pp1->pp_ref == 2);
+    assert(pp2->pp_ref == 0);
+
+    // pp2 should be returned by page_alloc
+    assert((pp = page_alloc(0)) && pp == pp2);
+
+    // unmapping pp1 at 0 should keep pp1 at PGSIZE
+    page_remove(kern_pgdir, 0x0);
+    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+    assert(pp1->pp_ref == 1);
+    assert(pp2->pp_ref == 0);
+
+    // test re-inserting pp1 at PGSIZE
+    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
+    assert(pp1->pp_ref);
+    assert(pp1->pp_link == NULL);
+
+    // unmapping pp1 at PGSIZE should free it
+    page_remove(kern_pgdir, (void*) PGSIZE);
+    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
+    assert(pp1->pp_ref == 0);
+    assert(pp2->pp_ref == 0);
+
+    // so it should be returned by page_alloc
+    assert((pp = page_alloc(0)) && pp == pp1);
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // forcibly take pp0 back
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+    kern_pgdir[0] = 0;
+    assert(pp0->pp_ref == 1);
+    pp0->pp_ref = 0;
+
+    // check pointer arithmetic in pgdir_walk
+    page_free(pp0);
+    va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
+    ptep = pgdir_walk(kern_pgdir, va, 1);
+    ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
+    assert(ptep == ptep1 + PTX(va));
+    kern_pgdir[PDX(va)] = 0;
+    pp0->pp_ref = 0;
+
+    // check that new page tables get cleared
+    memset(page2kva(pp0), 0xFF, PGSIZE);
+    page_free(pp0);
+    pgdir_walk(kern_pgdir, 0x0, 1);
+    ptep = (pte_t *) page2kva(pp0);
+    for(i=0; i<NPTENTRIES; i++)
+	assert((ptep[i] & PTE_P) == 0);
+    kern_pgdir[0] = 0;
+    pp0->pp_ref = 0;
+
+    // give free list back
+    page_free_list = fl;
+
+    // free the pages we took
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+
+    cprintf("check_page() succeeded!\n");
 }
 
 // check page_insert, page_remove, &c, with an installed kern_pgdir
-static void
+    static void
 check_page_installed_pgdir(void)
 {
-	struct PageInfo *pp, *pp0, *pp1, *pp2;
-	struct PageInfo *fl;
-	pte_t *ptep, *ptep1;
-	uintptr_t va;
-	int i;
-
-	// check that we can read and write installed pages
-	pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-	page_free(pp0);
-	memset(page2kva(pp1), 1, PGSIZE);
-	memset(page2kva(pp2), 2, PGSIZE);
-	page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
-	assert(pp1->pp_ref == 1);
-	assert(*(uint32_t *)PGSIZE == 0x01010101U);
-	page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
-	assert(*(uint32_t *)PGSIZE == 0x02020202U);
-	assert(pp2->pp_ref == 1);
-	assert(pp1->pp_ref == 0);
-	*(uint32_t *)PGSIZE = 0x03030303U;
-	assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
-	page_remove(kern_pgdir, (void*) PGSIZE);
-	assert(pp2->pp_ref == 0);
-
-	// forcibly take pp0 back
-	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
-	kern_pgdir[0] = 0;
-	assert(pp0->pp_ref == 1);
-	pp0->pp_ref = 0;
-
-	// free the pages we took
-	page_free(pp0);
-
-	cprintf("check_page_installed_pgdir() succeeded!\n");
+    struct PageInfo *pp, *pp0, *pp1, *pp2;
+    struct PageInfo *fl;
+    pte_t *ptep, *ptep1;
+    uintptr_t va;
+    int i;
+
+    // check that we can read and write installed pages
+    pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+    page_free(pp0);
+    memset(page2kva(pp1), 1, PGSIZE);
+    memset(page2kva(pp2), 2, PGSIZE);
+    page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
+    assert(pp1->pp_ref == 1);
+    assert(*(uint32_t *)PGSIZE == 0x01010101U);
+    page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
+    assert(*(uint32_t *)PGSIZE == 0x02020202U);
+    assert(pp2->pp_ref == 1);
+    assert(pp1->pp_ref == 0);
+    *(uint32_t *)PGSIZE = 0x03030303U;
+    assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
+    page_remove(kern_pgdir, (void*) PGSIZE);
+    assert(pp2->pp_ref == 0);
+
+    // forcibly take pp0 back
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+    kern_pgdir[0] = 0;
+    assert(pp0->pp_ref == 1);
+    pp0->pp_ref = 0;
+
+    // free the pages we took
+    page_free(pp0);
+
+    cprintf("check_page_installed_pgdir() succeeded!\n");
 }
diff --git a/kern/pmap.c~ b/kern/pmap.c~
new file mode 100644
index 0000000..180c733
--- /dev/null
+++ b/kern/pmap.c~
@@ -0,0 +1,973 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/x86.h>
+#include <inc/mmu.h>
+#include <inc/error.h>
+#include <inc/string.h>
+#include <inc/assert.h>
+
+#include <kern/pmap.h>
+#include <kern/kclock.h>
+#include <kern/env.h>
+
+// These variables are set by i386_detect_memory()
+size_t npages;			// Amount of physical memory (in pages)
+static size_t npages_basemem;	// Amount of base memory (in pages)
+
+// These variables are set in mem_init()
+pde_t *kern_pgdir;		// Kernel's initial page directory
+struct PageInfo *pages;		// Physical page state array
+static struct PageInfo *page_free_list;	// Free list of physical pages
+
+// --------------------------------------------------------------
+// Detect machine's physical memory setup.
+// --------------------------------------------------------------
+
+static int
+nvram_read(int r)
+{
+	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
+}
+
+static void
+i386_detect_memory(void)
+{
+	size_t basemem, extmem, ext16mem, totalmem;
+
+	// Use CMOS calls to measure available base & extended memory.
+	// (CMOS calls return results in kilobytes.)
+	basemem = nvram_read(NVRAM_BASELO);
+	extmem = nvram_read(NVRAM_EXTLO);
+	ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
+
+	// Calculate the number of physical pages available in both base
+	// and extended memory.
+	if (ext16mem)
+		totalmem = 16 * 1024 + ext16mem;
+	else if (extmem)
+		totalmem = 1 * 1024 + extmem;
+	else
+		totalmem = basemem;
+
+	npages = totalmem / (PGSIZE / 1024);
+	npages_basemem = basemem / (PGSIZE / 1024);
+
+	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
+		totalmem, basemem, totalmem - basemem);
+}
+
+
+// --------------------------------------------------------------
+// Set up memory mappings above UTOP.
+// --------------------------------------------------------------
+
+static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);
+static void check_page_free_list(bool only_low_memory);
+static void check_page_alloc(void);
+static void check_kern_pgdir(void);
+static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
+static void check_page(void);
+static void check_page_installed_pgdir(void);
+
+// This simple physical memory allocator is used only while JOS is setting
+// up its virtual memory system.  page_alloc() is the real allocator.
+//
+// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
+// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
+//
+// If n==0, returns the address of the next free page without allocating
+// anything.
+//
+// If we're out of memory, boot_alloc should panic.
+// This function may ONLY be used during initialization,
+// before the page_free_list list has been set up.
+static void *
+boot_alloc(uint32_t n)
+{
+	static char *nextfree;	// virtual address of next byte of free memory
+	char *result;
+	// Initialize nextfree if this is the first time.
+	// 'end' is a magic symbol automatically generated by the linker,
+	// which points to the end of the kernel's bss segment:
+	// the first virtual address that the linker did *not* assign
+	// to any kernel code or global variables.
+	if (!nextfree) {
+		extern char end[];
+		nextfree = ROUNDUP((char *) end, PGSIZE);
+	}
+
+	// Allocate a chunk large enough to hold 'n' bytes, then update
+	// nextfree.  Make sure nextfree is kept aligned
+	// to a multiple of PGSIZE.
+	// LAB 2: Your code here.
+	if (n == 0) return (void*)nextfree;
+	n = ROUNDUP(n, PGSIZE);
+	if (PADDR(nextfree + n) > npages * PGSIZE)
+	{
+		panic("kern/pmap.c: boot_alloc()");
+		return NULL;
+	}
+	result = nextfree;
+	nextfree += n;
+	return result;
+}
+
+// Set up a two-level page table:
+//    kern_pgdir is its linear (virtual) address of the root
+//
+// This function only sets up the kernel part of the address space
+// (ie. addresses >= UTOP).  The user part of the address space
+// will be setup later.
+//
+// From UTOP to ULIM, the user is allowed to read but not write.
+// Above ULIM the user cannot read or write.
+void
+mem_init(void)
+{
+	uint32_t cr0;
+	size_t n;
+
+	// Find out how much memory the machine has (npages & npages_basemem).
+	i386_detect_memory();
+
+	// Remove this line when you're ready to test this function.
+	//panic("mem_init: This function is not finished\n");
+
+	//////////////////////////////////////////////////////////////////////
+	// create initial page directory.
+	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
+	memset(kern_pgdir, 0, PGSIZE);
+
+	//////////////////////////////////////////////////////////////////////
+	// Recursively insert PD in itself as a page table, to form
+	// a virtual page table at virtual address UVPT.
+	// (For now, you don't have understand the greater purpose of the
+	// following line.)
+
+	// Permissions: kernel R, user R
+	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
+
+	//////////////////////////////////////////////////////////////////////
+	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
+	// The kernel uses this array to keep track of physical pages: for
+	// each physical page, there is a corresponding struct PageInfo in this
+	// array.  'npages' is the number of physical pages in memory.  Use memset
+	// to initialize all fields of each struct PageInfo to 0.
+	// Your code goes here:
+	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
+	memset(pages, 0, npages * sizeof(struct PageInfo));
+
+	//////////////////////////////////////////////////////////////////////
+	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
+	// LAB 3: Your code here.
+	 envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
+
+	//////////////////////////////////////////////////////////////////////
+	// Now that we've allocated the initial kernel data structures, we set
+	// up the list of free physical pages. Once we've done so, all further
+	// memory management will go through the page_* functions. In
+	// particular, we can now map memory using boot_map_region
+	// or page_insert
+	page_init();
+	
+
+	check_page_free_list(1);
+	check_page_alloc();
+	check_page();
+
+	//////////////////////////////////////////////////////////////////////
+	// Now we set up virtual memory
+
+	//////////////////////////////////////////////////////////////////////
+	// Map 'pages' read-only by the user at linear address UPAGES
+	// Permissions:
+	//    - the new image at UPAGES -- kernel R, user R
+	//      (ie. perm = PTE_U | PTE_P)
+	//    - pages itself -- kernel RW, user NONE
+	// Your code goes here:
+    	boot_map_region(kern_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo)* npages, PGSIZE), PADDR(pages), PTE_U);
+
+	//////////////////////////////////////////////////////////////////////
+	// Map the 'envs' array read-only by the user at linear address UENVS
+	// (ie. perm = PTE_U | PTE_P).
+	// Permissions:
+	//    - the new image at UENVS  -- kernel R, user R
+	//    - envs itself -- kernel RW, user NONE
+	// LAB 3: Your code here.
+ 	//boot_map_region(kern_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);	
+
+	//////////////////////////////////////////////////////////////////////
+	// Use the physical memory that 'bootstack' refers to as the kernel
+	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
+	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
+	// to be the kernel stack, but break this into two pieces:
+	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
+	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
+	//       the kernel overflows its stack, it will fault rather than
+	//       overwrite memory.  Known as a "guard page".
+	//     Permissions: kernel RW, user NONE
+	// Your code goes here:
+	 boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+
+	//////////////////////////////////////////////////////////////////////
+	// Map all of physical memory at KERNBASE.
+	// Ie.  the VA range [KERNBASE, 2^32) should map to
+	//      the PA range [0, 2^32 - KERNBASE)
+	// We might not have 2^32 - KERNBASE bytes of physical memory, but
+	// we just set up the mapping anyway.
+	// Permissions: kernel RW, user NONE
+	// Your code goes here:
+    boot_map_region(kern_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+
+	// Check that the initial page directory has been set up correctly.
+	check_kern_pgdir();
+
+	// Switch from the minimal entry page directory to the full kern_pgdir
+	// page table we just created.	Our instruction pointer should be
+	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
+	// mapped the same way by both page tables.
+	//
+	// If the machine reboots at this point, you've probably set up your
+	// kern_pgdir wrong.
+	lcr3(PADDR(kern_pgdir));
+
+	check_page_free_list(0);
+
+	// entry.S set the really important flags in cr0 (including enabling
+	// paging).  Here we configure the rest of the flags that we care about.
+	cr0 = rcr0();
+	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
+	cr0 &= ~(CR0_TS|CR0_EM);
+	lcr0(cr0);
+
+	// Some more checks, only possible after kern_pgdir is installed.
+	check_page_installed_pgdir();
+}
+
+// --------------------------------------------------------------
+// Tracking of physical pages.
+// The 'pages' array has one 'struct PageInfo' entry per physical page.
+// Pages are reference counted, and free pages are kept on a linked list.
+// --------------------------------------------------------------
+
+//
+// Initialize page structure and memory free list.
+// After this is done, NEVER use boot_alloc again.  ONLY use the page
+// allocator functions below to allocate and deallocate physical
+// memory via the page_free_list.
+//
+void
+page_init(void)
+{
+	// The example code here marks all physical pages as free.
+	// However this is not truly the case.  What memory is free?
+	//  1) Mark physical page 0 as in use.
+	//     This way we preserve the real-mode IDT and BIOS structures
+	//     in case we ever need them.  (Currently we don't, but...)
+	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
+	//     is free.
+	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
+	//     never be allocated.
+	//  4) Then extended memory [EXTPHYSMEM, ...).
+	//     Some of it is in use, some is free. Where is the kernel
+	//     in physical memory?  Which pages are already in use for
+	//     page tables and other data structures?
+	//
+	// Change the code to reflect this.
+	// NB: DO NOT actually touch the physical memory corresponding to
+	// free pages!
+	size_t i;
+    	assert(page_free_list == 0);
+    	unsigned used_top = PADDR(boot_alloc(0));
+    	for (i = 0; i < npages; i++) {
+		if (i == 0 || (page2pa(&pages[i]) >= IOPHYSMEM && page2pa(&pages[i]) < used_top))
+	   	continue;
+	pages[i].pp_ref = 0;
+	pages[i].pp_link = page_free_list;
+	page_free_list = &pages[i];
+    	}
+}
+
+//
+// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
+// returned physical page with '\0' bytes.  Does NOT increment the reference
+// count of the page - the caller must do these if necessary (either explicitly
+// or via page_insert).
+//
+// Be sure to set the pp_link field of the allocated page to NULL so
+// page_free can check for double-free bugs.
+//
+// Returns NULL if out of free memory.
+//
+// Hint: use page2kva and memset
+struct PageInfo *
+page_alloc(int alloc_flags)
+{
+	// Fill this function in
+	if (page_free_list == NULL) return NULL;
+    	struct PageInfo* ret = page_free_list;
+   	page_free_list = ret->pp_link;
+    	if (alloc_flags & ALLOC_ZERO) 
+		memset(page2kva(ret), 0, PGSIZE);
+	ret->pp_link = NULL;
+    	return ret;
+
+}
+
+//
+// Return a page to the free list.
+// (This function should only be called when pp->pp_ref reaches 0.)
+//
+void
+page_free(struct PageInfo *pp)
+{
+	// Fill this function in
+	// Hint: You may want to panic if pp->pp_ref is nonzero or
+	// pp->pp_link is not NULL.
+		
+	if(pp->pp_ref == 0){
+    		pp->pp_link = page_free_list;
+	    	page_free_list = pp;
+	}
+	else
+	{
+		panic("pp->pp_ref is not zero. Wrong call of the page_free!!!");
+	}
+}
+
+
+//
+// Decrement the reference count on a page,
+// freeing it if there are no more refs.
+//
+void
+page_decref(struct PageInfo* pp)
+{
+	if (--pp->pp_ref == 0)
+		page_free(pp);
+}
+
+// Given 'pgdir', a pointer to a page directory, pgdir_walk returns
+// a pointer to the page table entry (PTE) for linear address 'va'.
+// This requires walking the two-level page table structure.
+//
+// The relevant page table page might not exist yet.
+// If this is true, and create == false, then pgdir_walk returns NULL.
+// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
+//    - If the allocation fails, pgdir_walk returns NULL.
+//    - Otherwise, the new page's reference count is incremented,
+//	the page is cleared,
+//	and pgdir_walk returns a pointer into the new page table page.
+//
+// Hint 1: you can turn a PageInfo * into the physical address of the
+// page it refers to with page2pa() from kern/pmap.h.
+//
+// Hint 2: the x86 MMU checks permission bits in both the page directory
+// and the page table, so it's safe to leave permissions in the page
+// directory more permissive than strictly necessary.
+//
+// Hint 3: look at inc/mmu.h for useful macros that mainipulate page
+// table and page directory entries.
+//
+pte_t *
+pgdir_walk(pde_t *pgdir, const void *va, int create)
+{
+    // Fill this function in
+      if (!(pgdir[PDX(va)] & PTE_P)) {
+	if (!create) return NULL;
+	struct PageInfo *page = page_alloc(ALLOC_ZERO);
+	if (!page) return NULL;
+	page->pp_ref = 1;
+	pgdir[PDX(va)] = page2pa(page) | PTE_P | PTE_U | PTE_W;
+    }
+    return KADDR(PTE_ADDR(pgdir[PDX(va)])) + PTX(va) * sizeof(pte_t*);
+}
+
+//
+// Map [va, va+size) of virtual address space to physical [pa, pa+size)
+// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
+// va and pa are both page-aligned.
+// Use permission bits perm|PTE_P for the entries.
+//
+// This function is only intended to set up the ``static'' mappings
+// above UTOP. As such, it should *not* change the pp_ref field on the
+// mapped pages.
+//
+// Hint: the TA solution uses pgdir_walk
+//
+static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    // Fill this function in
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+
+
+//
+// Map the physical page 'pp' at virtual address 'va'.
+// The permissions (the low 12 bits) of the page table entry
+// should be set to 'perm|PTE_P'.
+//
+// Requirements
+//   - If there is already a page mapped at 'va', it should be page_remove()d.
+//   - If necessary, on demand, a page table should be allocated and inserted
+//     into 'pgdir'.
+//   - pp->pp_ref should be incremented if the insertion succeeds.
+//   - The TLB must be invalidated if a page was formerly present at 'va'.
+//
+// Corner-case hint: Make sure to consider what happens when the same
+// pp is re-inserted at the same virtual address in the same pgdir.
+// However, try not to distinguish this case in your code, as this
+// frequently leads to subtle bugs; there's an elegant way to handle
+// everything in one code path.
+//
+// RETURNS:
+//   0 on success
+//   -E_NO_MEM, if page table couldn't be allocated
+//
+// Hint: The TA solution is implemented using pgdir_walk, page_remove,
+// and page2pa.
+//
+int
+page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
+{
+	// Fill this function in
+	pte_t *pte = pgdir_walk(pgdir, va, 1);
+    	if (pte == NULL) return -E_NO_MEM;
+    	if (*pte & PTE_P) {
+		if (PTE_ADDR(*pte) == page2pa(pp)) {
+		    pp->pp_ref--;
+		    tlb_invalidate(pgdir, va);
+		}
+		else {
+		    page_remove(pgdir, va);
+		}
+    	}
+    	*pte = page2pa(pp) | perm | PTE_P;
+    	pp->pp_ref++;
+    	return 0;
+}
+
+//
+// Return the page mapped at virtual address 'va'.
+// If pte_store is not zero, then we store in it the address
+// of the pte for this page.  This is used by page_remove and
+// can be used to verify page permissions for syscall arguments,
+// but should not be used by most callers.
+//
+// Return NULL if there is no page mapped at va.
+//
+// Hint: the TA solution uses pgdir_walk and pa2page.
+//
+struct PageInfo *
+page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
+{
+	// Fill this function in
+    	pte_t *pte = pgdir_walk(pgdir, va, 0);
+   	if (pte_store != NULL) *pte_store = pte;
+    	if (pte == NULL || !(*pte & PTE_P)) return NULL;
+    	return pa2page(PTE_ADDR(*pte));
+}
+
+//
+// Unmaps the physical page at virtual address 'va'.
+// If there is no physical page at that address, silently does nothing.
+// 
+// Details:
+//   - The ref count on the physical page should decrement.
+//   - The physical page should be freed if the refcount reaches 0.
+//   - The pg table entry corresponding to 'va' should be set to 0.
+//     (if such a PTE exists)
+//   - The TLB must be invalidated if you remove an entry from
+//     the page table.
+//
+// Hint: The TA solution is implemented using page_lookup,
+// 	tlb_invalidate, and page_decref.
+//
+void
+page_remove(pde_t *pgdir, void *va)
+{
+   	// Fill this function in
+    	struct PageInfo *page = page_lookup(pgdir, va, 0);
+    	pte_t *pte = pgdir_walk(pgdir, va, 0);
+    	if (page != NULL) page_decref(page);
+    	if (pte != NULL) {
+		*pte = 0;
+		tlb_invalidate(pgdir, va);
+    	}
+}
+
+//
+// Invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+//
+void
+tlb_invalidate(pde_t *pgdir, void *va)
+{
+	// Flush the entry only if we're modifying the current address space.
+	// For now, there is only one address space, so always invalidate.
+	invlpg(va);
+}
+
+static uintptr_t user_mem_check_addr;
+
+//
+// Check that an environment is allowed to access the range of memory
+// [va, va+len) with permissions 'perm | PTE_P'.
+// Normally 'perm' will contain PTE_U at least, but this is not required.
+// 'va' and 'len' need not be page-aligned; you must test every page that
+// contains any of that range.  You will test either 'len/PGSIZE',
+// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.
+//
+// A user program can access a virtual address if (1) the address is below
+// ULIM, and (2) the page table gives it permission.  These are exactly
+// the tests you should implement here.
+//
+// If there is an error, set the 'user_mem_check_addr' variable to the first
+// erroneous virtual address.
+//
+// Returns 0 if the user program can access this range of addresses,
+// and -E_FAULT otherwise.
+//
+int
+user_mem_check(struct Env *env, const void *va, size_t len, int perm)
+{
+	// LAB 3: Your code here.
+
+	return 0;
+}
+
+//
+// Checks that environment 'env' is allowed to access the range
+// of memory [va, va+len) with permissions 'perm | PTE_U | PTE_P'.
+// If it can, then the function simply returns.
+// If it cannot, 'env' is destroyed and, if env is the current
+// environment, this function will not return.
+//
+void
+user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
+{
+	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
+		cprintf("[%08x] user_mem_check assertion failure for "
+			"va %08x\n", env->env_id, user_mem_check_addr);
+		env_destroy(env);	// may not return
+	}
+}
+
+
+// --------------------------------------------------------------
+// Checking functions.
+// --------------------------------------------------------------
+
+//
+// Check that the pages on the page_free_list are reasonable.
+//
+static void
+check_page_free_list(bool only_low_memory)
+{
+	struct PageInfo *pp;
+	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
+	int nfree_basemem = 0, nfree_extmem = 0;
+	char *first_free_page;
+
+	if (!page_free_list)
+		panic("'page_free_list' is a null pointer!");
+
+	if (only_low_memory) {
+		// Move pages with lower addresses first in the free
+		// list, since entry_pgdir does not map all pages.
+		struct PageInfo *pp1, *pp2;
+		struct PageInfo **tp[2] = { &pp1, &pp2 };
+		for (pp = page_free_list; pp; pp = pp->pp_link) {
+			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
+			*tp[pagetype] = pp;
+			tp[pagetype] = &pp->pp_link;
+		}
+		*tp[1] = 0;
+		*tp[0] = pp2;
+		page_free_list = pp1;
+	}
+
+	// if there's a page that shouldn't be on the free list,
+	// try to make sure it eventually causes trouble.
+	for (pp = page_free_list; pp; pp = pp->pp_link)
+		if (PDX(page2pa(pp)) < pdx_limit)
+			memset(page2kva(pp), 0x97, 128);
+
+	first_free_page = (char *) boot_alloc(0);
+	for (pp = page_free_list; pp; pp = pp->pp_link) {
+		// check that we didn't corrupt the free list itself
+		assert(pp >= pages);
+		assert(pp < pages + npages);
+		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
+
+		// check a few pages that shouldn't be on the free list
+		assert(page2pa(pp) != 0);
+		assert(page2pa(pp) != IOPHYSMEM);
+		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
+		assert(page2pa(pp) != EXTPHYSMEM);
+		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
+
+		if (page2pa(pp) < EXTPHYSMEM)
+			++nfree_basemem;
+		else
+			++nfree_extmem;
+	}
+
+	assert(nfree_basemem > 0);
+	assert(nfree_extmem > 0);
+}
+
+//
+// Check the physical page allocator (page_alloc(), page_free(),
+// and page_init()).
+//
+static void
+check_page_alloc(void)
+{
+	struct PageInfo *pp, *pp0, *pp1, *pp2;
+	int nfree;
+	struct PageInfo *fl;
+	char *c;
+	int i;
+
+	if (!pages)
+		panic("'pages' is a null pointer!");
+
+	// check number of free pages
+	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
+		++nfree;
+
+	// should be able to allocate three pages
+	pp0 = pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+
+	assert(pp0);
+	assert(pp1 && pp1 != pp0);
+	assert(pp2 && pp2 != pp1 && pp2 != pp0);
+	assert(page2pa(pp0) < npages*PGSIZE);
+	assert(page2pa(pp1) < npages*PGSIZE);
+	assert(page2pa(pp2) < npages*PGSIZE);
+
+	// temporarily steal the rest of the free pages
+	fl = page_free_list;
+	page_free_list = 0;
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// free and re-allocate?
+	page_free(pp0);
+	page_free(pp1);
+	page_free(pp2);
+	pp0 = pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+	assert(pp0);
+	assert(pp1 && pp1 != pp0);
+	assert(pp2 && pp2 != pp1 && pp2 != pp0);
+	assert(!page_alloc(0));
+
+	// test flags
+	memset(page2kva(pp0), 1, PGSIZE);
+	page_free(pp0);
+	assert((pp = page_alloc(ALLOC_ZERO)));
+	assert(pp && pp0 == pp);
+	c = page2kva(pp);
+	for (i = 0; i < PGSIZE; i++)
+		assert(c[i] == 0);
+
+	// give free list back
+	page_free_list = fl;
+
+	// free the pages we took
+	page_free(pp0);
+	page_free(pp1);
+	page_free(pp2);
+
+	// number of free pages should be the same
+	for (pp = page_free_list; pp; pp = pp->pp_link)
+		--nfree;
+	assert(nfree == 0);
+
+	cprintf("check_page_alloc() succeeded!\n");
+}
+
+//
+// Checks that the kernel part of virtual address space
+// has been setup roughly correctly (by mem_init()).
+//
+// This function doesn't test every corner case,
+// but it is a pretty good sanity check.
+//
+
+static void
+check_kern_pgdir(void)
+{
+	uint32_t i, n;
+	pde_t *pgdir;
+
+	pgdir = kern_pgdir;
+
+	// check pages array
+	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
+	for (i = 0; i < n; i += PGSIZE)
+		assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+
+	// check envs array (new test for lab 3)
+	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+	for (i = 0; i < n; i += PGSIZE)
+		assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+
+	// check phys mem
+	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+		assert(check_va2pa(pgdir, KERNBASE + i) == i);
+
+	// check kernel stack
+	for (i = 0; i < KSTKSIZE; i += PGSIZE)
+		assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
+	assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);
+
+	// check PDE permissions
+	for (i = 0; i < NPDENTRIES; i++) {
+		switch (i) {
+		case PDX(UVPT):
+		case PDX(KSTACKTOP-1):
+		case PDX(UPAGES):
+		case PDX(UENVS):
+			assert(pgdir[i] & PTE_P);
+			break;
+		default:
+			if (i >= PDX(KERNBASE)) {
+				assert(pgdir[i] & PTE_P);
+				assert(pgdir[i] & PTE_W);
+			} else
+				assert(pgdir[i] == 0);
+			break;
+		}
+	}
+	cprintf("check_kern_pgdir() succeeded!\n");
+}
+
+// This function returns the physical address of the page containing 'va',
+// defined by the page directory 'pgdir'.  The hardware normally performs
+// this functionality for us!  We define our own version to help check
+// the check_kern_pgdir() function; it shouldn't be used elsewhere.
+
+static physaddr_t
+check_va2pa(pde_t *pgdir, uintptr_t va)
+{
+	pte_t *p;
+
+	pgdir = &pgdir[PDX(va)];
+	if (!(*pgdir & PTE_P))
+		return ~0;
+	p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
+	if (!(p[PTX(va)] & PTE_P))
+		return ~0;
+	return PTE_ADDR(p[PTX(va)]);
+}
+
+
+// check page_insert, page_remove, &c
+static void
+check_page(void)
+{
+	struct PageInfo *pp, *pp0, *pp1, *pp2;
+	struct PageInfo *fl;
+	pte_t *ptep, *ptep1;
+	void *va;
+	int i;
+	extern pde_t entry_pgdir[];
+
+	// should be able to allocate three pages
+	pp0 = pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+
+	assert(pp0);
+	assert(pp1 && pp1 != pp0);
+	assert(pp2 && pp2 != pp1 && pp2 != pp0);
+
+	// temporarily steal the rest of the free pages
+	fl = page_free_list;
+	page_free_list = 0;
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// there is no page allocated at address 0
+	assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
+
+	// there is no free memory, so we can't allocate a page table
+	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
+
+	// free pp0 and try again: pp0 should be used for page table
+	page_free(pp0);
+	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
+	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+	assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
+	assert(pp1->pp_ref == 1);
+	assert(pp0->pp_ref == 1);
+
+	// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+	assert(pp2->pp_ref == 1);
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// should be able to map pp2 at PGSIZE because it's already there
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+	assert(pp2->pp_ref == 1);
+
+	// pp2 should NOT be on the free list
+	// could happen in ref counts are handled sloppily in page_insert
+	assert(!page_alloc(0));
+
+	// check that pgdir_walk returns a pointer to the pte
+	ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
+	assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
+
+	// should be able to change permissions too.
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+	assert(pp2->pp_ref == 1);
+	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
+	assert(kern_pgdir[0] & PTE_U);
+
+	// should be able to remap with fewer permissions
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
+	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+	// should not be able to map at PTSIZE because need free page for page table
+	assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
+
+	// insert pp1 at PGSIZE (replacing pp2)
+	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
+	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+	// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
+	assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+	// ... and ref counts should reflect this
+	assert(pp1->pp_ref == 2);
+	assert(pp2->pp_ref == 0);
+
+	// pp2 should be returned by page_alloc
+	assert((pp = page_alloc(0)) && pp == pp2);
+
+	// unmapping pp1 at 0 should keep pp1 at PGSIZE
+	page_remove(kern_pgdir, 0x0);
+	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+	assert(pp1->pp_ref == 1);
+	assert(pp2->pp_ref == 0);
+
+	// test re-inserting pp1 at PGSIZE
+	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
+	assert(pp1->pp_ref);
+	assert(pp1->pp_link == NULL);
+
+	// unmapping pp1 at PGSIZE should free it
+	page_remove(kern_pgdir, (void*) PGSIZE);
+	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
+	assert(pp1->pp_ref == 0);
+	assert(pp2->pp_ref == 0);
+
+	// so it should be returned by page_alloc
+	assert((pp = page_alloc(0)) && pp == pp1);
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// forcibly take pp0 back
+	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+	kern_pgdir[0] = 0;
+	assert(pp0->pp_ref == 1);
+	pp0->pp_ref = 0;
+
+	// check pointer arithmetic in pgdir_walk
+	page_free(pp0);
+	va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
+	ptep = pgdir_walk(kern_pgdir, va, 1);
+	ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
+	assert(ptep == ptep1 + PTX(va));
+	kern_pgdir[PDX(va)] = 0;
+	pp0->pp_ref = 0;
+
+	// check that new page tables get cleared
+	memset(page2kva(pp0), 0xFF, PGSIZE);
+	page_free(pp0);
+	pgdir_walk(kern_pgdir, 0x0, 1);
+	ptep = (pte_t *) page2kva(pp0);
+	for(i=0; i<NPTENTRIES; i++)
+		assert((ptep[i] & PTE_P) == 0);
+	kern_pgdir[0] = 0;
+	pp0->pp_ref = 0;
+
+	// give free list back
+	page_free_list = fl;
+
+	// free the pages we took
+	page_free(pp0);
+	page_free(pp1);
+	page_free(pp2);
+
+	cprintf("check_page() succeeded!\n");
+}
+
+// check page_insert, page_remove, &c, with an installed kern_pgdir
+static void
+check_page_installed_pgdir(void)
+{
+	struct PageInfo *pp, *pp0, *pp1, *pp2;
+	struct PageInfo *fl;
+	pte_t *ptep, *ptep1;
+	uintptr_t va;
+	int i;
+
+	// check that we can read and write installed pages
+	pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+	page_free(pp0);
+	memset(page2kva(pp1), 1, PGSIZE);
+	memset(page2kva(pp2), 2, PGSIZE);
+	page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
+	assert(pp1->pp_ref == 1);
+	assert(*(uint32_t *)PGSIZE == 0x01010101U);
+	page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
+	assert(*(uint32_t *)PGSIZE == 0x02020202U);
+	assert(pp2->pp_ref == 1);
+	assert(pp1->pp_ref == 0);
+	*(uint32_t *)PGSIZE = 0x03030303U;
+	assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
+	page_remove(kern_pgdir, (void*) PGSIZE);
+	assert(pp2->pp_ref == 0);
+
+	// forcibly take pp0 back
+	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+	kern_pgdir[0] = 0;
+	assert(pp0->pp_ref == 1);
+	pp0->pp_ref = 0;
+
+	// free the pages we took
+	page_free(pp0);
+
+	cprintf("check_page_installed_pgdir() succeeded!\n");
+}
diff --git a/kern/pmap.h~ b/kern/pmap.h~
new file mode 100644
index 0000000..950cca1
--- /dev/null
+++ b/kern/pmap.h~
@@ -0,0 +1,87 @@
+/* See COPYRIGHT for copyright information. */
+
+#ifndef JOS_KERN_PMAP_H
+#define JOS_KERN_PMAP_H
+#ifndef JOS_KERNEL
+# error "This is a JOS kernel header; user programs should not #include it"
+#endif
+
+#include <inc/memlayout.h>
+#include <inc/assert.h>
+
+extern char bootstacktop[], bootstack[];
+
+extern struct PageInfo *pages;
+extern size_t npages;
+
+extern pde_t *kern_pgdir;
+
+
+/* This macro takes a kernel virtual address -- an address that points above
+ * KERNBASE, where the machine's maximum 256MB of physical memory is mapped --
+ * and returns the corresponding physical address.  It panics if you pass it a
+ * non-kernel virtual address.
+ */
+#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)
+
+static inline physaddr_t
+_paddr(const char *file, int line, void *kva)
+{
+	if ((uint32_t)kva < KERNBASE)
+		_panic(file, line, "PADDR called with invalid kva %08lx", kva);
+	return (physaddr_t)kva - KERNBASE;
+}
+
+/* This macro takes a physical address and returns the corresponding kernel
+ * virtual address.  It panics if you pass an invalid physical address. */
+#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)
+
+static inline void*
+_kaddr(const char *file, int line, physaddr_t pa)
+{
+	if (PGNUM(pa) >= npages)
+		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
+	return (void *)(pa + KERNBASE);
+}
+
+
+enum {
+	// For page_alloc, zero the returned physical page.
+	ALLOC_ZERO = 1<<0,
+};
+
+void	mem_init(void);
+
+void	page_init(void);
+struct PageInfo *page_alloc(int alloc_flags);
+void	page_free(struct PageInfo *pp);
+int	page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);
+void	page_remove(pde_t *pgdir, void *va);
+struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);
+void	page_decref(struct PageInfo *pp);
+
+void	tlb_invalidate(pde_t *pgdir, void *va);
+
+static inline physaddr_t
+page2pa(struct PageInfo *pp)
+{
+	return (pp - pages) << PGSHIFT;
+}
+
+static inline struct PageInfo*
+pa2page(physaddr_t pa)
+{
+	if (PGNUM(pa) >= npages)
+		panic("pa2page called with invalid pa");
+	return &pages[PGNUM(pa)];
+}
+
+static inline void*
+page2kva(struct PageInfo *pp)
+{
+	return KADDR(page2pa(pp));
+}
+
+pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);
+
+#endif /* !JOS_KERN_PMAP_H */
diff --git a/kern/syscall. b/kern/syscall.
new file mode 100644
index 0000000..e69de29
diff --git a/kern/syscall.c b/kern/syscall.c
index 414d489..e63318e 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -14,31 +14,33 @@
 // Print a string to the system console.
 // The string is exactly 'len' characters long.
 // Destroys the environment on memory errors.
-static void
+    static void
 sys_cputs(const char *s, size_t len)
 {
-	// Check that the user has permission to read memory [s, s+len).
-	// Destroy the environment if not.
+    // Check that the user has permission to read memory [s, s+len).
+    // Destroy the environment if not.
 
-	// LAB 3: Your code here.
+    // LAB 3: Your code here.
+    if (curenv->env_tf.tf_cs & 3)
+	user_mem_assert(curenv, s, len, 0);
 
-	// Print the string supplied by the user.
-	cprintf("%.*s", len, s);
+    // Print the string supplied by the user.
+    cprintf("%.*s", len, s);
 }
 
 // Read a character from the system console without blocking.
 // Returns the character, or 0 if there is no input waiting.
-static int
+    static int
 sys_cgetc(void)
 {
-	return cons_getc();
+    return cons_getc();
 }
 
 // Returns the current environment's envid.
-static envid_t
+    static envid_t
 sys_getenvid(void)
 {
-	return curenv->env_id;
+    return curenv->env_id;
 }
 
 // Destroy a given environment (possibly the currently running environment).
@@ -46,35 +48,44 @@ sys_getenvid(void)
 // Returns 0 on success, < 0 on error.  Errors are:
 //	-E_BAD_ENV if environment envid doesn't currently exist,
 //		or the caller doesn't have permission to change envid.
-static int
+    static int
 sys_env_destroy(envid_t envid)
 {
-	int r;
-	struct Env *e;
+    int r;
+    struct Env *e;
 
-	if ((r = envid2env(envid, &e, 1)) < 0)
-		return r;
-	if (e == curenv)
-		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
-	else
-		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
-	env_destroy(e);
-	return 0;
+    if ((r = envid2env(envid, &e, 1)) < 0)
+	return r;
+    if (e == curenv)
+	cprintf("[%08x] exiting gracefully\n", curenv->env_id);
+    else
+	cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
+    env_destroy(e);
+    return 0;
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
-int32_t
+    int32_t
 syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
 {
-	// Call the function corresponding to the 'syscallno' parameter.
-	// Return any appropriate return value.
-	// LAB 3: Your code here.
+    // Call the function corresponding to the 'syscallno' parameter.
+    // Return any appropriate return value.
+    // LAB 3: Your code here.
 
-	panic("syscall not implemented");
+    //panic("syscall not implemented");
 
-	switch (syscallno) {
+    switch (syscallno) {
+	case SYS_cputs:
+	    sys_cputs((const char*)a1, (size_t)a2);
+	    return 0;
+	case SYS_cgetc:
+	    return sys_cgetc();
+	case SYS_getenvid:
+	    return sys_getenvid();
+	case SYS_env_destroy:
+	    return sys_env_destroy((envid_t)a1);
 	default:
-		return -E_INVAL;
-	}
+	    return -E_INVAL;
+    }
 }
 
diff --git a/kern/trap.c b/kern/trap.c
index 7356610..7b339ab 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -9,6 +9,7 @@
 #include <kern/env.h>
 #include <kern/syscall.h>
 
+
 static struct Taskstate ts;
 
 /* For debugging, so print_trapframe can distinguish between printing
@@ -22,196 +23,221 @@ static struct Trapframe *last_tf;
  */
 struct Gatedesc idt[256] = { { 0 } };
 struct Pseudodesc idt_pd = {
-	sizeof(idt) - 1, (uint32_t) idt
+    sizeof(idt) - 1, (uint32_t) idt
 };
 
 
 static const char *trapname(int trapno)
 {
-	static const char * const excnames[] = {
-		"Divide error",
-		"Debug",
-		"Non-Maskable Interrupt",
-		"Breakpoint",
-		"Overflow",
-		"BOUND Range Exceeded",
-		"Invalid Opcode",
-		"Device Not Available",
-		"Double Fault",
-		"Coprocessor Segment Overrun",
-		"Invalid TSS",
-		"Segment Not Present",
-		"Stack Fault",
-		"General Protection",
-		"Page Fault",
-		"(unknown trap)",
-		"x87 FPU Floating-Point Error",
-		"Alignment Check",
-		"Machine-Check",
-		"SIMD Floating-Point Exception"
-	};
-
-	if (trapno < ARRAY_SIZE(excnames))
-		return excnames[trapno];
-	if (trapno == T_SYSCALL)
-		return "System call";
-	return "(unknown trap)";
+    static const char * const excnames[] = {
+	"Divide error",
+	"Debug",
+	"Non-Maskable Interrupt",
+	"Breakpoint",
+	"Overflow",
+	"BOUND Range Exceeded",
+	"Invalid Opcode",
+	"Device Not Available",
+	"Double Fault",
+	"Coprocessor Segment Overrun",
+	"Invalid TSS",
+	"Segment Not Present",
+	"Stack Fault",
+	"General Protection",
+	"Page Fault",
+	"(unknown trap)",
+	"x87 FPU Floating-Point Error",
+	"Alignment Check",
+	"Machine-Check",
+	"SIMD Floating-Point Exception"
+    };
+
+    if (trapno < ARRAY_SIZE(excnames))
+	return excnames[trapno];
+    if (trapno == T_SYSCALL)
+	return "System call";
+    return "(unknown trap)";
 }
 
 
-void
+    void
 trap_init(void)
 {
-	extern struct Segdesc gdt[];
-
-	// LAB 3: Your code here.
-
-	// Per-CPU setup 
-	trap_init_percpu();
+    extern struct Segdesc gdt[];
+    extern long vectors[];
+    int i;
+
+    // LAB 3: Your code here.
+    for (i = 0; i <= 0x30; ++i) {
+	switch (i) {
+	    case T_BRKPT:
+	    case T_SYSCALL:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 3);
+		break;
+	    default:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 0);
+	}
+    }
+    // Per-CPU setup 
+    trap_init_percpu();
 }
 
 // Initialize and load the per-CPU TSS and IDT
-void
+    void
 trap_init_percpu(void)
 {
-	// Setup a TSS so that we get the right stack
-	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-
-	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
-					sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
-
-	// Load the TSS selector (like other segment selectors, the
-	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
-
-	// Load the IDT
-	lidt(&idt_pd);
+    // Setup a TSS so that we get the right stack
+    // when we trap to the kernel.
+    ts.ts_esp0 = KSTACKTOP;
+    ts.ts_ss0 = GD_KD;
+
+    // Initialize the TSS slot of the gdt.
+    gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
+	    sizeof(struct Taskstate) - 1, 0);
+    gdt[GD_TSS0 >> 3].sd_s = 0;
+
+    // Load the TSS selector (like other segment selectors, the
+    // bottom three bits are special; we leave them 0)
+    ltr(GD_TSS0);
+
+    // Load the IDT
+    lidt(&idt_pd);
 }
 
-void
+    void
 print_trapframe(struct Trapframe *tf)
 {
-	cprintf("TRAP frame at %p\n", tf);
-	print_regs(&tf->tf_regs);
-	cprintf("  es   0x----%04x\n", tf->tf_es);
-	cprintf("  ds   0x----%04x\n", tf->tf_ds);
-	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
-	// If this trap was a page fault that just happened
-	// (so %cr2 is meaningful), print the faulting linear address.
-	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
-		cprintf("  cr2  0x%08x\n", rcr2());
-	cprintf("  err  0x%08x", tf->tf_err);
-	// For page faults, print decoded fault error code:
-	// U/K=fault occurred in user/kernel mode
-	// W/R=a write/read caused the fault
-	// PR=a protection violation caused the fault (NP=page not present).
-	if (tf->tf_trapno == T_PGFLT)
-		cprintf(" [%s, %s, %s]\n",
-			tf->tf_err & 4 ? "user" : "kernel",
-			tf->tf_err & 2 ? "write" : "read",
-			tf->tf_err & 1 ? "protection" : "not-present");
-	else
-		cprintf("\n");
-	cprintf("  eip  0x%08x\n", tf->tf_eip);
-	cprintf("  cs   0x----%04x\n", tf->tf_cs);
-	cprintf("  flag 0x%08x\n", tf->tf_eflags);
-	if ((tf->tf_cs & 3) != 0) {
-		cprintf("  esp  0x%08x\n", tf->tf_esp);
-		cprintf("  ss   0x----%04x\n", tf->tf_ss);
-	}
+    cprintf("TRAP frame at %p\n", tf);
+    print_regs(&tf->tf_regs);
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+    // If this trap was a page fault that just happened
+    // (so %cr2 is meaningful), print the faulting linear address.
+    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
+	cprintf("  cr2  0x%08x\n", rcr2());
+    cprintf("  err  0x%08x", tf->tf_err);
+    // For page faults, print decoded fault error code:
+    // U/K=fault occurred in user/kernel mode
+    // W/R=a write/read caused the fault
+    // PR=a protection violation caused the fault (NP=page not present).
+    if (tf->tf_trapno == T_PGFLT)
+	cprintf(" [%s, %s, %s]\n",
+		tf->tf_err & 4 ? "user" : "kernel",
+		tf->tf_err & 2 ? "write" : "read",
+		tf->tf_err & 1 ? "protection" : "not-present");
+    else
+	cprintf("\n");
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x\n", tf->tf_eflags);
+    if ((tf->tf_cs & 3) != 0) {
+	cprintf("  esp  0x%08x\n", tf->tf_esp);
+	cprintf("  ss   0x----%04x\n", tf->tf_ss);
+    }
 }
 
-void
+    void
 print_regs(struct PushRegs *regs)
 {
-	cprintf("  edi  0x%08x\n", regs->reg_edi);
-	cprintf("  esi  0x%08x\n", regs->reg_esi);
-	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
-	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
-	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
-	cprintf("  edx  0x%08x\n", regs->reg_edx);
-	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
-	cprintf("  eax  0x%08x\n", regs->reg_eax);
+
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
 }
 
-static void
+    static void
 trap_dispatch(struct Trapframe *tf)
 {
-	// Handle processor exceptions.
-	// LAB 3: Your code here.
-
-	// Unexpected trap: The user process or the kernel has a bug.
-	print_trapframe(tf);
-	if (tf->tf_cs == GD_KT)
+    // Handle processor exceptions.
+    // LAB 3: Your code here.
+    switch (tf->tf_trapno) {
+	case T_DEBUG:
+	case T_BRKPT:
+	    monitor(tf);
+	    break;
+	case T_PGFLT:
+	    page_fault_handler(tf);
+	    break;
+	case T_SYSCALL:
+	    tf->tf_regs.reg_eax = 
+		syscall(tf->tf_regs.reg_eax, tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi, tf->tf_regs.reg_esi);
+	    break;
+	default:
+	    // Unexpected trap: The user process or the kernel has a bug.
+	    print_trapframe(tf);
+	    if (tf->tf_cs == GD_KT)
 		panic("unhandled trap in kernel");
-	else {
+	    else {
 		env_destroy(curenv);
 		return;
-	}
+	    }
+    }
 }
-
-void
+    void
 trap(struct Trapframe *tf)
 {
-	// The environment may have set DF and some versions
-	// of GCC rely on DF being clear
-	asm volatile("cld" ::: "cc");
-
-	// Check that interrupts are disabled.  If this assertion
-	// fails, DO NOT be tempted to fix it by inserting a "cli" in
-	// the interrupt path.
-	assert(!(read_eflags() & FL_IF));
-
-	cprintf("Incoming TRAP frame at %p\n", tf);
-
-	if ((tf->tf_cs & 3) == 3) {
-		// Trapped from user mode.
-		assert(curenv);
-
-		// Copy trap frame (which is currently on the stack)
-		// into 'curenv->env_tf', so that running the environment
-		// will restart at the trap point.
-		curenv->env_tf = *tf;
-		// The trapframe on the stack should be ignored from here on.
-		tf = &curenv->env_tf;
-	}
-
-	// Record that tf is the last real trapframe so
-	// print_trapframe can print some additional information.
-	last_tf = tf;
-
-	// Dispatch based on what type of trap occurred
-	trap_dispatch(tf);
-
-	// Return to the current environment, which should be running.
-	assert(curenv && curenv->env_status == ENV_RUNNING);
-	env_run(curenv);
+    // The environment may have set DF and some versions
+    // of GCC rely on DF being clear
+    asm volatile("cld" ::: "cc");
+
+    // Check that interrupts are disabled.  If this assertion
+    // fails, DO NOT be tempted to fix it by inserting a "cli" in
+    // the interrupt path.
+    assert(!(read_eflags() & FL_IF));
+
+    cprintf("Incoming TRAP frame at %p\n", tf);
+
+    if ((tf->tf_cs & 3) == 3) {
+	// Trapped from user mode.
+	assert(curenv);
+
+	// Copy trap frame (which is currently on the stack)
+	// into 'curenv->env_tf', so that running the environment
+	// will restart at the trap point.
+	curenv->env_tf = *tf;
+	// The trapframe on the stack should be ignored from here on.
+	tf = &curenv->env_tf;
+    }
+
+    // Record that tf is the last real trapframe so
+    // print_trapframe can print some additional information.
+    last_tf = tf;
+
+    // Dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+
+    // Return to the current environment, which should be running.
+    assert(curenv && curenv->env_status == ENV_RUNNING);
+    env_run(curenv);
 }
 
 
-void
+    void
 page_fault_handler(struct Trapframe *tf)
 {
-	uint32_t fault_va;
+    uint32_t fault_va;
 
-	// Read processor's CR2 register to find the faulting address
-	fault_va = rcr2();
+    // Read processor's CR2 register to find the faulting address
+    fault_va = rcr2();
 
-	// Handle kernel-mode page faults.
+    // Handle kernel-mode page faults.
 
-	// LAB 3: Your code here.
+    // LAB 3: Your code here.
+    if (!(tf->tf_cs & 3))
+	panic("a page fault happens in kernel mode\n");
 
-	// We've already handled kernel-mode exceptions, so if we get here,
-	// the page fault happened in user mode.
+    // We've already handled kernel-mode exceptions, so if we get here,
+    // the page fault happened in user mode.
 
-	// Destroy the environment that caused the fault.
-	cprintf("[%08x] user fault va %08x ip %08x\n",
-		curenv->env_id, fault_va, tf->tf_eip);
-	print_trapframe(tf);
-	env_destroy(curenv);
+    // Destroy the environment that caused the fault.
+    cprintf("[%08x] user fault va %08x ip %08x\n",
+	    curenv->env_id, fault_va, tf->tf_eip);
+    print_trapframe(tf);
+    env_destroy(curenv);
 }
 
diff --git a/kern/trap.c~ b/kern/trap.c~
new file mode 100644
index 0000000..1f975c4
--- /dev/null
+++ b/kern/trap.c~
@@ -0,0 +1,229 @@
+#include <inc/mmu.h>
+#include <inc/x86.h>
+#include <inc/assert.h>
+
+#include <kern/pmap.h>
+#include <kern/trap.h>
+#include <kern/console.h>
+#include <kern/monitor.h>
+#include <kern/env.h>
+#include <kern/syscall.h>
+
+
+static struct Taskstate ts;
+
+/* For debugging, so print_trapframe can distinguish between printing
+ * a saved trapframe and printing the current trapframe and print some
+ * additional information in the latter case.
+ */
+static struct Trapframe *last_tf;
+
+/* Interrupt descriptor table.  (Must be built at run time because
+ * shifted function addresses can't be represented in relocation records.)
+ */
+struct Gatedesc idt[256] = { { 0 } };
+struct Pseudodesc idt_pd = {
+	sizeof(idt) - 1, (uint32_t) idt
+};
+
+
+static const char *trapname(int trapno)
+{
+	static const char * const excnames[] = {
+		"Divide error",
+		"Debug",
+		"Non-Maskable Interrupt",
+		"Breakpoint",
+		"Overflow",
+		"BOUND Range Exceeded",
+		"Invalid Opcode",
+		"Device Not Available",
+		"Double Fault",
+		"Coprocessor Segment Overrun",
+		"Invalid TSS",
+		"Segment Not Present",
+		"Stack Fault",
+		"General Protection",
+		"Page Fault",
+		"(unknown trap)",
+		"x87 FPU Floating-Point Error",
+		"Alignment Check",
+		"Machine-Check",
+		"SIMD Floating-Point Exception"
+	};
+
+	if (trapno < ARRAY_SIZE(excnames))
+		return excnames[trapno];
+	if (trapno == T_SYSCALL)
+		return "System call";
+	return "(unknown trap)";
+}
+
+
+void
+trap_init(void)
+{
+	extern struct Segdesc gdt[];
+	extern long* vectors;
+	int i;
+
+	// LAB 3: Your code here.
+	for (i = 0; i <= 0x30; ++i) {
+	    switch (i) {
+		case T_BRKPT:
+		case T_SYSCALL:
+		    SETGATE(idt[i], 0, GD_KT, vectors[i], 3);
+		    break;
+		default:
+		    SETGATE(idt[i], 0, GD_KT, vectors[i], 0);
+	    }
+	}
+	// Per-CPU setup 
+	trap_init_percpu();
+}
+
+// Initialize and load the per-CPU TSS and IDT
+void
+trap_init_percpu(void)
+{
+	// Setup a TSS so that we get the right stack
+	// when we trap to the kernel.
+	ts.ts_esp0 = KSTACKTOP;
+	ts.ts_ss0 = GD_KD;
+
+	// Initialize the TSS slot of the gdt.
+	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
+					sizeof(struct Taskstate) - 1, 0);
+	gdt[GD_TSS0 >> 3].sd_s = 0;
+
+	// Load the TSS selector (like other segment selectors, the
+	// bottom three bits are special; we leave them 0)
+	ltr(GD_TSS0);
+
+	// Load the IDT
+	lidt(&idt_pd);
+}
+
+void
+print_trapframe(struct Trapframe *tf)
+{
+	cprintf("TRAP frame at %p\n", tf);
+	print_regs(&tf->tf_regs);
+	cprintf("  es   0x----%04x\n", tf->tf_es);
+	cprintf("  ds   0x----%04x\n", tf->tf_ds);
+	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+	// If this trap was a page fault that just happened
+	// (so %cr2 is meaningful), print the faulting linear address.
+	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
+		cprintf("  cr2  0x%08x\n", rcr2());
+	cprintf("  err  0x%08x", tf->tf_err);
+	// For page faults, print decoded fault error code:
+	// U/K=fault occurred in user/kernel mode
+	// W/R=a write/read caused the fault
+	// PR=a protection violation caused the fault (NP=page not present).
+	if (tf->tf_trapno == T_PGFLT)
+		cprintf(" [%s, %s, %s]\n",
+			tf->tf_err & 4 ? "user" : "kernel",
+			tf->tf_err & 2 ? "write" : "read",
+			tf->tf_err & 1 ? "protection" : "not-present");
+	else
+		cprintf("\n");
+	cprintf("  eip  0x%08x\n", tf->tf_eip);
+	cprintf("  cs   0x----%04x\n", tf->tf_cs);
+	cprintf("  flag 0x%08x\n", tf->tf_eflags);
+	if ((tf->tf_cs & 3) != 0) {
+		cprintf("  esp  0x%08x\n", tf->tf_esp);
+		cprintf("  ss   0x----%04x\n", tf->tf_ss);
+	}
+}
+
+void
+print_regs(struct PushRegs *regs)
+{
+	cprintf("  edi  0x%08x\n", regs->reg_edi);
+	cprintf("  esi  0x%08x\n", regs->reg_esi);
+	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+	cprintf("  edx  0x%08x\n", regs->reg_edx);
+	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+	cprintf("  eax  0x%08x\n", regs->reg_eax);
+}
+
+static void
+trap_dispatch(struct Trapframe *tf)
+{
+	// Handle processor exceptions.
+	// LAB 3: Your code here.
+
+	// Unexpected trap: The user process or the kernel has a bug.
+	print_trapframe(tf);
+	if (tf->tf_cs == GD_KT)
+		panic("unhandled trap in kernel");
+	else {
+		env_destroy(curenv);
+		return;
+	}
+}
+
+void
+trap(struct Trapframe *tf)
+{
+	// The environment may have set DF and some versions
+	// of GCC rely on DF being clear
+	asm volatile("cld" ::: "cc");
+
+	// Check that interrupts are disabled.  If this assertion
+	// fails, DO NOT be tempted to fix it by inserting a "cli" in
+	// the interrupt path.
+	assert(!(read_eflags() & FL_IF));
+
+	cprintf("Incoming TRAP frame at %p\n", tf);
+
+	if ((tf->tf_cs & 3) == 3) {
+		// Trapped from user mode.
+		assert(curenv);
+
+		// Copy trap frame (which is currently on the stack)
+		// into 'curenv->env_tf', so that running the environment
+		// will restart at the trap point.
+		curenv->env_tf = *tf;
+		// The trapframe on the stack should be ignored from here on.
+		tf = &curenv->env_tf;
+	}
+
+	// Record that tf is the last real trapframe so
+	// print_trapframe can print some additional information.
+	last_tf = tf;
+
+	// Dispatch based on what type of trap occurred
+	trap_dispatch(tf);
+
+	// Return to the current environment, which should be running.
+	assert(curenv && curenv->env_status == ENV_RUNNING);
+	env_run(curenv);
+}
+
+
+void
+page_fault_handler(struct Trapframe *tf)
+{
+	uint32_t fault_va;
+
+	// Read processor's CR2 register to find the faulting address
+	fault_va = rcr2();
+
+	// Handle kernel-mode page faults.
+
+	// LAB 3: Your code here.
+
+	// We've already handled kernel-mode exceptions, so if we get here,
+	// the page fault happened in user mode.
+
+	// Destroy the environment that caused the fault.
+	cprintf("[%08x] user fault va %08x ip %08x\n",
+		curenv->env_id, fault_va, tf->tf_eip);
+	print_trapframe(tf);
+	env_destroy(curenv);
+}
+
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 22fc640..fac803a 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -20,36 +20,94 @@
  *   void NAME();
  * where NAME is the argument passed to TRAPHANDLER.
  */
-#define TRAPHANDLER(name, num)						\
-	.globl name;		/* define global symbol for 'name' */	\
-	.type name, @function;	/* symbol type is function */		\
-	.align 2;		/* align function definition */		\
-	name:			/* function starts here */		\
-	pushl $(num);							\
-	jmp _alltraps
-
-/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
- * It pushes a 0 in place of the error code, so the trap frame has the same
- * format in either case.
- */
-#define TRAPHANDLER_NOEC(name, num)					\
-	.globl name;							\
-	.type name, @function;						\
-	.align 2;							\
-	name:								\
-	pushl $0;							\
-	pushl $(num);							\
-	jmp _alltraps
+#define TRAPHANDLER(name, num)			    \
+	.text;				    \
+    .globl name;	/* define global symbol for 'name' */	\
+    .type name, @function;  /* symbol type is function */	\
+    .align 2;	    /* align function definition */	\
+    name:	    /* function starts here */	    \
+    .if !(num == 8 || num >= 10 && num <= 14 || num == 17); \
+    pushl $0; \
+    .endif; \
+    pushl $(num);			    \
+    jmp _alltraps;			    \
+    .data;				\
+    .long name;
+
+
+
 
-.text
 
 /*
  * Lab 3: Your code here for generating entry points for the different traps.
- */
+     * Lab 3: Your code here for _alltraps
+     */
+.data
+.global vectors
+vectors:
+TRAPHANDLER(vector0, 0)
+    TRAPHANDLER(vector1, 1)
+    TRAPHANDLER(vector2, 2)
+    TRAPHANDLER(vector3, 3)
+    TRAPHANDLER(vector4, 4)
+    TRAPHANDLER(vector5, 5)
+    TRAPHANDLER(vector6, 6)
+    TRAPHANDLER(vector7, 7)
+    TRAPHANDLER(vector8, 8)
+    TRAPHANDLER(vector9, 9)
+    TRAPHANDLER(vector10, 10)
+    TRAPHANDLER(vector11, 11)
+    TRAPHANDLER(vector12, 12)
+    TRAPHANDLER(vector13, 13)
+    TRAPHANDLER(vector14, 14)
+    TRAPHANDLER(vector15, 15)
+    TRAPHANDLER(vector16, 16)
+    TRAPHANDLER(vector17, 17)
+    TRAPHANDLER(vector18, 18)
+    TRAPHANDLER(vector19, 19)
+    TRAPHANDLER(vector20, 20)
+    TRAPHANDLER(vector21, 21)
+    TRAPHANDLER(vector22, 22)
+    TRAPHANDLER(vector23, 23)
+    TRAPHANDLER(vector24, 24)
+    TRAPHANDLER(vector25, 25)
+    TRAPHANDLER(vector26, 26)
+    TRAPHANDLER(vector27, 27)
+    TRAPHANDLER(vector28, 28)
+    TRAPHANDLER(vector29, 29)
+    TRAPHANDLER(vector30, 30)
+    TRAPHANDLER(vector31, 31)
+    TRAPHANDLER(vector32, 32)
+    TRAPHANDLER(vector33, 33)
+    TRAPHANDLER(vector34, 34)
+    TRAPHANDLER(vector35, 35)
+    TRAPHANDLER(vector36, 36)
+    TRAPHANDLER(vector37, 37)
+    TRAPHANDLER(vector38, 38)
+    TRAPHANDLER(vector39, 39)
+    TRAPHANDLER(vector40, 40)
+    TRAPHANDLER(vector41, 41)
+    TRAPHANDLER(vector42, 42)
+    TRAPHANDLER(vector43, 43)
+    TRAPHANDLER(vector44, 44)
+    TRAPHANDLER(vector45, 45)
+    TRAPHANDLER(vector46, 46)
+    TRAPHANDLER(vector47, 47)
+    TRAPHANDLER(vector48, 48)
 
+    .text
+    _alltraps:
+    pushw $0x0
+    pushw %ds
+    pushw $0x0
+    pushw %es
+    pushal
+
+    movw $GD_KD, %ax
+    movw %ax, %ds
+    movw %ax, %es
+    pushl %esp
+    call trap
 
 
-/*
- * Lab 3: Your code here for _alltraps
- */
 
diff --git a/kern/trapentry.S~ b/kern/trapentry.S~
new file mode 100644
index 0000000..8379271
--- /dev/null
+++ b/kern/trapentry.S~
@@ -0,0 +1,109 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/mmu.h>
+#include <inc/memlayout.h>
+#include <inc/trap.h>
+
+
+
+###################################################################
+# exceptions/interrupts
+###################################################################
+
+/* TRAPHANDLER defines a globally-visible function for handling a trap.
+ * It pushes a trap number onto the stack, then jumps to _alltraps.
+ * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
+ *
+ * You shouldn't call a TRAPHANDLER function from C, but you may
+ * need to _declare_ one in C (for instance, to get a function pointer
+ * during IDT setup).  You can declare the function with
+ *   void NAME();
+ * where NAME is the argument passed to TRAPHANDLER.
+ */
+#define TRAPHANDLER(name, num)						\
+	.globl name;		/* define global symbol for 'name' */	\
+	.type name, @function;	/* symbol type is function */		\
+	.align 2;		/* align function definition */		\
+	name:			/* function starts here */		\
+	pushl $(num);							\
+	jmp _alltraps
+
+/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
+ * It pushes a 0 in place of the error code, so the trap frame has the same
+ * format in either case.
+ */
+#define TRAPHANDLER_NOEC(name, num)					\
+	.globl name;							\
+	.type name, @function;						\
+	.align 2;							\
+	name:								\
+	pushl $0;							\
+	pushl $(num);							\
+	jmp _alltraps
+
+.text
+
+/*
+ * Lab 3: Your code here for generating entry points for the different traps.
+ */
+.data
+.global vectors
+vectors:
+.long vector0
+.long vector1
+.long vector2
+.long vector3
+.long vector4
+.long vector5
+.long vector6
+.long vector7
+.long vector8
+.long vector9
+.long vector10
+.long vector11
+.long vector12
+.long vector13
+.long vector14
+.long vector15
+.long vector16
+
+TRAPHANDLER_NOEC(vector0, 0)
+TRAPHANDLER_NOEC(vector1, 1)
+TRAPHANDLER_NOEC(vector2, 2)
+TRAPHANDLER_NOEC(vector3, 3)
+TRAPHANDLER_NOEC(vector4, 4)
+TRAPHANDLER_NOEC(vector5, 5)
+TRAPHANDLER_NOEC(vector6, 6)
+TRAPHANDLER_NOEC(vector7, 7)
+TRAPHANDLER(vector8, 8)
+TRAPHANDLER(vector9, 9)
+TRAPHANDLER(vector10, 10)
+TRAPHANDLER(vector11, 11)
+TRAPHANDLER(vector12, 12)
+TRAPHANDLER(vector13, 13)
+TRAPHANDLER(vector14, 14)
+TRAPHANDLER(vector15, 15)
+TRAPHANDLER_NOEC(vector16, 16)
+TRAPHANDLER(vector17, 17)
+TRAPHANDLER_NOEC(vector18, 18)
+TRAPHANDLER_NOEC(vector19, 19)
+
+
+/*
+ * Lab 3: Your code here for _alltraps
+ */
+.text
+_alltraps:
+pushw $0x0
+pushw %ds
+pushw $0x0
+pushl %es
+pushal
+
+movw $GD_KD, %ax
+movw %ax, %ds
+movw %ax, %es
+pushl %esp
+call trap
+
+
diff --git a/lab2-handin.tar.gz b/lab2-handin.tar.gz
new file mode 100644
index 0000000..451324f
Binary files /dev/null and b/lab2-handin.tar.gz differ
diff --git a/lib/libmain.c b/lib/libmain.c
index 8a14b29..a5aa1e1 100644
--- a/lib/libmain.c
+++ b/lib/libmain.c
@@ -13,8 +13,8 @@ libmain(int argc, char **argv)
 {
 	// set thisenv to point at our Env structure in envs[].
 	// LAB 3: Your code here.
-	thisenv = 0;
-
+        thisenv = envs + ENVX(sys_getenvid());
+    
 	// save the name of the program so that panic() can use it
 	if (argc > 0)
 		binaryname = argv[0];
diff --git a/lib/printfmt.c b/lib/printfmt.c
index 28e01c9..50b0aa9 100644
--- a/lib/printfmt.c
+++ b/lib/printfmt.c
@@ -7,6 +7,7 @@
 #include <inc/string.h>
 #include <inc/stdarg.h>
 #include <inc/error.h>
+#include <inc/color.h>
 
 /*
  * Space or zero padding and a field width are supported for the numeric
@@ -92,6 +93,33 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 		while ((ch = *(unsigned char *) fmt++) != '%') {
 			if (ch == '\0')
 				return;
+			else if(ch == '\033'){
+				if((ch = *(unsigned char *) fmt++) != '[') {
+				    putch(ch, putdat);
+				    continue;
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+				FG_COLOR = *(unsigned char *) fmt++;
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+				    BG_COLOR -= '0';
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+				else BG_COLOR = 0;
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+				    FG_COLOR -= '0';
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+				else BG_COLOR = 7;
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+				continue;
+			}	
 			putch(ch, putdat);
 		}
 
@@ -205,11 +233,9 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 
 		// (unsigned) octal
 		case 'o':
-			// Replace this with your code.
-			putch('X', putdat);
-			putch('X', putdat);
-			putch('X', putdat);
-			break;
+			num = getuint(&ap,lflag);
+			base = 8;
+			goto number;
 
 		// pointer
 		case 'p':
@@ -231,7 +257,7 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 		// escaped '%' character
 		case '%':
 			putch(ch, putdat);
-			break;
+			break;			
 
 		// unrecognized escape sequence - just print it literally
 		default:
diff --git a/obj/.deps b/obj/.deps
new file mode 100644
index 0000000..e7908f7
--- /dev/null
+++ b/obj/.deps
@@ -0,0 +1,105 @@
+obj/user/faultwritekernel.o: user/faultwritekernel.c inc/lib.h \
+ inc/types.h inc/stdio.h inc/stdarg.h inc/string.h inc/error.h \
+ inc/assert.h inc/env.h inc/trap.h inc/memlayout.h inc/mmu.h \
+ inc/syscall.h
+obj/user/testbss.o: user/testbss.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/console.o: kern/console.c inc/x86.h inc/types.h inc/memlayout.h \
+ inc/mmu.h inc/kbdreg.h inc/string.h inc/assert.h inc/stdio.h \
+ inc/stdarg.h inc/color.h kern/console.h
+obj/kern/kclock.o: kern/kclock.c inc/x86.h inc/types.h kern/kclock.h
+obj/user/faultwrite.o: user/faultwrite.c inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/user/faultreadkernel.o: user/faultreadkernel.c inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/lib/string.o: lib/string.c inc/string.h inc/types.h
+obj/user/softint.o: user/softint.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/lib/readline.o: lib/readline.c inc/stdio.h inc/stdarg.h inc/error.h
+obj/kern/entrypgdir.o: kern/entrypgdir.c inc/mmu.h inc/types.h \
+ inc/memlayout.h
+obj/kern/entry.o: kern/entry.S inc/mmu.h inc/memlayout.h inc/trap.h
+obj/lib/console.o: lib/console.c inc/string.h inc/types.h inc/lib.h \
+ inc/stdio.h inc/stdarg.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/kdebug.o: kern/kdebug.c inc/stab.h inc/types.h inc/string.h \
+ inc/memlayout.h inc/mmu.h inc/assert.h inc/stdio.h inc/stdarg.h \
+ kern/kdebug.h kern/pmap.h kern/env.h inc/env.h inc/trap.h
+obj/kern/syscall.o: kern/syscall.c inc/x86.h inc/types.h inc/error.h \
+ inc/string.h inc/assert.h inc/stdio.h inc/stdarg.h kern/env.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h kern/pmap.h kern/trap.h \
+ kern/syscall.h inc/syscall.h kern/console.h
+obj/lib/exit.o: lib/exit.c inc/lib.h inc/types.h inc/stdio.h inc/stdarg.h \
+ inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/pmap.o: kern/pmap.c inc/x86.h inc/types.h inc/mmu.h inc/error.h \
+ inc/string.h inc/assert.h inc/stdio.h inc/stdarg.h kern/pmap.h \
+ inc/memlayout.h kern/kclock.h kern/env.h inc/env.h inc/trap.h
+obj/kern/init.o: kern/init.c inc/stdio.h inc/stdarg.h inc/string.h \
+ inc/types.h inc/assert.h kern/monitor.h kern/console.h kern/pmap.h \
+ inc/memlayout.h inc/mmu.h kern/kclock.h kern/env.h inc/env.h inc/trap.h \
+ kern/trap.h
+obj/lib/printfmt.o: lib/printfmt.c inc/types.h inc/stdio.h inc/stdarg.h \
+ inc/string.h inc/error.h inc/color.h
+obj/user/divzero.o: user/divzero.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/boot/main.o: boot/main.c inc/x86.h inc/types.h inc/elf.h
+obj/boot/boot.o: boot/boot.S inc/mmu.h
+obj/user/faultread.o: user/faultread.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/trap.o: kern/trap.c inc/mmu.h inc/types.h inc/x86.h inc/assert.h \
+ inc/stdio.h inc/stdarg.h kern/pmap.h inc/memlayout.h kern/trap.h \
+ inc/trap.h kern/console.h kern/monitor.h kern/env.h inc/env.h \
+ kern/syscall.h inc/syscall.h
+obj/kern/string.o: lib/string.c inc/string.h inc/types.h
+obj/kern/env.o: kern/env.c inc/x86.h inc/types.h inc/mmu.h inc/error.h \
+ inc/string.h inc/assert.h inc/stdio.h inc/stdarg.h inc/elf.h kern/env.h \
+ inc/env.h inc/trap.h inc/memlayout.h kern/pmap.h kern/trap.h \
+ kern/monitor.h
+obj/user/buggyhello2.o: user/buggyhello2.c inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/lib/entry.o: lib/entry.S inc/mmu.h inc/memlayout.h
+obj/user/badsegment.o: user/badsegment.c inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/printf.o: kern/printf.c inc/types.h inc/stdio.h inc/stdarg.h
+obj/kern/readline.o: lib/readline.c inc/stdio.h inc/stdarg.h inc/error.h
+obj/lib/printf.o: lib/printf.c inc/types.h inc/stdio.h inc/stdarg.h \
+ inc/lib.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/lib/panic.o: lib/panic.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/user/evilhello.o: user/evilhello.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/printfmt.o: lib/printfmt.c inc/types.h inc/stdio.h inc/stdarg.h \
+ inc/string.h inc/error.h inc/color.h
+obj/user/buggyhello.o: user/buggyhello.c inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/lib/syscall.o: lib/syscall.c inc/syscall.h inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h
+obj/lib/libmain.o: lib/libmain.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/user/breakpoint.o: user/breakpoint.c inc/lib.h inc/types.h \
+ inc/stdio.h inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h \
+ inc/trap.h inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/trapentry.o: kern/trapentry.S inc/mmu.h inc/memlayout.h \
+ inc/trap.h
+obj/user/hello.o: user/hello.c inc/lib.h inc/types.h inc/stdio.h \
+ inc/stdarg.h inc/string.h inc/error.h inc/assert.h inc/env.h inc/trap.h \
+ inc/memlayout.h inc/mmu.h inc/syscall.h
+obj/kern/monitor.o: kern/monitor.c inc/stdio.h inc/stdarg.h inc/string.h \
+ inc/types.h inc/memlayout.h inc/mmu.h inc/assert.h inc/x86.h \
+ kern/console.h kern/monitor.h kern/kdebug.h kern/trap.h inc/trap.h \
+ kern/pmap.h
diff --git a/obj/.vars.INIT_CFLAGS b/obj/.vars.INIT_CFLAGS
new file mode 100644
index 0000000..8303241
--- /dev/null
+++ b/obj/.vars.INIT_CFLAGS
@@ -0,0 +1 @@
+-DTEST=user_breakpoint
diff --git a/obj/.vars.KERN_CFLAGS b/obj/.vars.KERN_CFLAGS
new file mode 100644
index 0000000..997f866
--- /dev/null
+++ b/obj/.vars.KERN_CFLAGS
@@ -0,0 +1 @@
+   -fno-builtin -I. -MD -fno-omit-frame-pointer -std=gnu99 -static -Wall -Wno-format -Wno-unused -Werror -gstabs -m32 -fno-tree-ch -fno-stack-protector -DJOS_KERNEL -gstabs
diff --git a/obj/.vars.KERN_LDFLAGS b/obj/.vars.KERN_LDFLAGS
new file mode 100644
index 0000000..29bdd68
--- /dev/null
+++ b/obj/.vars.KERN_LDFLAGS
@@ -0,0 +1 @@
+-m elf_i386 -T kern/kernel.ld -nostdlib
diff --git a/obj/.vars.USER_CFLAGS b/obj/.vars.USER_CFLAGS
new file mode 100644
index 0000000..9ffbf33
--- /dev/null
+++ b/obj/.vars.USER_CFLAGS
@@ -0,0 +1 @@
+   -fno-builtin -I. -MD -fno-omit-frame-pointer -std=gnu99 -static -Wall -Wno-format -Wno-unused -Werror -gstabs -m32 -fno-tree-ch -fno-stack-protector -DJOS_USER -gstabs
diff --git a/obj/boot/boot b/obj/boot/boot
new file mode 100755
index 0000000..520530a
Binary files /dev/null and b/obj/boot/boot differ
diff --git a/obj/boot/boot.asm b/obj/boot/boot.asm
new file mode 100644
index 0000000..2036441
--- /dev/null
+++ b/obj/boot/boot.asm
@@ -0,0 +1,405 @@
+
+obj/boot/boot.out:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+.set CR0_PE_ON,      0x1         # protected mode enable flag
+
+.globl start
+start:
+  .code16                     # Assemble for 16-bit mode
+  cli                         # Disable interrupts
+    7c00:	fa                   	cli    
+  cld                         # String operations increment
+    7c01:	fc                   	cld    
+
+  # Set up the important data segment registers (DS, ES, SS).
+  xorw    %ax,%ax             # Segment number zero
+    7c02:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds             # -> Data Segment
+    7c04:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es             # -> Extra Segment
+    7c06:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss             # -> Stack Segment
+    7c08:	8e d0                	mov    %eax,%ss
+
+00007c0a <seta20.1>:
+  # Enable A20:
+  #   For backwards compatibility with the earliest PCs, physical
+  #   address line 20 is tied low, so that addresses higher than
+  #   1MB wrap around to zero by default.  This code undoes this.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+    7c0a:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c0c:	a8 02                	test   $0x2,%al
+  jnz     seta20.1
+    7c0e:	75 fa                	jne    7c0a <seta20.1>
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+    7c10:	b0 d1                	mov    $0xd1,%al
+  outb    %al,$0x64
+    7c12:	e6 64                	out    %al,$0x64
+
+00007c14 <seta20.2>:
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+    7c14:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c16:	a8 02                	test   $0x2,%al
+  jnz     seta20.2
+    7c18:	75 fa                	jne    7c14 <seta20.2>
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+    7c1a:	b0 df                	mov    $0xdf,%al
+  outb    %al,$0x60
+    7c1c:	e6 60                	out    %al,$0x60
+
+  # Switch from real to protected mode, using a bootstrap GDT
+  # and segment translation that makes virtual addresses 
+  # identical to their physical addresses, so that the 
+  # effective memory map does not change during the switch.
+  lgdt    gdtdesc
+    7c1e:	0f 01 16             	lgdtl  (%esi)
+    7c21:	64                   	fs
+    7c22:	7c 0f                	jl     7c33 <protcseg+0x1>
+  movl    %cr0, %eax
+    7c24:	20 c0                	and    %al,%al
+  orl     $CR0_PE_ON, %eax
+    7c26:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7c2a:	0f 22 c0             	mov    %eax,%cr0
+  
+  # Jump to next instruction, but in 32-bit code segment.
+  # Switches processor into 32-bit mode.
+  ljmp    $PROT_MODE_CSEG, $protcseg
+    7c2d:	ea 32 7c 08 00 66 b8 	ljmp   $0xb866,$0x87c32
+
+00007c32 <protcseg>:
+
+  .code32                     # Assemble for 32-bit mode
+protcseg:
+  # Set up the protected-mode data segment registers
+  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
+    7c32:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7c36:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7c38:	8e c0                	mov    %eax,%es
+  movw    %ax, %fs                # -> FS
+    7c3a:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7c3c:	8e e8                	mov    %eax,%gs
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7c3e:	8e d0                	mov    %eax,%ss
+  
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+    7c40:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+  call bootmain
+    7c45:	e8 c0 00 00 00       	call   7d0a <bootmain>
+
+00007c4a <spin>:
+
+  # If bootmain returns (it shouldn't), loop.
+spin:
+  jmp spin
+    7c4a:	eb fe                	jmp    7c4a <spin>
+
+00007c4c <gdt>:
+	...
+    7c54:	ff                   	(bad)  
+    7c55:	ff 00                	incl   (%eax)
+    7c57:	00 00                	add    %al,(%eax)
+    7c59:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c60:	00 92 cf 00 17 00    	add    %dl,0x1700cf(%edx)
+
+00007c64 <gdtdesc>:
+    7c64:	17                   	pop    %ss
+    7c65:	00 4c 7c 00          	add    %cl,0x0(%esp,%edi,2)
+	...
+
+00007c6a <waitdisk>:
+	}
+}
+
+void
+waitdisk(void)
+{
+    7c6a:	55                   	push   %ebp
+
+static inline uint8_t
+inb(int port)
+{
+	uint8_t data;
+	asm volatile("inb %w1,%0" : "=a" (data) : "d" (port));
+    7c6b:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c70:	89 e5                	mov    %esp,%ebp
+    7c72:	ec                   	in     (%dx),%al
+	// wait for disk reaady
+	while ((inb(0x1F7) & 0xC0) != 0x40)
+    7c73:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c76:	3c 40                	cmp    $0x40,%al
+    7c78:	75 f8                	jne    7c72 <waitdisk+0x8>
+		/* do nothing */;
+}
+    7c7a:	5d                   	pop    %ebp
+    7c7b:	c3                   	ret    
+
+00007c7c <readsect>:
+
+void
+readsect(void *dst, uint32_t offset)
+{
+    7c7c:	55                   	push   %ebp
+    7c7d:	89 e5                	mov    %esp,%ebp
+    7c7f:	57                   	push   %edi
+    7c80:	53                   	push   %ebx
+    7c81:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+	// wait for disk to be ready
+	waitdisk();
+    7c84:	e8 e1 ff ff ff       	call   7c6a <waitdisk>
+}
+
+static inline void
+outb(int port, uint8_t data)
+{
+	asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
+    7c89:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7c8e:	b0 01                	mov    $0x1,%al
+    7c90:	ee                   	out    %al,(%dx)
+    7c91:	0f b6 c3             	movzbl %bl,%eax
+    7c94:	b2 f3                	mov    $0xf3,%dl
+    7c96:	ee                   	out    %al,(%dx)
+    7c97:	0f b6 c7             	movzbl %bh,%eax
+    7c9a:	b2 f4                	mov    $0xf4,%dl
+    7c9c:	ee                   	out    %al,(%dx)
+
+	outb(0x1F2, 1);		// count = 1
+	outb(0x1F3, offset);
+	outb(0x1F4, offset >> 8);
+	outb(0x1F5, offset >> 16);
+    7c9d:	89 d8                	mov    %ebx,%eax
+    7c9f:	b2 f5                	mov    $0xf5,%dl
+    7ca1:	c1 e8 10             	shr    $0x10,%eax
+    7ca4:	0f b6 c0             	movzbl %al,%eax
+    7ca7:	ee                   	out    %al,(%dx)
+	outb(0x1F6, (offset >> 24) | 0xE0);
+    7ca8:	c1 eb 18             	shr    $0x18,%ebx
+    7cab:	b2 f6                	mov    $0xf6,%dl
+    7cad:	88 d8                	mov    %bl,%al
+    7caf:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cb2:	ee                   	out    %al,(%dx)
+    7cb3:	b0 20                	mov    $0x20,%al
+    7cb5:	b2 f7                	mov    $0xf7,%dl
+    7cb7:	ee                   	out    %al,(%dx)
+	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors
+
+	// wait for disk to be ready
+	waitdisk();
+    7cb8:	e8 ad ff ff ff       	call   7c6a <waitdisk>
+}
+
+static inline void
+insl(int port, void *addr, int cnt)
+{
+	asm volatile("cld\n\trepne\n\tinsl"
+    7cbd:	8b 7d 08             	mov    0x8(%ebp),%edi
+    7cc0:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7cc5:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7cca:	fc                   	cld    
+    7ccb:	f2 6d                	repnz insl (%dx),%es:(%edi)
+
+	// read a sector
+	insl(0x1F0, dst, SECTSIZE/4);
+}
+    7ccd:	5b                   	pop    %ebx
+    7cce:	5f                   	pop    %edi
+    7ccf:	5d                   	pop    %ebp
+    7cd0:	c3                   	ret    
+
+00007cd1 <readseg>:
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked
+void
+readseg(uint32_t pa, uint32_t count, uint32_t offset)
+{
+    7cd1:	55                   	push   %ebp
+    7cd2:	89 e5                	mov    %esp,%ebp
+    7cd4:	57                   	push   %edi
+	uint32_t end_pa;
+
+	end_pa = pa + count;
+    7cd5:	8b 7d 0c             	mov    0xc(%ebp),%edi
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked
+void
+readseg(uint32_t pa, uint32_t count, uint32_t offset)
+{
+    7cd8:	56                   	push   %esi
+    7cd9:	8b 75 10             	mov    0x10(%ebp),%esi
+    7cdc:	53                   	push   %ebx
+    7cdd:	8b 5d 08             	mov    0x8(%ebp),%ebx
+
+	// round down to sector boundary
+	pa &= ~(SECTSIZE - 1);
+
+	// translate from bytes to sectors, and kernel starts at sector 1
+	offset = (offset / SECTSIZE) + 1;
+    7ce0:	c1 ee 09             	shr    $0x9,%esi
+void
+readseg(uint32_t pa, uint32_t count, uint32_t offset)
+{
+	uint32_t end_pa;
+
+	end_pa = pa + count;
+    7ce3:	01 df                	add    %ebx,%edi
+
+	// round down to sector boundary
+	pa &= ~(SECTSIZE - 1);
+
+	// translate from bytes to sectors, and kernel starts at sector 1
+	offset = (offset / SECTSIZE) + 1;
+    7ce5:	46                   	inc    %esi
+	uint32_t end_pa;
+
+	end_pa = pa + count;
+
+	// round down to sector boundary
+	pa &= ~(SECTSIZE - 1);
+    7ce6:	81 e3 00 fe ff ff    	and    $0xfffffe00,%ebx
+	offset = (offset / SECTSIZE) + 1;
+
+	// If this is too slow, we could read lots of sectors at a time.
+	// We'd write more to memory than asked, but it doesn't matter --
+	// we load in increasing order.
+	while (pa < end_pa) {
+    7cec:	39 fb                	cmp    %edi,%ebx
+    7cee:	73 12                	jae    7d02 <readseg+0x31>
+		// Since we haven't enabled paging yet and we're using
+		// an identity segment mapping (see boot.S), we can
+		// use physical addresses directly.  This won't be the
+		// case once JOS enables the MMU.
+		readsect((uint8_t*) pa, offset);
+    7cf0:	56                   	push   %esi
+		pa += SECTSIZE;
+		offset++;
+    7cf1:	46                   	inc    %esi
+	while (pa < end_pa) {
+		// Since we haven't enabled paging yet and we're using
+		// an identity segment mapping (see boot.S), we can
+		// use physical addresses directly.  This won't be the
+		// case once JOS enables the MMU.
+		readsect((uint8_t*) pa, offset);
+    7cf2:	53                   	push   %ebx
+		pa += SECTSIZE;
+    7cf3:	81 c3 00 02 00 00    	add    $0x200,%ebx
+	while (pa < end_pa) {
+		// Since we haven't enabled paging yet and we're using
+		// an identity segment mapping (see boot.S), we can
+		// use physical addresses directly.  This won't be the
+		// case once JOS enables the MMU.
+		readsect((uint8_t*) pa, offset);
+    7cf9:	e8 7e ff ff ff       	call   7c7c <readsect>
+		pa += SECTSIZE;
+		offset++;
+    7cfe:	58                   	pop    %eax
+    7cff:	5a                   	pop    %edx
+    7d00:	eb ea                	jmp    7cec <readseg+0x1b>
+	}
+}
+    7d02:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    7d05:	5b                   	pop    %ebx
+    7d06:	5e                   	pop    %esi
+    7d07:	5f                   	pop    %edi
+    7d08:	5d                   	pop    %ebp
+    7d09:	c3                   	ret    
+
+00007d0a <bootmain>:
+void readsect(void*, uint32_t);
+void readseg(uint32_t, uint32_t, uint32_t);
+
+void
+bootmain(void)
+{
+    7d0a:	55                   	push   %ebp
+    7d0b:	89 e5                	mov    %esp,%ebp
+    7d0d:	56                   	push   %esi
+    7d0e:	53                   	push   %ebx
+	struct Proghdr *ph, *eph;
+
+	// read 1st page off disk
+	readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
+    7d0f:	6a 00                	push   $0x0
+    7d11:	68 00 10 00 00       	push   $0x1000
+    7d16:	68 00 00 01 00       	push   $0x10000
+    7d1b:	e8 b1 ff ff ff       	call   7cd1 <readseg>
+
+	// is this a valid ELF?
+	if (ELFHDR->e_magic != ELF_MAGIC)
+    7d20:	83 c4 0c             	add    $0xc,%esp
+    7d23:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d2a:	45 4c 46 
+    7d2d:	75 38                	jne    7d67 <bootmain+0x5d>
+		goto bad;
+
+	// load each program segment (ignores ph flags)
+	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
+    7d2f:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d34:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+	eph = ph + ELFHDR->e_phnum;
+    7d3a:	0f b7 05 2c 00 01 00 	movzwl 0x1002c,%eax
+    7d41:	c1 e0 05             	shl    $0x5,%eax
+    7d44:	8d 34 03             	lea    (%ebx,%eax,1),%esi
+	for (; ph < eph; ph++)
+    7d47:	39 f3                	cmp    %esi,%ebx
+    7d49:	73 16                	jae    7d61 <bootmain+0x57>
+		// p_pa is the load address of this segment (as well
+		// as the physical address)
+		readseg(ph->p_pa, ph->p_memsz, ph->p_offset);
+    7d4b:	ff 73 04             	pushl  0x4(%ebx)
+		goto bad;
+
+	// load each program segment (ignores ph flags)
+	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
+	eph = ph + ELFHDR->e_phnum;
+	for (; ph < eph; ph++)
+    7d4e:	83 c3 20             	add    $0x20,%ebx
+		// p_pa is the load address of this segment (as well
+		// as the physical address)
+		readseg(ph->p_pa, ph->p_memsz, ph->p_offset);
+    7d51:	ff 73 f4             	pushl  -0xc(%ebx)
+    7d54:	ff 73 ec             	pushl  -0x14(%ebx)
+    7d57:	e8 75 ff ff ff       	call   7cd1 <readseg>
+		goto bad;
+
+	// load each program segment (ignores ph flags)
+	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
+	eph = ph + ELFHDR->e_phnum;
+	for (; ph < eph; ph++)
+    7d5c:	83 c4 0c             	add    $0xc,%esp
+    7d5f:	eb e6                	jmp    7d47 <bootmain+0x3d>
+		// as the physical address)
+		readseg(ph->p_pa, ph->p_memsz, ph->p_offset);
+
+	// call the entry point from the ELF header
+	// note: does not return!
+	((void (*)(void)) (ELFHDR->e_entry))();
+    7d61:	ff 15 18 00 01 00    	call   *0x10018
+}
+
+static inline void
+outw(int port, uint16_t data)
+{
+	asm volatile("outw %0,%w1" : : "a" (data), "d" (port));
+    7d67:	ba 00 8a 00 00       	mov    $0x8a00,%edx
+    7d6c:	b8 00 8a ff ff       	mov    $0xffff8a00,%eax
+    7d71:	66 ef                	out    %ax,(%dx)
+    7d73:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
+    7d78:	66 ef                	out    %ax,(%dx)
+    7d7a:	eb fe                	jmp    7d7a <bootmain+0x70>
diff --git a/obj/boot/boot.o b/obj/boot/boot.o
new file mode 100644
index 0000000..33937f4
Binary files /dev/null and b/obj/boot/boot.o differ
diff --git a/obj/boot/boot.out b/obj/boot/boot.out
new file mode 100755
index 0000000..97e3f66
Binary files /dev/null and b/obj/boot/boot.out differ
diff --git a/obj/boot/main.o b/obj/boot/main.o
new file mode 100644
index 0000000..1a5761f
Binary files /dev/null and b/obj/boot/main.o differ
diff --git a/obj/kern/console.o b/obj/kern/console.o
new file mode 100644
index 0000000..25260fd
Binary files /dev/null and b/obj/kern/console.o differ
diff --git a/obj/kern/entry.o b/obj/kern/entry.o
new file mode 100644
index 0000000..02e6017
Binary files /dev/null and b/obj/kern/entry.o differ
diff --git a/obj/kern/entrypgdir.o b/obj/kern/entrypgdir.o
new file mode 100644
index 0000000..5232796
Binary files /dev/null and b/obj/kern/entrypgdir.o differ
diff --git a/obj/kern/env.o b/obj/kern/env.o
new file mode 100644
index 0000000..7f0ae03
Binary files /dev/null and b/obj/kern/env.o differ
diff --git a/obj/kern/init.o b/obj/kern/init.o
new file mode 100644
index 0000000..42c365d
Binary files /dev/null and b/obj/kern/init.o differ
diff --git a/obj/kern/kclock.o b/obj/kern/kclock.o
new file mode 100644
index 0000000..63bfe0e
Binary files /dev/null and b/obj/kern/kclock.o differ
diff --git a/obj/kern/kdebug.o b/obj/kern/kdebug.o
new file mode 100644
index 0000000..c7a5ac8
Binary files /dev/null and b/obj/kern/kdebug.o differ
diff --git a/obj/kern/kernel b/obj/kern/kernel
new file mode 100755
index 0000000..59cbd04
Binary files /dev/null and b/obj/kern/kernel differ
diff --git a/obj/kern/kernel.asm b/obj/kern/kernel.asm
new file mode 100644
index 0000000..2315c63
--- /dev/null
+++ b/obj/kern/kernel.asm
@@ -0,0 +1,12036 @@
+
+obj/kern/kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+f0100000 <_start+0xeffffff4>:
+.globl		_start
+_start = RELOC(entry)
+
+.globl entry
+entry:
+	movw	$0x1234,0x472			# warm boot
+f0100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
+f0100006:	00 00                	add    %al,(%eax)
+f0100008:	fe 4f 52             	decb   0x52(%edi)
+f010000b:	e4 66                	in     $0x66,%al
+
+f010000c <entry>:
+f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
+f0100013:	34 12 
+	# sufficient until we set up our real page table in mem_init
+	# in lab 2.
+
+	# Load the physical address of entry_pgdir into cr3.  entry_pgdir
+	# is defined in entrypgdir.c.
+	movl	$(RELOC(entry_pgdir)), %eax
+f0100015:	b8 00 e0 11 00       	mov    $0x11e000,%eax
+	movl	%eax, %cr3
+f010001a:	0f 22 d8             	mov    %eax,%cr3
+	# Turn on paging.
+	movl	%cr0, %eax
+f010001d:	0f 20 c0             	mov    %cr0,%eax
+	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
+f0100020:	0d 01 00 01 80       	or     $0x80010001,%eax
+	movl	%eax, %cr0
+f0100025:	0f 22 c0             	mov    %eax,%cr0
+
+	# Now paging is enabled, but we're still running at a low EIP
+	# (why is this okay?).  Jump up above KERNBASE before entering
+	# C code.
+	mov	$relocated, %eax
+f0100028:	b8 2f 00 10 f0       	mov    $0xf010002f,%eax
+	jmp	*%eax
+f010002d:	ff e0                	jmp    *%eax
+
+f010002f <relocated>:
+relocated:
+
+	# Clear the frame pointer register (EBP)
+	# so that once we get into debugging C code,
+	# stack backtraces will be terminated properly.
+	movl	$0x0,%ebp			# nuke frame pointer
+f010002f:	bd 00 00 00 00       	mov    $0x0,%ebp
+
+	# Set the stack pointer
+	movl	$(bootstacktop),%esp
+f0100034:	bc 00 d0 11 f0       	mov    $0xf011d000,%esp
+
+	# now to C code
+	call	i386_init
+f0100039:	e8 02 00 00 00       	call   f0100040 <i386_init>
+
+f010003e <spin>:
+
+	# Should never get here, but in case we do, just spin.
+spin:	jmp	spin
+f010003e:	eb fe                	jmp    f010003e <spin>
+
+f0100040 <i386_init>:
+#include <kern/trap.h>
+
+
+void
+i386_init(void)
+{
+f0100040:	55                   	push   %ebp
+f0100041:	89 e5                	mov    %esp,%ebp
+f0100043:	83 ec 18             	sub    $0x18,%esp
+	extern char edata[], end[];
+
+	// Before doing anything else, complete the ELF loading process.
+	// Clear the uninitialized global data (BSS) section of our program.
+	// This ensures that all static/global variables start out zero.
+	memset(edata, 0, end - edata);
+f0100046:	ba dc f7 18 f0       	mov    $0xf018f7dc,%edx
+f010004b:	b8 d2 e8 18 f0       	mov    $0xf018e8d2,%eax
+f0100050:	29 c2                	sub    %eax,%edx
+f0100052:	89 d0                	mov    %edx,%eax
+f0100054:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0100058:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010005f:	00 
+f0100060:	c7 04 24 d2 e8 18 f0 	movl   $0xf018e8d2,(%esp)
+f0100067:	e8 76 64 00 00       	call   f01064e2 <memset>
+
+	// Initialize the console.
+	// Can't call cprintf until after we do this!
+	cons_init();
+f010006c:	e8 74 08 00 00       	call   f01008e5 <cons_init>
+
+	cprintf("6828 decimal is %o octal!\n", 6828);
+f0100071:	c7 44 24 04 ac 1a 00 	movl   $0x1aac,0x4(%esp)
+f0100078:	00 
+f0100079:	c7 04 24 e0 6a 10 f0 	movl   $0xf0106ae0,(%esp)
+f0100080:	e8 08 49 00 00       	call   f010498d <cprintf>
+
+	// Lab 2 memory management initialization functions
+	mem_init();
+f0100085:	e8 8f 14 00 00       	call   f0101519 <mem_init>
+
+	// Lab 3 user environment initialization functions
+	env_init();
+f010008a:	e8 d8 3e 00 00       	call   f0103f67 <env_init>
+	trap_init();
+f010008f:	e8 8c 49 00 00       	call   f0104a20 <trap_init>
+
+#if defined(TEST)
+	// Don't touch -- used by grading script!
+	ENV_CREATE(TEST, ENV_TYPE_USER);
+f0100094:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010009b:	00 
+f010009c:	c7 04 24 61 2b 15 f0 	movl   $0xf0152b61,(%esp)
+f01000a3:	e8 55 45 00 00       	call   f01045fd <env_create>
+	// Touch all you want.
+	ENV_CREATE(user_hello, ENV_TYPE_USER);
+#endif // TEST*
+
+	// We only have one user environment for now, so just run it.
+	env_run(&envs[0]);
+f01000a8:	a1 1c eb 18 f0       	mov    0xf018eb1c,%eax
+f01000ad:	89 04 24             	mov    %eax,(%esp)
+f01000b0:	e8 82 47 00 00       	call   f0104837 <env_run>
+
+f01000b5 <_panic>:
+ * Panic is called on unresolvable fatal errors.
+ * It prints "panic: mesg", and then enters the kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt,...)
+{
+f01000b5:	55                   	push   %ebp
+f01000b6:	89 e5                	mov    %esp,%ebp
+f01000b8:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	if (panicstr)
+f01000bb:	a1 c0 f7 18 f0       	mov    0xf018f7c0,%eax
+f01000c0:	85 c0                	test   %eax,%eax
+f01000c2:	74 02                	je     f01000c6 <_panic+0x11>
+		goto dead;
+f01000c4:	eb 48                	jmp    f010010e <_panic+0x59>
+	panicstr = fmt;
+f01000c6:	8b 45 10             	mov    0x10(%ebp),%eax
+f01000c9:	a3 c0 f7 18 f0       	mov    %eax,0xf018f7c0
+
+	// Be extra sure that the machine is in as reasonable state
+	asm volatile("cli; cld");
+f01000ce:	fa                   	cli    
+f01000cf:	fc                   	cld    
+
+	va_start(ap, fmt);
+f01000d0:	8d 45 14             	lea    0x14(%ebp),%eax
+f01000d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	cprintf("kernel panic at %s:%d: ", file, line);
+f01000d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01000d9:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01000dd:	8b 45 08             	mov    0x8(%ebp),%eax
+f01000e0:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01000e4:	c7 04 24 fb 6a 10 f0 	movl   $0xf0106afb,(%esp)
+f01000eb:	e8 9d 48 00 00       	call   f010498d <cprintf>
+	vcprintf(fmt, ap);
+f01000f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01000f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01000f7:	8b 45 10             	mov    0x10(%ebp),%eax
+f01000fa:	89 04 24             	mov    %eax,(%esp)
+f01000fd:	e8 58 48 00 00       	call   f010495a <vcprintf>
+	cprintf("\n");
+f0100102:	c7 04 24 13 6b 10 f0 	movl   $0xf0106b13,(%esp)
+f0100109:	e8 7f 48 00 00       	call   f010498d <cprintf>
+	va_end(ap);
+
+dead:
+	/* break into the kernel monitor */
+	while (1)
+		monitor(NULL);
+f010010e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0100115:	e8 38 10 00 00       	call   f0101152 <monitor>
+f010011a:	eb f2                	jmp    f010010e <_panic+0x59>
+
+f010011c <_warn>:
+}
+
+/* like panic, but don't */
+void
+_warn(const char *file, int line, const char *fmt,...)
+{
+f010011c:	55                   	push   %ebp
+f010011d:	89 e5                	mov    %esp,%ebp
+f010011f:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+f0100122:	8d 45 14             	lea    0x14(%ebp),%eax
+f0100125:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	cprintf("kernel warning at %s:%d: ", file, line);
+f0100128:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010012b:	89 44 24 08          	mov    %eax,0x8(%esp)
+f010012f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0100132:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100136:	c7 04 24 15 6b 10 f0 	movl   $0xf0106b15,(%esp)
+f010013d:	e8 4b 48 00 00       	call   f010498d <cprintf>
+	vcprintf(fmt, ap);
+f0100142:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100145:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100149:	8b 45 10             	mov    0x10(%ebp),%eax
+f010014c:	89 04 24             	mov    %eax,(%esp)
+f010014f:	e8 06 48 00 00       	call   f010495a <vcprintf>
+	cprintf("\n");
+f0100154:	c7 04 24 13 6b 10 f0 	movl   $0xf0106b13,(%esp)
+f010015b:	e8 2d 48 00 00       	call   f010498d <cprintf>
+	va_end(ap);
+}
+f0100160:	c9                   	leave  
+f0100161:	c3                   	ret    
+
+f0100162 <inb>:
+	asm volatile("int3");
+}
+
+static inline uint8_t
+inb(int port)
+{
+f0100162:	55                   	push   %ebp
+f0100163:	89 e5                	mov    %esp,%ebp
+f0100165:	83 ec 10             	sub    $0x10,%esp
+	uint8_t data;
+	asm volatile("inb %w1,%0" : "=a" (data) : "d" (port));
+f0100168:	8b 45 08             	mov    0x8(%ebp),%eax
+f010016b:	89 c2                	mov    %eax,%edx
+f010016d:	ec                   	in     (%dx),%al
+f010016e:	88 45 ff             	mov    %al,-0x1(%ebp)
+	return data;
+f0100171:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+f0100175:	c9                   	leave  
+f0100176:	c3                   	ret    
+
+f0100177 <outb>:
+		     : "memory", "cc");
+}
+
+static inline void
+outb(int port, uint8_t data)
+{
+f0100177:	55                   	push   %ebp
+f0100178:	89 e5                	mov    %esp,%ebp
+f010017a:	83 ec 04             	sub    $0x4,%esp
+f010017d:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100180:	88 45 fc             	mov    %al,-0x4(%ebp)
+	asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
+f0100183:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
+f0100187:	8b 55 08             	mov    0x8(%ebp),%edx
+f010018a:	ee                   	out    %al,(%dx)
+}
+f010018b:	c9                   	leave  
+f010018c:	c3                   	ret    
+
+f010018d <delay>:
+static void cons_putc(int c);
+
+// Stupid I/O delay routine necessitated by historical PC design flaws
+static void
+delay(void)
+{
+f010018d:	55                   	push   %ebp
+f010018e:	89 e5                	mov    %esp,%ebp
+f0100190:	83 ec 04             	sub    $0x4,%esp
+	inb(0x84);
+f0100193:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
+f010019a:	e8 c3 ff ff ff       	call   f0100162 <inb>
+	inb(0x84);
+f010019f:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
+f01001a6:	e8 b7 ff ff ff       	call   f0100162 <inb>
+	inb(0x84);
+f01001ab:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
+f01001b2:	e8 ab ff ff ff       	call   f0100162 <inb>
+	inb(0x84);
+f01001b7:	c7 04 24 84 00 00 00 	movl   $0x84,(%esp)
+f01001be:	e8 9f ff ff ff       	call   f0100162 <inb>
+}
+f01001c3:	c9                   	leave  
+f01001c4:	c3                   	ret    
+
+f01001c5 <serial_proc_data>:
+
+static bool serial_exists;
+
+static int
+serial_proc_data(void)
+{
+f01001c5:	55                   	push   %ebp
+f01001c6:	89 e5                	mov    %esp,%ebp
+f01001c8:	83 ec 04             	sub    $0x4,%esp
+	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
+f01001cb:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
+f01001d2:	e8 8b ff ff ff       	call   f0100162 <inb>
+f01001d7:	0f b6 c0             	movzbl %al,%eax
+f01001da:	83 e0 01             	and    $0x1,%eax
+f01001dd:	85 c0                	test   %eax,%eax
+f01001df:	75 07                	jne    f01001e8 <serial_proc_data+0x23>
+		return -1;
+f01001e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f01001e6:	eb 0f                	jmp    f01001f7 <serial_proc_data+0x32>
+	return inb(COM1+COM_RX);
+f01001e8:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+f01001ef:	e8 6e ff ff ff       	call   f0100162 <inb>
+f01001f4:	0f b6 c0             	movzbl %al,%eax
+}
+f01001f7:	c9                   	leave  
+f01001f8:	c3                   	ret    
+
+f01001f9 <serial_intr>:
+
+void
+serial_intr(void)
+{
+f01001f9:	55                   	push   %ebp
+f01001fa:	89 e5                	mov    %esp,%ebp
+f01001fc:	83 ec 18             	sub    $0x18,%esp
+	if (serial_exists)
+f01001ff:	0f b6 05 e0 e8 18 f0 	movzbl 0xf018e8e0,%eax
+f0100206:	84 c0                	test   %al,%al
+f0100208:	74 0c                	je     f0100216 <serial_intr+0x1d>
+		cons_intr(serial_proc_data);
+f010020a:	c7 04 24 c5 01 10 f0 	movl   $0xf01001c5,(%esp)
+f0100211:	e8 fd 05 00 00       	call   f0100813 <cons_intr>
+}
+f0100216:	c9                   	leave  
+f0100217:	c3                   	ret    
+
+f0100218 <serial_putc>:
+
+static void
+serial_putc(int c)
+{
+f0100218:	55                   	push   %ebp
+f0100219:	89 e5                	mov    %esp,%ebp
+f010021b:	83 ec 18             	sub    $0x18,%esp
+	int i;
+
+	for (i = 0;
+f010021e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+f0100225:	eb 09                	jmp    f0100230 <serial_putc+0x18>
+	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
+	     i++)
+		delay();
+f0100227:	e8 61 ff ff ff       	call   f010018d <delay>
+{
+	int i;
+
+	for (i = 0;
+	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
+	     i++)
+f010022c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+serial_putc(int c)
+{
+	int i;
+
+	for (i = 0;
+	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
+f0100230:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
+f0100237:	e8 26 ff ff ff       	call   f0100162 <inb>
+f010023c:	0f b6 c0             	movzbl %al,%eax
+f010023f:	83 e0 20             	and    $0x20,%eax
+static void
+serial_putc(int c)
+{
+	int i;
+
+	for (i = 0;
+f0100242:	85 c0                	test   %eax,%eax
+f0100244:	75 09                	jne    f010024f <serial_putc+0x37>
+	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
+f0100246:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+f010024d:	7e d8                	jle    f0100227 <serial_putc+0xf>
+	     i++)
+		delay();
+
+	outb(COM1 + COM_TX, c);
+f010024f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0100252:	0f b6 c0             	movzbl %al,%eax
+f0100255:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100259:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+f0100260:	e8 12 ff ff ff       	call   f0100177 <outb>
+}
+f0100265:	c9                   	leave  
+f0100266:	c3                   	ret    
+
+f0100267 <serial_init>:
+
+static void
+serial_init(void)
+{
+f0100267:	55                   	push   %ebp
+f0100268:	89 e5                	mov    %esp,%ebp
+f010026a:	83 ec 08             	sub    $0x8,%esp
+	// Turn off the FIFO
+	outb(COM1+COM_FCR, 0);
+f010026d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100274:	00 
+f0100275:	c7 04 24 fa 03 00 00 	movl   $0x3fa,(%esp)
+f010027c:	e8 f6 fe ff ff       	call   f0100177 <outb>
+
+	// Set speed; requires DLAB latch
+	outb(COM1+COM_LCR, COM_LCR_DLAB);
+f0100281:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
+f0100288:	00 
+f0100289:	c7 04 24 fb 03 00 00 	movl   $0x3fb,(%esp)
+f0100290:	e8 e2 fe ff ff       	call   f0100177 <outb>
+	outb(COM1+COM_DLL, (uint8_t) (115200 / 9600));
+f0100295:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
+f010029c:	00 
+f010029d:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+f01002a4:	e8 ce fe ff ff       	call   f0100177 <outb>
+	outb(COM1+COM_DLM, 0);
+f01002a9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f01002b0:	00 
+f01002b1:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp)
+f01002b8:	e8 ba fe ff ff       	call   f0100177 <outb>
+
+	// 8 data bits, 1 stop bit, parity off; turn off DLAB latch
+	outb(COM1+COM_LCR, COM_LCR_WLEN8 & ~COM_LCR_DLAB);
+f01002bd:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+f01002c4:	00 
+f01002c5:	c7 04 24 fb 03 00 00 	movl   $0x3fb,(%esp)
+f01002cc:	e8 a6 fe ff ff       	call   f0100177 <outb>
+
+	// No modem controls
+	outb(COM1+COM_MCR, 0);
+f01002d1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f01002d8:	00 
+f01002d9:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
+f01002e0:	e8 92 fe ff ff       	call   f0100177 <outb>
+	// Enable rcv interrupts
+	outb(COM1+COM_IER, COM_IER_RDI);
+f01002e5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+f01002ec:	00 
+f01002ed:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp)
+f01002f4:	e8 7e fe ff ff       	call   f0100177 <outb>
+
+	// Clear any preexisting overrun indications and interrupts
+	// Serial port doesn't exist if COM_LSR returns 0xFF
+	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
+f01002f9:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
+f0100300:	e8 5d fe ff ff       	call   f0100162 <inb>
+f0100305:	3c ff                	cmp    $0xff,%al
+f0100307:	0f 95 c0             	setne  %al
+f010030a:	a2 e0 e8 18 f0       	mov    %al,0xf018e8e0
+	(void) inb(COM1+COM_IIR);
+f010030f:	c7 04 24 fa 03 00 00 	movl   $0x3fa,(%esp)
+f0100316:	e8 47 fe ff ff       	call   f0100162 <inb>
+	(void) inb(COM1+COM_RX);
+f010031b:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
+f0100322:	e8 3b fe ff ff       	call   f0100162 <inb>
+
+}
+f0100327:	c9                   	leave  
+f0100328:	c3                   	ret    
+
+f0100329 <lpt_putc>:
+// For information on PC parallel port programming, see the class References
+// page.
+
+static void
+lpt_putc(int c)
+{
+f0100329:	55                   	push   %ebp
+f010032a:	89 e5                	mov    %esp,%ebp
+f010032c:	83 ec 18             	sub    $0x18,%esp
+	int i;
+
+	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
+f010032f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+f0100336:	eb 09                	jmp    f0100341 <lpt_putc+0x18>
+		delay();
+f0100338:	e8 50 fe ff ff       	call   f010018d <delay>
+static void
+lpt_putc(int c)
+{
+	int i;
+
+	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
+f010033d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+f0100341:	c7 04 24 79 03 00 00 	movl   $0x379,(%esp)
+f0100348:	e8 15 fe ff ff       	call   f0100162 <inb>
+f010034d:	84 c0                	test   %al,%al
+f010034f:	78 09                	js     f010035a <lpt_putc+0x31>
+f0100351:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+f0100358:	7e de                	jle    f0100338 <lpt_putc+0xf>
+		delay();
+	outb(0x378+0, c);
+f010035a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010035d:	0f b6 c0             	movzbl %al,%eax
+f0100360:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100364:	c7 04 24 78 03 00 00 	movl   $0x378,(%esp)
+f010036b:	e8 07 fe ff ff       	call   f0100177 <outb>
+	outb(0x378+2, 0x08|0x04|0x01);
+f0100370:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
+f0100377:	00 
+f0100378:	c7 04 24 7a 03 00 00 	movl   $0x37a,(%esp)
+f010037f:	e8 f3 fd ff ff       	call   f0100177 <outb>
+	outb(0x378+2, 0x08);
+f0100384:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
+f010038b:	00 
+f010038c:	c7 04 24 7a 03 00 00 	movl   $0x37a,(%esp)
+f0100393:	e8 df fd ff ff       	call   f0100177 <outb>
+}
+f0100398:	c9                   	leave  
+f0100399:	c3                   	ret    
+
+f010039a <cga_init>:
+static uint16_t *crt_buf;
+static uint16_t crt_pos;
+
+static void
+cga_init(void)
+{
+f010039a:	55                   	push   %ebp
+f010039b:	89 e5                	mov    %esp,%ebp
+f010039d:	83 ec 18             	sub    $0x18,%esp
+	volatile uint16_t *cp;
+	uint16_t was;
+	unsigned pos;
+
+	cp = (uint16_t*) (KERNBASE + CGA_BUF);
+f01003a0:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
+	was = *cp;
+f01003a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f01003aa:	0f b7 00             	movzwl (%eax),%eax
+f01003ad:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+	*cp = (uint16_t) 0xA55A;
+f01003b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f01003b4:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+	if (*cp != 0xA55A) {
+f01003b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f01003bc:	0f b7 00             	movzwl (%eax),%eax
+f01003bf:	66 3d 5a a5          	cmp    $0xa55a,%ax
+f01003c3:	74 13                	je     f01003d8 <cga_init+0x3e>
+		cp = (uint16_t*) (KERNBASE + MONO_BUF);
+f01003c5:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
+		addr_6845 = MONO_BASE;
+f01003cc:	c7 05 e4 e8 18 f0 b4 	movl   $0x3b4,0xf018e8e4
+f01003d3:	03 00 00 
+f01003d6:	eb 14                	jmp    f01003ec <cga_init+0x52>
+	} else {
+		*cp = was;
+f01003d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f01003db:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+f01003df:	66 89 10             	mov    %dx,(%eax)
+		addr_6845 = CGA_BASE;
+f01003e2:	c7 05 e4 e8 18 f0 d4 	movl   $0x3d4,0xf018e8e4
+f01003e9:	03 00 00 
+	}
+
+	/* Extract cursor location */
+	outb(addr_6845, 14);
+f01003ec:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f01003f1:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
+f01003f8:	00 
+f01003f9:	89 04 24             	mov    %eax,(%esp)
+f01003fc:	e8 76 fd ff ff       	call   f0100177 <outb>
+	pos = inb(addr_6845 + 1) << 8;
+f0100401:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f0100406:	83 c0 01             	add    $0x1,%eax
+f0100409:	89 04 24             	mov    %eax,(%esp)
+f010040c:	e8 51 fd ff ff       	call   f0100162 <inb>
+f0100411:	0f b6 c0             	movzbl %al,%eax
+f0100414:	c1 e0 08             	shl    $0x8,%eax
+f0100417:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	outb(addr_6845, 15);
+f010041a:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f010041f:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
+f0100426:	00 
+f0100427:	89 04 24             	mov    %eax,(%esp)
+f010042a:	e8 48 fd ff ff       	call   f0100177 <outb>
+	pos |= inb(addr_6845 + 1);
+f010042f:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f0100434:	83 c0 01             	add    $0x1,%eax
+f0100437:	89 04 24             	mov    %eax,(%esp)
+f010043a:	e8 23 fd ff ff       	call   f0100162 <inb>
+f010043f:	0f b6 c0             	movzbl %al,%eax
+f0100442:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+	crt_buf = (uint16_t*) cp;
+f0100445:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0100448:	a3 e8 e8 18 f0       	mov    %eax,0xf018e8e8
+	crt_pos = pos;
+f010044d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100450:	66 a3 ec e8 18 f0    	mov    %ax,0xf018e8ec
+}
+f0100456:	c9                   	leave  
+f0100457:	c3                   	ret    
+
+f0100458 <cga_putc>:
+
+
+
+static void
+cga_putc(int c)
+{
+f0100458:	55                   	push   %ebp
+f0100459:	89 e5                	mov    %esp,%ebp
+f010045b:	53                   	push   %ebx
+f010045c:	83 ec 24             	sub    $0x24,%esp
+	// if no attribute given, then use black on white
+	if (!(c & ~0xFF))
+f010045f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0100462:	b0 00                	mov    $0x0,%al
+f0100464:	85 c0                	test   %eax,%eax
+f0100466:	75 08                	jne    f0100470 <cga_putc+0x18>
+	   	c |= COLOR;
+f0100468:	a1 c8 f7 18 f0       	mov    0xf018f7c8,%eax
+f010046d:	09 45 08             	or     %eax,0x8(%ebp)
+	switch (c & 0xff) {
+f0100470:	8b 45 08             	mov    0x8(%ebp),%eax
+f0100473:	0f b6 c0             	movzbl %al,%eax
+f0100476:	83 f8 09             	cmp    $0x9,%eax
+f0100479:	0f 84 ac 00 00 00    	je     f010052b <cga_putc+0xd3>
+f010047f:	83 f8 09             	cmp    $0x9,%eax
+f0100482:	7f 0a                	jg     f010048e <cga_putc+0x36>
+f0100484:	83 f8 08             	cmp    $0x8,%eax
+f0100487:	74 14                	je     f010049d <cga_putc+0x45>
+f0100489:	e9 db 00 00 00       	jmp    f0100569 <cga_putc+0x111>
+f010048e:	83 f8 0a             	cmp    $0xa,%eax
+f0100491:	74 4e                	je     f01004e1 <cga_putc+0x89>
+f0100493:	83 f8 0d             	cmp    $0xd,%eax
+f0100496:	74 59                	je     f01004f1 <cga_putc+0x99>
+f0100498:	e9 cc 00 00 00       	jmp    f0100569 <cga_putc+0x111>
+	case '\b':
+		if (crt_pos > 0) {
+f010049d:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f01004a4:	66 85 c0             	test   %ax,%ax
+f01004a7:	74 33                	je     f01004dc <cga_putc+0x84>
+			crt_pos--;
+f01004a9:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f01004b0:	83 e8 01             	sub    $0x1,%eax
+f01004b3:	66 a3 ec e8 18 f0    	mov    %ax,0xf018e8ec
+			crt_buf[crt_pos] = (c & ~0xff) | ' ';
+f01004b9:	a1 e8 e8 18 f0       	mov    0xf018e8e8,%eax
+f01004be:	0f b7 15 ec e8 18 f0 	movzwl 0xf018e8ec,%edx
+f01004c5:	0f b7 d2             	movzwl %dx,%edx
+f01004c8:	01 d2                	add    %edx,%edx
+f01004ca:	01 c2                	add    %eax,%edx
+f01004cc:	8b 45 08             	mov    0x8(%ebp),%eax
+f01004cf:	b0 00                	mov    $0x0,%al
+f01004d1:	83 c8 20             	or     $0x20,%eax
+f01004d4:	66 89 02             	mov    %ax,(%edx)
+		}
+		break;
+f01004d7:	e9 b3 00 00 00       	jmp    f010058f <cga_putc+0x137>
+f01004dc:	e9 ae 00 00 00       	jmp    f010058f <cga_putc+0x137>
+	case '\n':
+		crt_pos += CRT_COLS;
+f01004e1:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f01004e8:	83 c0 50             	add    $0x50,%eax
+f01004eb:	66 a3 ec e8 18 f0    	mov    %ax,0xf018e8ec
+		/* fallthru */
+	case '\r':
+		crt_pos -= (crt_pos % CRT_COLS);
+f01004f1:	0f b7 1d ec e8 18 f0 	movzwl 0xf018e8ec,%ebx
+f01004f8:	0f b7 0d ec e8 18 f0 	movzwl 0xf018e8ec,%ecx
+f01004ff:	0f b7 c1             	movzwl %cx,%eax
+f0100502:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
+f0100508:	c1 e8 10             	shr    $0x10,%eax
+f010050b:	89 c2                	mov    %eax,%edx
+f010050d:	66 c1 ea 06          	shr    $0x6,%dx
+f0100511:	89 d0                	mov    %edx,%eax
+f0100513:	c1 e0 02             	shl    $0x2,%eax
+f0100516:	01 d0                	add    %edx,%eax
+f0100518:	c1 e0 04             	shl    $0x4,%eax
+f010051b:	29 c1                	sub    %eax,%ecx
+f010051d:	89 ca                	mov    %ecx,%edx
+f010051f:	89 d8                	mov    %ebx,%eax
+f0100521:	29 d0                	sub    %edx,%eax
+f0100523:	66 a3 ec e8 18 f0    	mov    %ax,0xf018e8ec
+		break;
+f0100529:	eb 64                	jmp    f010058f <cga_putc+0x137>
+	case '\t':
+		cons_putc(' ');
+f010052b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+f0100532:	e8 85 03 00 00       	call   f01008bc <cons_putc>
+		cons_putc(' ');
+f0100537:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+f010053e:	e8 79 03 00 00       	call   f01008bc <cons_putc>
+		cons_putc(' ');
+f0100543:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+f010054a:	e8 6d 03 00 00       	call   f01008bc <cons_putc>
+		cons_putc(' ');
+f010054f:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+f0100556:	e8 61 03 00 00       	call   f01008bc <cons_putc>
+		cons_putc(' ');
+f010055b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+f0100562:	e8 55 03 00 00       	call   f01008bc <cons_putc>
+		break;
+f0100567:	eb 26                	jmp    f010058f <cga_putc+0x137>
+	default:
+		crt_buf[crt_pos++] = c;		/* write the character */
+f0100569:	8b 0d e8 e8 18 f0    	mov    0xf018e8e8,%ecx
+f010056f:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f0100576:	8d 50 01             	lea    0x1(%eax),%edx
+f0100579:	66 89 15 ec e8 18 f0 	mov    %dx,0xf018e8ec
+f0100580:	0f b7 c0             	movzwl %ax,%eax
+f0100583:	01 c0                	add    %eax,%eax
+f0100585:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+f0100588:	8b 45 08             	mov    0x8(%ebp),%eax
+f010058b:	66 89 02             	mov    %ax,(%edx)
+		break;
+f010058e:	90                   	nop
+	}
+
+	// What is the purpose of this?
+	if (crt_pos >= CRT_SIZE) {
+f010058f:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f0100596:	66 3d cf 07          	cmp    $0x7cf,%ax
+f010059a:	76 5b                	jbe    f01005f7 <cga_putc+0x19f>
+		int i;
+
+		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+f010059c:	a1 e8 e8 18 f0       	mov    0xf018e8e8,%eax
+f01005a1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+f01005a7:	a1 e8 e8 18 f0       	mov    0xf018e8e8,%eax
+f01005ac:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
+f01005b3:	00 
+f01005b4:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01005b8:	89 04 24             	mov    %eax,(%esp)
+f01005bb:	e8 90 5f 00 00       	call   f0106550 <memmove>
+		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
+f01005c0:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+f01005c7:	eb 15                	jmp    f01005de <cga_putc+0x186>
+			crt_buf[i] = 0x0700 | ' ';
+f01005c9:	a1 e8 e8 18 f0       	mov    0xf018e8e8,%eax
+f01005ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01005d1:	01 d2                	add    %edx,%edx
+f01005d3:	01 d0                	add    %edx,%eax
+f01005d5:	66 c7 00 20 07       	movw   $0x720,(%eax)
+	// What is the purpose of this?
+	if (crt_pos >= CRT_SIZE) {
+		int i;
+
+		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
+f01005da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f01005de:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+f01005e5:	7e e2                	jle    f01005c9 <cga_putc+0x171>
+			crt_buf[i] = 0x0700 | ' ';
+		crt_pos -= CRT_COLS;
+f01005e7:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f01005ee:	83 e8 50             	sub    $0x50,%eax
+f01005f1:	66 a3 ec e8 18 f0    	mov    %ax,0xf018e8ec
+	}
+
+	/* move that little blinky thing */
+	outb(addr_6845, 14);
+f01005f7:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f01005fc:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
+f0100603:	00 
+f0100604:	89 04 24             	mov    %eax,(%esp)
+f0100607:	e8 6b fb ff ff       	call   f0100177 <outb>
+	outb(addr_6845 + 1, crt_pos >> 8);
+f010060c:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f0100613:	66 c1 e8 08          	shr    $0x8,%ax
+f0100617:	0f b6 d0             	movzbl %al,%edx
+f010061a:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f010061f:	83 c0 01             	add    $0x1,%eax
+f0100622:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0100626:	89 04 24             	mov    %eax,(%esp)
+f0100629:	e8 49 fb ff ff       	call   f0100177 <outb>
+	outb(addr_6845, 15);
+f010062e:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f0100633:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
+f010063a:	00 
+f010063b:	89 04 24             	mov    %eax,(%esp)
+f010063e:	e8 34 fb ff ff       	call   f0100177 <outb>
+	outb(addr_6845 + 1, crt_pos);
+f0100643:	0f b7 05 ec e8 18 f0 	movzwl 0xf018e8ec,%eax
+f010064a:	0f b6 d0             	movzbl %al,%edx
+f010064d:	a1 e4 e8 18 f0       	mov    0xf018e8e4,%eax
+f0100652:	83 c0 01             	add    $0x1,%eax
+f0100655:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0100659:	89 04 24             	mov    %eax,(%esp)
+f010065c:	e8 16 fb ff ff       	call   f0100177 <outb>
+}
+f0100661:	83 c4 24             	add    $0x24,%esp
+f0100664:	5b                   	pop    %ebx
+f0100665:	5d                   	pop    %ebp
+f0100666:	c3                   	ret    
+
+f0100667 <kbd_proc_data>:
+ * Get data from the keyboard.  If we finish a character, return it.  Else 0.
+ * Return -1 if no data.
+ */
+static int
+kbd_proc_data(void)
+{
+f0100667:	55                   	push   %ebp
+f0100668:	89 e5                	mov    %esp,%ebp
+f010066a:	83 ec 28             	sub    $0x28,%esp
+	int c;
+	uint8_t stat, data;
+	static uint32_t shift;
+
+	stat = inb(KBSTATP);
+f010066d:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
+f0100674:	e8 e9 fa ff ff       	call   f0100162 <inb>
+f0100679:	88 45 f2             	mov    %al,-0xe(%ebp)
+	if ((stat & KBS_DIB) == 0)
+f010067c:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
+f0100680:	83 e0 01             	and    $0x1,%eax
+f0100683:	85 c0                	test   %eax,%eax
+f0100685:	75 0a                	jne    f0100691 <kbd_proc_data+0x2a>
+		return -1;
+f0100687:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f010068c:	e9 67 01 00 00       	jmp    f01007f8 <kbd_proc_data+0x191>
+	// Ignore data from mouse.
+	if (stat & KBS_TERR)
+f0100691:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
+f0100695:	83 e0 20             	and    $0x20,%eax
+f0100698:	85 c0                	test   %eax,%eax
+f010069a:	74 0a                	je     f01006a6 <kbd_proc_data+0x3f>
+		return -1;
+f010069c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f01006a1:	e9 52 01 00 00       	jmp    f01007f8 <kbd_proc_data+0x191>
+
+	data = inb(KBDATAP);
+f01006a6:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
+f01006ad:	e8 b0 fa ff ff       	call   f0100162 <inb>
+f01006b2:	88 45 f3             	mov    %al,-0xd(%ebp)
+
+	if (data == 0xE0) {
+f01006b5:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+f01006b9:	75 17                	jne    f01006d2 <kbd_proc_data+0x6b>
+		// E0 escape character
+		shift |= E0ESC;
+f01006bb:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f01006c0:	83 c8 40             	or     $0x40,%eax
+f01006c3:	a3 08 eb 18 f0       	mov    %eax,0xf018eb08
+		return 0;
+f01006c8:	b8 00 00 00 00       	mov    $0x0,%eax
+f01006cd:	e9 26 01 00 00       	jmp    f01007f8 <kbd_proc_data+0x191>
+	} else if (data & 0x80) {
+f01006d2:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f01006d6:	84 c0                	test   %al,%al
+f01006d8:	79 47                	jns    f0100721 <kbd_proc_data+0xba>
+		// Key released
+		data = (shift & E0ESC ? data : data & 0x7F);
+f01006da:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f01006df:	83 e0 40             	and    $0x40,%eax
+f01006e2:	85 c0                	test   %eax,%eax
+f01006e4:	75 09                	jne    f01006ef <kbd_proc_data+0x88>
+f01006e6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f01006ea:	83 e0 7f             	and    $0x7f,%eax
+f01006ed:	eb 04                	jmp    f01006f3 <kbd_proc_data+0x8c>
+f01006ef:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f01006f3:	88 45 f3             	mov    %al,-0xd(%ebp)
+		shift &= ~(shiftcode[data] | E0ESC);
+f01006f6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f01006fa:	0f b6 80 00 f0 11 f0 	movzbl -0xfee1000(%eax),%eax
+f0100701:	83 c8 40             	or     $0x40,%eax
+f0100704:	0f b6 c0             	movzbl %al,%eax
+f0100707:	f7 d0                	not    %eax
+f0100709:	89 c2                	mov    %eax,%edx
+f010070b:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f0100710:	21 d0                	and    %edx,%eax
+f0100712:	a3 08 eb 18 f0       	mov    %eax,0xf018eb08
+		return 0;
+f0100717:	b8 00 00 00 00       	mov    $0x0,%eax
+f010071c:	e9 d7 00 00 00       	jmp    f01007f8 <kbd_proc_data+0x191>
+	} else if (shift & E0ESC) {
+f0100721:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f0100726:	83 e0 40             	and    $0x40,%eax
+f0100729:	85 c0                	test   %eax,%eax
+f010072b:	74 11                	je     f010073e <kbd_proc_data+0xd7>
+		// Last character was an E0 escape; or with 0x80
+		data |= 0x80;
+f010072d:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+		shift &= ~E0ESC;
+f0100731:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f0100736:	83 e0 bf             	and    $0xffffffbf,%eax
+f0100739:	a3 08 eb 18 f0       	mov    %eax,0xf018eb08
+	}
+
+	shift |= shiftcode[data];
+f010073e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f0100742:	0f b6 80 00 f0 11 f0 	movzbl -0xfee1000(%eax),%eax
+f0100749:	0f b6 d0             	movzbl %al,%edx
+f010074c:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f0100751:	09 d0                	or     %edx,%eax
+f0100753:	a3 08 eb 18 f0       	mov    %eax,0xf018eb08
+	shift ^= togglecode[data];
+f0100758:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f010075c:	0f b6 80 00 f1 11 f0 	movzbl -0xfee0f00(%eax),%eax
+f0100763:	0f b6 d0             	movzbl %al,%edx
+f0100766:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f010076b:	31 d0                	xor    %edx,%eax
+f010076d:	a3 08 eb 18 f0       	mov    %eax,0xf018eb08
+
+	c = charcode[shift & (CTL | SHIFT)][data];
+f0100772:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f0100777:	83 e0 03             	and    $0x3,%eax
+f010077a:	8b 14 85 00 f5 11 f0 	mov    -0xfee0b00(,%eax,4),%edx
+f0100781:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+f0100785:	01 d0                	add    %edx,%eax
+f0100787:	0f b6 00             	movzbl (%eax),%eax
+f010078a:	0f b6 c0             	movzbl %al,%eax
+f010078d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	if (shift & CAPSLOCK) {
+f0100790:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f0100795:	83 e0 08             	and    $0x8,%eax
+f0100798:	85 c0                	test   %eax,%eax
+f010079a:	74 22                	je     f01007be <kbd_proc_data+0x157>
+		if ('a' <= c && c <= 'z')
+f010079c:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+f01007a0:	7e 0c                	jle    f01007ae <kbd_proc_data+0x147>
+f01007a2:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+f01007a6:	7f 06                	jg     f01007ae <kbd_proc_data+0x147>
+			c += 'A' - 'a';
+f01007a8:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+f01007ac:	eb 10                	jmp    f01007be <kbd_proc_data+0x157>
+		else if ('A' <= c && c <= 'Z')
+f01007ae:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+f01007b2:	7e 0a                	jle    f01007be <kbd_proc_data+0x157>
+f01007b4:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+f01007b8:	7f 04                	jg     f01007be <kbd_proc_data+0x157>
+			c += 'a' - 'A';
+f01007ba:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+	}
+
+	// Process special keys
+	// Ctrl-Alt-Del: reboot
+	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+f01007be:	a1 08 eb 18 f0       	mov    0xf018eb08,%eax
+f01007c3:	f7 d0                	not    %eax
+f01007c5:	83 e0 06             	and    $0x6,%eax
+f01007c8:	85 c0                	test   %eax,%eax
+f01007ca:	75 29                	jne    f01007f5 <kbd_proc_data+0x18e>
+f01007cc:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+f01007d3:	75 20                	jne    f01007f5 <kbd_proc_data+0x18e>
+		cprintf("Rebooting!\n");
+f01007d5:	c7 04 24 2f 6b 10 f0 	movl   $0xf0106b2f,(%esp)
+f01007dc:	e8 ac 41 00 00       	call   f010498d <cprintf>
+		outb(0x92, 0x3); // courtesy of Chris Frost
+f01007e1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+f01007e8:	00 
+f01007e9:	c7 04 24 92 00 00 00 	movl   $0x92,(%esp)
+f01007f0:	e8 82 f9 ff ff       	call   f0100177 <outb>
+	}
+
+	return c;
+f01007f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+f01007f8:	c9                   	leave  
+f01007f9:	c3                   	ret    
+
+f01007fa <kbd_intr>:
+
+void
+kbd_intr(void)
+{
+f01007fa:	55                   	push   %ebp
+f01007fb:	89 e5                	mov    %esp,%ebp
+f01007fd:	83 ec 18             	sub    $0x18,%esp
+	cons_intr(kbd_proc_data);
+f0100800:	c7 04 24 67 06 10 f0 	movl   $0xf0100667,(%esp)
+f0100807:	e8 07 00 00 00       	call   f0100813 <cons_intr>
+}
+f010080c:	c9                   	leave  
+f010080d:	c3                   	ret    
+
+f010080e <kbd_init>:
+
+static void
+kbd_init(void)
+{
+f010080e:	55                   	push   %ebp
+f010080f:	89 e5                	mov    %esp,%ebp
+}
+f0100811:	5d                   	pop    %ebp
+f0100812:	c3                   	ret    
+
+f0100813 <cons_intr>:
+
+// called by device interrupt routines to feed input characters
+// into the circular console input buffer.
+static void
+cons_intr(int (*proc)(void))
+{
+f0100813:	55                   	push   %ebp
+f0100814:	89 e5                	mov    %esp,%ebp
+f0100816:	83 ec 18             	sub    $0x18,%esp
+	int c;
+
+	while ((c = (*proc)()) != -1) {
+f0100819:	eb 35                	jmp    f0100850 <cons_intr+0x3d>
+		if (c == 0)
+f010081b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f010081f:	75 02                	jne    f0100823 <cons_intr+0x10>
+			continue;
+f0100821:	eb 2d                	jmp    f0100850 <cons_intr+0x3d>
+		cons.buf[cons.wpos++] = c;
+f0100823:	a1 04 eb 18 f0       	mov    0xf018eb04,%eax
+f0100828:	8d 50 01             	lea    0x1(%eax),%edx
+f010082b:	89 15 04 eb 18 f0    	mov    %edx,0xf018eb04
+f0100831:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0100834:	88 90 00 e9 18 f0    	mov    %dl,-0xfe71700(%eax)
+		if (cons.wpos == CONSBUFSIZE)
+f010083a:	a1 04 eb 18 f0       	mov    0xf018eb04,%eax
+f010083f:	3d 00 02 00 00       	cmp    $0x200,%eax
+f0100844:	75 0a                	jne    f0100850 <cons_intr+0x3d>
+			cons.wpos = 0;
+f0100846:	c7 05 04 eb 18 f0 00 	movl   $0x0,0xf018eb04
+f010084d:	00 00 00 
+static void
+cons_intr(int (*proc)(void))
+{
+	int c;
+
+	while ((c = (*proc)()) != -1) {
+f0100850:	8b 45 08             	mov    0x8(%ebp),%eax
+f0100853:	ff d0                	call   *%eax
+f0100855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0100858:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+f010085c:	75 bd                	jne    f010081b <cons_intr+0x8>
+			continue;
+		cons.buf[cons.wpos++] = c;
+		if (cons.wpos == CONSBUFSIZE)
+			cons.wpos = 0;
+	}
+}
+f010085e:	c9                   	leave  
+f010085f:	c3                   	ret    
+
+f0100860 <cons_getc>:
+
+// return the next input character from the console, or 0 if none waiting
+int
+cons_getc(void)
+{
+f0100860:	55                   	push   %ebp
+f0100861:	89 e5                	mov    %esp,%ebp
+f0100863:	83 ec 18             	sub    $0x18,%esp
+	int c;
+
+	// poll for any pending input characters,
+	// so that this function works even when interrupts are disabled
+	// (e.g., when called from the kernel monitor).
+	serial_intr();
+f0100866:	e8 8e f9 ff ff       	call   f01001f9 <serial_intr>
+	kbd_intr();
+f010086b:	e8 8a ff ff ff       	call   f01007fa <kbd_intr>
+
+	// grab the next character from the input buffer.
+	if (cons.rpos != cons.wpos) {
+f0100870:	8b 15 00 eb 18 f0    	mov    0xf018eb00,%edx
+f0100876:	a1 04 eb 18 f0       	mov    0xf018eb04,%eax
+f010087b:	39 c2                	cmp    %eax,%edx
+f010087d:	74 36                	je     f01008b5 <cons_getc+0x55>
+		c = cons.buf[cons.rpos++];
+f010087f:	a1 00 eb 18 f0       	mov    0xf018eb00,%eax
+f0100884:	8d 50 01             	lea    0x1(%eax),%edx
+f0100887:	89 15 00 eb 18 f0    	mov    %edx,0xf018eb00
+f010088d:	0f b6 80 00 e9 18 f0 	movzbl -0xfe71700(%eax),%eax
+f0100894:	0f b6 c0             	movzbl %al,%eax
+f0100897:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		if (cons.rpos == CONSBUFSIZE)
+f010089a:	a1 00 eb 18 f0       	mov    0xf018eb00,%eax
+f010089f:	3d 00 02 00 00       	cmp    $0x200,%eax
+f01008a4:	75 0a                	jne    f01008b0 <cons_getc+0x50>
+			cons.rpos = 0;
+f01008a6:	c7 05 00 eb 18 f0 00 	movl   $0x0,0xf018eb00
+f01008ad:	00 00 00 
+		return c;
+f01008b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01008b3:	eb 05                	jmp    f01008ba <cons_getc+0x5a>
+	}
+	return 0;
+f01008b5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f01008ba:	c9                   	leave  
+f01008bb:	c3                   	ret    
+
+f01008bc <cons_putc>:
+
+// output a character to the console
+static void
+cons_putc(int c)
+{
+f01008bc:	55                   	push   %ebp
+f01008bd:	89 e5                	mov    %esp,%ebp
+f01008bf:	83 ec 18             	sub    $0x18,%esp
+	serial_putc(c);
+f01008c2:	8b 45 08             	mov    0x8(%ebp),%eax
+f01008c5:	89 04 24             	mov    %eax,(%esp)
+f01008c8:	e8 4b f9 ff ff       	call   f0100218 <serial_putc>
+	lpt_putc(c);
+f01008cd:	8b 45 08             	mov    0x8(%ebp),%eax
+f01008d0:	89 04 24             	mov    %eax,(%esp)
+f01008d3:	e8 51 fa ff ff       	call   f0100329 <lpt_putc>
+	cga_putc(c);
+f01008d8:	8b 45 08             	mov    0x8(%ebp),%eax
+f01008db:	89 04 24             	mov    %eax,(%esp)
+f01008de:	e8 75 fb ff ff       	call   f0100458 <cga_putc>
+}
+f01008e3:	c9                   	leave  
+f01008e4:	c3                   	ret    
+
+f01008e5 <cons_init>:
+
+// initialize the console devices
+void
+cons_init(void)
+{
+f01008e5:	55                   	push   %ebp
+f01008e6:	89 e5                	mov    %esp,%ebp
+f01008e8:	83 ec 18             	sub    $0x18,%esp
+	cga_init();
+f01008eb:	e8 aa fa ff ff       	call   f010039a <cga_init>
+	kbd_init();
+f01008f0:	e8 19 ff ff ff       	call   f010080e <kbd_init>
+	serial_init();
+f01008f5:	e8 6d f9 ff ff       	call   f0100267 <serial_init>
+
+	if (!serial_exists)
+f01008fa:	0f b6 05 e0 e8 18 f0 	movzbl 0xf018e8e0,%eax
+f0100901:	83 f0 01             	xor    $0x1,%eax
+f0100904:	84 c0                	test   %al,%al
+f0100906:	74 0c                	je     f0100914 <cons_init+0x2f>
+		cprintf("Serial port does not exist!\n");
+f0100908:	c7 04 24 3b 6b 10 f0 	movl   $0xf0106b3b,(%esp)
+f010090f:	e8 79 40 00 00       	call   f010498d <cprintf>
+}
+f0100914:	c9                   	leave  
+f0100915:	c3                   	ret    
+
+f0100916 <cputchar>:
+
+// `High'-level console I/O.  Used by readline and cprintf.
+
+void
+cputchar(int c)
+{
+f0100916:	55                   	push   %ebp
+f0100917:	89 e5                	mov    %esp,%ebp
+f0100919:	83 ec 18             	sub    $0x18,%esp
+	cons_putc(c);
+f010091c:	8b 45 08             	mov    0x8(%ebp),%eax
+f010091f:	89 04 24             	mov    %eax,(%esp)
+f0100922:	e8 95 ff ff ff       	call   f01008bc <cons_putc>
+}
+f0100927:	c9                   	leave  
+f0100928:	c3                   	ret    
+
+f0100929 <getchar>:
+
+int
+getchar(void)
+{
+f0100929:	55                   	push   %ebp
+f010092a:	89 e5                	mov    %esp,%ebp
+f010092c:	83 ec 18             	sub    $0x18,%esp
+	int c;
+
+	while ((c = cons_getc()) == 0)
+f010092f:	e8 2c ff ff ff       	call   f0100860 <cons_getc>
+f0100934:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0100937:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f010093b:	74 f2                	je     f010092f <getchar+0x6>
+		/* do nothing */;
+	return c;
+f010093d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+f0100940:	c9                   	leave  
+f0100941:	c3                   	ret    
+
+f0100942 <iscons>:
+
+int
+iscons(int fdnum)
+{
+f0100942:	55                   	push   %ebp
+f0100943:	89 e5                	mov    %esp,%ebp
+	// used by readline
+	return 1;
+f0100945:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+f010094a:	5d                   	pop    %ebp
+f010094b:	c3                   	ret    
+
+f010094c <read_ebp>:
+	asm volatile("pushl %0; popfl" : : "r" (eflags));
+}
+
+static inline uint32_t
+read_ebp(void)
+{
+f010094c:	55                   	push   %ebp
+f010094d:	89 e5                	mov    %esp,%ebp
+f010094f:	83 ec 10             	sub    $0x10,%esp
+	uint32_t ebp;
+	asm volatile("movl %%ebp,%0" : "=r" (ebp));
+f0100952:	89 e8                	mov    %ebp,%eax
+f0100954:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	return ebp;
+f0100957:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f010095a:	c9                   	leave  
+f010095b:	c3                   	ret    
+
+f010095c <_kaddr>:
+ * virtual address.  It panics if you pass an invalid physical address. */
+#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)
+
+static inline void*
+_kaddr(const char *file, int line, physaddr_t pa)
+{
+f010095c:	55                   	push   %ebp
+f010095d:	89 e5                	mov    %esp,%ebp
+f010095f:	83 ec 18             	sub    $0x18,%esp
+	if (PGNUM(pa) >= npages)
+f0100962:	8b 45 10             	mov    0x10(%ebp),%eax
+f0100965:	c1 e8 0c             	shr    $0xc,%eax
+f0100968:	89 c2                	mov    %eax,%edx
+f010096a:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f010096f:	39 c2                	cmp    %eax,%edx
+f0100971:	72 21                	jb     f0100994 <_kaddr+0x38>
+		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
+f0100973:	8b 45 10             	mov    0x10(%ebp),%eax
+f0100976:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f010097a:	c7 44 24 08 58 6b 10 	movl   $0xf0106b58,0x8(%esp)
+f0100981:	f0 
+f0100982:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100985:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100989:	8b 45 08             	mov    0x8(%ebp),%eax
+f010098c:	89 04 24             	mov    %eax,(%esp)
+f010098f:	e8 21 f7 ff ff       	call   f01000b5 <_panic>
+	return (void *)(pa + KERNBASE);
+f0100994:	8b 45 10             	mov    0x10(%ebp),%eax
+f0100997:	2d 00 00 00 10       	sub    $0x10000000,%eax
+}
+f010099c:	c9                   	leave  
+f010099d:	c3                   	ret    
+
+f010099e <page2pa>:
+int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
+void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);
+
+static inline physaddr_t
+page2pa(struct PageInfo *pp)
+{
+f010099e:	55                   	push   %ebp
+f010099f:	89 e5                	mov    %esp,%ebp
+	return (pp - pages) << PGSHIFT;
+f01009a1:	8b 55 08             	mov    0x8(%ebp),%edx
+f01009a4:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01009a9:	29 c2                	sub    %eax,%edx
+f01009ab:	89 d0                	mov    %edx,%eax
+f01009ad:	c1 f8 03             	sar    $0x3,%eax
+f01009b0:	c1 e0 0c             	shl    $0xc,%eax
+}
+f01009b3:	5d                   	pop    %ebp
+f01009b4:	c3                   	ret    
+
+f01009b5 <mon_help>:
+
+/***** Implementations of basic kernel monitor commands *****/
+
+    int
+mon_help(int argc, char **argv, struct Trapframe *tf)
+{
+f01009b5:	55                   	push   %ebp
+f01009b6:	89 e5                	mov    %esp,%ebp
+f01009b8:	83 ec 28             	sub    $0x28,%esp
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(commands); i++)
+f01009bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f01009c2:	eb 3f                	jmp    f0100a03 <mon_help+0x4e>
+	cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+f01009c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01009c7:	89 d0                	mov    %edx,%eax
+f01009c9:	01 c0                	add    %eax,%eax
+f01009cb:	01 d0                	add    %edx,%eax
+f01009cd:	c1 e0 02             	shl    $0x2,%eax
+f01009d0:	05 20 f5 11 f0       	add    $0xf011f520,%eax
+f01009d5:	8b 48 04             	mov    0x4(%eax),%ecx
+f01009d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01009db:	89 d0                	mov    %edx,%eax
+f01009dd:	01 c0                	add    %eax,%eax
+f01009df:	01 d0                	add    %edx,%eax
+f01009e1:	c1 e0 02             	shl    $0x2,%eax
+f01009e4:	05 20 f5 11 f0       	add    $0xf011f520,%eax
+f01009e9:	8b 00                	mov    (%eax),%eax
+f01009eb:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+f01009ef:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01009f3:	c7 04 24 a1 6c 10 f0 	movl   $0xf0106ca1,(%esp)
+f01009fa:	e8 8e 3f 00 00       	call   f010498d <cprintf>
+    int
+mon_help(int argc, char **argv, struct Trapframe *tf)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(commands); i++)
+f01009ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f0100a03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100a06:	83 f8 07             	cmp    $0x7,%eax
+f0100a09:	76 b9                	jbe    f01009c4 <mon_help+0xf>
+	cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    return 0;
+f0100a0b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0100a10:	c9                   	leave  
+f0100a11:	c3                   	ret    
+
+f0100a12 <mon_kerninfo>:
+
+    int
+mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
+{
+f0100a12:	55                   	push   %ebp
+f0100a13:	89 e5                	mov    %esp,%ebp
+f0100a15:	83 ec 28             	sub    $0x28,%esp
+    extern char _start[], entry[], etext[], edata[], end[];
+
+    cprintf("Special kernel symbols:\n");
+f0100a18:	c7 04 24 aa 6c 10 f0 	movl   $0xf0106caa,(%esp)
+f0100a1f:	e8 69 3f 00 00       	call   f010498d <cprintf>
+    cprintf("  _start                  %08x (phys)\n", _start);
+f0100a24:	c7 44 24 04 0c 00 10 	movl   $0x10000c,0x4(%esp)
+f0100a2b:	00 
+f0100a2c:	c7 04 24 c4 6c 10 f0 	movl   $0xf0106cc4,(%esp)
+f0100a33:	e8 55 3f 00 00       	call   f010498d <cprintf>
+    cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+f0100a38:	c7 44 24 08 0c 00 10 	movl   $0x10000c,0x8(%esp)
+f0100a3f:	00 
+f0100a40:	c7 44 24 04 0c 00 10 	movl   $0xf010000c,0x4(%esp)
+f0100a47:	f0 
+f0100a48:	c7 04 24 ec 6c 10 f0 	movl   $0xf0106cec,(%esp)
+f0100a4f:	e8 39 3f 00 00       	call   f010498d <cprintf>
+    cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+f0100a54:	c7 44 24 08 c7 6a 10 	movl   $0x106ac7,0x8(%esp)
+f0100a5b:	00 
+f0100a5c:	c7 44 24 04 c7 6a 10 	movl   $0xf0106ac7,0x4(%esp)
+f0100a63:	f0 
+f0100a64:	c7 04 24 10 6d 10 f0 	movl   $0xf0106d10,(%esp)
+f0100a6b:	e8 1d 3f 00 00       	call   f010498d <cprintf>
+    cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+f0100a70:	c7 44 24 08 d2 e8 18 	movl   $0x18e8d2,0x8(%esp)
+f0100a77:	00 
+f0100a78:	c7 44 24 04 d2 e8 18 	movl   $0xf018e8d2,0x4(%esp)
+f0100a7f:	f0 
+f0100a80:	c7 04 24 34 6d 10 f0 	movl   $0xf0106d34,(%esp)
+f0100a87:	e8 01 3f 00 00       	call   f010498d <cprintf>
+    cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+f0100a8c:	c7 44 24 08 dc f7 18 	movl   $0x18f7dc,0x8(%esp)
+f0100a93:	00 
+f0100a94:	c7 44 24 04 dc f7 18 	movl   $0xf018f7dc,0x4(%esp)
+f0100a9b:	f0 
+f0100a9c:	c7 04 24 58 6d 10 f0 	movl   $0xf0106d58,(%esp)
+f0100aa3:	e8 e5 3e 00 00       	call   f010498d <cprintf>
+    cprintf("Kernel executable memory footprint: %dKB\n",
+	    ROUNDUP(end - entry, 1024) / 1024);
+f0100aa8:	c7 45 f4 00 04 00 00 	movl   $0x400,-0xc(%ebp)
+f0100aaf:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
+f0100ab4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0100ab7:	29 c2                	sub    %eax,%edx
+f0100ab9:	b8 dc f7 18 f0       	mov    $0xf018f7dc,%eax
+f0100abe:	83 e8 01             	sub    $0x1,%eax
+f0100ac1:	01 d0                	add    %edx,%eax
+f0100ac3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0100ac6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0100ac9:	ba 00 00 00 00       	mov    $0x0,%edx
+f0100ace:	f7 75 f4             	divl   -0xc(%ebp)
+f0100ad1:	89 d0                	mov    %edx,%eax
+f0100ad3:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0100ad6:	29 c2                	sub    %eax,%edx
+f0100ad8:	89 d0                	mov    %edx,%eax
+    cprintf("  _start                  %08x (phys)\n", _start);
+    cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+    cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+    cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+    cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+    cprintf("Kernel executable memory footprint: %dKB\n",
+f0100ada:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+f0100ae0:	85 c0                	test   %eax,%eax
+f0100ae2:	0f 48 c2             	cmovs  %edx,%eax
+f0100ae5:	c1 f8 0a             	sar    $0xa,%eax
+f0100ae8:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100aec:	c7 04 24 7c 6d 10 f0 	movl   $0xf0106d7c,(%esp)
+f0100af3:	e8 95 3e 00 00       	call   f010498d <cprintf>
+	    ROUNDUP(end - entry, 1024) / 1024);
+    return 0;
+f0100af8:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0100afd:	c9                   	leave  
+f0100afe:	c3                   	ret    
+
+f0100aff <mon_backtrace>:
+
+    int
+mon_backtrace(int argc, char **argv, struct Trapframe *tf)
+{
+f0100aff:	55                   	push   %ebp
+f0100b00:	89 e5                	mov    %esp,%ebp
+f0100b02:	56                   	push   %esi
+f0100b03:	53                   	push   %ebx
+f0100b04:	83 ec 60             	sub    $0x60,%esp
+    int *ebp, eip, *old_ebp;
+    int ary[5]={};
+f0100b07:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
+f0100b0e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+f0100b15:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
+f0100b1c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+f0100b23:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+
+    cprintf("Stack backtrace:\n");
+f0100b2a:	c7 04 24 a6 6d 10 f0 	movl   $0xf0106da6,(%esp)
+f0100b31:	e8 57 3e 00 00       	call   f010498d <cprintf>
+
+    ebp=(int *)read_ebp();
+f0100b36:	e8 11 fe ff ff       	call   f010094c <read_ebp>
+f0100b3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    while((int)ebp!=0)
+f0100b3e:	e9 dc 00 00 00       	jmp    f0100c1f <mon_backtrace+0x120>
+    {
+	old_ebp=(int *)*(ebp);
+f0100b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100b46:	8b 00                	mov    (%eax),%eax
+f0100b48:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	eip=*(ebp+1);
+f0100b4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100b4e:	8b 40 04             	mov    0x4(%eax),%eax
+f0100b51:	89 45 e8             	mov    %eax,-0x18(%ebp)
+	for(int i=0;i<5;++i)
+f0100b54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+f0100b5b:	eb 25                	jmp    f0100b82 <mon_backtrace+0x83>
+	{
+	    int j=i+2;
+f0100b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0100b60:	83 c0 02             	add    $0x2,%eax
+f0100b63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+	    ary[i]=*(ebp+j);
+f0100b66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0100b69:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0100b70:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100b73:	01 d0                	add    %edx,%eax
+f0100b75:	8b 10                	mov    (%eax),%edx
+f0100b77:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0100b7a:	89 54 85 d0          	mov    %edx,-0x30(%ebp,%eax,4)
+    ebp=(int *)read_ebp();
+    while((int)ebp!=0)
+    {
+	old_ebp=(int *)*(ebp);
+	eip=*(ebp+1);
+	for(int i=0;i<5;++i)
+f0100b7e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+f0100b82:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+f0100b86:	7e d5                	jle    f0100b5d <mon_backtrace+0x5e>
+	{
+	    int j=i+2;
+	    ary[i]=*(ebp+j);
+	}
+	struct Eipdebuginfo eip_info;
+	debuginfo_eip((uintptr_t)eip, &eip_info);
+f0100b88:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0100b8b:	8d 55 b8             	lea    -0x48(%ebp),%edx
+f0100b8e:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0100b92:	89 04 24             	mov    %eax,(%esp)
+f0100b95:	e8 4f 4a 00 00       	call   f01055e9 <debuginfo_eip>
+	cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
+f0100b9a:	8b 75 e0             	mov    -0x20(%ebp),%esi
+f0100b9d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
+f0100ba0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
+f0100ba3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+f0100ba6:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f0100ba9:	89 74 24 1c          	mov    %esi,0x1c(%esp)
+f0100bad:	89 5c 24 18          	mov    %ebx,0x18(%esp)
+f0100bb1:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+f0100bb5:	89 54 24 10          	mov    %edx,0x10(%esp)
+f0100bb9:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0100bbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0100bc0:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0100bc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100bc7:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100bcb:	c7 04 24 b8 6d 10 f0 	movl   $0xf0106db8,(%esp)
+f0100bd2:	e8 b6 3d 00 00       	call   f010498d <cprintf>
+	cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
+f0100bd7:	8b 55 bc             	mov    -0x44(%ebp),%edx
+f0100bda:	8b 45 b8             	mov    -0x48(%ebp),%eax
+f0100bdd:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0100be1:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100be5:	c7 04 24 ed 6d 10 f0 	movl   $0xf0106ded,(%esp)
+f0100bec:	e8 9c 3d 00 00       	call   f010498d <cprintf>
+	cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
+f0100bf1:	8b 55 e8             	mov    -0x18(%ebp),%edx
+f0100bf4:	8b 45 c8             	mov    -0x38(%ebp),%eax
+f0100bf7:	89 d1                	mov    %edx,%ecx
+f0100bf9:	29 c1                	sub    %eax,%ecx
+f0100bfb:	8b 55 c0             	mov    -0x40(%ebp),%edx
+f0100bfe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+f0100c01:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f0100c05:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0100c09:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100c0d:	c7 04 24 f9 6d 10 f0 	movl   $0xf0106df9,(%esp)
+f0100c14:	e8 74 3d 00 00       	call   f010498d <cprintf>
+	ebp=old_ebp;
+f0100c19:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100c1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    int ary[5]={};
+
+    cprintf("Stack backtrace:\n");
+
+    ebp=(int *)read_ebp();
+    while((int)ebp!=0)
+f0100c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100c22:	85 c0                	test   %eax,%eax
+f0100c24:	0f 85 19 ff ff ff    	jne    f0100b43 <mon_backtrace+0x44>
+	cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
+	cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
+	ebp=old_ebp;
+    }
+
+    return 0;
+f0100c2a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0100c2f:	83 c4 60             	add    $0x60,%esp
+f0100c32:	5b                   	pop    %ebx
+f0100c33:	5e                   	pop    %esi
+f0100c34:	5d                   	pop    %ebp
+f0100c35:	c3                   	ret    
+
+f0100c36 <mon_pgmap>:
+
+
+
+    int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf)
+{
+f0100c36:	55                   	push   %ebp
+f0100c37:	89 e5                	mov    %esp,%ebp
+f0100c39:	53                   	push   %ebx
+f0100c3a:	83 ec 44             	sub    $0x44,%esp
+    uintptr_t va1, va2, va;
+    struct PageInfo *pg;
+    pte_t *pte;
+    if (argc != 3) {
+f0100c3d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
+f0100c41:	74 16                	je     f0100c59 <mon_pgmap+0x23>
+	cprintf("Usage: pgmap va1 va2\n Display physical memory mapping from virtual memory va1 to va2\nva1 and va2 are hex\n");
+f0100c43:	c7 04 24 08 6e 10 f0 	movl   $0xf0106e08,(%esp)
+f0100c4a:	e8 3e 3d 00 00       	call   f010498d <cprintf>
+	return 0;
+f0100c4f:	b8 00 00 00 00       	mov    $0x0,%eax
+f0100c54:	e9 73 01 00 00       	jmp    f0100dcc <mon_pgmap+0x196>
+    }
+    else {
+	for (va1 = strtol(argv[1], 0, 16), va2 = strtol(argv[2], 0, 16); va1 < va2; va1 += PGSIZE) {
+f0100c59:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100c5c:	83 c0 04             	add    $0x4,%eax
+f0100c5f:	8b 00                	mov    (%eax),%eax
+f0100c61:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f0100c68:	00 
+f0100c69:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100c70:	00 
+f0100c71:	89 04 24             	mov    %eax,(%esp)
+f0100c74:	e8 5d 5a 00 00       	call   f01066d6 <strtol>
+f0100c79:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0100c7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100c7f:	83 c0 08             	add    $0x8,%eax
+f0100c82:	8b 00                	mov    (%eax),%eax
+f0100c84:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f0100c8b:	00 
+f0100c8c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100c93:	00 
+f0100c94:	89 04 24             	mov    %eax,(%esp)
+f0100c97:	e8 3a 5a 00 00       	call   f01066d6 <strtol>
+f0100c9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0100c9f:	e9 17 01 00 00       	jmp    f0100dbb <mon_pgmap+0x185>
+	    va = va1 & ~0xfff;
+f0100ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100ca7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0100cac:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	    pg = page_lookup(kern_pgdir, (void*)va, 0);
+f0100caf:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0100cb2:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0100cb7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0100cbe:	00 
+f0100cbf:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0100cc3:	89 04 24             	mov    %eax,(%esp)
+f0100cc6:	e8 9d 0e 00 00       	call   f0101b68 <page_lookup>
+f0100ccb:	89 45 e8             	mov    %eax,-0x18(%ebp)
+	    pte = pgdir_walk(kern_pgdir, (void* )va,0);
+f0100cce:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0100cd1:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0100cd6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0100cdd:	00 
+f0100cde:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0100ce2:	89 04 24             	mov    %eax,(%esp)
+f0100ce5:	e8 95 0c 00 00       	call   f010197f <pgdir_walk>
+f0100cea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+	    if (pg){
+f0100ced:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f0100cf1:	0f 84 92 00 00 00    	je     f0100d89 <mon_pgmap+0x153>
+		cprintf("[%x, %x) ---> [%x, %x)    ", va, va + PGSIZE, page2pa(pg), page2pa(pg) + PGSIZE);
+f0100cf7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0100cfa:	89 04 24             	mov    %eax,(%esp)
+f0100cfd:	e8 9c fc ff ff       	call   f010099e <page2pa>
+f0100d02:	8d 98 00 10 00 00    	lea    0x1000(%eax),%ebx
+f0100d08:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0100d0b:	89 04 24             	mov    %eax,(%esp)
+f0100d0e:	e8 8b fc ff ff       	call   f010099e <page2pa>
+f0100d13:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0100d16:	81 c2 00 10 00 00    	add    $0x1000,%edx
+f0100d1c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
+f0100d20:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0100d24:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0100d28:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100d2b:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100d2f:	c7 04 24 72 6e 10 f0 	movl   $0xf0106e72,(%esp)
+f0100d36:	e8 52 3c 00 00       	call   f010498d <cprintf>
+		if(*pte & PTE_U)
+f0100d3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0100d3e:	8b 00                	mov    (%eax),%eax
+f0100d40:	83 e0 04             	and    $0x4,%eax
+f0100d43:	85 c0                	test   %eax,%eax
+f0100d45:	74 0e                	je     f0100d55 <mon_pgmap+0x11f>
+		    cprintf("user: ");
+f0100d47:	c7 04 24 8d 6e 10 f0 	movl   $0xf0106e8d,(%esp)
+f0100d4e:	e8 3a 3c 00 00       	call   f010498d <cprintf>
+f0100d53:	eb 0c                	jmp    f0100d61 <mon_pgmap+0x12b>
+		else 
+		    cprintf("kernel: ");
+f0100d55:	c7 04 24 94 6e 10 f0 	movl   $0xf0106e94,(%esp)
+f0100d5c:	e8 2c 3c 00 00       	call   f010498d <cprintf>
+
+		if(*pte &PTE_W)
+f0100d61:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0100d64:	8b 00                	mov    (%eax),%eax
+f0100d66:	83 e0 02             	and    $0x2,%eax
+f0100d69:	85 c0                	test   %eax,%eax
+f0100d6b:	74 0e                	je     f0100d7b <mon_pgmap+0x145>
+		    cprintf("read/write ");
+f0100d6d:	c7 04 24 9d 6e 10 f0 	movl   $0xf0106e9d,(%esp)
+f0100d74:	e8 14 3c 00 00       	call   f010498d <cprintf>
+f0100d79:	eb 2d                	jmp    f0100da8 <mon_pgmap+0x172>
+		else 
+		    cprintf("read only ");
+f0100d7b:	c7 04 24 a9 6e 10 f0 	movl   $0xf0106ea9,(%esp)
+f0100d82:	e8 06 3c 00 00       	call   f010498d <cprintf>
+f0100d87:	eb 1f                	jmp    f0100da8 <mon_pgmap+0x172>
+	    }else
+		cprintf("[%x, %x) ---> NULL    ", va, va + PGSIZE);
+f0100d89:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100d8c:	05 00 10 00 00       	add    $0x1000,%eax
+f0100d91:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0100d95:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100d98:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100d9c:	c7 04 24 b4 6e 10 f0 	movl   $0xf0106eb4,(%esp)
+f0100da3:	e8 e5 3b 00 00       	call   f010498d <cprintf>
+
+	    cprintf("\n");                                                                                       
+f0100da8:	c7 04 24 cb 6e 10 f0 	movl   $0xf0106ecb,(%esp)
+f0100daf:	e8 d9 3b 00 00       	call   f010498d <cprintf>
+    if (argc != 3) {
+	cprintf("Usage: pgmap va1 va2\n Display physical memory mapping from virtual memory va1 to va2\nva1 and va2 are hex\n");
+	return 0;
+    }
+    else {
+	for (va1 = strtol(argv[1], 0, 16), va2 = strtol(argv[2], 0, 16); va1 < va2; va1 += PGSIZE) {
+f0100db4:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f0100dbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100dbe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+f0100dc1:	0f 82 dd fe ff ff    	jb     f0100ca4 <mon_pgmap+0x6e>
+		cprintf("[%x, %x) ---> NULL    ", va, va + PGSIZE);
+
+	    cprintf("\n");                                                                                       
+	}
+    }
+    return 0;
+f0100dc7:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0100dcc:	83 c4 44             	add    $0x44,%esp
+f0100dcf:	5b                   	pop    %ebx
+f0100dd0:	5d                   	pop    %ebp
+f0100dd1:	c3                   	ret    
+
+f0100dd2 <mon_pgperm>:
+
+
+    int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf)
+{
+f0100dd2:	55                   	push   %ebp
+f0100dd3:	89 e5                	mov    %esp,%ebp
+f0100dd5:	83 ec 28             	sub    $0x28,%esp
+    uintptr_t va, perm;
+    if (argc != 4) {
+f0100dd8:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
+f0100ddc:	74 16                	je     f0100df4 <mon_pgperm+0x22>
+	cprintf("Usage: pgperm +/-/= perm va\nset perm of page which contains va, va is hex\n");
+f0100dde:	c7 04 24 d0 6e 10 f0 	movl   $0xf0106ed0,(%esp)
+f0100de5:	e8 a3 3b 00 00       	call   f010498d <cprintf>
+	return 0;
+f0100dea:	b8 00 00 00 00       	mov    $0x0,%eax
+f0100def:	e9 e6 00 00 00       	jmp    f0100eda <mon_pgperm+0x108>
+    }
+    else {
+	va = strtol(argv[3], 0, 16);
+f0100df4:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100df7:	83 c0 0c             	add    $0xc,%eax
+f0100dfa:	8b 00                	mov    (%eax),%eax
+f0100dfc:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f0100e03:	00 
+f0100e04:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100e0b:	00 
+f0100e0c:	89 04 24             	mov    %eax,(%esp)
+f0100e0f:	e8 c2 58 00 00       	call   f01066d6 <strtol>
+f0100e14:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	perm = strtol(argv[2], 0, 16);
+f0100e17:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100e1a:	83 c0 08             	add    $0x8,%eax
+f0100e1d:	8b 00                	mov    (%eax),%eax
+f0100e1f:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f0100e26:	00 
+f0100e27:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100e2e:	00 
+f0100e2f:	89 04 24             	mov    %eax,(%esp)
+f0100e32:	e8 9f 58 00 00       	call   f01066d6 <strtol>
+f0100e37:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	pte_t *pte = pgdir_walk(kern_pgdir, (void*)va, 0);
+f0100e3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0100e3d:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0100e42:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0100e49:	00 
+f0100e4a:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0100e4e:	89 04 24             	mov    %eax,(%esp)
+f0100e51:	e8 29 0b 00 00       	call   f010197f <pgdir_walk>
+f0100e56:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (!pte) {
+f0100e59:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f0100e5d:	75 15                	jne    f0100e74 <mon_pgperm+0xa2>
+	    cprintf("0x%x is not mapped\n", va);
+f0100e5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100e62:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100e66:	c7 04 24 1b 6f 10 f0 	movl   $0xf0106f1b,(%esp)
+f0100e6d:	e8 1b 3b 00 00       	call   f010498d <cprintf>
+f0100e72:	eb 61                	jmp    f0100ed5 <mon_pgperm+0x103>
+	}
+	else {
+	    if (argv[1][0] == '+') *pte |= perm;
+f0100e74:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100e77:	83 c0 04             	add    $0x4,%eax
+f0100e7a:	8b 00                	mov    (%eax),%eax
+f0100e7c:	0f b6 00             	movzbl (%eax),%eax
+f0100e7f:	3c 2b                	cmp    $0x2b,%al
+f0100e81:	75 0f                	jne    f0100e92 <mon_pgperm+0xc0>
+f0100e83:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100e86:	8b 00                	mov    (%eax),%eax
+f0100e88:	0b 45 f0             	or     -0x10(%ebp),%eax
+f0100e8b:	89 c2                	mov    %eax,%edx
+f0100e8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100e90:	89 10                	mov    %edx,(%eax)
+	    if (argv[1][0] == '0') *pte &= ~perm;
+f0100e92:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100e95:	83 c0 04             	add    $0x4,%eax
+f0100e98:	8b 00                	mov    (%eax),%eax
+f0100e9a:	0f b6 00             	movzbl (%eax),%eax
+f0100e9d:	3c 30                	cmp    $0x30,%al
+f0100e9f:	75 11                	jne    f0100eb2 <mon_pgperm+0xe0>
+f0100ea1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100ea4:	8b 00                	mov    (%eax),%eax
+f0100ea6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0100ea9:	f7 d2                	not    %edx
+f0100eab:	21 c2                	and    %eax,%edx
+f0100ead:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100eb0:	89 10                	mov    %edx,(%eax)
+	    if (argv[1][0] == '=') *pte = PTE_ADDR(*pte) | perm;
+f0100eb2:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100eb5:	83 c0 04             	add    $0x4,%eax
+f0100eb8:	8b 00                	mov    (%eax),%eax
+f0100eba:	0f b6 00             	movzbl (%eax),%eax
+f0100ebd:	3c 3d                	cmp    $0x3d,%al
+f0100ebf:	75 14                	jne    f0100ed5 <mon_pgperm+0x103>
+f0100ec1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100ec4:	8b 00                	mov    (%eax),%eax
+f0100ec6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0100ecb:	0b 45 f0             	or     -0x10(%ebp),%eax
+f0100ece:	89 c2                	mov    %eax,%edx
+f0100ed0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100ed3:	89 10                	mov    %edx,(%eax)
+	}
+    }
+    return 0;
+f0100ed5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0100eda:	c9                   	leave  
+f0100edb:	c3                   	ret    
+
+f0100edc <mon_memdump>:
+
+    int
+mon_memdump(int argc, char **argv, struct Trapframe *tf)
+{
+f0100edc:	55                   	push   %ebp
+f0100edd:	89 e5                	mov    %esp,%ebp
+f0100edf:	83 ec 28             	sub    $0x28,%esp
+    uintptr_t a1, a2, a;
+    struct PageInfo *pg;
+    if (argc != 4) {
+f0100ee2:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
+f0100ee6:	74 16                	je     f0100efe <mon_memdump+0x22>
+	cprintf("Usage: memdump p/v a1 a2\n Dump memory content via virtual or physical address\na1 and a2 are hex\n");
+f0100ee8:	c7 04 24 30 6f 10 f0 	movl   $0xf0106f30,(%esp)
+f0100eef:	e8 99 3a 00 00       	call   f010498d <cprintf>
+	return 0;
+f0100ef4:	b8 00 00 00 00       	mov    $0x0,%eax
+f0100ef9:	e9 f8 00 00 00       	jmp    f0100ff6 <mon_memdump+0x11a>
+    }
+    else {
+	a1 = strtol(argv[2], 0, 16), a2 = strtol(argv[3], 0, 16);
+f0100efe:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100f01:	83 c0 08             	add    $0x8,%eax
+f0100f04:	8b 00                	mov    (%eax),%eax
+f0100f06:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f0100f0d:	00 
+f0100f0e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100f15:	00 
+f0100f16:	89 04 24             	mov    %eax,(%esp)
+f0100f19:	e8 b8 57 00 00       	call   f01066d6 <strtol>
+f0100f1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0100f21:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100f24:	83 c0 0c             	add    $0xc,%eax
+f0100f27:	8b 00                	mov    (%eax),%eax
+f0100f29:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f0100f30:	00 
+f0100f31:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0100f38:	00 
+f0100f39:	89 04 24             	mov    %eax,(%esp)
+f0100f3c:	e8 95 57 00 00       	call   f01066d6 <strtol>
+f0100f41:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	if (argv[1][0] == 'p') a1 = (int)KADDR(a1), a2 = (int)KADDR(a2);
+f0100f44:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0100f47:	83 c0 04             	add    $0x4,%eax
+f0100f4a:	8b 00                	mov    (%eax),%eax
+f0100f4c:	0f b6 00             	movzbl (%eax),%eax
+f0100f4f:	3c 70                	cmp    $0x70,%al
+f0100f51:	75 3c                	jne    f0100f8f <mon_memdump+0xb3>
+f0100f53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100f56:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0100f5a:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
+f0100f61:	00 
+f0100f62:	c7 04 24 91 6f 10 f0 	movl   $0xf0106f91,(%esp)
+f0100f69:	e8 ee f9 ff ff       	call   f010095c <_kaddr>
+f0100f6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0100f71:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0100f74:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0100f78:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
+f0100f7f:	00 
+f0100f80:	c7 04 24 91 6f 10 f0 	movl   $0xf0106f91,(%esp)
+f0100f87:	e8 d0 f9 ff ff       	call   f010095c <_kaddr>
+f0100f8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	for (a = a1; a < a2 && a >= KERNBASE; a += 4) {
+f0100f8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100f92:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f0100f95:	eb 3d                	jmp    f0100fd4 <mon_memdump+0xf8>
+	    if (!((a - a1) & 0xf)) cprintf("\n%x:\t", a);
+f0100f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0100f9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0100f9d:	29 c2                	sub    %eax,%edx
+f0100f9f:	89 d0                	mov    %edx,%eax
+f0100fa1:	83 e0 0f             	and    $0xf,%eax
+f0100fa4:	85 c0                	test   %eax,%eax
+f0100fa6:	75 13                	jne    f0100fbb <mon_memdump+0xdf>
+f0100fa8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100fab:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100faf:	c7 04 24 a0 6f 10 f0 	movl   $0xf0106fa0,(%esp)
+f0100fb6:	e8 d2 39 00 00       	call   f010498d <cprintf>
+	    cprintf(" %x", *(int*)(a));
+f0100fbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100fbe:	8b 00                	mov    (%eax),%eax
+f0100fc0:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0100fc4:	c7 04 24 a6 6f 10 f0 	movl   $0xf0106fa6,(%esp)
+f0100fcb:	e8 bd 39 00 00       	call   f010498d <cprintf>
+	return 0;
+    }
+    else {
+	a1 = strtol(argv[2], 0, 16), a2 = strtol(argv[3], 0, 16);
+	if (argv[1][0] == 'p') a1 = (int)KADDR(a1), a2 = (int)KADDR(a2);
+	for (a = a1; a < a2 && a >= KERNBASE; a += 4) {
+f0100fd0:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
+f0100fd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0100fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+f0100fda:	73 09                	jae    f0100fe5 <mon_memdump+0x109>
+f0100fdc:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
+f0100fe3:	77 b2                	ja     f0100f97 <mon_memdump+0xbb>
+	    if (!((a - a1) & 0xf)) cprintf("\n%x:\t", a);
+	    cprintf(" %x", *(int*)(a));
+	}
+	cprintf("\n");
+f0100fe5:	c7 04 24 cb 6e 10 f0 	movl   $0xf0106ecb,(%esp)
+f0100fec:	e8 9c 39 00 00       	call   f010498d <cprintf>
+    }
+    return 0;
+f0100ff1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0100ff6:	c9                   	leave  
+f0100ff7:	c3                   	ret    
+
+f0100ff8 <runcmd>:
+#define WHITESPACE "\t\r\n "
+#define MAXARGS 16
+
+    static int
+runcmd(char *buf, struct Trapframe *tf)
+{
+f0100ff8:	55                   	push   %ebp
+f0100ff9:	89 e5                	mov    %esp,%ebp
+f0100ffb:	83 ec 68             	sub    $0x68,%esp
+    int argc;
+    char *argv[MAXARGS];
+    int i;
+
+    // Parse the command buffer into whitespace-separated arguments
+    argc = 0;
+f0100ffe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    argv[argc] = 0;
+f0101005:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101008:	c7 44 85 b0 00 00 00 	movl   $0x0,-0x50(%ebp,%eax,4)
+f010100f:	00 
+    while (1) {
+	// gobble whitespace
+	while (*buf && strchr(WHITESPACE, *buf))
+f0101010:	eb 0c                	jmp    f010101e <runcmd+0x26>
+	    *buf++ = 0;
+f0101012:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101015:	8d 50 01             	lea    0x1(%eax),%edx
+f0101018:	89 55 08             	mov    %edx,0x8(%ebp)
+f010101b:	c6 00 00             	movb   $0x0,(%eax)
+    // Parse the command buffer into whitespace-separated arguments
+    argc = 0;
+    argv[argc] = 0;
+    while (1) {
+	// gobble whitespace
+	while (*buf && strchr(WHITESPACE, *buf))
+f010101e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101021:	0f b6 00             	movzbl (%eax),%eax
+f0101024:	84 c0                	test   %al,%al
+f0101026:	74 1d                	je     f0101045 <runcmd+0x4d>
+f0101028:	8b 45 08             	mov    0x8(%ebp),%eax
+f010102b:	0f b6 00             	movzbl (%eax),%eax
+f010102e:	0f be c0             	movsbl %al,%eax
+f0101031:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101035:	c7 04 24 aa 6f 10 f0 	movl   $0xf0106faa,(%esp)
+f010103c:	e8 40 54 00 00       	call   f0106481 <strchr>
+f0101041:	85 c0                	test   %eax,%eax
+f0101043:	75 cd                	jne    f0101012 <runcmd+0x1a>
+	    *buf++ = 0;
+	if (*buf == 0)
+f0101045:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101048:	0f b6 00             	movzbl (%eax),%eax
+f010104b:	84 c0                	test   %al,%al
+f010104d:	75 14                	jne    f0101063 <runcmd+0x6b>
+	    break;
+f010104f:	90                   	nop
+	}
+	argv[argc++] = buf;
+	while (*buf && !strchr(WHITESPACE, *buf))
+	    buf++;
+    }
+    argv[argc] = 0;
+f0101050:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101053:	c7 44 85 b0 00 00 00 	movl   $0x0,-0x50(%ebp,%eax,4)
+f010105a:	00 
+
+    // Lookup and invoke the command
+    if (argc == 0)
+f010105b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f010105f:	75 70                	jne    f01010d1 <runcmd+0xd9>
+f0101061:	eb 67                	jmp    f01010ca <runcmd+0xd2>
+	    *buf++ = 0;
+	if (*buf == 0)
+	    break;
+
+	// save and scan past next arg
+	if (argc == MAXARGS-1) {
+f0101063:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+f0101067:	75 1e                	jne    f0101087 <runcmd+0x8f>
+	    cprintf("Too many arguments (max %d)\n", MAXARGS);
+f0101069:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+f0101070:	00 
+f0101071:	c7 04 24 af 6f 10 f0 	movl   $0xf0106faf,(%esp)
+f0101078:	e8 10 39 00 00       	call   f010498d <cprintf>
+	    return 0;
+f010107d:	b8 00 00 00 00       	mov    $0x0,%eax
+f0101082:	e9 c9 00 00 00       	jmp    f0101150 <runcmd+0x158>
+	}
+	argv[argc++] = buf;
+f0101087:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010108a:	8d 50 01             	lea    0x1(%eax),%edx
+f010108d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+f0101090:	8b 55 08             	mov    0x8(%ebp),%edx
+f0101093:	89 54 85 b0          	mov    %edx,-0x50(%ebp,%eax,4)
+	while (*buf && !strchr(WHITESPACE, *buf))
+f0101097:	eb 04                	jmp    f010109d <runcmd+0xa5>
+	    buf++;
+f0101099:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+	if (argc == MAXARGS-1) {
+	    cprintf("Too many arguments (max %d)\n", MAXARGS);
+	    return 0;
+	}
+	argv[argc++] = buf;
+	while (*buf && !strchr(WHITESPACE, *buf))
+f010109d:	8b 45 08             	mov    0x8(%ebp),%eax
+f01010a0:	0f b6 00             	movzbl (%eax),%eax
+f01010a3:	84 c0                	test   %al,%al
+f01010a5:	74 1d                	je     f01010c4 <runcmd+0xcc>
+f01010a7:	8b 45 08             	mov    0x8(%ebp),%eax
+f01010aa:	0f b6 00             	movzbl (%eax),%eax
+f01010ad:	0f be c0             	movsbl %al,%eax
+f01010b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01010b4:	c7 04 24 aa 6f 10 f0 	movl   $0xf0106faa,(%esp)
+f01010bb:	e8 c1 53 00 00       	call   f0106481 <strchr>
+f01010c0:	85 c0                	test   %eax,%eax
+f01010c2:	74 d5                	je     f0101099 <runcmd+0xa1>
+	    buf++;
+    }
+f01010c4:	90                   	nop
+    // Parse the command buffer into whitespace-separated arguments
+    argc = 0;
+    argv[argc] = 0;
+    while (1) {
+	// gobble whitespace
+	while (*buf && strchr(WHITESPACE, *buf))
+f01010c5:	e9 54 ff ff ff       	jmp    f010101e <runcmd+0x26>
+    }
+    argv[argc] = 0;
+
+    // Lookup and invoke the command
+    if (argc == 0)
+	return 0;
+f01010ca:	b8 00 00 00 00       	mov    $0x0,%eax
+f01010cf:	eb 7f                	jmp    f0101150 <runcmd+0x158>
+    for (i = 0; i < ARRAY_SIZE(commands); i++) {
+f01010d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+f01010d8:	eb 56                	jmp    f0101130 <runcmd+0x138>
+	if (strcmp(argv[0], commands[i].name) == 0)
+f01010da:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01010dd:	89 d0                	mov    %edx,%eax
+f01010df:	01 c0                	add    %eax,%eax
+f01010e1:	01 d0                	add    %edx,%eax
+f01010e3:	c1 e0 02             	shl    $0x2,%eax
+f01010e6:	05 20 f5 11 f0       	add    $0xf011f520,%eax
+f01010eb:	8b 10                	mov    (%eax),%edx
+f01010ed:	8b 45 b0             	mov    -0x50(%ebp),%eax
+f01010f0:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01010f4:	89 04 24             	mov    %eax,(%esp)
+f01010f7:	e8 f0 52 00 00       	call   f01063ec <strcmp>
+f01010fc:	85 c0                	test   %eax,%eax
+f01010fe:	75 2c                	jne    f010112c <runcmd+0x134>
+	    return commands[i].func(argc, argv, tf);
+f0101100:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0101103:	89 d0                	mov    %edx,%eax
+f0101105:	01 c0                	add    %eax,%eax
+f0101107:	01 d0                	add    %edx,%eax
+f0101109:	c1 e0 02             	shl    $0x2,%eax
+f010110c:	05 20 f5 11 f0       	add    $0xf011f520,%eax
+f0101111:	8b 40 08             	mov    0x8(%eax),%eax
+f0101114:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0101117:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010111b:	8d 55 b0             	lea    -0x50(%ebp),%edx
+f010111e:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0101122:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101125:	89 14 24             	mov    %edx,(%esp)
+f0101128:	ff d0                	call   *%eax
+f010112a:	eb 24                	jmp    f0101150 <runcmd+0x158>
+    argv[argc] = 0;
+
+    // Lookup and invoke the command
+    if (argc == 0)
+	return 0;
+    for (i = 0; i < ARRAY_SIZE(commands); i++) {
+f010112c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+f0101130:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0101133:	83 f8 07             	cmp    $0x7,%eax
+f0101136:	76 a2                	jbe    f01010da <runcmd+0xe2>
+	if (strcmp(argv[0], commands[i].name) == 0)
+	    return commands[i].func(argc, argv, tf);
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+f0101138:	8b 45 b0             	mov    -0x50(%ebp),%eax
+f010113b:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010113f:	c7 04 24 cc 6f 10 f0 	movl   $0xf0106fcc,(%esp)
+f0101146:	e8 42 38 00 00       	call   f010498d <cprintf>
+    return 0;
+f010114b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0101150:	c9                   	leave  
+f0101151:	c3                   	ret    
+
+f0101152 <monitor>:
+
+    void
+monitor(struct Trapframe *tf)
+{
+f0101152:	55                   	push   %ebp
+f0101153:	89 e5                	mov    %esp,%ebp
+f0101155:	83 ec 28             	sub    $0x28,%esp
+    char *buf;
+
+    cprintf("Welcome to the JOS kernel monitor!\n");
+f0101158:	c7 04 24 e4 6f 10 f0 	movl   $0xf0106fe4,(%esp)
+f010115f:	e8 29 38 00 00       	call   f010498d <cprintf>
+    cprintf("Type 'help' for a list of commands.\n");
+f0101164:	c7 04 24 08 70 10 f0 	movl   $0xf0107008,(%esp)
+f010116b:	e8 1d 38 00 00       	call   f010498d <cprintf>
+
+    if (tf != NULL)
+f0101170:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+f0101174:	74 0b                	je     f0101181 <monitor+0x2f>
+	print_trapframe(tf);
+f0101176:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101179:	89 04 24             	mov    %eax,(%esp)
+f010117c:	e8 54 3b 00 00       	call   f0104cd5 <print_trapframe>
+
+    while (1) {
+	buf = readline("K> ");
+f0101181:	c7 04 24 2d 70 10 f0 	movl   $0xf010702d,(%esp)
+f0101188:	e8 1e 50 00 00       	call   f01061ab <readline>
+f010118d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	if (buf != NULL)
+f0101190:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101194:	74 18                	je     f01011ae <monitor+0x5c>
+	    if (runcmd(buf, tf) < 0)
+f0101196:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101199:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010119d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01011a0:	89 04 24             	mov    %eax,(%esp)
+f01011a3:	e8 50 fe ff ff       	call   f0100ff8 <runcmd>
+f01011a8:	85 c0                	test   %eax,%eax
+f01011aa:	79 02                	jns    f01011ae <monitor+0x5c>
+		break;
+f01011ac:	eb 02                	jmp    f01011b0 <monitor+0x5e>
+    }
+f01011ae:	eb d1                	jmp    f0101181 <monitor+0x2f>
+}
+f01011b0:	c9                   	leave  
+f01011b1:	c3                   	ret    
+
+f01011b2 <mon_continue>:
+
+extern void env_pop_tf(struct Trapframe *tf);
+    int
+mon_continue(int argc, char **argv, struct Trapframe *tf)
+{
+f01011b2:	55                   	push   %ebp
+f01011b3:	89 e5                	mov    %esp,%ebp
+f01011b5:	83 ec 18             	sub    $0x18,%esp
+    if (tf->tf_trapno == T_BRKPT || tf->tf_trapno == T_DEBUG) {
+f01011b8:	8b 45 10             	mov    0x10(%ebp),%eax
+f01011bb:	8b 40 28             	mov    0x28(%eax),%eax
+f01011be:	83 f8 03             	cmp    $0x3,%eax
+f01011c1:	74 0b                	je     f01011ce <mon_continue+0x1c>
+f01011c3:	8b 45 10             	mov    0x10(%ebp),%eax
+f01011c6:	8b 40 28             	mov    0x28(%eax),%eax
+f01011c9:	83 f8 01             	cmp    $0x1,%eax
+f01011cc:	75 1c                	jne    f01011ea <mon_continue+0x38>
+	tf->tf_eflags &= ~FL_TF;
+f01011ce:	8b 45 10             	mov    0x10(%ebp),%eax
+f01011d1:	8b 40 38             	mov    0x38(%eax),%eax
+f01011d4:	80 e4 fe             	and    $0xfe,%ah
+f01011d7:	89 c2                	mov    %eax,%edx
+f01011d9:	8b 45 10             	mov    0x10(%ebp),%eax
+f01011dc:	89 50 38             	mov    %edx,0x38(%eax)
+	env_pop_tf(tf);
+f01011df:	8b 45 10             	mov    0x10(%ebp),%eax
+f01011e2:	89 04 24             	mov    %eax,(%esp)
+f01011e5:	e8 21 36 00 00       	call   f010480b <env_pop_tf>
+    }
+    return 0;
+f01011ea:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f01011ef:	c9                   	leave  
+f01011f0:	c3                   	ret    
+
+f01011f1 <mon_stepins>:
+
+    int
+mon_stepins(int argc, char **argv, struct Trapframe *tf)
+{
+f01011f1:	55                   	push   %ebp
+f01011f2:	89 e5                	mov    %esp,%ebp
+f01011f4:	83 ec 18             	sub    $0x18,%esp
+    if (tf->tf_trapno == T_BRKPT || tf->tf_trapno == T_DEBUG) {
+f01011f7:	8b 45 10             	mov    0x10(%ebp),%eax
+f01011fa:	8b 40 28             	mov    0x28(%eax),%eax
+f01011fd:	83 f8 03             	cmp    $0x3,%eax
+f0101200:	74 0b                	je     f010120d <mon_stepins+0x1c>
+f0101202:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101205:	8b 40 28             	mov    0x28(%eax),%eax
+f0101208:	83 f8 01             	cmp    $0x1,%eax
+f010120b:	75 1c                	jne    f0101229 <mon_stepins+0x38>
+	tf->tf_eflags |= FL_TF;
+f010120d:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101210:	8b 40 38             	mov    0x38(%eax),%eax
+f0101213:	80 cc 01             	or     $0x1,%ah
+f0101216:	89 c2                	mov    %eax,%edx
+f0101218:	8b 45 10             	mov    0x10(%ebp),%eax
+f010121b:	89 50 38             	mov    %edx,0x38(%eax)
+	env_pop_tf(tf);
+f010121e:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101221:	89 04 24             	mov    %eax,(%esp)
+f0101224:	e8 e2 35 00 00       	call   f010480b <env_pop_tf>
+    }
+    return 0;
+f0101229:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f010122e:	c9                   	leave  
+f010122f:	c3                   	ret    
+
+f0101230 <invlpg>:
+	asm volatile("outl %0,%w1" : : "a" (data), "d" (port));
+}
+
+static inline void
+invlpg(void *addr)
+{
+f0101230:	55                   	push   %ebp
+f0101231:	89 e5                	mov    %esp,%ebp
+	asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
+f0101233:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101236:	0f 01 38             	invlpg (%eax)
+}
+f0101239:	5d                   	pop    %ebp
+f010123a:	c3                   	ret    
+
+f010123b <lcr0>:
+	asm volatile("ltr %0" : : "r" (sel));
+}
+
+static inline void
+lcr0(uint32_t val)
+{
+f010123b:	55                   	push   %ebp
+f010123c:	89 e5                	mov    %esp,%ebp
+	asm volatile("movl %0,%%cr0" : : "r" (val));
+f010123e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101241:	0f 22 c0             	mov    %eax,%cr0
+}
+f0101244:	5d                   	pop    %ebp
+f0101245:	c3                   	ret    
+
+f0101246 <rcr0>:
+
+static inline uint32_t
+rcr0(void)
+{
+f0101246:	55                   	push   %ebp
+f0101247:	89 e5                	mov    %esp,%ebp
+f0101249:	83 ec 10             	sub    $0x10,%esp
+	uint32_t val;
+	asm volatile("movl %%cr0,%0" : "=r" (val));
+f010124c:	0f 20 c0             	mov    %cr0,%eax
+f010124f:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	return val;
+f0101252:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f0101255:	c9                   	leave  
+f0101256:	c3                   	ret    
+
+f0101257 <lcr3>:
+	return val;
+}
+
+static inline void
+lcr3(uint32_t val)
+{
+f0101257:	55                   	push   %ebp
+f0101258:	89 e5                	mov    %esp,%ebp
+	asm volatile("movl %0,%%cr3" : : "r" (val));
+f010125a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010125d:	0f 22 d8             	mov    %eax,%cr3
+}
+f0101260:	5d                   	pop    %ebp
+f0101261:	c3                   	ret    
+
+f0101262 <_paddr>:
+ */
+#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)
+
+static inline physaddr_t
+_paddr(const char *file, int line, void *kva)
+{
+f0101262:	55                   	push   %ebp
+f0101263:	89 e5                	mov    %esp,%ebp
+f0101265:	83 ec 18             	sub    $0x18,%esp
+	if ((uint32_t)kva < KERNBASE)
+f0101268:	8b 45 10             	mov    0x10(%ebp),%eax
+f010126b:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
+f0101270:	77 21                	ja     f0101293 <_paddr+0x31>
+		_panic(file, line, "PADDR called with invalid kva %08lx", kva);
+f0101272:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101275:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0101279:	c7 44 24 08 34 70 10 	movl   $0xf0107034,0x8(%esp)
+f0101280:	f0 
+f0101281:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101284:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101288:	8b 45 08             	mov    0x8(%ebp),%eax
+f010128b:	89 04 24             	mov    %eax,(%esp)
+f010128e:	e8 22 ee ff ff       	call   f01000b5 <_panic>
+	return (physaddr_t)kva - KERNBASE;
+f0101293:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101296:	05 00 00 00 10       	add    $0x10000000,%eax
+}
+f010129b:	c9                   	leave  
+f010129c:	c3                   	ret    
+
+f010129d <_kaddr>:
+ * virtual address.  It panics if you pass an invalid physical address. */
+#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)
+
+static inline void*
+_kaddr(const char *file, int line, physaddr_t pa)
+{
+f010129d:	55                   	push   %ebp
+f010129e:	89 e5                	mov    %esp,%ebp
+f01012a0:	83 ec 18             	sub    $0x18,%esp
+	if (PGNUM(pa) >= npages)
+f01012a3:	8b 45 10             	mov    0x10(%ebp),%eax
+f01012a6:	c1 e8 0c             	shr    $0xc,%eax
+f01012a9:	89 c2                	mov    %eax,%edx
+f01012ab:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f01012b0:	39 c2                	cmp    %eax,%edx
+f01012b2:	72 21                	jb     f01012d5 <_kaddr+0x38>
+		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
+f01012b4:	8b 45 10             	mov    0x10(%ebp),%eax
+f01012b7:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f01012bb:	c7 44 24 08 58 70 10 	movl   $0xf0107058,0x8(%esp)
+f01012c2:	f0 
+f01012c3:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01012c6:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01012ca:	8b 45 08             	mov    0x8(%ebp),%eax
+f01012cd:	89 04 24             	mov    %eax,(%esp)
+f01012d0:	e8 e0 ed ff ff       	call   f01000b5 <_panic>
+	return (void *)(pa + KERNBASE);
+f01012d5:	8b 45 10             	mov    0x10(%ebp),%eax
+f01012d8:	2d 00 00 00 10       	sub    $0x10000000,%eax
+}
+f01012dd:	c9                   	leave  
+f01012de:	c3                   	ret    
+
+f01012df <page2pa>:
+int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
+void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);
+
+static inline physaddr_t
+page2pa(struct PageInfo *pp)
+{
+f01012df:	55                   	push   %ebp
+f01012e0:	89 e5                	mov    %esp,%ebp
+	return (pp - pages) << PGSHIFT;
+f01012e2:	8b 55 08             	mov    0x8(%ebp),%edx
+f01012e5:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01012ea:	29 c2                	sub    %eax,%edx
+f01012ec:	89 d0                	mov    %edx,%eax
+f01012ee:	c1 f8 03             	sar    $0x3,%eax
+f01012f1:	c1 e0 0c             	shl    $0xc,%eax
+}
+f01012f4:	5d                   	pop    %ebp
+f01012f5:	c3                   	ret    
+
+f01012f6 <pa2page>:
+
+static inline struct PageInfo*
+pa2page(physaddr_t pa)
+{
+f01012f6:	55                   	push   %ebp
+f01012f7:	89 e5                	mov    %esp,%ebp
+f01012f9:	83 ec 18             	sub    $0x18,%esp
+	if (PGNUM(pa) >= npages)
+f01012fc:	8b 45 08             	mov    0x8(%ebp),%eax
+f01012ff:	c1 e8 0c             	shr    $0xc,%eax
+f0101302:	89 c2                	mov    %eax,%edx
+f0101304:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f0101309:	39 c2                	cmp    %eax,%edx
+f010130b:	72 1c                	jb     f0101329 <pa2page+0x33>
+		panic("pa2page called with invalid pa");
+f010130d:	c7 44 24 08 7c 70 10 	movl   $0xf010707c,0x8(%esp)
+f0101314:	f0 
+f0101315:	c7 44 24 04 4f 00 00 	movl   $0x4f,0x4(%esp)
+f010131c:	00 
+f010131d:	c7 04 24 9b 70 10 f0 	movl   $0xf010709b,(%esp)
+f0101324:	e8 8c ed ff ff       	call   f01000b5 <_panic>
+	return &pages[PGNUM(pa)];
+f0101329:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f010132e:	8b 55 08             	mov    0x8(%ebp),%edx
+f0101331:	c1 ea 0c             	shr    $0xc,%edx
+f0101334:	c1 e2 03             	shl    $0x3,%edx
+f0101337:	01 d0                	add    %edx,%eax
+}
+f0101339:	c9                   	leave  
+f010133a:	c3                   	ret    
+
+f010133b <page2kva>:
+
+static inline void*
+page2kva(struct PageInfo *pp)
+{
+f010133b:	55                   	push   %ebp
+f010133c:	89 e5                	mov    %esp,%ebp
+f010133e:	83 ec 18             	sub    $0x18,%esp
+	return KADDR(page2pa(pp));
+f0101341:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101344:	89 04 24             	mov    %eax,(%esp)
+f0101347:	e8 93 ff ff ff       	call   f01012df <page2pa>
+f010134c:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101350:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
+f0101357:	00 
+f0101358:	c7 04 24 9b 70 10 f0 	movl   $0xf010709b,(%esp)
+f010135f:	e8 39 ff ff ff       	call   f010129d <_kaddr>
+}
+f0101364:	c9                   	leave  
+f0101365:	c3                   	ret    
+
+f0101366 <nvram_read>:
+// Detect machine's physical memory setup.
+// --------------------------------------------------------------
+
+    static int
+nvram_read(int r)
+{
+f0101366:	55                   	push   %ebp
+f0101367:	89 e5                	mov    %esp,%ebp
+f0101369:	53                   	push   %ebx
+f010136a:	83 ec 14             	sub    $0x14,%esp
+    return mc146818_read(r) | (mc146818_read(r + 1) << 8);
+f010136d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101370:	89 04 24             	mov    %eax,(%esp)
+f0101373:	e8 65 35 00 00       	call   f01048dd <mc146818_read>
+f0101378:	89 c3                	mov    %eax,%ebx
+f010137a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010137d:	83 c0 01             	add    $0x1,%eax
+f0101380:	89 04 24             	mov    %eax,(%esp)
+f0101383:	e8 55 35 00 00       	call   f01048dd <mc146818_read>
+f0101388:	c1 e0 08             	shl    $0x8,%eax
+f010138b:	09 d8                	or     %ebx,%eax
+}
+f010138d:	83 c4 14             	add    $0x14,%esp
+f0101390:	5b                   	pop    %ebx
+f0101391:	5d                   	pop    %ebp
+f0101392:	c3                   	ret    
+
+f0101393 <i386_detect_memory>:
+
+    static void
+i386_detect_memory(void)
+{
+f0101393:	55                   	push   %ebp
+f0101394:	89 e5                	mov    %esp,%ebp
+f0101396:	83 ec 28             	sub    $0x28,%esp
+    size_t basemem, extmem, ext16mem, totalmem;
+
+    // Use CMOS calls to measure available base & extended memory.
+    // (CMOS calls return results in kilobytes.)
+    basemem = nvram_read(NVRAM_BASELO);
+f0101399:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
+f01013a0:	e8 c1 ff ff ff       	call   f0101366 <nvram_read>
+f01013a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    extmem = nvram_read(NVRAM_EXTLO);
+f01013a8:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
+f01013af:	e8 b2 ff ff ff       	call   f0101366 <nvram_read>
+f01013b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
+f01013b7:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
+f01013be:	e8 a3 ff ff ff       	call   f0101366 <nvram_read>
+f01013c3:	c1 e0 06             	shl    $0x6,%eax
+f01013c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+    // Calculate the number of physical pages available in both base
+    // and extended memory.
+    if (ext16mem)
+f01013c9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f01013cd:	74 0d                	je     f01013dc <i386_detect_memory+0x49>
+	totalmem = 16 * 1024 + ext16mem;
+f01013cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f01013d2:	05 00 40 00 00       	add    $0x4000,%eax
+f01013d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01013da:	eb 19                	jmp    f01013f5 <i386_detect_memory+0x62>
+    else if (extmem)
+f01013dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f01013e0:	74 0d                	je     f01013ef <i386_detect_memory+0x5c>
+	totalmem = 1 * 1024 + extmem;
+f01013e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01013e5:	05 00 04 00 00       	add    $0x400,%eax
+f01013ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01013ed:	eb 06                	jmp    f01013f5 <i386_detect_memory+0x62>
+    else
+	totalmem = basemem;
+f01013ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01013f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+    npages = totalmem / (PGSIZE / 1024);
+f01013f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01013f8:	c1 e8 02             	shr    $0x2,%eax
+f01013fb:	a3 d0 f7 18 f0       	mov    %eax,0xf018f7d0
+    npages_basemem = basemem / (PGSIZE / 1024);
+f0101400:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0101403:	c1 e8 02             	shr    $0x2,%eax
+f0101406:	a3 0c eb 18 f0       	mov    %eax,0xf018eb0c
+
+    cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
+f010140b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010140e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101411:	29 c2                	sub    %eax,%edx
+f0101413:	89 d0                	mov    %edx,%eax
+f0101415:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0101419:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010141c:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101420:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101423:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101427:	c7 04 24 ac 70 10 f0 	movl   $0xf01070ac,(%esp)
+f010142e:	e8 5a 35 00 00       	call   f010498d <cprintf>
+	    totalmem, basemem, totalmem - basemem);
+}
+f0101433:	c9                   	leave  
+f0101434:	c3                   	ret    
+
+f0101435 <boot_alloc>:
+// If we're out of memory, boot_alloc should panic.
+// This function may ONLY be used during initialization,
+// before the page_free_list list has been set up.
+    static void *
+boot_alloc(uint32_t n)
+{
+f0101435:	55                   	push   %ebp
+f0101436:	89 e5                	mov    %esp,%ebp
+f0101438:	83 ec 38             	sub    $0x38,%esp
+    // Initialize nextfree if this is the first time.
+    // 'end' is a magic symbol automatically generated by the linker,
+    // which points to the end of the kernel's bss segment:
+    // the first virtual address that the linker did *not* assign
+    // to any kernel code or global variables.
+    if (!nextfree) {
+f010143b:	a1 18 eb 18 f0       	mov    0xf018eb18,%eax
+f0101440:	85 c0                	test   %eax,%eax
+f0101442:	75 30                	jne    f0101474 <boot_alloc+0x3f>
+	extern char end[];
+	nextfree = ROUNDUP((char *) end, PGSIZE);
+f0101444:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
+f010144b:	b8 dc f7 18 f0       	mov    $0xf018f7dc,%eax
+f0101450:	8d 50 ff             	lea    -0x1(%eax),%edx
+f0101453:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101456:	01 d0                	add    %edx,%eax
+f0101458:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f010145b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010145e:	ba 00 00 00 00       	mov    $0x0,%edx
+f0101463:	f7 75 f4             	divl   -0xc(%ebp)
+f0101466:	89 d0                	mov    %edx,%eax
+f0101468:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f010146b:	29 c2                	sub    %eax,%edx
+f010146d:	89 d0                	mov    %edx,%eax
+f010146f:	a3 18 eb 18 f0       	mov    %eax,0xf018eb18
+
+    // Allocate a chunk large enough to hold 'n' bytes, then update
+    // nextfree.  Make sure nextfree is kept aligned
+    // to a multiple of PGSIZE.
+    // LAB 2: Your code here.
+    if (n == 0) return (void*)nextfree;
+f0101474:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+f0101478:	75 0a                	jne    f0101484 <boot_alloc+0x4f>
+f010147a:	a1 18 eb 18 f0       	mov    0xf018eb18,%eax
+f010147f:	e9 93 00 00 00       	jmp    f0101517 <boot_alloc+0xe2>
+    n = ROUNDUP(n, PGSIZE);
+f0101484:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
+f010148b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f010148e:	8b 55 08             	mov    0x8(%ebp),%edx
+f0101491:	01 d0                	add    %edx,%eax
+f0101493:	83 e8 01             	sub    $0x1,%eax
+f0101496:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f0101499:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010149c:	ba 00 00 00 00       	mov    $0x0,%edx
+f01014a1:	f7 75 ec             	divl   -0x14(%ebp)
+f01014a4:	89 d0                	mov    %edx,%eax
+f01014a6:	8b 55 e8             	mov    -0x18(%ebp),%edx
+f01014a9:	29 c2                	sub    %eax,%edx
+f01014ab:	89 d0                	mov    %edx,%eax
+f01014ad:	89 45 08             	mov    %eax,0x8(%ebp)
+    if (PADDR(nextfree + n) > npages * PGSIZE)
+f01014b0:	8b 15 18 eb 18 f0    	mov    0xf018eb18,%edx
+f01014b6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01014b9:	01 d0                	add    %edx,%eax
+f01014bb:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01014bf:	c7 44 24 04 69 00 00 	movl   $0x69,0x4(%esp)
+f01014c6:	00 
+f01014c7:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01014ce:	e8 8f fd ff ff       	call   f0101262 <_paddr>
+f01014d3:	8b 15 d0 f7 18 f0    	mov    0xf018f7d0,%edx
+f01014d9:	c1 e2 0c             	shl    $0xc,%edx
+f01014dc:	39 d0                	cmp    %edx,%eax
+f01014de:	76 1c                	jbe    f01014fc <boot_alloc+0xc7>
+    {
+	panic("kern/pmap.c: boot_alloc()");
+f01014e0:	c7 44 24 08 f4 70 10 	movl   $0xf01070f4,0x8(%esp)
+f01014e7:	f0 
+f01014e8:	c7 44 24 04 6b 00 00 	movl   $0x6b,0x4(%esp)
+f01014ef:	00 
+f01014f0:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01014f7:	e8 b9 eb ff ff       	call   f01000b5 <_panic>
+	return NULL;
+    }
+    result = nextfree;
+f01014fc:	a1 18 eb 18 f0       	mov    0xf018eb18,%eax
+f0101501:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    nextfree += n;
+f0101504:	8b 15 18 eb 18 f0    	mov    0xf018eb18,%edx
+f010150a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010150d:	01 d0                	add    %edx,%eax
+f010150f:	a3 18 eb 18 f0       	mov    %eax,0xf018eb18
+    return result;
+f0101514:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+f0101517:	c9                   	leave  
+f0101518:	c3                   	ret    
+
+f0101519 <mem_init>:
+//
+// From UTOP to ULIM, the user is allowed to read but not write.
+// Above ULIM the user cannot read or write.
+    void
+mem_init(void)
+{
+f0101519:	55                   	push   %ebp
+f010151a:	89 e5                	mov    %esp,%ebp
+f010151c:	53                   	push   %ebx
+f010151d:	83 ec 44             	sub    $0x44,%esp
+    uint32_t cr0;
+    size_t n;
+
+    // Find out how much memory the machine has (npages & npages_basemem).
+    i386_detect_memory();
+f0101520:	e8 6e fe ff ff       	call   f0101393 <i386_detect_memory>
+    // Remove this line when you're ready to test this function.
+    //panic("mem_init: This function is not finished\n");
+
+    //////////////////////////////////////////////////////////////////////
+    // create initial page directory.
+    kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
+f0101525:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+f010152c:	e8 04 ff ff ff       	call   f0101435 <boot_alloc>
+f0101531:	a3 d4 f7 18 f0       	mov    %eax,0xf018f7d4
+    memset(kern_pgdir, 0, PGSIZE);
+f0101536:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010153b:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0101542:	00 
+f0101543:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010154a:	00 
+f010154b:	89 04 24             	mov    %eax,(%esp)
+f010154e:	e8 8f 4f 00 00       	call   f01064e2 <memset>
+    // a virtual page table at virtual address UVPT.
+    // (For now, you don't have understand the greater purpose of the
+    // following line.)
+
+    // Permissions: kernel R, user R
+    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
+f0101553:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0101558:	8d 98 f4 0e 00 00    	lea    0xef4(%eax),%ebx
+f010155e:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0101563:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101567:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
+f010156e:	00 
+f010156f:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101576:	e8 e7 fc ff ff       	call   f0101262 <_paddr>
+f010157b:	83 c8 05             	or     $0x5,%eax
+f010157e:	89 03                	mov    %eax,(%ebx)
+    // The kernel uses this array to keep track of physical pages: for
+    // each physical page, there is a corresponding struct PageInfo in this
+    // array.  'npages' is the number of physical pages in memory.  Use memset
+    // to initialize all fields of each struct PageInfo to 0.
+    // Your code goes here:
+    pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
+f0101580:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f0101585:	c1 e0 03             	shl    $0x3,%eax
+f0101588:	89 04 24             	mov    %eax,(%esp)
+f010158b:	e8 a5 fe ff ff       	call   f0101435 <boot_alloc>
+f0101590:	a3 d8 f7 18 f0       	mov    %eax,0xf018f7d8
+    memset(pages, 0, npages * sizeof(struct PageInfo));
+f0101595:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f010159a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+f01015a1:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01015a6:	89 54 24 08          	mov    %edx,0x8(%esp)
+f01015aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f01015b1:	00 
+f01015b2:	89 04 24             	mov    %eax,(%esp)
+f01015b5:	e8 28 4f 00 00       	call   f01064e2 <memset>
+
+    //////////////////////////////////////////////////////////////////////
+    // Make 'envs' point to an array of size 'NENV' of 'struct Env'.
+    // LAB 3: Your code here.
+    envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
+f01015ba:	c7 04 24 00 80 01 00 	movl   $0x18000,(%esp)
+f01015c1:	e8 6f fe ff ff       	call   f0101435 <boot_alloc>
+f01015c6:	a3 1c eb 18 f0       	mov    %eax,0xf018eb1c
+    // Now that we've allocated the initial kernel data structures, we set
+    // up the list of free physical pages. Once we've done so, all further
+    // memory management will go through the page_* functions. In
+    // particular, we can now map memory using boot_map_region
+    // or page_insert
+    page_init();
+f01015cb:	e8 e9 01 00 00       	call   f01017b9 <page_init>
+
+
+    check_page_free_list(1);
+f01015d0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+f01015d7:	e8 67 07 00 00       	call   f0101d43 <check_page_free_list>
+    check_page_alloc();
+f01015dc:	e8 d0 0a 00 00       	call   f01020b1 <check_page_alloc>
+    check_page();
+f01015e1:	e8 c8 14 00 00       	call   f0102aae <check_page>
+    // Permissions:
+    //    - the new image at UPAGES -- kernel R, user R
+    //      (ie. perm = PTE_U | PTE_P)
+    //    - pages itself -- kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo)* npages, PGSIZE), PADDR(pages), PTE_U);
+f01015e6:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01015eb:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01015ef:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
+f01015f6:	00 
+f01015f7:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01015fe:	e8 5f fc ff ff       	call   f0101262 <_paddr>
+f0101603:	89 c1                	mov    %eax,%ecx
+f0101605:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
+f010160c:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f0101611:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+f0101618:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010161b:	01 d0                	add    %edx,%eax
+f010161d:	83 e8 01             	sub    $0x1,%eax
+f0101620:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0101623:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0101626:	ba 00 00 00 00       	mov    $0x0,%edx
+f010162b:	f7 75 f4             	divl   -0xc(%ebp)
+f010162e:	89 d0                	mov    %edx,%eax
+f0101630:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0101633:	29 c2                	sub    %eax,%edx
+f0101635:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010163a:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
+f0101641:	00 
+f0101642:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f0101646:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010164a:	c7 44 24 04 00 00 00 	movl   $0xef000000,0x4(%esp)
+f0101651:	ef 
+f0101652:	89 04 24             	mov    %eax,(%esp)
+f0101655:	e8 e7 03 00 00       	call   f0101a41 <boot_map_region>
+    // (ie. perm = PTE_U | PTE_P).
+    // Permissions:
+    //    - the new image at UENVS  -- kernel R, user R
+    //    - envs itself -- kernel RW, user NONE
+    // LAB 3: Your code here.
+    boot_map_region(kern_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);	
+f010165a:	a1 1c eb 18 f0       	mov    0xf018eb1c,%eax
+f010165f:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101663:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
+f010166a:	00 
+f010166b:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101672:	e8 eb fb ff ff       	call   f0101262 <_paddr>
+f0101677:	89 c1                	mov    %eax,%ecx
+f0101679:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
+f0101680:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0101683:	05 ff 7f 01 00       	add    $0x17fff,%eax
+f0101688:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f010168b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010168e:	ba 00 00 00 00       	mov    $0x0,%edx
+f0101693:	f7 75 ec             	divl   -0x14(%ebp)
+f0101696:	89 d0                	mov    %edx,%eax
+f0101698:	8b 55 e8             	mov    -0x18(%ebp),%edx
+f010169b:	29 c2                	sub    %eax,%edx
+f010169d:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01016a2:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
+f01016a9:	00 
+f01016aa:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f01016ae:	89 54 24 08          	mov    %edx,0x8(%esp)
+f01016b2:	c7 44 24 04 00 00 c0 	movl   $0xeec00000,0x4(%esp)
+f01016b9:	ee 
+f01016ba:	89 04 24             	mov    %eax,(%esp)
+f01016bd:	e8 7f 03 00 00       	call   f0101a41 <boot_map_region>
+    //     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
+    //       the kernel overflows its stack, it will fault rather than
+    //       overwrite memory.  Known as a "guard page".
+    //     Permissions: kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+f01016c2:	c7 44 24 08 00 50 11 	movl   $0xf0115000,0x8(%esp)
+f01016c9:	f0 
+f01016ca:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
+f01016d1:	00 
+f01016d2:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01016d9:	e8 84 fb ff ff       	call   f0101262 <_paddr>
+f01016de:	89 c1                	mov    %eax,%ecx
+f01016e0:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
+f01016e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f01016ea:	05 ff 7f 00 00       	add    $0x7fff,%eax
+f01016ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
+f01016f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f01016f5:	ba 00 00 00 00       	mov    $0x0,%edx
+f01016fa:	f7 75 e4             	divl   -0x1c(%ebp)
+f01016fd:	89 d0                	mov    %edx,%eax
+f01016ff:	8b 55 e0             	mov    -0x20(%ebp),%edx
+f0101702:	29 c2                	sub    %eax,%edx
+f0101704:	89 d0                	mov    %edx,%eax
+f0101706:	89 c2                	mov    %eax,%edx
+f0101708:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010170d:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+f0101714:	00 
+f0101715:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f0101719:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010171d:	c7 44 24 04 00 80 ff 	movl   $0xefff8000,0x4(%esp)
+f0101724:	ef 
+f0101725:	89 04 24             	mov    %eax,(%esp)
+f0101728:	e8 14 03 00 00       	call   f0101a41 <boot_map_region>
+    //      the PA range [0, 2^32 - KERNBASE)
+    // We might not have 2^32 - KERNBASE bytes of physical memory, but
+    // we just set up the mapping anyway.
+    // Permissions: kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+f010172d:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0101732:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+f0101739:	00 
+f010173a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+f0101741:	00 
+f0101742:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
+f0101749:	10 
+f010174a:	c7 44 24 04 00 00 00 	movl   $0xf0000000,0x4(%esp)
+f0101751:	f0 
+f0101752:	89 04 24             	mov    %eax,(%esp)
+f0101755:	e8 e7 02 00 00       	call   f0101a41 <boot_map_region>
+
+
+    // Check that the initial page directory has been set up correctly.
+    check_kern_pgdir();
+f010175a:	e8 04 0f 00 00       	call   f0102663 <check_kern_pgdir>
+    // somewhere between KERNBASE and KERNBASE+4MB right now, which is
+    // mapped the same way by both page tables.
+    //
+    // If the machine reboots at this point, you've probably set up your
+    // kern_pgdir wrong.
+    lcr3(PADDR(kern_pgdir));
+f010175f:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0101764:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101768:	c7 44 24 04 e9 00 00 	movl   $0xe9,0x4(%esp)
+f010176f:	00 
+f0101770:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101777:	e8 e6 fa ff ff       	call   f0101262 <_paddr>
+f010177c:	89 04 24             	mov    %eax,(%esp)
+f010177f:	e8 d3 fa ff ff       	call   f0101257 <lcr3>
+
+    check_page_free_list(0);
+f0101784:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f010178b:	e8 b3 05 00 00       	call   f0101d43 <check_page_free_list>
+
+    // entry.S set the really important flags in cr0 (including enabling
+    // paging).  Here we configure the rest of the flags that we care about.
+    cr0 = rcr0();
+f0101790:	e8 b1 fa ff ff       	call   f0101246 <rcr0>
+f0101795:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
+f0101798:	81 4d dc 23 00 05 80 	orl    $0x80050023,-0x24(%ebp)
+    cr0 &= ~(CR0_TS|CR0_EM);
+f010179f:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
+    lcr0(cr0);
+f01017a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f01017a6:	89 04 24             	mov    %eax,(%esp)
+f01017a9:	e8 8d fa ff ff       	call   f010123b <lcr0>
+
+    // Some more checks, only possible after kern_pgdir is installed.
+    check_page_installed_pgdir();
+f01017ae:	e8 60 22 00 00       	call   f0103a13 <check_page_installed_pgdir>
+}
+f01017b3:	83 c4 44             	add    $0x44,%esp
+f01017b6:	5b                   	pop    %ebx
+f01017b7:	5d                   	pop    %ebp
+f01017b8:	c3                   	ret    
+
+f01017b9 <page_init>:
+// allocator functions below to allocate and deallocate physical
+// memory via the page_free_list.
+//
+    void
+page_init(void)
+{
+f01017b9:	55                   	push   %ebp
+f01017ba:	89 e5                	mov    %esp,%ebp
+f01017bc:	83 ec 28             	sub    $0x28,%esp
+    //
+    // Change the code to reflect this.
+    // NB: DO NOT actually touch the physical memory corresponding to
+    // free pages!
+    size_t i;
+    assert(page_free_list == 0);
+f01017bf:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f01017c4:	85 c0                	test   %eax,%eax
+f01017c6:	74 24                	je     f01017ec <page_init+0x33>
+f01017c8:	c7 44 24 0c 0e 71 10 	movl   $0xf010710e,0xc(%esp)
+f01017cf:	f0 
+f01017d0:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01017d7:	f0 
+f01017d8:	c7 44 24 04 19 01 00 	movl   $0x119,0x4(%esp)
+f01017df:	00 
+f01017e0:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01017e7:	e8 c9 e8 ff ff       	call   f01000b5 <_panic>
+    unsigned used_top = PADDR(boot_alloc(0));
+f01017ec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f01017f3:	e8 3d fc ff ff       	call   f0101435 <boot_alloc>
+f01017f8:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01017fc:	c7 44 24 04 1a 01 00 	movl   $0x11a,0x4(%esp)
+f0101803:	00 
+f0101804:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010180b:	e8 52 fa ff ff       	call   f0101262 <_paddr>
+f0101810:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    for (i = 0; i < npages; i++) {
+f0101813:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f010181a:	eb 7b                	jmp    f0101897 <page_init+0xde>
+	if (i == 0 || (page2pa(&pages[i]) >= IOPHYSMEM && page2pa(&pages[i]) < used_top))
+f010181c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101820:	74 36                	je     f0101858 <page_init+0x9f>
+f0101822:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101827:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f010182a:	c1 e2 03             	shl    $0x3,%edx
+f010182d:	01 d0                	add    %edx,%eax
+f010182f:	89 04 24             	mov    %eax,(%esp)
+f0101832:	e8 a8 fa ff ff       	call   f01012df <page2pa>
+f0101837:	3d ff ff 09 00       	cmp    $0x9ffff,%eax
+f010183c:	76 1c                	jbe    f010185a <page_init+0xa1>
+f010183e:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101843:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101846:	c1 e2 03             	shl    $0x3,%edx
+f0101849:	01 d0                	add    %edx,%eax
+f010184b:	89 04 24             	mov    %eax,(%esp)
+f010184e:	e8 8c fa ff ff       	call   f01012df <page2pa>
+f0101853:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+f0101856:	73 02                	jae    f010185a <page_init+0xa1>
+	    continue;
+f0101858:	eb 39                	jmp    f0101893 <page_init+0xda>
+	pages[i].pp_ref = 0;
+f010185a:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f010185f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101862:	c1 e2 03             	shl    $0x3,%edx
+f0101865:	01 d0                	add    %edx,%eax
+f0101867:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
+	pages[i].pp_link = page_free_list;
+f010186d:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101872:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101875:	c1 e2 03             	shl    $0x3,%edx
+f0101878:	01 c2                	add    %eax,%edx
+f010187a:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f010187f:	89 02                	mov    %eax,(%edx)
+	page_free_list = &pages[i];
+f0101881:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101886:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101889:	c1 e2 03             	shl    $0x3,%edx
+f010188c:	01 d0                	add    %edx,%eax
+f010188e:	a3 10 eb 18 f0       	mov    %eax,0xf018eb10
+    // NB: DO NOT actually touch the physical memory corresponding to
+    // free pages!
+    size_t i;
+    assert(page_free_list == 0);
+    unsigned used_top = PADDR(boot_alloc(0));
+    for (i = 0; i < npages; i++) {
+f0101893:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f0101897:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f010189c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+f010189f:	0f 82 77 ff ff ff    	jb     f010181c <page_init+0x63>
+	    continue;
+	pages[i].pp_ref = 0;
+	pages[i].pp_link = page_free_list;
+	page_free_list = &pages[i];
+    }
+}
+f01018a5:	c9                   	leave  
+f01018a6:	c3                   	ret    
+
+f01018a7 <page_alloc>:
+// Returns NULL if out of free memory.
+//
+// Hint: use page2kva and memset
+    struct PageInfo *
+page_alloc(int alloc_flags)
+{
+f01018a7:	55                   	push   %ebp
+f01018a8:	89 e5                	mov    %esp,%ebp
+f01018aa:	83 ec 28             	sub    $0x28,%esp
+    // Fill this function in
+    if (page_free_list == NULL) return NULL;
+f01018ad:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f01018b2:	85 c0                	test   %eax,%eax
+f01018b4:	75 07                	jne    f01018bd <page_alloc+0x16>
+f01018b6:	b8 00 00 00 00       	mov    $0x0,%eax
+f01018bb:	eb 4b                	jmp    f0101908 <page_alloc+0x61>
+    struct PageInfo* ret = page_free_list;
+f01018bd:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f01018c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    page_free_list = ret->pp_link;
+f01018c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01018c8:	8b 00                	mov    (%eax),%eax
+f01018ca:	a3 10 eb 18 f0       	mov    %eax,0xf018eb10
+    if (alloc_flags & ALLOC_ZERO) 
+f01018cf:	8b 45 08             	mov    0x8(%ebp),%eax
+f01018d2:	83 e0 01             	and    $0x1,%eax
+f01018d5:	85 c0                	test   %eax,%eax
+f01018d7:	74 23                	je     f01018fc <page_alloc+0x55>
+	memset(page2kva(ret), 0, PGSIZE);
+f01018d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01018dc:	89 04 24             	mov    %eax,(%esp)
+f01018df:	e8 57 fa ff ff       	call   f010133b <page2kva>
+f01018e4:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f01018eb:	00 
+f01018ec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f01018f3:	00 
+f01018f4:	89 04 24             	mov    %eax,(%esp)
+f01018f7:	e8 e6 4b 00 00       	call   f01064e2 <memset>
+    ret->pp_link = NULL;
+f01018fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01018ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+    return ret;
+f0101905:	8b 45 f4             	mov    -0xc(%ebp),%eax
+
+}
+f0101908:	c9                   	leave  
+f0101909:	c3                   	ret    
+
+f010190a <page_free>:
+// Return a page to the free list.
+// (This function should only be called when pp->pp_ref reaches 0.)
+//
+    void
+page_free(struct PageInfo *pp)
+{
+f010190a:	55                   	push   %ebp
+f010190b:	89 e5                	mov    %esp,%ebp
+f010190d:	83 ec 18             	sub    $0x18,%esp
+    // Fill this function in
+    // Hint: You may want to panic if pp->pp_ref is nonzero or
+    // pp->pp_link is not NULL.
+
+    if(pp->pp_ref == 0){
+f0101910:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101913:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0101917:	66 85 c0             	test   %ax,%ax
+f010191a:	75 15                	jne    f0101931 <page_free+0x27>
+	pp->pp_link = page_free_list;
+f010191c:	8b 15 10 eb 18 f0    	mov    0xf018eb10,%edx
+f0101922:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101925:	89 10                	mov    %edx,(%eax)
+	page_free_list = pp;
+f0101927:	8b 45 08             	mov    0x8(%ebp),%eax
+f010192a:	a3 10 eb 18 f0       	mov    %eax,0xf018eb10
+f010192f:	eb 1c                	jmp    f010194d <page_free+0x43>
+    }
+    else
+    {
+	panic("pp->pp_ref is not zero. Wrong call of the page_free!!!");
+f0101931:	c7 44 24 08 38 71 10 	movl   $0xf0107138,0x8(%esp)
+f0101938:	f0 
+f0101939:	c7 44 24 04 4f 01 00 	movl   $0x14f,0x4(%esp)
+f0101940:	00 
+f0101941:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101948:	e8 68 e7 ff ff       	call   f01000b5 <_panic>
+    }
+}
+f010194d:	c9                   	leave  
+f010194e:	c3                   	ret    
+
+f010194f <page_decref>:
+// Decrement the reference count on a page,
+// freeing it if there are no more refs.
+//
+    void
+page_decref(struct PageInfo* pp)
+{
+f010194f:	55                   	push   %ebp
+f0101950:	89 e5                	mov    %esp,%ebp
+f0101952:	83 ec 18             	sub    $0x18,%esp
+    if (--pp->pp_ref == 0)
+f0101955:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101958:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f010195c:	8d 50 ff             	lea    -0x1(%eax),%edx
+f010195f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101962:	66 89 50 04          	mov    %dx,0x4(%eax)
+f0101966:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101969:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f010196d:	66 85 c0             	test   %ax,%ax
+f0101970:	75 0b                	jne    f010197d <page_decref+0x2e>
+	page_free(pp);
+f0101972:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101975:	89 04 24             	mov    %eax,(%esp)
+f0101978:	e8 8d ff ff ff       	call   f010190a <page_free>
+}
+f010197d:	c9                   	leave  
+f010197e:	c3                   	ret    
+
+f010197f <pgdir_walk>:
+// Hint 3: look at inc/mmu.h for useful macros that mainipulate page
+// table and page directory entries.
+//
+    pte_t *
+pgdir_walk(pde_t *pgdir, const void *va, int create)
+{
+f010197f:	55                   	push   %ebp
+f0101980:	89 e5                	mov    %esp,%ebp
+f0101982:	53                   	push   %ebx
+f0101983:	83 ec 24             	sub    $0x24,%esp
+    // Fill this function in
+    if (!(pgdir[PDX(va)] & PTE_P)) {
+f0101986:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101989:	c1 e8 16             	shr    $0x16,%eax
+f010198c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0101993:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101996:	01 d0                	add    %edx,%eax
+f0101998:	8b 00                	mov    (%eax),%eax
+f010199a:	83 e0 01             	and    $0x1,%eax
+f010199d:	85 c0                	test   %eax,%eax
+f010199f:	75 58                	jne    f01019f9 <pgdir_walk+0x7a>
+	if (!create) return NULL;
+f01019a1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f01019a5:	75 0a                	jne    f01019b1 <pgdir_walk+0x32>
+f01019a7:	b8 00 00 00 00       	mov    $0x0,%eax
+f01019ac:	e9 8a 00 00 00       	jmp    f0101a3b <pgdir_walk+0xbc>
+	struct PageInfo *page = page_alloc(ALLOC_ZERO);
+f01019b1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+f01019b8:	e8 ea fe ff ff       	call   f01018a7 <page_alloc>
+f01019bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	if (!page) return NULL;
+f01019c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f01019c4:	75 07                	jne    f01019cd <pgdir_walk+0x4e>
+f01019c6:	b8 00 00 00 00       	mov    $0x0,%eax
+f01019cb:	eb 6e                	jmp    f0101a3b <pgdir_walk+0xbc>
+	page->pp_ref = 1;
+f01019cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01019d0:	66 c7 40 04 01 00    	movw   $0x1,0x4(%eax)
+	pgdir[PDX(va)] = page2pa(page) | PTE_P | PTE_U | PTE_W;
+f01019d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01019d9:	c1 e8 16             	shr    $0x16,%eax
+f01019dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f01019e3:	8b 45 08             	mov    0x8(%ebp),%eax
+f01019e6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+f01019e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01019ec:	89 04 24             	mov    %eax,(%esp)
+f01019ef:	e8 eb f8 ff ff       	call   f01012df <page2pa>
+f01019f4:	83 c8 07             	or     $0x7,%eax
+f01019f7:	89 03                	mov    %eax,(%ebx)
+    }
+    return KADDR(PTE_ADDR(pgdir[PDX(va)])) + PTX(va) * sizeof(pte_t*);
+f01019f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01019fc:	c1 e8 16             	shr    $0x16,%eax
+f01019ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0101a06:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101a09:	01 d0                	add    %edx,%eax
+f0101a0b:	8b 00                	mov    (%eax),%eax
+f0101a0d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0101a12:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101a16:	c7 44 24 04 80 01 00 	movl   $0x180,0x4(%esp)
+f0101a1d:	00 
+f0101a1e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101a25:	e8 73 f8 ff ff       	call   f010129d <_kaddr>
+f0101a2a:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0101a2d:	c1 ea 0c             	shr    $0xc,%edx
+f0101a30:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
+f0101a36:	c1 e2 02             	shl    $0x2,%edx
+f0101a39:	01 d0                	add    %edx,%eax
+}
+f0101a3b:	83 c4 24             	add    $0x24,%esp
+f0101a3e:	5b                   	pop    %ebx
+f0101a3f:	5d                   	pop    %ebp
+f0101a40:	c3                   	ret    
+
+f0101a41 <boot_map_region>:
+//
+// Hint: the TA solution uses pgdir_walk
+//
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+f0101a41:	55                   	push   %ebp
+f0101a42:	89 e5                	mov    %esp,%ebp
+f0101a44:	83 ec 28             	sub    $0x28,%esp
+    // Fill this function in
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+f0101a47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f0101a4e:	eb 46                	jmp    f0101a96 <boot_map_region+0x55>
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+f0101a50:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101a53:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101a56:	01 d0                	add    %edx,%eax
+f0101a58:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+f0101a5f:	00 
+f0101a60:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101a64:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101a67:	89 04 24             	mov    %eax,(%esp)
+f0101a6a:	e8 10 ff ff ff       	call   f010197f <pgdir_walk>
+f0101a6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+f0101a72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0101a76:	74 17                	je     f0101a8f <boot_map_region+0x4e>
+f0101a78:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101a7b:	8b 45 14             	mov    0x14(%ebp),%eax
+f0101a7e:	01 c2                	add    %eax,%edx
+f0101a80:	8b 45 18             	mov    0x18(%ebp),%eax
+f0101a83:	09 d0                	or     %edx,%eax
+f0101a85:	83 c8 01             	or     $0x1,%eax
+f0101a88:	89 c2                	mov    %eax,%edx
+f0101a8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0101a8d:	89 10                	mov    %edx,(%eax)
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    // Fill this function in
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+f0101a8f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f0101a96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101a99:	3b 45 10             	cmp    0x10(%ebp),%eax
+f0101a9c:	72 b2                	jb     f0101a50 <boot_map_region+0xf>
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+f0101a9e:	c9                   	leave  
+f0101a9f:	c3                   	ret    
+
+f0101aa0 <page_insert>:
+// Hint: The TA solution is implemented using pgdir_walk, page_remove,
+// and page2pa.
+//
+    int
+page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
+{
+f0101aa0:	55                   	push   %ebp
+f0101aa1:	89 e5                	mov    %esp,%ebp
+f0101aa3:	53                   	push   %ebx
+f0101aa4:	83 ec 24             	sub    $0x24,%esp
+    // Fill this function in
+    pte_t *pte = pgdir_walk(pgdir, va, 1);
+f0101aa7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+f0101aae:	00 
+f0101aaf:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101ab2:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101ab6:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101ab9:	89 04 24             	mov    %eax,(%esp)
+f0101abc:	e8 be fe ff ff       	call   f010197f <pgdir_walk>
+f0101ac1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (pte == NULL) return -E_NO_MEM;
+f0101ac4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101ac8:	75 0a                	jne    f0101ad4 <page_insert+0x34>
+f0101aca:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+f0101acf:	e9 8e 00 00 00       	jmp    f0101b62 <page_insert+0xc2>
+    if (*pte & PTE_P) {
+f0101ad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101ad7:	8b 00                	mov    (%eax),%eax
+f0101ad9:	83 e0 01             	and    $0x1,%eax
+f0101adc:	85 c0                	test   %eax,%eax
+f0101ade:	74 52                	je     f0101b32 <page_insert+0x92>
+	if (PTE_ADDR(*pte) == page2pa(pp)) {
+f0101ae0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101ae3:	8b 00                	mov    (%eax),%eax
+f0101ae5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0101aea:	89 c3                	mov    %eax,%ebx
+f0101aec:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101aef:	89 04 24             	mov    %eax,(%esp)
+f0101af2:	e8 e8 f7 ff ff       	call   f01012df <page2pa>
+f0101af7:	39 c3                	cmp    %eax,%ebx
+f0101af9:	75 25                	jne    f0101b20 <page_insert+0x80>
+	    pp->pp_ref--;
+f0101afb:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101afe:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0101b02:	8d 50 ff             	lea    -0x1(%eax),%edx
+f0101b05:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101b08:	66 89 50 04          	mov    %dx,0x4(%eax)
+	    tlb_invalidate(pgdir, va);
+f0101b0c:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101b0f:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101b13:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101b16:	89 04 24             	mov    %eax,(%esp)
+f0101b19:	e8 1c 01 00 00       	call   f0101c3a <tlb_invalidate>
+f0101b1e:	eb 12                	jmp    f0101b32 <page_insert+0x92>
+	}
+	else {
+	    page_remove(pgdir, va);
+f0101b20:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101b23:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101b27:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101b2a:	89 04 24             	mov    %eax,(%esp)
+f0101b2d:	e8 94 00 00 00       	call   f0101bc6 <page_remove>
+	}
+    }
+    *pte = page2pa(pp) | perm | PTE_P;
+f0101b32:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101b35:	89 04 24             	mov    %eax,(%esp)
+f0101b38:	e8 a2 f7 ff ff       	call   f01012df <page2pa>
+f0101b3d:	8b 55 14             	mov    0x14(%ebp),%edx
+f0101b40:	09 d0                	or     %edx,%eax
+f0101b42:	83 c8 01             	or     $0x1,%eax
+f0101b45:	89 c2                	mov    %eax,%edx
+f0101b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101b4a:	89 10                	mov    %edx,(%eax)
+    pp->pp_ref++;
+f0101b4c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101b4f:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0101b53:	8d 50 01             	lea    0x1(%eax),%edx
+f0101b56:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101b59:	66 89 50 04          	mov    %dx,0x4(%eax)
+    return 0;
+f0101b5d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0101b62:	83 c4 24             	add    $0x24,%esp
+f0101b65:	5b                   	pop    %ebx
+f0101b66:	5d                   	pop    %ebp
+f0101b67:	c3                   	ret    
+
+f0101b68 <page_lookup>:
+//
+// Hint: the TA solution uses pgdir_walk and pa2page.
+//
+    struct PageInfo *
+page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
+{
+f0101b68:	55                   	push   %ebp
+f0101b69:	89 e5                	mov    %esp,%ebp
+f0101b6b:	83 ec 28             	sub    $0x28,%esp
+    // Fill this function in
+    pte_t *pte = pgdir_walk(pgdir, va, 0);
+f0101b6e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0101b75:	00 
+f0101b76:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101b79:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101b7d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101b80:	89 04 24             	mov    %eax,(%esp)
+f0101b83:	e8 f7 fd ff ff       	call   f010197f <pgdir_walk>
+f0101b88:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (pte_store != NULL) *pte_store = pte;
+f0101b8b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f0101b8f:	74 08                	je     f0101b99 <page_lookup+0x31>
+f0101b91:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101b94:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101b97:	89 10                	mov    %edx,(%eax)
+    if (pte == NULL || !(*pte & PTE_P)) return NULL;
+f0101b99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101b9d:	74 0c                	je     f0101bab <page_lookup+0x43>
+f0101b9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101ba2:	8b 00                	mov    (%eax),%eax
+f0101ba4:	83 e0 01             	and    $0x1,%eax
+f0101ba7:	85 c0                	test   %eax,%eax
+f0101ba9:	75 07                	jne    f0101bb2 <page_lookup+0x4a>
+f0101bab:	b8 00 00 00 00       	mov    $0x0,%eax
+f0101bb0:	eb 12                	jmp    f0101bc4 <page_lookup+0x5c>
+    return pa2page(PTE_ADDR(*pte));
+f0101bb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101bb5:	8b 00                	mov    (%eax),%eax
+f0101bb7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0101bbc:	89 04 24             	mov    %eax,(%esp)
+f0101bbf:	e8 32 f7 ff ff       	call   f01012f6 <pa2page>
+}
+f0101bc4:	c9                   	leave  
+f0101bc5:	c3                   	ret    
+
+f0101bc6 <page_remove>:
+// Hint: The TA solution is implemented using page_lookup,
+// 	tlb_invalidate, and page_decref.
+//
+    void
+page_remove(pde_t *pgdir, void *va)
+{
+f0101bc6:	55                   	push   %ebp
+f0101bc7:	89 e5                	mov    %esp,%ebp
+f0101bc9:	83 ec 28             	sub    $0x28,%esp
+    // Fill this function in
+    struct PageInfo *page = page_lookup(pgdir, va, 0);
+f0101bcc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0101bd3:	00 
+f0101bd4:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101bd7:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101bdb:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101bde:	89 04 24             	mov    %eax,(%esp)
+f0101be1:	e8 82 ff ff ff       	call   f0101b68 <page_lookup>
+f0101be6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    pte_t *pte = pgdir_walk(pgdir, va, 0);
+f0101be9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0101bf0:	00 
+f0101bf1:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101bf4:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101bf8:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101bfb:	89 04 24             	mov    %eax,(%esp)
+f0101bfe:	e8 7c fd ff ff       	call   f010197f <pgdir_walk>
+f0101c03:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (page != NULL) page_decref(page);
+f0101c06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101c0a:	74 0b                	je     f0101c17 <page_remove+0x51>
+f0101c0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101c0f:	89 04 24             	mov    %eax,(%esp)
+f0101c12:	e8 38 fd ff ff       	call   f010194f <page_decref>
+    if (pte != NULL) {
+f0101c17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0101c1b:	74 1b                	je     f0101c38 <page_remove+0x72>
+	*pte = 0;
+f0101c1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0101c20:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	tlb_invalidate(pgdir, va);
+f0101c26:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101c29:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101c2d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101c30:	89 04 24             	mov    %eax,(%esp)
+f0101c33:	e8 02 00 00 00       	call   f0101c3a <tlb_invalidate>
+    }
+}
+f0101c38:	c9                   	leave  
+f0101c39:	c3                   	ret    
+
+f0101c3a <tlb_invalidate>:
+// Invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+//
+    void
+tlb_invalidate(pde_t *pgdir, void *va)
+{
+f0101c3a:	55                   	push   %ebp
+f0101c3b:	89 e5                	mov    %esp,%ebp
+f0101c3d:	83 ec 04             	sub    $0x4,%esp
+    // Flush the entry only if we're modifying the current address space.
+    // For now, there is only one address space, so always invalidate.
+    invlpg(va);
+f0101c40:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101c43:	89 04 24             	mov    %eax,(%esp)
+f0101c46:	e8 e5 f5 ff ff       	call   f0101230 <invlpg>
+}
+f0101c4b:	c9                   	leave  
+f0101c4c:	c3                   	ret    
+
+f0101c4d <user_mem_check>:
+// Returns 0 if the user program can access this range of addresses,
+// and -E_FAULT otherwise.
+//
+    int
+user_mem_check(struct Env *env, const void *va, size_t len, int perm)
+{
+f0101c4d:	55                   	push   %ebp
+f0101c4e:	89 e5                	mov    %esp,%ebp
+f0101c50:	83 ec 28             	sub    $0x28,%esp
+    // LAB 3: Your code here.
+
+    uintptr_t va1 = (uintptr_t)va, va2 = va1 + len;
+f0101c53:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101c56:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101c59:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101c5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101c5f:	01 d0                	add    %edx,%eax
+f0101c61:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    pte_t *pte;
+    for (; va1 < va2; va1 = ROUNDDOWN(va1 + PGSIZE, PGSIZE)) {
+f0101c64:	eb 74                	jmp    f0101cda <user_mem_check+0x8d>
+	if (va1 >= ULIM) {
+f0101c66:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
+f0101c6d:	76 0f                	jbe    f0101c7e <user_mem_check+0x31>
+	    user_mem_check_addr = va1;
+f0101c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101c72:	a3 14 eb 18 f0       	mov    %eax,0xf018eb14
+	    return -E_FAULT;
+f0101c77:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
+f0101c7c:	eb 69                	jmp    f0101ce7 <user_mem_check+0x9a>
+	}
+	pte = pgdir_walk(env->env_pgdir, (void*)va1, 0);
+f0101c7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101c81:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101c84:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0101c87:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0101c8e:	00 
+f0101c8f:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0101c93:	89 04 24             	mov    %eax,(%esp)
+f0101c96:	e8 e4 fc ff ff       	call   f010197f <pgdir_walk>
+f0101c9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if ((*pte & (perm | PTE_P)) != (perm | PTE_P)) {
+f0101c9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0101ca1:	8b 10                	mov    (%eax),%edx
+f0101ca3:	8b 45 14             	mov    0x14(%ebp),%eax
+f0101ca6:	83 c8 01             	or     $0x1,%eax
+f0101ca9:	21 c2                	and    %eax,%edx
+f0101cab:	8b 45 14             	mov    0x14(%ebp),%eax
+f0101cae:	83 c8 01             	or     $0x1,%eax
+f0101cb1:	39 c2                	cmp    %eax,%edx
+f0101cb3:	74 0f                	je     f0101cc4 <user_mem_check+0x77>
+	    user_mem_check_addr = va1;
+f0101cb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101cb8:	a3 14 eb 18 f0       	mov    %eax,0xf018eb14
+	    return -E_FAULT;
+f0101cbd:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
+f0101cc2:	eb 23                	jmp    f0101ce7 <user_mem_check+0x9a>
+{
+    // LAB 3: Your code here.
+
+    uintptr_t va1 = (uintptr_t)va, va2 = va1 + len;
+    pte_t *pte;
+    for (; va1 < va2; va1 = ROUNDDOWN(va1 + PGSIZE, PGSIZE)) {
+f0101cc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101cc7:	05 00 10 00 00       	add    $0x1000,%eax
+f0101ccc:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f0101ccf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0101cd2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0101cd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101cda:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101cdd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+f0101ce0:	72 84                	jb     f0101c66 <user_mem_check+0x19>
+	if ((*pte & (perm | PTE_P)) != (perm | PTE_P)) {
+	    user_mem_check_addr = va1;
+	    return -E_FAULT;
+	}
+    }
+    return 0;
+f0101ce2:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0101ce7:	c9                   	leave  
+f0101ce8:	c3                   	ret    
+
+f0101ce9 <user_mem_assert>:
+// If it cannot, 'env' is destroyed and, if env is the current
+// environment, this function will not return.
+//
+    void
+user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
+{
+f0101ce9:	55                   	push   %ebp
+f0101cea:	89 e5                	mov    %esp,%ebp
+f0101cec:	83 ec 18             	sub    $0x18,%esp
+    if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
+f0101cef:	8b 45 14             	mov    0x14(%ebp),%eax
+f0101cf2:	83 c8 04             	or     $0x4,%eax
+f0101cf5:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0101cf9:	8b 45 10             	mov    0x10(%ebp),%eax
+f0101cfc:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0101d00:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0101d03:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101d07:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101d0a:	89 04 24             	mov    %eax,(%esp)
+f0101d0d:	e8 3b ff ff ff       	call   f0101c4d <user_mem_check>
+f0101d12:	85 c0                	test   %eax,%eax
+f0101d14:	79 2b                	jns    f0101d41 <user_mem_assert+0x58>
+	cprintf("[%08x] user_mem_check assertion failure for "
+f0101d16:	8b 15 14 eb 18 f0    	mov    0xf018eb14,%edx
+f0101d1c:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101d1f:	8b 40 48             	mov    0x48(%eax),%eax
+f0101d22:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0101d26:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0101d2a:	c7 04 24 70 71 10 f0 	movl   $0xf0107170,(%esp)
+f0101d31:	e8 57 2c 00 00       	call   f010498d <cprintf>
+		"va %08x\n", env->env_id, user_mem_check_addr);
+	env_destroy(env);	// may not return
+f0101d36:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101d39:	89 04 24             	mov    %eax,(%esp)
+f0101d3c:	e8 9f 2a 00 00       	call   f01047e0 <env_destroy>
+    }
+}
+f0101d41:	c9                   	leave  
+f0101d42:	c3                   	ret    
+
+f0101d43 <check_page_free_list>:
+//
+// Check that the pages on the page_free_list are reasonable.
+//
+    static void
+check_page_free_list(bool only_low_memory)
+{
+f0101d43:	55                   	push   %ebp
+f0101d44:	89 e5                	mov    %esp,%ebp
+f0101d46:	83 ec 58             	sub    $0x58,%esp
+f0101d49:	8b 45 08             	mov    0x8(%ebp),%eax
+f0101d4c:	88 45 c4             	mov    %al,-0x3c(%ebp)
+    struct PageInfo *pp;
+    unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
+f0101d4f:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
+f0101d53:	74 07                	je     f0101d5c <check_page_free_list+0x19>
+f0101d55:	b8 01 00 00 00       	mov    $0x1,%eax
+f0101d5a:	eb 05                	jmp    f0101d61 <check_page_free_list+0x1e>
+f0101d5c:	b8 00 04 00 00       	mov    $0x400,%eax
+f0101d61:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    int nfree_basemem = 0, nfree_extmem = 0;
+f0101d64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+f0101d6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+    char *first_free_page;
+
+    if (!page_free_list)
+f0101d72:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f0101d77:	85 c0                	test   %eax,%eax
+f0101d79:	75 1c                	jne    f0101d97 <check_page_free_list+0x54>
+	panic("'page_free_list' is a null pointer!");
+f0101d7b:	c7 44 24 08 a8 71 10 	movl   $0xf01071a8,0x8(%esp)
+f0101d82:	f0 
+f0101d83:	c7 44 24 04 50 02 00 	movl   $0x250,0x4(%esp)
+f0101d8a:	00 
+f0101d8b:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101d92:	e8 1e e3 ff ff       	call   f01000b5 <_panic>
+
+    if (only_low_memory) {
+f0101d97:	80 7d c4 00          	cmpb   $0x0,-0x3c(%ebp)
+f0101d9b:	74 6d                	je     f0101e0a <check_page_free_list+0xc7>
+	// Move pages with lower addresses first in the free
+	// list, since entry_pgdir does not map all pages.
+	struct PageInfo *pp1, *pp2;
+	struct PageInfo **tp[2] = { &pp1, &pp2 };
+f0101d9d:	8d 45 dc             	lea    -0x24(%ebp),%eax
+f0101da0:	89 45 d0             	mov    %eax,-0x30(%ebp)
+f0101da3:	8d 45 d8             	lea    -0x28(%ebp),%eax
+f0101da6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+	for (pp = page_free_list; pp; pp = pp->pp_link) {
+f0101da9:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f0101dae:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101db1:	eb 38                	jmp    f0101deb <check_page_free_list+0xa8>
+	    int pagetype = PDX(page2pa(pp)) >= pdx_limit;
+f0101db3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101db6:	89 04 24             	mov    %eax,(%esp)
+f0101db9:	e8 21 f5 ff ff       	call   f01012df <page2pa>
+f0101dbe:	c1 e8 16             	shr    $0x16,%eax
+f0101dc1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+f0101dc4:	0f 93 c0             	setae  %al
+f0101dc7:	0f b6 c0             	movzbl %al,%eax
+f0101dca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+	    *tp[pagetype] = pp;
+f0101dcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0101dd0:	8b 44 85 d0          	mov    -0x30(%ebp,%eax,4),%eax
+f0101dd4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101dd7:	89 10                	mov    %edx,(%eax)
+	    tp[pagetype] = &pp->pp_link;
+f0101dd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101ddc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0101ddf:	89 54 85 d0          	mov    %edx,-0x30(%ebp,%eax,4)
+    if (only_low_memory) {
+	// Move pages with lower addresses first in the free
+	// list, since entry_pgdir does not map all pages.
+	struct PageInfo *pp1, *pp2;
+	struct PageInfo **tp[2] = { &pp1, &pp2 };
+	for (pp = page_free_list; pp; pp = pp->pp_link) {
+f0101de3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101de6:	8b 00                	mov    (%eax),%eax
+f0101de8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101deb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101def:	75 c2                	jne    f0101db3 <check_page_free_list+0x70>
+	    int pagetype = PDX(page2pa(pp)) >= pdx_limit;
+	    *tp[pagetype] = pp;
+	    tp[pagetype] = &pp->pp_link;
+	}
+	*tp[1] = 0;
+f0101df1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+f0101df4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	*tp[0] = pp2;
+f0101dfa:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f0101dfd:	8b 55 d8             	mov    -0x28(%ebp),%edx
+f0101e00:	89 10                	mov    %edx,(%eax)
+	page_free_list = pp1;
+f0101e02:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f0101e05:	a3 10 eb 18 f0       	mov    %eax,0xf018eb10
+    }
+
+    // if there's a page that shouldn't be on the free list,
+    // try to make sure it eventually causes trouble.
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+f0101e0a:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f0101e0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101e12:	eb 3e                	jmp    f0101e52 <check_page_free_list+0x10f>
+	if (PDX(page2pa(pp)) < pdx_limit)
+f0101e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101e17:	89 04 24             	mov    %eax,(%esp)
+f0101e1a:	e8 c0 f4 ff ff       	call   f01012df <page2pa>
+f0101e1f:	c1 e8 16             	shr    $0x16,%eax
+f0101e22:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+f0101e25:	73 23                	jae    f0101e4a <check_page_free_list+0x107>
+	    memset(page2kva(pp), 0x97, 128);
+f0101e27:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101e2a:	89 04 24             	mov    %eax,(%esp)
+f0101e2d:	e8 09 f5 ff ff       	call   f010133b <page2kva>
+f0101e32:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
+f0101e39:	00 
+f0101e3a:	c7 44 24 04 97 00 00 	movl   $0x97,0x4(%esp)
+f0101e41:	00 
+f0101e42:	89 04 24             	mov    %eax,(%esp)
+f0101e45:	e8 98 46 00 00       	call   f01064e2 <memset>
+	page_free_list = pp1;
+    }
+
+    // if there's a page that shouldn't be on the free list,
+    // try to make sure it eventually causes trouble.
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+f0101e4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101e4d:	8b 00                	mov    (%eax),%eax
+f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101e52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0101e56:	75 bc                	jne    f0101e14 <check_page_free_list+0xd1>
+	if (PDX(page2pa(pp)) < pdx_limit)
+	    memset(page2kva(pp), 0x97, 128);
+
+    first_free_page = (char *) boot_alloc(0);
+f0101e58:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0101e5f:	e8 d1 f5 ff ff       	call   f0101435 <boot_alloc>
+f0101e64:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    for (pp = page_free_list; pp; pp = pp->pp_link) {
+f0101e67:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f0101e6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0101e6f:	e9 dd 01 00 00       	jmp    f0102051 <check_page_free_list+0x30e>
+	// check that we didn't corrupt the free list itself
+	assert(pp >= pages);
+f0101e74:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101e79:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+f0101e7c:	73 24                	jae    f0101ea2 <check_page_free_list+0x15f>
+f0101e7e:	c7 44 24 0c cc 71 10 	movl   $0xf01071cc,0xc(%esp)
+f0101e85:	f0 
+f0101e86:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101e8d:	f0 
+f0101e8e:	c7 44 24 04 6a 02 00 	movl   $0x26a,0x4(%esp)
+f0101e95:	00 
+f0101e96:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101e9d:	e8 13 e2 ff ff       	call   f01000b5 <_panic>
+	assert(pp < pages + npages);
+f0101ea2:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101ea7:	8b 15 d0 f7 18 f0    	mov    0xf018f7d0,%edx
+f0101ead:	c1 e2 03             	shl    $0x3,%edx
+f0101eb0:	01 d0                	add    %edx,%eax
+f0101eb2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+f0101eb5:	77 24                	ja     f0101edb <check_page_free_list+0x198>
+f0101eb7:	c7 44 24 0c d8 71 10 	movl   $0xf01071d8,0xc(%esp)
+f0101ebe:	f0 
+f0101ebf:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101ec6:	f0 
+f0101ec7:	c7 44 24 04 6b 02 00 	movl   $0x26b,0x4(%esp)
+f0101ece:	00 
+f0101ecf:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101ed6:	e8 da e1 ff ff       	call   f01000b5 <_panic>
+	assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
+f0101edb:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0101ede:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0101ee3:	29 c2                	sub    %eax,%edx
+f0101ee5:	89 d0                	mov    %edx,%eax
+f0101ee7:	83 e0 07             	and    $0x7,%eax
+f0101eea:	85 c0                	test   %eax,%eax
+f0101eec:	74 24                	je     f0101f12 <check_page_free_list+0x1cf>
+f0101eee:	c7 44 24 0c ec 71 10 	movl   $0xf01071ec,0xc(%esp)
+f0101ef5:	f0 
+f0101ef6:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101efd:	f0 
+f0101efe:	c7 44 24 04 6c 02 00 	movl   $0x26c,0x4(%esp)
+f0101f05:	00 
+f0101f06:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101f0d:	e8 a3 e1 ff ff       	call   f01000b5 <_panic>
+
+	// check a few pages that shouldn't be on the free list
+	assert(page2pa(pp) != 0);
+f0101f12:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101f15:	89 04 24             	mov    %eax,(%esp)
+f0101f18:	e8 c2 f3 ff ff       	call   f01012df <page2pa>
+f0101f1d:	85 c0                	test   %eax,%eax
+f0101f1f:	75 24                	jne    f0101f45 <check_page_free_list+0x202>
+f0101f21:	c7 44 24 0c 1e 72 10 	movl   $0xf010721e,0xc(%esp)
+f0101f28:	f0 
+f0101f29:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101f30:	f0 
+f0101f31:	c7 44 24 04 6f 02 00 	movl   $0x26f,0x4(%esp)
+f0101f38:	00 
+f0101f39:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101f40:	e8 70 e1 ff ff       	call   f01000b5 <_panic>
+	assert(page2pa(pp) != IOPHYSMEM);
+f0101f45:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101f48:	89 04 24             	mov    %eax,(%esp)
+f0101f4b:	e8 8f f3 ff ff       	call   f01012df <page2pa>
+f0101f50:	3d 00 00 0a 00       	cmp    $0xa0000,%eax
+f0101f55:	75 24                	jne    f0101f7b <check_page_free_list+0x238>
+f0101f57:	c7 44 24 0c 2f 72 10 	movl   $0xf010722f,0xc(%esp)
+f0101f5e:	f0 
+f0101f5f:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101f66:	f0 
+f0101f67:	c7 44 24 04 70 02 00 	movl   $0x270,0x4(%esp)
+f0101f6e:	00 
+f0101f6f:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101f76:	e8 3a e1 ff ff       	call   f01000b5 <_panic>
+	assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
+f0101f7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101f7e:	89 04 24             	mov    %eax,(%esp)
+f0101f81:	e8 59 f3 ff ff       	call   f01012df <page2pa>
+f0101f86:	3d 00 f0 0f 00       	cmp    $0xff000,%eax
+f0101f8b:	75 24                	jne    f0101fb1 <check_page_free_list+0x26e>
+f0101f8d:	c7 44 24 0c 48 72 10 	movl   $0xf0107248,0xc(%esp)
+f0101f94:	f0 
+f0101f95:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101f9c:	f0 
+f0101f9d:	c7 44 24 04 71 02 00 	movl   $0x271,0x4(%esp)
+f0101fa4:	00 
+f0101fa5:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101fac:	e8 04 e1 ff ff       	call   f01000b5 <_panic>
+	assert(page2pa(pp) != EXTPHYSMEM);
+f0101fb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101fb4:	89 04 24             	mov    %eax,(%esp)
+f0101fb7:	e8 23 f3 ff ff       	call   f01012df <page2pa>
+f0101fbc:	3d 00 00 10 00       	cmp    $0x100000,%eax
+f0101fc1:	75 24                	jne    f0101fe7 <check_page_free_list+0x2a4>
+f0101fc3:	c7 44 24 0c 6b 72 10 	movl   $0xf010726b,0xc(%esp)
+f0101fca:	f0 
+f0101fcb:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0101fd2:	f0 
+f0101fd3:	c7 44 24 04 72 02 00 	movl   $0x272,0x4(%esp)
+f0101fda:	00 
+f0101fdb:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0101fe2:	e8 ce e0 ff ff       	call   f01000b5 <_panic>
+	assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
+f0101fe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101fea:	89 04 24             	mov    %eax,(%esp)
+f0101fed:	e8 ed f2 ff ff       	call   f01012df <page2pa>
+f0101ff2:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
+f0101ff7:	76 34                	jbe    f010202d <check_page_free_list+0x2ea>
+f0101ff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0101ffc:	89 04 24             	mov    %eax,(%esp)
+f0101fff:	e8 37 f3 ff ff       	call   f010133b <page2kva>
+f0102004:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+f0102007:	73 24                	jae    f010202d <check_page_free_list+0x2ea>
+f0102009:	c7 44 24 0c 88 72 10 	movl   $0xf0107288,0xc(%esp)
+f0102010:	f0 
+f0102011:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102018:	f0 
+f0102019:	c7 44 24 04 73 02 00 	movl   $0x273,0x4(%esp)
+f0102020:	00 
+f0102021:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102028:	e8 88 e0 ff ff       	call   f01000b5 <_panic>
+
+	if (page2pa(pp) < EXTPHYSMEM)
+f010202d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102030:	89 04 24             	mov    %eax,(%esp)
+f0102033:	e8 a7 f2 ff ff       	call   f01012df <page2pa>
+f0102038:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
+f010203d:	77 06                	ja     f0102045 <check_page_free_list+0x302>
+	    ++nfree_basemem;
+f010203f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+f0102043:	eb 04                	jmp    f0102049 <check_page_free_list+0x306>
+	else
+	    ++nfree_extmem;
+f0102045:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+	if (PDX(page2pa(pp)) < pdx_limit)
+	    memset(page2kva(pp), 0x97, 128);
+
+    first_free_page = (char *) boot_alloc(0);
+    for (pp = page_free_list; pp; pp = pp->pp_link) {
+f0102049:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010204c:	8b 00                	mov    (%eax),%eax
+f010204e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0102051:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0102055:	0f 85 19 fe ff ff    	jne    f0101e74 <check_page_free_list+0x131>
+	    ++nfree_basemem;
+	else
+	    ++nfree_extmem;
+    }
+
+    assert(nfree_basemem > 0);
+f010205b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f010205f:	7f 24                	jg     f0102085 <check_page_free_list+0x342>
+f0102061:	c7 44 24 0c cd 72 10 	movl   $0xf01072cd,0xc(%esp)
+f0102068:	f0 
+f0102069:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102070:	f0 
+f0102071:	c7 44 24 04 7b 02 00 	movl   $0x27b,0x4(%esp)
+f0102078:	00 
+f0102079:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102080:	e8 30 e0 ff ff       	call   f01000b5 <_panic>
+    assert(nfree_extmem > 0);
+f0102085:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f0102089:	7f 24                	jg     f01020af <check_page_free_list+0x36c>
+f010208b:	c7 44 24 0c df 72 10 	movl   $0xf01072df,0xc(%esp)
+f0102092:	f0 
+f0102093:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010209a:	f0 
+f010209b:	c7 44 24 04 7c 02 00 	movl   $0x27c,0x4(%esp)
+f01020a2:	00 
+f01020a3:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01020aa:	e8 06 e0 ff ff       	call   f01000b5 <_panic>
+}
+f01020af:	c9                   	leave  
+f01020b0:	c3                   	ret    
+
+f01020b1 <check_page_alloc>:
+// Check the physical page allocator (page_alloc(), page_free(),
+// and page_init()).
+//
+    static void
+check_page_alloc(void)
+{
+f01020b1:	55                   	push   %ebp
+f01020b2:	89 e5                	mov    %esp,%ebp
+f01020b4:	83 ec 38             	sub    $0x38,%esp
+    int nfree;
+    struct PageInfo *fl;
+    char *c;
+    int i;
+
+    if (!pages)
+f01020b7:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01020bc:	85 c0                	test   %eax,%eax
+f01020be:	75 1c                	jne    f01020dc <check_page_alloc+0x2b>
+	panic("'pages' is a null pointer!");
+f01020c0:	c7 44 24 08 f0 72 10 	movl   $0xf01072f0,0x8(%esp)
+f01020c7:	f0 
+f01020c8:	c7 44 24 04 8d 02 00 	movl   $0x28d,0x4(%esp)
+f01020cf:	00 
+f01020d0:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01020d7:	e8 d9 df ff ff       	call   f01000b5 <_panic>
+
+    // check number of free pages
+    for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
+f01020dc:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f01020e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01020e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+f01020eb:	eb 0c                	jmp    f01020f9 <check_page_alloc+0x48>
+	++nfree;
+f01020ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+
+    if (!pages)
+	panic("'pages' is a null pointer!");
+
+    // check number of free pages
+    for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
+f01020f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01020f4:	8b 00                	mov    (%eax),%eax
+f01020f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01020f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f01020fd:	75 ee                	jne    f01020ed <check_page_alloc+0x3c>
+	++nfree;
+
+    // should be able to allocate three pages
+    pp0 = pp1 = pp2 = 0;
+f01020ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+f0102106:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102109:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f010210c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f010210f:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    assert((pp0 = page_alloc(0)));
+f0102112:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102119:	e8 89 f7 ff ff       	call   f01018a7 <page_alloc>
+f010211e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+f0102121:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0102125:	75 24                	jne    f010214b <check_page_alloc+0x9a>
+f0102127:	c7 44 24 0c 0b 73 10 	movl   $0xf010730b,0xc(%esp)
+f010212e:	f0 
+f010212f:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102136:	f0 
+f0102137:	c7 44 24 04 95 02 00 	movl   $0x295,0x4(%esp)
+f010213e:	00 
+f010213f:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102146:	e8 6a df ff ff       	call   f01000b5 <_panic>
+    assert((pp1 = page_alloc(0)));
+f010214b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102152:	e8 50 f7 ff ff       	call   f01018a7 <page_alloc>
+f0102157:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f010215a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f010215e:	75 24                	jne    f0102184 <check_page_alloc+0xd3>
+f0102160:	c7 44 24 0c 21 73 10 	movl   $0xf0107321,0xc(%esp)
+f0102167:	f0 
+f0102168:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010216f:	f0 
+f0102170:	c7 44 24 04 96 02 00 	movl   $0x296,0x4(%esp)
+f0102177:	00 
+f0102178:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010217f:	e8 31 df ff ff       	call   f01000b5 <_panic>
+    assert((pp2 = page_alloc(0)));
+f0102184:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f010218b:	e8 17 f7 ff ff       	call   f01018a7 <page_alloc>
+f0102190:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f0102193:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f0102197:	75 24                	jne    f01021bd <check_page_alloc+0x10c>
+f0102199:	c7 44 24 0c 37 73 10 	movl   $0xf0107337,0xc(%esp)
+f01021a0:	f0 
+f01021a1:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01021a8:	f0 
+f01021a9:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
+f01021b0:	00 
+f01021b1:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01021b8:	e8 f8 de ff ff       	call   f01000b5 <_panic>
+
+    assert(pp0);
+f01021bd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f01021c1:	75 24                	jne    f01021e7 <check_page_alloc+0x136>
+f01021c3:	c7 44 24 0c 4d 73 10 	movl   $0xf010734d,0xc(%esp)
+f01021ca:	f0 
+f01021cb:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01021d2:	f0 
+f01021d3:	c7 44 24 04 99 02 00 	movl   $0x299,0x4(%esp)
+f01021da:	00 
+f01021db:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01021e2:	e8 ce de ff ff       	call   f01000b5 <_panic>
+    assert(pp1 && pp1 != pp0);
+f01021e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f01021eb:	74 08                	je     f01021f5 <check_page_alloc+0x144>
+f01021ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f01021f0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+f01021f3:	75 24                	jne    f0102219 <check_page_alloc+0x168>
+f01021f5:	c7 44 24 0c 51 73 10 	movl   $0xf0107351,0xc(%esp)
+f01021fc:	f0 
+f01021fd:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102204:	f0 
+f0102205:	c7 44 24 04 9a 02 00 	movl   $0x29a,0x4(%esp)
+f010220c:	00 
+f010220d:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102214:	e8 9c de ff ff       	call   f01000b5 <_panic>
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+f0102219:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f010221d:	74 10                	je     f010222f <check_page_alloc+0x17e>
+f010221f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102222:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
+f0102225:	74 08                	je     f010222f <check_page_alloc+0x17e>
+f0102227:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010222a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+f010222d:	75 24                	jne    f0102253 <check_page_alloc+0x1a2>
+f010222f:	c7 44 24 0c 64 73 10 	movl   $0xf0107364,0xc(%esp)
+f0102236:	f0 
+f0102237:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010223e:	f0 
+f010223f:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
+f0102246:	00 
+f0102247:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010224e:	e8 62 de ff ff       	call   f01000b5 <_panic>
+    assert(page2pa(pp0) < npages*PGSIZE);
+f0102253:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0102256:	89 04 24             	mov    %eax,(%esp)
+f0102259:	e8 81 f0 ff ff       	call   f01012df <page2pa>
+f010225e:	8b 15 d0 f7 18 f0    	mov    0xf018f7d0,%edx
+f0102264:	c1 e2 0c             	shl    $0xc,%edx
+f0102267:	39 d0                	cmp    %edx,%eax
+f0102269:	72 24                	jb     f010228f <check_page_alloc+0x1de>
+f010226b:	c7 44 24 0c 84 73 10 	movl   $0xf0107384,0xc(%esp)
+f0102272:	f0 
+f0102273:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010227a:	f0 
+f010227b:	c7 44 24 04 9c 02 00 	movl   $0x29c,0x4(%esp)
+f0102282:	00 
+f0102283:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010228a:	e8 26 de ff ff       	call   f01000b5 <_panic>
+    assert(page2pa(pp1) < npages*PGSIZE);
+f010228f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0102292:	89 04 24             	mov    %eax,(%esp)
+f0102295:	e8 45 f0 ff ff       	call   f01012df <page2pa>
+f010229a:	8b 15 d0 f7 18 f0    	mov    0xf018f7d0,%edx
+f01022a0:	c1 e2 0c             	shl    $0xc,%edx
+f01022a3:	39 d0                	cmp    %edx,%eax
+f01022a5:	72 24                	jb     f01022cb <check_page_alloc+0x21a>
+f01022a7:	c7 44 24 0c a1 73 10 	movl   $0xf01073a1,0xc(%esp)
+f01022ae:	f0 
+f01022af:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01022b6:	f0 
+f01022b7:	c7 44 24 04 9d 02 00 	movl   $0x29d,0x4(%esp)
+f01022be:	00 
+f01022bf:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01022c6:	e8 ea dd ff ff       	call   f01000b5 <_panic>
+    assert(page2pa(pp2) < npages*PGSIZE);
+f01022cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f01022ce:	89 04 24             	mov    %eax,(%esp)
+f01022d1:	e8 09 f0 ff ff       	call   f01012df <page2pa>
+f01022d6:	8b 15 d0 f7 18 f0    	mov    0xf018f7d0,%edx
+f01022dc:	c1 e2 0c             	shl    $0xc,%edx
+f01022df:	39 d0                	cmp    %edx,%eax
+f01022e1:	72 24                	jb     f0102307 <check_page_alloc+0x256>
+f01022e3:	c7 44 24 0c be 73 10 	movl   $0xf01073be,0xc(%esp)
+f01022ea:	f0 
+f01022eb:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01022f2:	f0 
+f01022f3:	c7 44 24 04 9e 02 00 	movl   $0x29e,0x4(%esp)
+f01022fa:	00 
+f01022fb:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102302:	e8 ae dd ff ff       	call   f01000b5 <_panic>
+
+    // temporarily steal the rest of the free pages
+    fl = page_free_list;
+f0102307:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f010230c:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    page_free_list = 0;
+f010230f:	c7 05 10 eb 18 f0 00 	movl   $0x0,0xf018eb10
+f0102316:	00 00 00 
+
+    // should be no free memory
+    assert(!page_alloc(0));
+f0102319:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102320:	e8 82 f5 ff ff       	call   f01018a7 <page_alloc>
+f0102325:	85 c0                	test   %eax,%eax
+f0102327:	74 24                	je     f010234d <check_page_alloc+0x29c>
+f0102329:	c7 44 24 0c db 73 10 	movl   $0xf01073db,0xc(%esp)
+f0102330:	f0 
+f0102331:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102338:	f0 
+f0102339:	c7 44 24 04 a5 02 00 	movl   $0x2a5,0x4(%esp)
+f0102340:	00 
+f0102341:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102348:	e8 68 dd ff ff       	call   f01000b5 <_panic>
+
+    // free and re-allocate?
+    page_free(pp0);
+f010234d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0102350:	89 04 24             	mov    %eax,(%esp)
+f0102353:	e8 b2 f5 ff ff       	call   f010190a <page_free>
+    page_free(pp1);
+f0102358:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f010235b:	89 04 24             	mov    %eax,(%esp)
+f010235e:	e8 a7 f5 ff ff       	call   f010190a <page_free>
+    page_free(pp2);
+f0102363:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102366:	89 04 24             	mov    %eax,(%esp)
+f0102369:	e8 9c f5 ff ff       	call   f010190a <page_free>
+    pp0 = pp1 = pp2 = 0;
+f010236e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+f0102375:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102378:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f010237b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f010237e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    assert((pp0 = page_alloc(0)));
+f0102381:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102388:	e8 1a f5 ff ff       	call   f01018a7 <page_alloc>
+f010238d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+f0102390:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0102394:	75 24                	jne    f01023ba <check_page_alloc+0x309>
+f0102396:	c7 44 24 0c 0b 73 10 	movl   $0xf010730b,0xc(%esp)
+f010239d:	f0 
+f010239e:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01023a5:	f0 
+f01023a6:	c7 44 24 04 ac 02 00 	movl   $0x2ac,0x4(%esp)
+f01023ad:	00 
+f01023ae:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01023b5:	e8 fb dc ff ff       	call   f01000b5 <_panic>
+    assert((pp1 = page_alloc(0)));
+f01023ba:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f01023c1:	e8 e1 f4 ff ff       	call   f01018a7 <page_alloc>
+f01023c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f01023c9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f01023cd:	75 24                	jne    f01023f3 <check_page_alloc+0x342>
+f01023cf:	c7 44 24 0c 21 73 10 	movl   $0xf0107321,0xc(%esp)
+f01023d6:	f0 
+f01023d7:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01023de:	f0 
+f01023df:	c7 44 24 04 ad 02 00 	movl   $0x2ad,0x4(%esp)
+f01023e6:	00 
+f01023e7:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01023ee:	e8 c2 dc ff ff       	call   f01000b5 <_panic>
+    assert((pp2 = page_alloc(0)));
+f01023f3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f01023fa:	e8 a8 f4 ff ff       	call   f01018a7 <page_alloc>
+f01023ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f0102402:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f0102406:	75 24                	jne    f010242c <check_page_alloc+0x37b>
+f0102408:	c7 44 24 0c 37 73 10 	movl   $0xf0107337,0xc(%esp)
+f010240f:	f0 
+f0102410:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102417:	f0 
+f0102418:	c7 44 24 04 ae 02 00 	movl   $0x2ae,0x4(%esp)
+f010241f:	00 
+f0102420:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102427:	e8 89 dc ff ff       	call   f01000b5 <_panic>
+    assert(pp0);
+f010242c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0102430:	75 24                	jne    f0102456 <check_page_alloc+0x3a5>
+f0102432:	c7 44 24 0c 4d 73 10 	movl   $0xf010734d,0xc(%esp)
+f0102439:	f0 
+f010243a:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102441:	f0 
+f0102442:	c7 44 24 04 af 02 00 	movl   $0x2af,0x4(%esp)
+f0102449:	00 
+f010244a:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102451:	e8 5f dc ff ff       	call   f01000b5 <_panic>
+    assert(pp1 && pp1 != pp0);
+f0102456:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f010245a:	74 08                	je     f0102464 <check_page_alloc+0x3b3>
+f010245c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f010245f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+f0102462:	75 24                	jne    f0102488 <check_page_alloc+0x3d7>
+f0102464:	c7 44 24 0c 51 73 10 	movl   $0xf0107351,0xc(%esp)
+f010246b:	f0 
+f010246c:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102473:	f0 
+f0102474:	c7 44 24 04 b0 02 00 	movl   $0x2b0,0x4(%esp)
+f010247b:	00 
+f010247c:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102483:	e8 2d dc ff ff       	call   f01000b5 <_panic>
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+f0102488:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f010248c:	74 10                	je     f010249e <check_page_alloc+0x3ed>
+f010248e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102491:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
+f0102494:	74 08                	je     f010249e <check_page_alloc+0x3ed>
+f0102496:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102499:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+f010249c:	75 24                	jne    f01024c2 <check_page_alloc+0x411>
+f010249e:	c7 44 24 0c 64 73 10 	movl   $0xf0107364,0xc(%esp)
+f01024a5:	f0 
+f01024a6:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01024ad:	f0 
+f01024ae:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
+f01024b5:	00 
+f01024b6:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01024bd:	e8 f3 db ff ff       	call   f01000b5 <_panic>
+    assert(!page_alloc(0));
+f01024c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f01024c9:	e8 d9 f3 ff ff       	call   f01018a7 <page_alloc>
+f01024ce:	85 c0                	test   %eax,%eax
+f01024d0:	74 24                	je     f01024f6 <check_page_alloc+0x445>
+f01024d2:	c7 44 24 0c db 73 10 	movl   $0xf01073db,0xc(%esp)
+f01024d9:	f0 
+f01024da:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01024e1:	f0 
+f01024e2:	c7 44 24 04 b2 02 00 	movl   $0x2b2,0x4(%esp)
+f01024e9:	00 
+f01024ea:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01024f1:	e8 bf db ff ff       	call   f01000b5 <_panic>
+
+    // test flags
+    memset(page2kva(pp0), 1, PGSIZE);
+f01024f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f01024f9:	89 04 24             	mov    %eax,(%esp)
+f01024fc:	e8 3a ee ff ff       	call   f010133b <page2kva>
+f0102501:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0102508:	00 
+f0102509:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+f0102510:	00 
+f0102511:	89 04 24             	mov    %eax,(%esp)
+f0102514:	e8 c9 3f 00 00       	call   f01064e2 <memset>
+    page_free(pp0);
+f0102519:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f010251c:	89 04 24             	mov    %eax,(%esp)
+f010251f:	e8 e6 f3 ff ff       	call   f010190a <page_free>
+    assert((pp = page_alloc(ALLOC_ZERO)));
+f0102524:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+f010252b:	e8 77 f3 ff ff       	call   f01018a7 <page_alloc>
+f0102530:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0102533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0102537:	75 24                	jne    f010255d <check_page_alloc+0x4ac>
+f0102539:	c7 44 24 0c ea 73 10 	movl   $0xf01073ea,0xc(%esp)
+f0102540:	f0 
+f0102541:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102548:	f0 
+f0102549:	c7 44 24 04 b7 02 00 	movl   $0x2b7,0x4(%esp)
+f0102550:	00 
+f0102551:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102558:	e8 58 db ff ff       	call   f01000b5 <_panic>
+    assert(pp && pp0 == pp);
+f010255d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0102561:	74 08                	je     f010256b <check_page_alloc+0x4ba>
+f0102563:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0102566:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+f0102569:	74 24                	je     f010258f <check_page_alloc+0x4de>
+f010256b:	c7 44 24 0c 08 74 10 	movl   $0xf0107408,0xc(%esp)
+f0102572:	f0 
+f0102573:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010257a:	f0 
+f010257b:	c7 44 24 04 b8 02 00 	movl   $0x2b8,0x4(%esp)
+f0102582:	00 
+f0102583:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010258a:	e8 26 db ff ff       	call   f01000b5 <_panic>
+    c = page2kva(pp);
+f010258f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102592:	89 04 24             	mov    %eax,(%esp)
+f0102595:	e8 a1 ed ff ff       	call   f010133b <page2kva>
+f010259a:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    for (i = 0; i < PGSIZE; i++)
+f010259d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+f01025a4:	eb 37                	jmp    f01025dd <check_page_alloc+0x52c>
+	assert(c[i] == 0);
+f01025a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f01025a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f01025ac:	01 d0                	add    %edx,%eax
+f01025ae:	0f b6 00             	movzbl (%eax),%eax
+f01025b1:	84 c0                	test   %al,%al
+f01025b3:	74 24                	je     f01025d9 <check_page_alloc+0x528>
+f01025b5:	c7 44 24 0c 18 74 10 	movl   $0xf0107418,0xc(%esp)
+f01025bc:	f0 
+f01025bd:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01025c4:	f0 
+f01025c5:	c7 44 24 04 bb 02 00 	movl   $0x2bb,0x4(%esp)
+f01025cc:	00 
+f01025cd:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01025d4:	e8 dc da ff ff       	call   f01000b5 <_panic>
+    memset(page2kva(pp0), 1, PGSIZE);
+    page_free(pp0);
+    assert((pp = page_alloc(ALLOC_ZERO)));
+    assert(pp && pp0 == pp);
+    c = page2kva(pp);
+    for (i = 0; i < PGSIZE; i++)
+f01025d9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+f01025dd:	81 7d ec ff 0f 00 00 	cmpl   $0xfff,-0x14(%ebp)
+f01025e4:	7e c0                	jle    f01025a6 <check_page_alloc+0x4f5>
+	assert(c[i] == 0);
+
+    // give free list back
+    page_free_list = fl;
+f01025e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f01025e9:	a3 10 eb 18 f0       	mov    %eax,0xf018eb10
+
+    // free the pages we took
+    page_free(pp0);
+f01025ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f01025f1:	89 04 24             	mov    %eax,(%esp)
+f01025f4:	e8 11 f3 ff ff       	call   f010190a <page_free>
+    page_free(pp1);
+f01025f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f01025fc:	89 04 24             	mov    %eax,(%esp)
+f01025ff:	e8 06 f3 ff ff       	call   f010190a <page_free>
+    page_free(pp2);
+f0102604:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102607:	89 04 24             	mov    %eax,(%esp)
+f010260a:	e8 fb f2 ff ff       	call   f010190a <page_free>
+
+    // number of free pages should be the same
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+f010260f:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f0102614:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0102617:	eb 0c                	jmp    f0102625 <check_page_alloc+0x574>
+	--nfree;
+f0102619:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+
+    // number of free pages should be the same
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+f010261d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102620:	8b 00                	mov    (%eax),%eax
+f0102622:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0102625:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0102629:	75 ee                	jne    f0102619 <check_page_alloc+0x568>
+	--nfree;
+    assert(nfree == 0);
+f010262b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f010262f:	74 24                	je     f0102655 <check_page_alloc+0x5a4>
+f0102631:	c7 44 24 0c 22 74 10 	movl   $0xf0107422,0xc(%esp)
+f0102638:	f0 
+f0102639:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102640:	f0 
+f0102641:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
+f0102648:	00 
+f0102649:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102650:	e8 60 da ff ff       	call   f01000b5 <_panic>
+
+    cprintf("check_page_alloc() succeeded!\n");
+f0102655:	c7 04 24 30 74 10 f0 	movl   $0xf0107430,(%esp)
+f010265c:	e8 2c 23 00 00       	call   f010498d <cprintf>
+}
+f0102661:	c9                   	leave  
+f0102662:	c3                   	ret    
+
+f0102663 <check_kern_pgdir>:
+// but it is a pretty good sanity check.
+//
+
+    static void
+check_kern_pgdir(void)
+{
+f0102663:	55                   	push   %ebp
+f0102664:	89 e5                	mov    %esp,%ebp
+f0102666:	53                   	push   %ebx
+f0102667:	83 ec 34             	sub    $0x34,%esp
+    uint32_t i, n;
+    pde_t *pgdir;
+
+    pgdir = kern_pgdir;
+f010266a:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010266f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+    // check pages array
+    n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
+f0102672:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
+f0102679:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f010267e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+f0102685:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0102688:	01 d0                	add    %edx,%eax
+f010268a:	83 e8 01             	sub    $0x1,%eax
+f010268d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f0102690:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102693:	ba 00 00 00 00       	mov    $0x0,%edx
+f0102698:	f7 75 ec             	divl   -0x14(%ebp)
+f010269b:	89 d0                	mov    %edx,%eax
+f010269d:	8b 55 e8             	mov    -0x18(%ebp),%edx
+f01026a0:	29 c2                	sub    %eax,%edx
+f01026a2:	89 d0                	mov    %edx,%eax
+f01026a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for (i = 0; i < n; i += PGSIZE)
+f01026a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f01026ae:	eb 6a                	jmp    f010271a <check_kern_pgdir+0xb7>
+	assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+f01026b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01026b3:	2d 00 00 00 11       	sub    $0x11000000,%eax
+f01026b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01026bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01026bf:	89 04 24             	mov    %eax,(%esp)
+f01026c2:	e8 56 03 00 00       	call   f0102a1d <check_va2pa>
+f01026c7:	89 c3                	mov    %eax,%ebx
+f01026c9:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01026ce:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01026d2:	c7 44 24 04 e0 02 00 	movl   $0x2e0,0x4(%esp)
+f01026d9:	00 
+f01026da:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01026e1:	e8 7c eb ff ff       	call   f0101262 <_paddr>
+f01026e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01026e9:	01 d0                	add    %edx,%eax
+f01026eb:	39 c3                	cmp    %eax,%ebx
+f01026ed:	74 24                	je     f0102713 <check_kern_pgdir+0xb0>
+f01026ef:	c7 44 24 0c 50 74 10 	movl   $0xf0107450,0xc(%esp)
+f01026f6:	f0 
+f01026f7:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01026fe:	f0 
+f01026ff:	c7 44 24 04 e0 02 00 	movl   $0x2e0,0x4(%esp)
+f0102706:	00 
+f0102707:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010270e:	e8 a2 d9 ff ff       	call   f01000b5 <_panic>
+
+    pgdir = kern_pgdir;
+
+    // check pages array
+    n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+f0102713:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f010271a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010271d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
+f0102720:	72 8e                	jb     f01026b0 <check_kern_pgdir+0x4d>
+	assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+
+    // check envs array (new test for lab 3)
+    n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+f0102722:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
+f0102729:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f010272c:	05 ff 7f 01 00       	add    $0x17fff,%eax
+f0102731:	89 45 dc             	mov    %eax,-0x24(%ebp)
+f0102734:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f0102737:	ba 00 00 00 00       	mov    $0x0,%edx
+f010273c:	f7 75 e0             	divl   -0x20(%ebp)
+f010273f:	89 d0                	mov    %edx,%eax
+f0102741:	8b 55 dc             	mov    -0x24(%ebp),%edx
+f0102744:	29 c2                	sub    %eax,%edx
+f0102746:	89 d0                	mov    %edx,%eax
+f0102748:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for (i = 0; i < n; i += PGSIZE)
+f010274b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f0102752:	eb 6a                	jmp    f01027be <check_kern_pgdir+0x15b>
+	assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+f0102754:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102757:	2d 00 00 40 11       	sub    $0x11400000,%eax
+f010275c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0102760:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102763:	89 04 24             	mov    %eax,(%esp)
+f0102766:	e8 b2 02 00 00       	call   f0102a1d <check_va2pa>
+f010276b:	89 c3                	mov    %eax,%ebx
+f010276d:	a1 1c eb 18 f0       	mov    0xf018eb1c,%eax
+f0102772:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0102776:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
+f010277d:	00 
+f010277e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102785:	e8 d8 ea ff ff       	call   f0101262 <_paddr>
+f010278a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f010278d:	01 d0                	add    %edx,%eax
+f010278f:	39 c3                	cmp    %eax,%ebx
+f0102791:	74 24                	je     f01027b7 <check_kern_pgdir+0x154>
+f0102793:	c7 44 24 0c 84 74 10 	movl   $0xf0107484,0xc(%esp)
+f010279a:	f0 
+f010279b:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01027a2:	f0 
+f01027a3:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
+f01027aa:	00 
+f01027ab:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01027b2:	e8 fe d8 ff ff       	call   f01000b5 <_panic>
+    for (i = 0; i < n; i += PGSIZE)
+	assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+
+    // check envs array (new test for lab 3)
+    n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+f01027b7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f01027be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01027c1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
+f01027c4:	72 8e                	jb     f0102754 <check_kern_pgdir+0xf1>
+	assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+
+    // check phys mem
+    for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+f01027c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f01027cd:	eb 47                	jmp    f0102816 <check_kern_pgdir+0x1b3>
+	assert(check_va2pa(pgdir, KERNBASE + i) == i);
+f01027cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01027d2:	2d 00 00 00 10       	sub    $0x10000000,%eax
+f01027d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01027db:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01027de:	89 04 24             	mov    %eax,(%esp)
+f01027e1:	e8 37 02 00 00       	call   f0102a1d <check_va2pa>
+f01027e6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+f01027e9:	74 24                	je     f010280f <check_kern_pgdir+0x1ac>
+f01027eb:	c7 44 24 0c b8 74 10 	movl   $0xf01074b8,0xc(%esp)
+f01027f2:	f0 
+f01027f3:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01027fa:	f0 
+f01027fb:	c7 44 24 04 e9 02 00 	movl   $0x2e9,0x4(%esp)
+f0102802:	00 
+f0102803:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010280a:	e8 a6 d8 ff ff       	call   f01000b5 <_panic>
+    n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+	assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+
+    // check phys mem
+    for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+f010280f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f0102816:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f010281b:	c1 e0 0c             	shl    $0xc,%eax
+f010281e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+f0102821:	77 ac                	ja     f01027cf <check_kern_pgdir+0x16c>
+	assert(check_va2pa(pgdir, KERNBASE + i) == i);
+
+    // check kernel stack
+    for (i = 0; i < KSTKSIZE; i += PGSIZE)
+f0102823:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f010282a:	eb 69                	jmp    f0102895 <check_kern_pgdir+0x232>
+	assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
+f010282c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010282f:	2d 00 80 00 10       	sub    $0x10008000,%eax
+f0102834:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0102838:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010283b:	89 04 24             	mov    %eax,(%esp)
+f010283e:	e8 da 01 00 00       	call   f0102a1d <check_va2pa>
+f0102843:	89 c3                	mov    %eax,%ebx
+f0102845:	c7 44 24 08 00 50 11 	movl   $0xf0115000,0x8(%esp)
+f010284c:	f0 
+f010284d:	c7 44 24 04 ed 02 00 	movl   $0x2ed,0x4(%esp)
+f0102854:	00 
+f0102855:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010285c:	e8 01 ea ff ff       	call   f0101262 <_paddr>
+f0102861:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0102864:	01 d0                	add    %edx,%eax
+f0102866:	39 c3                	cmp    %eax,%ebx
+f0102868:	74 24                	je     f010288e <check_kern_pgdir+0x22b>
+f010286a:	c7 44 24 0c e0 74 10 	movl   $0xf01074e0,0xc(%esp)
+f0102871:	f0 
+f0102872:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102879:	f0 
+f010287a:	c7 44 24 04 ed 02 00 	movl   $0x2ed,0x4(%esp)
+f0102881:	00 
+f0102882:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102889:	e8 27 d8 ff ff       	call   f01000b5 <_panic>
+    // check phys mem
+    for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+	assert(check_va2pa(pgdir, KERNBASE + i) == i);
+
+    // check kernel stack
+    for (i = 0; i < KSTKSIZE; i += PGSIZE)
+f010288e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f0102895:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
+f010289c:	76 8e                	jbe    f010282c <check_kern_pgdir+0x1c9>
+	assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
+    assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);
+f010289e:	c7 44 24 04 00 00 c0 	movl   $0xefc00000,0x4(%esp)
+f01028a5:	ef 
+f01028a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01028a9:	89 04 24             	mov    %eax,(%esp)
+f01028ac:	e8 6c 01 00 00       	call   f0102a1d <check_va2pa>
+f01028b1:	83 f8 ff             	cmp    $0xffffffff,%eax
+f01028b4:	74 24                	je     f01028da <check_kern_pgdir+0x277>
+f01028b6:	c7 44 24 0c 28 75 10 	movl   $0xf0107528,0xc(%esp)
+f01028bd:	f0 
+f01028be:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01028c5:	f0 
+f01028c6:	c7 44 24 04 ee 02 00 	movl   $0x2ee,0x4(%esp)
+f01028cd:	00 
+f01028ce:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01028d5:	e8 db d7 ff ff       	call   f01000b5 <_panic>
+
+    // check PDE permissions
+    for (i = 0; i < NPDENTRIES; i++) {
+f01028da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f01028e1:	e9 18 01 00 00       	jmp    f01029fe <check_kern_pgdir+0x39b>
+	switch (i) {
+f01028e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01028e9:	3d bb 03 00 00       	cmp    $0x3bb,%eax
+f01028ee:	72 4f                	jb     f010293f <check_kern_pgdir+0x2dc>
+f01028f0:	3d bd 03 00 00       	cmp    $0x3bd,%eax
+f01028f5:	76 07                	jbe    f01028fe <check_kern_pgdir+0x29b>
+f01028f7:	3d bf 03 00 00       	cmp    $0x3bf,%eax
+f01028fc:	75 41                	jne    f010293f <check_kern_pgdir+0x2dc>
+	    case PDX(UVPT):
+	    case PDX(KSTACKTOP-1):
+	    case PDX(UPAGES):
+	    case PDX(UENVS):
+		assert(pgdir[i] & PTE_P);
+f01028fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102901:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0102908:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010290b:	01 d0                	add    %edx,%eax
+f010290d:	8b 00                	mov    (%eax),%eax
+f010290f:	83 e0 01             	and    $0x1,%eax
+f0102912:	85 c0                	test   %eax,%eax
+f0102914:	75 24                	jne    f010293a <check_kern_pgdir+0x2d7>
+f0102916:	c7 44 24 0c 55 75 10 	movl   $0xf0107555,0xc(%esp)
+f010291d:	f0 
+f010291e:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102925:	f0 
+f0102926:	c7 44 24 04 f7 02 00 	movl   $0x2f7,0x4(%esp)
+f010292d:	00 
+f010292e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102935:	e8 7b d7 ff ff       	call   f01000b5 <_panic>
+		break;
+f010293a:	e9 bb 00 00 00       	jmp    f01029fa <check_kern_pgdir+0x397>
+	    default:
+		if (i >= PDX(KERNBASE)) {
+f010293f:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
+f0102946:	76 78                	jbe    f01029c0 <check_kern_pgdir+0x35d>
+		    assert(pgdir[i] & PTE_P);
+f0102948:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010294b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0102952:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102955:	01 d0                	add    %edx,%eax
+f0102957:	8b 00                	mov    (%eax),%eax
+f0102959:	83 e0 01             	and    $0x1,%eax
+f010295c:	85 c0                	test   %eax,%eax
+f010295e:	75 24                	jne    f0102984 <check_kern_pgdir+0x321>
+f0102960:	c7 44 24 0c 55 75 10 	movl   $0xf0107555,0xc(%esp)
+f0102967:	f0 
+f0102968:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010296f:	f0 
+f0102970:	c7 44 24 04 fb 02 00 	movl   $0x2fb,0x4(%esp)
+f0102977:	00 
+f0102978:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010297f:	e8 31 d7 ff ff       	call   f01000b5 <_panic>
+		    assert(pgdir[i] & PTE_W);
+f0102984:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102987:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f010298e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102991:	01 d0                	add    %edx,%eax
+f0102993:	8b 00                	mov    (%eax),%eax
+f0102995:	83 e0 02             	and    $0x2,%eax
+f0102998:	85 c0                	test   %eax,%eax
+f010299a:	75 5d                	jne    f01029f9 <check_kern_pgdir+0x396>
+f010299c:	c7 44 24 0c 66 75 10 	movl   $0xf0107566,0xc(%esp)
+f01029a3:	f0 
+f01029a4:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01029ab:	f0 
+f01029ac:	c7 44 24 04 fc 02 00 	movl   $0x2fc,0x4(%esp)
+f01029b3:	00 
+f01029b4:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01029bb:	e8 f5 d6 ff ff       	call   f01000b5 <_panic>
+		} else
+		    assert(pgdir[i] == 0);
+f01029c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01029c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f01029ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01029cd:	01 d0                	add    %edx,%eax
+f01029cf:	8b 00                	mov    (%eax),%eax
+f01029d1:	85 c0                	test   %eax,%eax
+f01029d3:	74 24                	je     f01029f9 <check_kern_pgdir+0x396>
+f01029d5:	c7 44 24 0c 77 75 10 	movl   $0xf0107577,0xc(%esp)
+f01029dc:	f0 
+f01029dd:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01029e4:	f0 
+f01029e5:	c7 44 24 04 fe 02 00 	movl   $0x2fe,0x4(%esp)
+f01029ec:	00 
+f01029ed:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01029f4:	e8 bc d6 ff ff       	call   f01000b5 <_panic>
+		break;
+f01029f9:	90                   	nop
+    for (i = 0; i < KSTKSIZE; i += PGSIZE)
+	assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
+    assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);
+
+    // check PDE permissions
+    for (i = 0; i < NPDENTRIES; i++) {
+f01029fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f01029fe:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
+f0102a05:	0f 86 db fe ff ff    	jbe    f01028e6 <check_kern_pgdir+0x283>
+		} else
+		    assert(pgdir[i] == 0);
+		break;
+	}
+    }
+    cprintf("check_kern_pgdir() succeeded!\n");
+f0102a0b:	c7 04 24 88 75 10 f0 	movl   $0xf0107588,(%esp)
+f0102a12:	e8 76 1f 00 00       	call   f010498d <cprintf>
+}
+f0102a17:	83 c4 34             	add    $0x34,%esp
+f0102a1a:	5b                   	pop    %ebx
+f0102a1b:	5d                   	pop    %ebp
+f0102a1c:	c3                   	ret    
+
+f0102a1d <check_va2pa>:
+// this functionality for us!  We define our own version to help check
+// the check_kern_pgdir() function; it shouldn't be used elsewhere.
+
+    static physaddr_t
+check_va2pa(pde_t *pgdir, uintptr_t va)
+{
+f0102a1d:	55                   	push   %ebp
+f0102a1e:	89 e5                	mov    %esp,%ebp
+f0102a20:	83 ec 28             	sub    $0x28,%esp
+    pte_t *p;
+
+    pgdir = &pgdir[PDX(va)];
+f0102a23:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0102a26:	c1 e8 16             	shr    $0x16,%eax
+f0102a29:	c1 e0 02             	shl    $0x2,%eax
+f0102a2c:	01 45 08             	add    %eax,0x8(%ebp)
+    if (!(*pgdir & PTE_P))
+f0102a2f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0102a32:	8b 00                	mov    (%eax),%eax
+f0102a34:	83 e0 01             	and    $0x1,%eax
+f0102a37:	85 c0                	test   %eax,%eax
+f0102a39:	75 07                	jne    f0102a42 <check_va2pa+0x25>
+	return ~0;
+f0102a3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f0102a40:	eb 6a                	jmp    f0102aac <check_va2pa+0x8f>
+    p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
+f0102a42:	8b 45 08             	mov    0x8(%ebp),%eax
+f0102a45:	8b 00                	mov    (%eax),%eax
+f0102a47:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0102a4c:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0102a50:	c7 44 24 04 12 03 00 	movl   $0x312,0x4(%esp)
+f0102a57:	00 
+f0102a58:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102a5f:	e8 39 e8 ff ff       	call   f010129d <_kaddr>
+f0102a64:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (!(p[PTX(va)] & PTE_P))
+f0102a67:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0102a6a:	c1 e8 0c             	shr    $0xc,%eax
+f0102a6d:	25 ff 03 00 00       	and    $0x3ff,%eax
+f0102a72:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0102a79:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102a7c:	01 d0                	add    %edx,%eax
+f0102a7e:	8b 00                	mov    (%eax),%eax
+f0102a80:	83 e0 01             	and    $0x1,%eax
+f0102a83:	85 c0                	test   %eax,%eax
+f0102a85:	75 07                	jne    f0102a8e <check_va2pa+0x71>
+	return ~0;
+f0102a87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f0102a8c:	eb 1e                	jmp    f0102aac <check_va2pa+0x8f>
+    return PTE_ADDR(p[PTX(va)]);
+f0102a8e:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0102a91:	c1 e8 0c             	shr    $0xc,%eax
+f0102a94:	25 ff 03 00 00       	and    $0x3ff,%eax
+f0102a99:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f0102aa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0102aa3:	01 d0                	add    %edx,%eax
+f0102aa5:	8b 00                	mov    (%eax),%eax
+f0102aa7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+}
+f0102aac:	c9                   	leave  
+f0102aad:	c3                   	ret    
+
+f0102aae <check_page>:
+
+
+// check page_insert, page_remove, &c
+    static void
+check_page(void)
+{
+f0102aae:	55                   	push   %ebp
+f0102aaf:	89 e5                	mov    %esp,%ebp
+f0102ab1:	53                   	push   %ebx
+f0102ab2:	83 ec 44             	sub    $0x44,%esp
+    void *va;
+    int i;
+    extern pde_t entry_pgdir[];
+
+    // should be able to allocate three pages
+    pp0 = pp1 = pp2 = 0;
+f0102ab5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+f0102abc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102abf:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f0102ac2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0102ac5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    assert((pp0 = page_alloc(0)));
+f0102ac8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102acf:	e8 d3 ed ff ff       	call   f01018a7 <page_alloc>
+f0102ad4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+f0102ad7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f0102adb:	75 24                	jne    f0102b01 <check_page+0x53>
+f0102add:	c7 44 24 0c 0b 73 10 	movl   $0xf010730b,0xc(%esp)
+f0102ae4:	f0 
+f0102ae5:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102aec:	f0 
+f0102aed:	c7 44 24 04 26 03 00 	movl   $0x326,0x4(%esp)
+f0102af4:	00 
+f0102af5:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102afc:	e8 b4 d5 ff ff       	call   f01000b5 <_panic>
+    assert((pp1 = page_alloc(0)));
+f0102b01:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102b08:	e8 9a ed ff ff       	call   f01018a7 <page_alloc>
+f0102b0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f0102b10:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f0102b14:	75 24                	jne    f0102b3a <check_page+0x8c>
+f0102b16:	c7 44 24 0c 21 73 10 	movl   $0xf0107321,0xc(%esp)
+f0102b1d:	f0 
+f0102b1e:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102b25:	f0 
+f0102b26:	c7 44 24 04 27 03 00 	movl   $0x327,0x4(%esp)
+f0102b2d:	00 
+f0102b2e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102b35:	e8 7b d5 ff ff       	call   f01000b5 <_panic>
+    assert((pp2 = page_alloc(0)));
+f0102b3a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102b41:	e8 61 ed ff ff       	call   f01018a7 <page_alloc>
+f0102b46:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0102b49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0102b4d:	75 24                	jne    f0102b73 <check_page+0xc5>
+f0102b4f:	c7 44 24 0c 37 73 10 	movl   $0xf0107337,0xc(%esp)
+f0102b56:	f0 
+f0102b57:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102b5e:	f0 
+f0102b5f:	c7 44 24 04 28 03 00 	movl   $0x328,0x4(%esp)
+f0102b66:	00 
+f0102b67:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102b6e:	e8 42 d5 ff ff       	call   f01000b5 <_panic>
+
+    assert(pp0);
+f0102b73:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+f0102b77:	75 24                	jne    f0102b9d <check_page+0xef>
+f0102b79:	c7 44 24 0c 4d 73 10 	movl   $0xf010734d,0xc(%esp)
+f0102b80:	f0 
+f0102b81:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102b88:	f0 
+f0102b89:	c7 44 24 04 2a 03 00 	movl   $0x32a,0x4(%esp)
+f0102b90:	00 
+f0102b91:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102b98:	e8 18 d5 ff ff       	call   f01000b5 <_panic>
+    assert(pp1 && pp1 != pp0);
+f0102b9d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f0102ba1:	74 08                	je     f0102bab <check_page+0xfd>
+f0102ba3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0102ba6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+f0102ba9:	75 24                	jne    f0102bcf <check_page+0x121>
+f0102bab:	c7 44 24 0c 51 73 10 	movl   $0xf0107351,0xc(%esp)
+f0102bb2:	f0 
+f0102bb3:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102bba:	f0 
+f0102bbb:	c7 44 24 04 2b 03 00 	movl   $0x32b,0x4(%esp)
+f0102bc2:	00 
+f0102bc3:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102bca:	e8 e6 d4 ff ff       	call   f01000b5 <_panic>
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+f0102bcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0102bd3:	74 10                	je     f0102be5 <check_page+0x137>
+f0102bd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102bd8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+f0102bdb:	74 08                	je     f0102be5 <check_page+0x137>
+f0102bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102be0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+f0102be3:	75 24                	jne    f0102c09 <check_page+0x15b>
+f0102be5:	c7 44 24 0c 64 73 10 	movl   $0xf0107364,0xc(%esp)
+f0102bec:	f0 
+f0102bed:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102bf4:	f0 
+f0102bf5:	c7 44 24 04 2c 03 00 	movl   $0x32c,0x4(%esp)
+f0102bfc:	00 
+f0102bfd:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102c04:	e8 ac d4 ff ff       	call   f01000b5 <_panic>
+
+    // temporarily steal the rest of the free pages
+    fl = page_free_list;
+f0102c09:	a1 10 eb 18 f0       	mov    0xf018eb10,%eax
+f0102c0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    page_free_list = 0;
+f0102c11:	c7 05 10 eb 18 f0 00 	movl   $0x0,0xf018eb10
+f0102c18:	00 00 00 
+
+    // should be no free memory
+    assert(!page_alloc(0));
+f0102c1b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102c22:	e8 80 ec ff ff       	call   f01018a7 <page_alloc>
+f0102c27:	85 c0                	test   %eax,%eax
+f0102c29:	74 24                	je     f0102c4f <check_page+0x1a1>
+f0102c2b:	c7 44 24 0c db 73 10 	movl   $0xf01073db,0xc(%esp)
+f0102c32:	f0 
+f0102c33:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102c3a:	f0 
+f0102c3b:	c7 44 24 04 33 03 00 	movl   $0x333,0x4(%esp)
+f0102c42:	00 
+f0102c43:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102c4a:	e8 66 d4 ff ff       	call   f01000b5 <_panic>
+
+    // there is no page allocated at address 0
+    assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
+f0102c4f:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102c54:	8d 55 d4             	lea    -0x2c(%ebp),%edx
+f0102c57:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0102c5b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0102c62:	00 
+f0102c63:	89 04 24             	mov    %eax,(%esp)
+f0102c66:	e8 fd ee ff ff       	call   f0101b68 <page_lookup>
+f0102c6b:	85 c0                	test   %eax,%eax
+f0102c6d:	74 24                	je     f0102c93 <check_page+0x1e5>
+f0102c6f:	c7 44 24 0c a8 75 10 	movl   $0xf01075a8,0xc(%esp)
+f0102c76:	f0 
+f0102c77:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102c7e:	f0 
+f0102c7f:	c7 44 24 04 36 03 00 	movl   $0x336,0x4(%esp)
+f0102c86:	00 
+f0102c87:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102c8e:	e8 22 d4 ff ff       	call   f01000b5 <_panic>
+
+    // there is no free memory, so we can't allocate a page table
+    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
+f0102c93:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102c98:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0102c9f:	00 
+f0102ca0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0102ca7:	00 
+f0102ca8:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0102cab:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0102caf:	89 04 24             	mov    %eax,(%esp)
+f0102cb2:	e8 e9 ed ff ff       	call   f0101aa0 <page_insert>
+f0102cb7:	85 c0                	test   %eax,%eax
+f0102cb9:	78 24                	js     f0102cdf <check_page+0x231>
+f0102cbb:	c7 44 24 0c e0 75 10 	movl   $0xf01075e0,0xc(%esp)
+f0102cc2:	f0 
+f0102cc3:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102cca:	f0 
+f0102ccb:	c7 44 24 04 39 03 00 	movl   $0x339,0x4(%esp)
+f0102cd2:	00 
+f0102cd3:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102cda:	e8 d6 d3 ff ff       	call   f01000b5 <_panic>
+
+    // free pp0 and try again: pp0 should be used for page table
+    page_free(pp0);
+f0102cdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102ce2:	89 04 24             	mov    %eax,(%esp)
+f0102ce5:	e8 20 ec ff ff       	call   f010190a <page_free>
+    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
+f0102cea:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102cef:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0102cf6:	00 
+f0102cf7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0102cfe:	00 
+f0102cff:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0102d02:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0102d06:	89 04 24             	mov    %eax,(%esp)
+f0102d09:	e8 92 ed ff ff       	call   f0101aa0 <page_insert>
+f0102d0e:	85 c0                	test   %eax,%eax
+f0102d10:	74 24                	je     f0102d36 <check_page+0x288>
+f0102d12:	c7 44 24 0c 10 76 10 	movl   $0xf0107610,0xc(%esp)
+f0102d19:	f0 
+f0102d1a:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102d21:	f0 
+f0102d22:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
+f0102d29:	00 
+f0102d2a:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102d31:	e8 7f d3 ff ff       	call   f01000b5 <_panic>
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+f0102d36:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102d3b:	8b 00                	mov    (%eax),%eax
+f0102d3d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0102d42:	89 c3                	mov    %eax,%ebx
+f0102d44:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102d47:	89 04 24             	mov    %eax,(%esp)
+f0102d4a:	e8 90 e5 ff ff       	call   f01012df <page2pa>
+f0102d4f:	39 c3                	cmp    %eax,%ebx
+f0102d51:	74 24                	je     f0102d77 <check_page+0x2c9>
+f0102d53:	c7 44 24 0c 40 76 10 	movl   $0xf0107640,0xc(%esp)
+f0102d5a:	f0 
+f0102d5b:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102d62:	f0 
+f0102d63:	c7 44 24 04 3e 03 00 	movl   $0x33e,0x4(%esp)
+f0102d6a:	00 
+f0102d6b:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102d72:	e8 3e d3 ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
+f0102d77:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102d7c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0102d83:	00 
+f0102d84:	89 04 24             	mov    %eax,(%esp)
+f0102d87:	e8 91 fc ff ff       	call   f0102a1d <check_va2pa>
+f0102d8c:	89 c3                	mov    %eax,%ebx
+f0102d8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0102d91:	89 04 24             	mov    %eax,(%esp)
+f0102d94:	e8 46 e5 ff ff       	call   f01012df <page2pa>
+f0102d99:	39 c3                	cmp    %eax,%ebx
+f0102d9b:	74 24                	je     f0102dc1 <check_page+0x313>
+f0102d9d:	c7 44 24 0c 68 76 10 	movl   $0xf0107668,0xc(%esp)
+f0102da4:	f0 
+f0102da5:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102dac:	f0 
+f0102dad:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
+f0102db4:	00 
+f0102db5:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102dbc:	e8 f4 d2 ff ff       	call   f01000b5 <_panic>
+    assert(pp1->pp_ref == 1);
+f0102dc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0102dc4:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0102dc8:	66 83 f8 01          	cmp    $0x1,%ax
+f0102dcc:	74 24                	je     f0102df2 <check_page+0x344>
+f0102dce:	c7 44 24 0c 95 76 10 	movl   $0xf0107695,0xc(%esp)
+f0102dd5:	f0 
+f0102dd6:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102ddd:	f0 
+f0102dde:	c7 44 24 04 40 03 00 	movl   $0x340,0x4(%esp)
+f0102de5:	00 
+f0102de6:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102ded:	e8 c3 d2 ff ff       	call   f01000b5 <_panic>
+    assert(pp0->pp_ref == 1);
+f0102df2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0102df5:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0102df9:	66 83 f8 01          	cmp    $0x1,%ax
+f0102dfd:	74 24                	je     f0102e23 <check_page+0x375>
+f0102dff:	c7 44 24 0c a6 76 10 	movl   $0xf01076a6,0xc(%esp)
+f0102e06:	f0 
+f0102e07:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102e0e:	f0 
+f0102e0f:	c7 44 24 04 41 03 00 	movl   $0x341,0x4(%esp)
+f0102e16:	00 
+f0102e17:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102e1e:	e8 92 d2 ff ff       	call   f01000b5 <_panic>
+
+    // should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+f0102e23:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102e28:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0102e2f:	00 
+f0102e30:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0102e37:	00 
+f0102e38:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0102e3b:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0102e3f:	89 04 24             	mov    %eax,(%esp)
+f0102e42:	e8 59 ec ff ff       	call   f0101aa0 <page_insert>
+f0102e47:	85 c0                	test   %eax,%eax
+f0102e49:	74 24                	je     f0102e6f <check_page+0x3c1>
+f0102e4b:	c7 44 24 0c b8 76 10 	movl   $0xf01076b8,0xc(%esp)
+f0102e52:	f0 
+f0102e53:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102e5a:	f0 
+f0102e5b:	c7 44 24 04 44 03 00 	movl   $0x344,0x4(%esp)
+f0102e62:	00 
+f0102e63:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102e6a:	e8 46 d2 ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+f0102e6f:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102e74:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0102e7b:	00 
+f0102e7c:	89 04 24             	mov    %eax,(%esp)
+f0102e7f:	e8 99 fb ff ff       	call   f0102a1d <check_va2pa>
+f0102e84:	89 c3                	mov    %eax,%ebx
+f0102e86:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102e89:	89 04 24             	mov    %eax,(%esp)
+f0102e8c:	e8 4e e4 ff ff       	call   f01012df <page2pa>
+f0102e91:	39 c3                	cmp    %eax,%ebx
+f0102e93:	74 24                	je     f0102eb9 <check_page+0x40b>
+f0102e95:	c7 44 24 0c f4 76 10 	movl   $0xf01076f4,0xc(%esp)
+f0102e9c:	f0 
+f0102e9d:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102ea4:	f0 
+f0102ea5:	c7 44 24 04 45 03 00 	movl   $0x345,0x4(%esp)
+f0102eac:	00 
+f0102ead:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102eb4:	e8 fc d1 ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 1);
+f0102eb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102ebc:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0102ec0:	66 83 f8 01          	cmp    $0x1,%ax
+f0102ec4:	74 24                	je     f0102eea <check_page+0x43c>
+f0102ec6:	c7 44 24 0c 24 77 10 	movl   $0xf0107724,0xc(%esp)
+f0102ecd:	f0 
+f0102ece:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102ed5:	f0 
+f0102ed6:	c7 44 24 04 46 03 00 	movl   $0x346,0x4(%esp)
+f0102edd:	00 
+f0102ede:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102ee5:	e8 cb d1 ff ff       	call   f01000b5 <_panic>
+
+    // should be no free memory
+    assert(!page_alloc(0));
+f0102eea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102ef1:	e8 b1 e9 ff ff       	call   f01018a7 <page_alloc>
+f0102ef6:	85 c0                	test   %eax,%eax
+f0102ef8:	74 24                	je     f0102f1e <check_page+0x470>
+f0102efa:	c7 44 24 0c db 73 10 	movl   $0xf01073db,0xc(%esp)
+f0102f01:	f0 
+f0102f02:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102f09:	f0 
+f0102f0a:	c7 44 24 04 49 03 00 	movl   $0x349,0x4(%esp)
+f0102f11:	00 
+f0102f12:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102f19:	e8 97 d1 ff ff       	call   f01000b5 <_panic>
+
+    // should be able to map pp2 at PGSIZE because it's already there
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+f0102f1e:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102f23:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0102f2a:	00 
+f0102f2b:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0102f32:	00 
+f0102f33:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0102f36:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0102f3a:	89 04 24             	mov    %eax,(%esp)
+f0102f3d:	e8 5e eb ff ff       	call   f0101aa0 <page_insert>
+f0102f42:	85 c0                	test   %eax,%eax
+f0102f44:	74 24                	je     f0102f6a <check_page+0x4bc>
+f0102f46:	c7 44 24 0c b8 76 10 	movl   $0xf01076b8,0xc(%esp)
+f0102f4d:	f0 
+f0102f4e:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102f55:	f0 
+f0102f56:	c7 44 24 04 4c 03 00 	movl   $0x34c,0x4(%esp)
+f0102f5d:	00 
+f0102f5e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102f65:	e8 4b d1 ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+f0102f6a:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0102f6f:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0102f76:	00 
+f0102f77:	89 04 24             	mov    %eax,(%esp)
+f0102f7a:	e8 9e fa ff ff       	call   f0102a1d <check_va2pa>
+f0102f7f:	89 c3                	mov    %eax,%ebx
+f0102f81:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102f84:	89 04 24             	mov    %eax,(%esp)
+f0102f87:	e8 53 e3 ff ff       	call   f01012df <page2pa>
+f0102f8c:	39 c3                	cmp    %eax,%ebx
+f0102f8e:	74 24                	je     f0102fb4 <check_page+0x506>
+f0102f90:	c7 44 24 0c f4 76 10 	movl   $0xf01076f4,0xc(%esp)
+f0102f97:	f0 
+f0102f98:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102f9f:	f0 
+f0102fa0:	c7 44 24 04 4d 03 00 	movl   $0x34d,0x4(%esp)
+f0102fa7:	00 
+f0102fa8:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102faf:	e8 01 d1 ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 1);
+f0102fb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0102fb7:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0102fbb:	66 83 f8 01          	cmp    $0x1,%ax
+f0102fbf:	74 24                	je     f0102fe5 <check_page+0x537>
+f0102fc1:	c7 44 24 0c 24 77 10 	movl   $0xf0107724,0xc(%esp)
+f0102fc8:	f0 
+f0102fc9:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0102fd0:	f0 
+f0102fd1:	c7 44 24 04 4e 03 00 	movl   $0x34e,0x4(%esp)
+f0102fd8:	00 
+f0102fd9:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0102fe0:	e8 d0 d0 ff ff       	call   f01000b5 <_panic>
+
+    // pp2 should NOT be on the free list
+    // could happen in ref counts are handled sloppily in page_insert
+    assert(!page_alloc(0));
+f0102fe5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0102fec:	e8 b6 e8 ff ff       	call   f01018a7 <page_alloc>
+f0102ff1:	85 c0                	test   %eax,%eax
+f0102ff3:	74 24                	je     f0103019 <check_page+0x56b>
+f0102ff5:	c7 44 24 0c db 73 10 	movl   $0xf01073db,0xc(%esp)
+f0102ffc:	f0 
+f0102ffd:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103004:	f0 
+f0103005:	c7 44 24 04 52 03 00 	movl   $0x352,0x4(%esp)
+f010300c:	00 
+f010300d:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103014:	e8 9c d0 ff ff       	call   f01000b5 <_panic>
+
+    // check that pgdir_walk returns a pointer to the pte
+    ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
+f0103019:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010301e:	8b 00                	mov    (%eax),%eax
+f0103020:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0103025:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0103029:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
+f0103030:	00 
+f0103031:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103038:	e8 60 e2 ff ff       	call   f010129d <_kaddr>
+f010303d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
+f0103040:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103045:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f010304c:	00 
+f010304d:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0103054:	00 
+f0103055:	89 04 24             	mov    %eax,(%esp)
+f0103058:	e8 22 e9 ff ff       	call   f010197f <pgdir_walk>
+f010305d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+f0103060:	83 c2 04             	add    $0x4,%edx
+f0103063:	39 d0                	cmp    %edx,%eax
+f0103065:	74 24                	je     f010308b <check_page+0x5dd>
+f0103067:	c7 44 24 0c 38 77 10 	movl   $0xf0107738,0xc(%esp)
+f010306e:	f0 
+f010306f:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103076:	f0 
+f0103077:	c7 44 24 04 56 03 00 	movl   $0x356,0x4(%esp)
+f010307e:	00 
+f010307f:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103086:	e8 2a d0 ff ff       	call   f01000b5 <_panic>
+
+    // should be able to change permissions too.
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
+f010308b:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103090:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
+f0103097:	00 
+f0103098:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f010309f:	00 
+f01030a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01030a3:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01030a7:	89 04 24             	mov    %eax,(%esp)
+f01030aa:	e8 f1 e9 ff ff       	call   f0101aa0 <page_insert>
+f01030af:	85 c0                	test   %eax,%eax
+f01030b1:	74 24                	je     f01030d7 <check_page+0x629>
+f01030b3:	c7 44 24 0c 78 77 10 	movl   $0xf0107778,0xc(%esp)
+f01030ba:	f0 
+f01030bb:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01030c2:	f0 
+f01030c3:	c7 44 24 04 59 03 00 	movl   $0x359,0x4(%esp)
+f01030ca:	00 
+f01030cb:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01030d2:	e8 de cf ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+f01030d7:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01030dc:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f01030e3:	00 
+f01030e4:	89 04 24             	mov    %eax,(%esp)
+f01030e7:	e8 31 f9 ff ff       	call   f0102a1d <check_va2pa>
+f01030ec:	89 c3                	mov    %eax,%ebx
+f01030ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01030f1:	89 04 24             	mov    %eax,(%esp)
+f01030f4:	e8 e6 e1 ff ff       	call   f01012df <page2pa>
+f01030f9:	39 c3                	cmp    %eax,%ebx
+f01030fb:	74 24                	je     f0103121 <check_page+0x673>
+f01030fd:	c7 44 24 0c f4 76 10 	movl   $0xf01076f4,0xc(%esp)
+f0103104:	f0 
+f0103105:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010310c:	f0 
+f010310d:	c7 44 24 04 5a 03 00 	movl   $0x35a,0x4(%esp)
+f0103114:	00 
+f0103115:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010311c:	e8 94 cf ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 1);
+f0103121:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103124:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103128:	66 83 f8 01          	cmp    $0x1,%ax
+f010312c:	74 24                	je     f0103152 <check_page+0x6a4>
+f010312e:	c7 44 24 0c 24 77 10 	movl   $0xf0107724,0xc(%esp)
+f0103135:	f0 
+f0103136:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010313d:	f0 
+f010313e:	c7 44 24 04 5b 03 00 	movl   $0x35b,0x4(%esp)
+f0103145:	00 
+f0103146:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010314d:	e8 63 cf ff ff       	call   f01000b5 <_panic>
+    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
+f0103152:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103157:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f010315e:	00 
+f010315f:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0103166:	00 
+f0103167:	89 04 24             	mov    %eax,(%esp)
+f010316a:	e8 10 e8 ff ff       	call   f010197f <pgdir_walk>
+f010316f:	8b 00                	mov    (%eax),%eax
+f0103171:	83 e0 04             	and    $0x4,%eax
+f0103174:	85 c0                	test   %eax,%eax
+f0103176:	75 24                	jne    f010319c <check_page+0x6ee>
+f0103178:	c7 44 24 0c b8 77 10 	movl   $0xf01077b8,0xc(%esp)
+f010317f:	f0 
+f0103180:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103187:	f0 
+f0103188:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
+f010318f:	00 
+f0103190:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103197:	e8 19 cf ff ff       	call   f01000b5 <_panic>
+    assert(kern_pgdir[0] & PTE_U);
+f010319c:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01031a1:	8b 00                	mov    (%eax),%eax
+f01031a3:	83 e0 04             	and    $0x4,%eax
+f01031a6:	85 c0                	test   %eax,%eax
+f01031a8:	75 24                	jne    f01031ce <check_page+0x720>
+f01031aa:	c7 44 24 0c eb 77 10 	movl   $0xf01077eb,0xc(%esp)
+f01031b1:	f0 
+f01031b2:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01031b9:	f0 
+f01031ba:	c7 44 24 04 5d 03 00 	movl   $0x35d,0x4(%esp)
+f01031c1:	00 
+f01031c2:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01031c9:	e8 e7 ce ff ff       	call   f01000b5 <_panic>
+
+    // should be able to remap with fewer permissions
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+f01031ce:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01031d3:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f01031da:	00 
+f01031db:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f01031e2:	00 
+f01031e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01031e6:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01031ea:	89 04 24             	mov    %eax,(%esp)
+f01031ed:	e8 ae e8 ff ff       	call   f0101aa0 <page_insert>
+f01031f2:	85 c0                	test   %eax,%eax
+f01031f4:	74 24                	je     f010321a <check_page+0x76c>
+f01031f6:	c7 44 24 0c b8 76 10 	movl   $0xf01076b8,0xc(%esp)
+f01031fd:	f0 
+f01031fe:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103205:	f0 
+f0103206:	c7 44 24 04 60 03 00 	movl   $0x360,0x4(%esp)
+f010320d:	00 
+f010320e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103215:	e8 9b ce ff ff       	call   f01000b5 <_panic>
+    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
+f010321a:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010321f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0103226:	00 
+f0103227:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f010322e:	00 
+f010322f:	89 04 24             	mov    %eax,(%esp)
+f0103232:	e8 48 e7 ff ff       	call   f010197f <pgdir_walk>
+f0103237:	8b 00                	mov    (%eax),%eax
+f0103239:	83 e0 02             	and    $0x2,%eax
+f010323c:	85 c0                	test   %eax,%eax
+f010323e:	75 24                	jne    f0103264 <check_page+0x7b6>
+f0103240:	c7 44 24 0c 04 78 10 	movl   $0xf0107804,0xc(%esp)
+f0103247:	f0 
+f0103248:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010324f:	f0 
+f0103250:	c7 44 24 04 61 03 00 	movl   $0x361,0x4(%esp)
+f0103257:	00 
+f0103258:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010325f:	e8 51 ce ff ff       	call   f01000b5 <_panic>
+    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+f0103264:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103269:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0103270:	00 
+f0103271:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0103278:	00 
+f0103279:	89 04 24             	mov    %eax,(%esp)
+f010327c:	e8 fe e6 ff ff       	call   f010197f <pgdir_walk>
+f0103281:	8b 00                	mov    (%eax),%eax
+f0103283:	83 e0 04             	and    $0x4,%eax
+f0103286:	85 c0                	test   %eax,%eax
+f0103288:	74 24                	je     f01032ae <check_page+0x800>
+f010328a:	c7 44 24 0c 38 78 10 	movl   $0xf0107838,0xc(%esp)
+f0103291:	f0 
+f0103292:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103299:	f0 
+f010329a:	c7 44 24 04 62 03 00 	movl   $0x362,0x4(%esp)
+f01032a1:	00 
+f01032a2:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01032a9:	e8 07 ce ff ff       	call   f01000b5 <_panic>
+
+    // should not be able to map at PTSIZE because need free page for page table
+    assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
+f01032ae:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01032b3:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f01032ba:	00 
+f01032bb:	c7 44 24 08 00 00 40 	movl   $0x400000,0x8(%esp)
+f01032c2:	00 
+f01032c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
+f01032c6:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01032ca:	89 04 24             	mov    %eax,(%esp)
+f01032cd:	e8 ce e7 ff ff       	call   f0101aa0 <page_insert>
+f01032d2:	85 c0                	test   %eax,%eax
+f01032d4:	78 24                	js     f01032fa <check_page+0x84c>
+f01032d6:	c7 44 24 0c 70 78 10 	movl   $0xf0107870,0xc(%esp)
+f01032dd:	f0 
+f01032de:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01032e5:	f0 
+f01032e6:	c7 44 24 04 65 03 00 	movl   $0x365,0x4(%esp)
+f01032ed:	00 
+f01032ee:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01032f5:	e8 bb cd ff ff       	call   f01000b5 <_panic>
+
+    // insert pp1 at PGSIZE (replacing pp2)
+    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
+f01032fa:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01032ff:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0103306:	00 
+f0103307:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f010330e:	00 
+f010330f:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0103312:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0103316:	89 04 24             	mov    %eax,(%esp)
+f0103319:	e8 82 e7 ff ff       	call   f0101aa0 <page_insert>
+f010331e:	85 c0                	test   %eax,%eax
+f0103320:	74 24                	je     f0103346 <check_page+0x898>
+f0103322:	c7 44 24 0c a8 78 10 	movl   $0xf01078a8,0xc(%esp)
+f0103329:	f0 
+f010332a:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103331:	f0 
+f0103332:	c7 44 24 04 68 03 00 	movl   $0x368,0x4(%esp)
+f0103339:	00 
+f010333a:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103341:	e8 6f cd ff ff       	call   f01000b5 <_panic>
+    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+f0103346:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010334b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+f0103352:	00 
+f0103353:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f010335a:	00 
+f010335b:	89 04 24             	mov    %eax,(%esp)
+f010335e:	e8 1c e6 ff ff       	call   f010197f <pgdir_walk>
+f0103363:	8b 00                	mov    (%eax),%eax
+f0103365:	83 e0 04             	and    $0x4,%eax
+f0103368:	85 c0                	test   %eax,%eax
+f010336a:	74 24                	je     f0103390 <check_page+0x8e2>
+f010336c:	c7 44 24 0c 38 78 10 	movl   $0xf0107838,0xc(%esp)
+f0103373:	f0 
+f0103374:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010337b:	f0 
+f010337c:	c7 44 24 04 69 03 00 	movl   $0x369,0x4(%esp)
+f0103383:	00 
+f0103384:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010338b:	e8 25 cd ff ff       	call   f01000b5 <_panic>
+
+    // should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
+    assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
+f0103390:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103395:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010339c:	00 
+f010339d:	89 04 24             	mov    %eax,(%esp)
+f01033a0:	e8 78 f6 ff ff       	call   f0102a1d <check_va2pa>
+f01033a5:	89 c3                	mov    %eax,%ebx
+f01033a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01033aa:	89 04 24             	mov    %eax,(%esp)
+f01033ad:	e8 2d df ff ff       	call   f01012df <page2pa>
+f01033b2:	39 c3                	cmp    %eax,%ebx
+f01033b4:	74 24                	je     f01033da <check_page+0x92c>
+f01033b6:	c7 44 24 0c e4 78 10 	movl   $0xf01078e4,0xc(%esp)
+f01033bd:	f0 
+f01033be:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01033c5:	f0 
+f01033c6:	c7 44 24 04 6c 03 00 	movl   $0x36c,0x4(%esp)
+f01033cd:	00 
+f01033ce:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01033d5:	e8 db cc ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+f01033da:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01033df:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f01033e6:	00 
+f01033e7:	89 04 24             	mov    %eax,(%esp)
+f01033ea:	e8 2e f6 ff ff       	call   f0102a1d <check_va2pa>
+f01033ef:	89 c3                	mov    %eax,%ebx
+f01033f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01033f4:	89 04 24             	mov    %eax,(%esp)
+f01033f7:	e8 e3 de ff ff       	call   f01012df <page2pa>
+f01033fc:	39 c3                	cmp    %eax,%ebx
+f01033fe:	74 24                	je     f0103424 <check_page+0x976>
+f0103400:	c7 44 24 0c 10 79 10 	movl   $0xf0107910,0xc(%esp)
+f0103407:	f0 
+f0103408:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010340f:	f0 
+f0103410:	c7 44 24 04 6d 03 00 	movl   $0x36d,0x4(%esp)
+f0103417:	00 
+f0103418:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010341f:	e8 91 cc ff ff       	call   f01000b5 <_panic>
+    // ... and ref counts should reflect this
+    assert(pp1->pp_ref == 2);
+f0103424:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103427:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f010342b:	66 83 f8 02          	cmp    $0x2,%ax
+f010342f:	74 24                	je     f0103455 <check_page+0x9a7>
+f0103431:	c7 44 24 0c 40 79 10 	movl   $0xf0107940,0xc(%esp)
+f0103438:	f0 
+f0103439:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103440:	f0 
+f0103441:	c7 44 24 04 6f 03 00 	movl   $0x36f,0x4(%esp)
+f0103448:	00 
+f0103449:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103450:	e8 60 cc ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 0);
+f0103455:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103458:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f010345c:	66 85 c0             	test   %ax,%ax
+f010345f:	74 24                	je     f0103485 <check_page+0x9d7>
+f0103461:	c7 44 24 0c 51 79 10 	movl   $0xf0107951,0xc(%esp)
+f0103468:	f0 
+f0103469:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103470:	f0 
+f0103471:	c7 44 24 04 70 03 00 	movl   $0x370,0x4(%esp)
+f0103478:	00 
+f0103479:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103480:	e8 30 cc ff ff       	call   f01000b5 <_panic>
+
+    // pp2 should be returned by page_alloc
+    assert((pp = page_alloc(0)) && pp == pp2);
+f0103485:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f010348c:	e8 16 e4 ff ff       	call   f01018a7 <page_alloc>
+f0103491:	89 45 e0             	mov    %eax,-0x20(%ebp)
+f0103494:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0103498:	74 08                	je     f01034a2 <check_page+0x9f4>
+f010349a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f010349d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+f01034a0:	74 24                	je     f01034c6 <check_page+0xa18>
+f01034a2:	c7 44 24 0c 64 79 10 	movl   $0xf0107964,0xc(%esp)
+f01034a9:	f0 
+f01034aa:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01034b1:	f0 
+f01034b2:	c7 44 24 04 73 03 00 	movl   $0x373,0x4(%esp)
+f01034b9:	00 
+f01034ba:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01034c1:	e8 ef cb ff ff       	call   f01000b5 <_panic>
+
+    // unmapping pp1 at 0 should keep pp1 at PGSIZE
+    page_remove(kern_pgdir, 0x0);
+f01034c6:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01034cb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f01034d2:	00 
+f01034d3:	89 04 24             	mov    %eax,(%esp)
+f01034d6:	e8 eb e6 ff ff       	call   f0101bc6 <page_remove>
+    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+f01034db:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01034e0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f01034e7:	00 
+f01034e8:	89 04 24             	mov    %eax,(%esp)
+f01034eb:	e8 2d f5 ff ff       	call   f0102a1d <check_va2pa>
+f01034f0:	83 f8 ff             	cmp    $0xffffffff,%eax
+f01034f3:	74 24                	je     f0103519 <check_page+0xa6b>
+f01034f5:	c7 44 24 0c 88 79 10 	movl   $0xf0107988,0xc(%esp)
+f01034fc:	f0 
+f01034fd:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103504:	f0 
+f0103505:	c7 44 24 04 77 03 00 	movl   $0x377,0x4(%esp)
+f010350c:	00 
+f010350d:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103514:	e8 9c cb ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+f0103519:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010351e:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0103525:	00 
+f0103526:	89 04 24             	mov    %eax,(%esp)
+f0103529:	e8 ef f4 ff ff       	call   f0102a1d <check_va2pa>
+f010352e:	89 c3                	mov    %eax,%ebx
+f0103530:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103533:	89 04 24             	mov    %eax,(%esp)
+f0103536:	e8 a4 dd ff ff       	call   f01012df <page2pa>
+f010353b:	39 c3                	cmp    %eax,%ebx
+f010353d:	74 24                	je     f0103563 <check_page+0xab5>
+f010353f:	c7 44 24 0c 10 79 10 	movl   $0xf0107910,0xc(%esp)
+f0103546:	f0 
+f0103547:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010354e:	f0 
+f010354f:	c7 44 24 04 78 03 00 	movl   $0x378,0x4(%esp)
+f0103556:	00 
+f0103557:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010355e:	e8 52 cb ff ff       	call   f01000b5 <_panic>
+    assert(pp1->pp_ref == 1);
+f0103563:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103566:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f010356a:	66 83 f8 01          	cmp    $0x1,%ax
+f010356e:	74 24                	je     f0103594 <check_page+0xae6>
+f0103570:	c7 44 24 0c 95 76 10 	movl   $0xf0107695,0xc(%esp)
+f0103577:	f0 
+f0103578:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010357f:	f0 
+f0103580:	c7 44 24 04 79 03 00 	movl   $0x379,0x4(%esp)
+f0103587:	00 
+f0103588:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010358f:	e8 21 cb ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 0);
+f0103594:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103597:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f010359b:	66 85 c0             	test   %ax,%ax
+f010359e:	74 24                	je     f01035c4 <check_page+0xb16>
+f01035a0:	c7 44 24 0c 51 79 10 	movl   $0xf0107951,0xc(%esp)
+f01035a7:	f0 
+f01035a8:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01035af:	f0 
+f01035b0:	c7 44 24 04 7a 03 00 	movl   $0x37a,0x4(%esp)
+f01035b7:	00 
+f01035b8:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01035bf:	e8 f1 ca ff ff       	call   f01000b5 <_panic>
+
+    // test re-inserting pp1 at PGSIZE
+    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
+f01035c4:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01035c9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+f01035d0:	00 
+f01035d1:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f01035d8:	00 
+f01035d9:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f01035dc:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01035e0:	89 04 24             	mov    %eax,(%esp)
+f01035e3:	e8 b8 e4 ff ff       	call   f0101aa0 <page_insert>
+f01035e8:	85 c0                	test   %eax,%eax
+f01035ea:	74 24                	je     f0103610 <check_page+0xb62>
+f01035ec:	c7 44 24 0c ac 79 10 	movl   $0xf01079ac,0xc(%esp)
+f01035f3:	f0 
+f01035f4:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01035fb:	f0 
+f01035fc:	c7 44 24 04 7d 03 00 	movl   $0x37d,0x4(%esp)
+f0103603:	00 
+f0103604:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010360b:	e8 a5 ca ff ff       	call   f01000b5 <_panic>
+    assert(pp1->pp_ref);
+f0103610:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103613:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103617:	66 85 c0             	test   %ax,%ax
+f010361a:	75 24                	jne    f0103640 <check_page+0xb92>
+f010361c:	c7 44 24 0c e1 79 10 	movl   $0xf01079e1,0xc(%esp)
+f0103623:	f0 
+f0103624:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010362b:	f0 
+f010362c:	c7 44 24 04 7e 03 00 	movl   $0x37e,0x4(%esp)
+f0103633:	00 
+f0103634:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010363b:	e8 75 ca ff ff       	call   f01000b5 <_panic>
+    assert(pp1->pp_link == NULL);
+f0103640:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103643:	8b 00                	mov    (%eax),%eax
+f0103645:	85 c0                	test   %eax,%eax
+f0103647:	74 24                	je     f010366d <check_page+0xbbf>
+f0103649:	c7 44 24 0c ed 79 10 	movl   $0xf01079ed,0xc(%esp)
+f0103650:	f0 
+f0103651:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103658:	f0 
+f0103659:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
+f0103660:	00 
+f0103661:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103668:	e8 48 ca ff ff       	call   f01000b5 <_panic>
+
+    // unmapping pp1 at PGSIZE should free it
+    page_remove(kern_pgdir, (void*) PGSIZE);
+f010366d:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103672:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0103679:	00 
+f010367a:	89 04 24             	mov    %eax,(%esp)
+f010367d:	e8 44 e5 ff ff       	call   f0101bc6 <page_remove>
+    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+f0103682:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103687:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010368e:	00 
+f010368f:	89 04 24             	mov    %eax,(%esp)
+f0103692:	e8 86 f3 ff ff       	call   f0102a1d <check_va2pa>
+f0103697:	83 f8 ff             	cmp    $0xffffffff,%eax
+f010369a:	74 24                	je     f01036c0 <check_page+0xc12>
+f010369c:	c7 44 24 0c 88 79 10 	movl   $0xf0107988,0xc(%esp)
+f01036a3:	f0 
+f01036a4:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01036ab:	f0 
+f01036ac:	c7 44 24 04 83 03 00 	movl   $0x383,0x4(%esp)
+f01036b3:	00 
+f01036b4:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01036bb:	e8 f5 c9 ff ff       	call   f01000b5 <_panic>
+    assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
+f01036c0:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01036c5:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f01036cc:	00 
+f01036cd:	89 04 24             	mov    %eax,(%esp)
+f01036d0:	e8 48 f3 ff ff       	call   f0102a1d <check_va2pa>
+f01036d5:	83 f8 ff             	cmp    $0xffffffff,%eax
+f01036d8:	74 24                	je     f01036fe <check_page+0xc50>
+f01036da:	c7 44 24 0c 04 7a 10 	movl   $0xf0107a04,0xc(%esp)
+f01036e1:	f0 
+f01036e2:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01036e9:	f0 
+f01036ea:	c7 44 24 04 84 03 00 	movl   $0x384,0x4(%esp)
+f01036f1:	00 
+f01036f2:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01036f9:	e8 b7 c9 ff ff       	call   f01000b5 <_panic>
+    assert(pp1->pp_ref == 0);
+f01036fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103701:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103705:	66 85 c0             	test   %ax,%ax
+f0103708:	74 24                	je     f010372e <check_page+0xc80>
+f010370a:	c7 44 24 0c 2a 7a 10 	movl   $0xf0107a2a,0xc(%esp)
+f0103711:	f0 
+f0103712:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103719:	f0 
+f010371a:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
+f0103721:	00 
+f0103722:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103729:	e8 87 c9 ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 0);
+f010372e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103731:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103735:	66 85 c0             	test   %ax,%ax
+f0103738:	74 24                	je     f010375e <check_page+0xcb0>
+f010373a:	c7 44 24 0c 51 79 10 	movl   $0xf0107951,0xc(%esp)
+f0103741:	f0 
+f0103742:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103749:	f0 
+f010374a:	c7 44 24 04 86 03 00 	movl   $0x386,0x4(%esp)
+f0103751:	00 
+f0103752:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103759:	e8 57 c9 ff ff       	call   f01000b5 <_panic>
+
+    // so it should be returned by page_alloc
+    assert((pp = page_alloc(0)) && pp == pp1);
+f010375e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0103765:	e8 3d e1 ff ff       	call   f01018a7 <page_alloc>
+f010376a:	89 45 e0             	mov    %eax,-0x20(%ebp)
+f010376d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0103771:	74 08                	je     f010377b <check_page+0xccd>
+f0103773:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0103776:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+f0103779:	74 24                	je     f010379f <check_page+0xcf1>
+f010377b:	c7 44 24 0c 3c 7a 10 	movl   $0xf0107a3c,0xc(%esp)
+f0103782:	f0 
+f0103783:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010378a:	f0 
+f010378b:	c7 44 24 04 89 03 00 	movl   $0x389,0x4(%esp)
+f0103792:	00 
+f0103793:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010379a:	e8 16 c9 ff ff       	call   f01000b5 <_panic>
+
+    // should be no free memory
+    assert(!page_alloc(0));
+f010379f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f01037a6:	e8 fc e0 ff ff       	call   f01018a7 <page_alloc>
+f01037ab:	85 c0                	test   %eax,%eax
+f01037ad:	74 24                	je     f01037d3 <check_page+0xd25>
+f01037af:	c7 44 24 0c db 73 10 	movl   $0xf01073db,0xc(%esp)
+f01037b6:	f0 
+f01037b7:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01037be:	f0 
+f01037bf:	c7 44 24 04 8c 03 00 	movl   $0x38c,0x4(%esp)
+f01037c6:	00 
+f01037c7:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01037ce:	e8 e2 c8 ff ff       	call   f01000b5 <_panic>
+
+    // forcibly take pp0 back
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+f01037d3:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01037d8:	8b 00                	mov    (%eax),%eax
+f01037da:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f01037df:	89 c3                	mov    %eax,%ebx
+f01037e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f01037e4:	89 04 24             	mov    %eax,(%esp)
+f01037e7:	e8 f3 da ff ff       	call   f01012df <page2pa>
+f01037ec:	39 c3                	cmp    %eax,%ebx
+f01037ee:	74 24                	je     f0103814 <check_page+0xd66>
+f01037f0:	c7 44 24 0c 40 76 10 	movl   $0xf0107640,0xc(%esp)
+f01037f7:	f0 
+f01037f8:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01037ff:	f0 
+f0103800:	c7 44 24 04 8f 03 00 	movl   $0x38f,0x4(%esp)
+f0103807:	00 
+f0103808:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010380f:	e8 a1 c8 ff ff       	call   f01000b5 <_panic>
+    kern_pgdir[0] = 0;
+f0103814:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103819:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+    assert(pp0->pp_ref == 1);
+f010381f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0103822:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103826:	66 83 f8 01          	cmp    $0x1,%ax
+f010382a:	74 24                	je     f0103850 <check_page+0xda2>
+f010382c:	c7 44 24 0c a6 76 10 	movl   $0xf01076a6,0xc(%esp)
+f0103833:	f0 
+f0103834:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f010383b:	f0 
+f010383c:	c7 44 24 04 91 03 00 	movl   $0x391,0x4(%esp)
+f0103843:	00 
+f0103844:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f010384b:	e8 65 c8 ff ff       	call   f01000b5 <_panic>
+    pp0->pp_ref = 0;
+f0103850:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0103853:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
+
+    // check pointer arithmetic in pgdir_walk
+    page_free(pp0);
+f0103859:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010385c:	89 04 24             	mov    %eax,(%esp)
+f010385f:	e8 a6 e0 ff ff       	call   f010190a <page_free>
+    va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
+f0103864:	c7 45 dc 00 10 40 00 	movl   $0x401000,-0x24(%ebp)
+    ptep = pgdir_walk(kern_pgdir, va, 1);
+f010386b:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103870:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+f0103877:	00 
+f0103878:	8b 55 dc             	mov    -0x24(%ebp),%edx
+f010387b:	89 54 24 04          	mov    %edx,0x4(%esp)
+f010387f:	89 04 24             	mov    %eax,(%esp)
+f0103882:	e8 f8 e0 ff ff       	call   f010197f <pgdir_walk>
+f0103887:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
+f010388a:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f010388f:	8b 55 dc             	mov    -0x24(%ebp),%edx
+f0103892:	c1 ea 16             	shr    $0x16,%edx
+f0103895:	c1 e2 02             	shl    $0x2,%edx
+f0103898:	01 d0                	add    %edx,%eax
+f010389a:	8b 00                	mov    (%eax),%eax
+f010389c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f01038a1:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01038a5:	c7 44 24 04 98 03 00 	movl   $0x398,0x4(%esp)
+f01038ac:	00 
+f01038ad:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01038b4:	e8 e4 d9 ff ff       	call   f010129d <_kaddr>
+f01038b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    assert(ptep == ptep1 + PTX(va));
+f01038bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f01038bf:	c1 e8 0c             	shr    $0xc,%eax
+f01038c2:	25 ff 03 00 00       	and    $0x3ff,%eax
+f01038c7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f01038ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f01038d1:	01 c2                	add    %eax,%edx
+f01038d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+f01038d6:	39 c2                	cmp    %eax,%edx
+f01038d8:	74 24                	je     f01038fe <check_page+0xe50>
+f01038da:	c7 44 24 0c 5e 7a 10 	movl   $0xf0107a5e,0xc(%esp)
+f01038e1:	f0 
+f01038e2:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01038e9:	f0 
+f01038ea:	c7 44 24 04 99 03 00 	movl   $0x399,0x4(%esp)
+f01038f1:	00 
+f01038f2:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01038f9:	e8 b7 c7 ff ff       	call   f01000b5 <_panic>
+    kern_pgdir[PDX(va)] = 0;
+f01038fe:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103903:	8b 55 dc             	mov    -0x24(%ebp),%edx
+f0103906:	c1 ea 16             	shr    $0x16,%edx
+f0103909:	c1 e2 02             	shl    $0x2,%edx
+f010390c:	01 d0                	add    %edx,%eax
+f010390e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+    pp0->pp_ref = 0;
+f0103914:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0103917:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
+
+    // check that new page tables get cleared
+    memset(page2kva(pp0), 0xFF, PGSIZE);
+f010391d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0103920:	89 04 24             	mov    %eax,(%esp)
+f0103923:	e8 13 da ff ff       	call   f010133b <page2kva>
+f0103928:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f010392f:	00 
+f0103930:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
+f0103937:	00 
+f0103938:	89 04 24             	mov    %eax,(%esp)
+f010393b:	e8 a2 2b 00 00       	call   f01064e2 <memset>
+    page_free(pp0);
+f0103940:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0103943:	89 04 24             	mov    %eax,(%esp)
+f0103946:	e8 bf df ff ff       	call   f010190a <page_free>
+    pgdir_walk(kern_pgdir, 0x0, 1);
+f010394b:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103950:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+f0103957:	00 
+f0103958:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010395f:	00 
+f0103960:	89 04 24             	mov    %eax,(%esp)
+f0103963:	e8 17 e0 ff ff       	call   f010197f <pgdir_walk>
+    ptep = (pte_t *) page2kva(pp0);
+f0103968:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010396b:	89 04 24             	mov    %eax,(%esp)
+f010396e:	e8 c8 d9 ff ff       	call   f010133b <page2kva>
+f0103973:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    for(i=0; i<NPTENTRIES; i++)
+f0103976:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f010397d:	eb 3c                	jmp    f01039bb <check_page+0xf0d>
+	assert((ptep[i] & PTE_P) == 0);
+f010397f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+f0103982:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0103985:	c1 e2 02             	shl    $0x2,%edx
+f0103988:	01 d0                	add    %edx,%eax
+f010398a:	8b 00                	mov    (%eax),%eax
+f010398c:	83 e0 01             	and    $0x1,%eax
+f010398f:	85 c0                	test   %eax,%eax
+f0103991:	74 24                	je     f01039b7 <check_page+0xf09>
+f0103993:	c7 44 24 0c 76 7a 10 	movl   $0xf0107a76,0xc(%esp)
+f010399a:	f0 
+f010399b:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f01039a2:	f0 
+f01039a3:	c7 44 24 04 a3 03 00 	movl   $0x3a3,0x4(%esp)
+f01039aa:	00 
+f01039ab:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f01039b2:	e8 fe c6 ff ff       	call   f01000b5 <_panic>
+    // check that new page tables get cleared
+    memset(page2kva(pp0), 0xFF, PGSIZE);
+    page_free(pp0);
+    pgdir_walk(kern_pgdir, 0x0, 1);
+    ptep = (pte_t *) page2kva(pp0);
+    for(i=0; i<NPTENTRIES; i++)
+f01039b7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f01039bb:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
+f01039c2:	7e bb                	jle    f010397f <check_page+0xed1>
+	assert((ptep[i] & PTE_P) == 0);
+    kern_pgdir[0] = 0;
+f01039c4:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01039c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+    pp0->pp_ref = 0;
+f01039cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f01039d2:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
+
+    // give free list back
+    page_free_list = fl;
+f01039d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f01039db:	a3 10 eb 18 f0       	mov    %eax,0xf018eb10
+
+    // free the pages we took
+    page_free(pp0);
+f01039e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f01039e3:	89 04 24             	mov    %eax,(%esp)
+f01039e6:	e8 1f df ff ff       	call   f010190a <page_free>
+    page_free(pp1);
+f01039eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01039ee:	89 04 24             	mov    %eax,(%esp)
+f01039f1:	e8 14 df ff ff       	call   f010190a <page_free>
+    page_free(pp2);
+f01039f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01039f9:	89 04 24             	mov    %eax,(%esp)
+f01039fc:	e8 09 df ff ff       	call   f010190a <page_free>
+
+    cprintf("check_page() succeeded!\n");
+f0103a01:	c7 04 24 8d 7a 10 f0 	movl   $0xf0107a8d,(%esp)
+f0103a08:	e8 80 0f 00 00       	call   f010498d <cprintf>
+}
+f0103a0d:	83 c4 44             	add    $0x44,%esp
+f0103a10:	5b                   	pop    %ebx
+f0103a11:	5d                   	pop    %ebp
+f0103a12:	c3                   	ret    
+
+f0103a13 <check_page_installed_pgdir>:
+
+// check page_insert, page_remove, &c, with an installed kern_pgdir
+    static void
+check_page_installed_pgdir(void)
+{
+f0103a13:	55                   	push   %ebp
+f0103a14:	89 e5                	mov    %esp,%ebp
+f0103a16:	53                   	push   %ebx
+f0103a17:	83 ec 24             	sub    $0x24,%esp
+    pte_t *ptep, *ptep1;
+    uintptr_t va;
+    int i;
+
+    // check that we can read and write installed pages
+    pp1 = pp2 = 0;
+f0103a1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f0103a21:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0103a24:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    assert((pp0 = page_alloc(0)));
+f0103a27:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0103a2e:	e8 74 de ff ff       	call   f01018a7 <page_alloc>
+f0103a33:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f0103a36:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f0103a3a:	75 24                	jne    f0103a60 <check_page_installed_pgdir+0x4d>
+f0103a3c:	c7 44 24 0c 0b 73 10 	movl   $0xf010730b,0xc(%esp)
+f0103a43:	f0 
+f0103a44:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103a4b:	f0 
+f0103a4c:	c7 44 24 04 be 03 00 	movl   $0x3be,0x4(%esp)
+f0103a53:	00 
+f0103a54:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103a5b:	e8 55 c6 ff ff       	call   f01000b5 <_panic>
+    assert((pp1 = page_alloc(0)));
+f0103a60:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0103a67:	e8 3b de ff ff       	call   f01018a7 <page_alloc>
+f0103a6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0103a6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0103a73:	75 24                	jne    f0103a99 <check_page_installed_pgdir+0x86>
+f0103a75:	c7 44 24 0c 21 73 10 	movl   $0xf0107321,0xc(%esp)
+f0103a7c:	f0 
+f0103a7d:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103a84:	f0 
+f0103a85:	c7 44 24 04 bf 03 00 	movl   $0x3bf,0x4(%esp)
+f0103a8c:	00 
+f0103a8d:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103a94:	e8 1c c6 ff ff       	call   f01000b5 <_panic>
+    assert((pp2 = page_alloc(0)));
+f0103a99:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0103aa0:	e8 02 de ff ff       	call   f01018a7 <page_alloc>
+f0103aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f0103aa8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0103aac:	75 24                	jne    f0103ad2 <check_page_installed_pgdir+0xbf>
+f0103aae:	c7 44 24 0c 37 73 10 	movl   $0xf0107337,0xc(%esp)
+f0103ab5:	f0 
+f0103ab6:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103abd:	f0 
+f0103abe:	c7 44 24 04 c0 03 00 	movl   $0x3c0,0x4(%esp)
+f0103ac5:	00 
+f0103ac6:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103acd:	e8 e3 c5 ff ff       	call   f01000b5 <_panic>
+    page_free(pp0);
+f0103ad2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103ad5:	89 04 24             	mov    %eax,(%esp)
+f0103ad8:	e8 2d de ff ff       	call   f010190a <page_free>
+    memset(page2kva(pp1), 1, PGSIZE);
+f0103add:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103ae0:	89 04 24             	mov    %eax,(%esp)
+f0103ae3:	e8 53 d8 ff ff       	call   f010133b <page2kva>
+f0103ae8:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0103aef:	00 
+f0103af0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+f0103af7:	00 
+f0103af8:	89 04 24             	mov    %eax,(%esp)
+f0103afb:	e8 e2 29 00 00       	call   f01064e2 <memset>
+    memset(page2kva(pp2), 2, PGSIZE);
+f0103b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0103b03:	89 04 24             	mov    %eax,(%esp)
+f0103b06:	e8 30 d8 ff ff       	call   f010133b <page2kva>
+f0103b0b:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0103b12:	00 
+f0103b13:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+f0103b1a:	00 
+f0103b1b:	89 04 24             	mov    %eax,(%esp)
+f0103b1e:	e8 bf 29 00 00       	call   f01064e2 <memset>
+    page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
+f0103b23:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103b28:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0103b2f:	00 
+f0103b30:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0103b37:	00 
+f0103b38:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0103b3b:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0103b3f:	89 04 24             	mov    %eax,(%esp)
+f0103b42:	e8 59 df ff ff       	call   f0101aa0 <page_insert>
+    assert(pp1->pp_ref == 1);
+f0103b47:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103b4a:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103b4e:	66 83 f8 01          	cmp    $0x1,%ax
+f0103b52:	74 24                	je     f0103b78 <check_page_installed_pgdir+0x165>
+f0103b54:	c7 44 24 0c 95 76 10 	movl   $0xf0107695,0xc(%esp)
+f0103b5b:	f0 
+f0103b5c:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103b63:	f0 
+f0103b64:	c7 44 24 04 c5 03 00 	movl   $0x3c5,0x4(%esp)
+f0103b6b:	00 
+f0103b6c:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103b73:	e8 3d c5 ff ff       	call   f01000b5 <_panic>
+    assert(*(uint32_t *)PGSIZE == 0x01010101U);
+f0103b78:	b8 00 10 00 00       	mov    $0x1000,%eax
+f0103b7d:	8b 00                	mov    (%eax),%eax
+f0103b7f:	3d 01 01 01 01       	cmp    $0x1010101,%eax
+f0103b84:	74 24                	je     f0103baa <check_page_installed_pgdir+0x197>
+f0103b86:	c7 44 24 0c a8 7a 10 	movl   $0xf0107aa8,0xc(%esp)
+f0103b8d:	f0 
+f0103b8e:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103b95:	f0 
+f0103b96:	c7 44 24 04 c6 03 00 	movl   $0x3c6,0x4(%esp)
+f0103b9d:	00 
+f0103b9e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103ba5:	e8 0b c5 ff ff       	call   f01000b5 <_panic>
+    page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
+f0103baa:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103baf:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+f0103bb6:	00 
+f0103bb7:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f0103bbe:	00 
+f0103bbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0103bc2:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0103bc6:	89 04 24             	mov    %eax,(%esp)
+f0103bc9:	e8 d2 de ff ff       	call   f0101aa0 <page_insert>
+    assert(*(uint32_t *)PGSIZE == 0x02020202U);
+f0103bce:	b8 00 10 00 00       	mov    $0x1000,%eax
+f0103bd3:	8b 00                	mov    (%eax),%eax
+f0103bd5:	3d 02 02 02 02       	cmp    $0x2020202,%eax
+f0103bda:	74 24                	je     f0103c00 <check_page_installed_pgdir+0x1ed>
+f0103bdc:	c7 44 24 0c cc 7a 10 	movl   $0xf0107acc,0xc(%esp)
+f0103be3:	f0 
+f0103be4:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103beb:	f0 
+f0103bec:	c7 44 24 04 c8 03 00 	movl   $0x3c8,0x4(%esp)
+f0103bf3:	00 
+f0103bf4:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103bfb:	e8 b5 c4 ff ff       	call   f01000b5 <_panic>
+    assert(pp2->pp_ref == 1);
+f0103c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0103c03:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103c07:	66 83 f8 01          	cmp    $0x1,%ax
+f0103c0b:	74 24                	je     f0103c31 <check_page_installed_pgdir+0x21e>
+f0103c0d:	c7 44 24 0c 24 77 10 	movl   $0xf0107724,0xc(%esp)
+f0103c14:	f0 
+f0103c15:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103c1c:	f0 
+f0103c1d:	c7 44 24 04 c9 03 00 	movl   $0x3c9,0x4(%esp)
+f0103c24:	00 
+f0103c25:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103c2c:	e8 84 c4 ff ff       	call   f01000b5 <_panic>
+    assert(pp1->pp_ref == 0);
+f0103c31:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0103c34:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103c38:	66 85 c0             	test   %ax,%ax
+f0103c3b:	74 24                	je     f0103c61 <check_page_installed_pgdir+0x24e>
+f0103c3d:	c7 44 24 0c 2a 7a 10 	movl   $0xf0107a2a,0xc(%esp)
+f0103c44:	f0 
+f0103c45:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103c4c:	f0 
+f0103c4d:	c7 44 24 04 ca 03 00 	movl   $0x3ca,0x4(%esp)
+f0103c54:	00 
+f0103c55:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103c5c:	e8 54 c4 ff ff       	call   f01000b5 <_panic>
+    *(uint32_t *)PGSIZE = 0x03030303U;
+f0103c61:	b8 00 10 00 00       	mov    $0x1000,%eax
+f0103c66:	c7 00 03 03 03 03    	movl   $0x3030303,(%eax)
+    assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
+f0103c6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0103c6f:	89 04 24             	mov    %eax,(%esp)
+f0103c72:	e8 c4 d6 ff ff       	call   f010133b <page2kva>
+f0103c77:	8b 00                	mov    (%eax),%eax
+f0103c79:	3d 03 03 03 03       	cmp    $0x3030303,%eax
+f0103c7e:	74 24                	je     f0103ca4 <check_page_installed_pgdir+0x291>
+f0103c80:	c7 44 24 0c f0 7a 10 	movl   $0xf0107af0,0xc(%esp)
+f0103c87:	f0 
+f0103c88:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103c8f:	f0 
+f0103c90:	c7 44 24 04 cc 03 00 	movl   $0x3cc,0x4(%esp)
+f0103c97:	00 
+f0103c98:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103c9f:	e8 11 c4 ff ff       	call   f01000b5 <_panic>
+    page_remove(kern_pgdir, (void*) PGSIZE);
+f0103ca4:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103ca9:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+f0103cb0:	00 
+f0103cb1:	89 04 24             	mov    %eax,(%esp)
+f0103cb4:	e8 0d df ff ff       	call   f0101bc6 <page_remove>
+    assert(pp2->pp_ref == 0);
+f0103cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0103cbc:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103cc0:	66 85 c0             	test   %ax,%ax
+f0103cc3:	74 24                	je     f0103ce9 <check_page_installed_pgdir+0x2d6>
+f0103cc5:	c7 44 24 0c 51 79 10 	movl   $0xf0107951,0xc(%esp)
+f0103ccc:	f0 
+f0103ccd:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103cd4:	f0 
+f0103cd5:	c7 44 24 04 ce 03 00 	movl   $0x3ce,0x4(%esp)
+f0103cdc:	00 
+f0103cdd:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103ce4:	e8 cc c3 ff ff       	call   f01000b5 <_panic>
+
+    // forcibly take pp0 back
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+f0103ce9:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103cee:	8b 00                	mov    (%eax),%eax
+f0103cf0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f0103cf5:	89 c3                	mov    %eax,%ebx
+f0103cf7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103cfa:	89 04 24             	mov    %eax,(%esp)
+f0103cfd:	e8 dd d5 ff ff       	call   f01012df <page2pa>
+f0103d02:	39 c3                	cmp    %eax,%ebx
+f0103d04:	74 24                	je     f0103d2a <check_page_installed_pgdir+0x317>
+f0103d06:	c7 44 24 0c 40 76 10 	movl   $0xf0107640,0xc(%esp)
+f0103d0d:	f0 
+f0103d0e:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103d15:	f0 
+f0103d16:	c7 44 24 04 d1 03 00 	movl   $0x3d1,0x4(%esp)
+f0103d1d:	00 
+f0103d1e:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103d25:	e8 8b c3 ff ff       	call   f01000b5 <_panic>
+    kern_pgdir[0] = 0;
+f0103d2a:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0103d2f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+    assert(pp0->pp_ref == 1);
+f0103d35:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103d38:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f0103d3c:	66 83 f8 01          	cmp    $0x1,%ax
+f0103d40:	74 24                	je     f0103d66 <check_page_installed_pgdir+0x353>
+f0103d42:	c7 44 24 0c a6 76 10 	movl   $0xf01076a6,0xc(%esp)
+f0103d49:	f0 
+f0103d4a:	c7 44 24 08 22 71 10 	movl   $0xf0107122,0x8(%esp)
+f0103d51:	f0 
+f0103d52:	c7 44 24 04 d3 03 00 	movl   $0x3d3,0x4(%esp)
+f0103d59:	00 
+f0103d5a:	c7 04 24 e8 70 10 f0 	movl   $0xf01070e8,(%esp)
+f0103d61:	e8 4f c3 ff ff       	call   f01000b5 <_panic>
+    pp0->pp_ref = 0;
+f0103d66:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103d69:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
+
+    // free the pages we took
+    page_free(pp0);
+f0103d6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0103d72:	89 04 24             	mov    %eax,(%esp)
+f0103d75:	e8 90 db ff ff       	call   f010190a <page_free>
+
+    cprintf("check_page_installed_pgdir() succeeded!\n");
+f0103d7a:	c7 04 24 1c 7b 10 f0 	movl   $0xf0107b1c,(%esp)
+f0103d81:	e8 07 0c 00 00       	call   f010498d <cprintf>
+}
+f0103d86:	83 c4 24             	add    $0x24,%esp
+f0103d89:	5b                   	pop    %ebx
+f0103d8a:	5d                   	pop    %ebp
+f0103d8b:	c3                   	ret    
+
+f0103d8c <lgdt>:
+	asm volatile("lidt (%0)" : : "r" (p));
+}
+
+static inline void
+lgdt(void *p)
+{
+f0103d8c:	55                   	push   %ebp
+f0103d8d:	89 e5                	mov    %esp,%ebp
+	asm volatile("lgdt (%0)" : : "r" (p));
+f0103d8f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103d92:	0f 01 10             	lgdtl  (%eax)
+}
+f0103d95:	5d                   	pop    %ebp
+f0103d96:	c3                   	ret    
+
+f0103d97 <lldt>:
+
+static inline void
+lldt(uint16_t sel)
+{
+f0103d97:	55                   	push   %ebp
+f0103d98:	89 e5                	mov    %esp,%ebp
+f0103d9a:	83 ec 04             	sub    $0x4,%esp
+f0103d9d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103da0:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+	asm volatile("lldt %0" : : "r" (sel));
+f0103da4:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+f0103da8:	0f 00 d0             	lldt   %ax
+}
+f0103dab:	c9                   	leave  
+f0103dac:	c3                   	ret    
+
+f0103dad <lcr3>:
+	return val;
+}
+
+static inline void
+lcr3(uint32_t val)
+{
+f0103dad:	55                   	push   %ebp
+f0103dae:	89 e5                	mov    %esp,%ebp
+	asm volatile("movl %0,%%cr3" : : "r" (val));
+f0103db0:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103db3:	0f 22 d8             	mov    %eax,%cr3
+}
+f0103db6:	5d                   	pop    %ebp
+f0103db7:	c3                   	ret    
+
+f0103db8 <_paddr>:
+ */
+#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)
+
+static inline physaddr_t
+_paddr(const char *file, int line, void *kva)
+{
+f0103db8:	55                   	push   %ebp
+f0103db9:	89 e5                	mov    %esp,%ebp
+f0103dbb:	83 ec 18             	sub    $0x18,%esp
+	if ((uint32_t)kva < KERNBASE)
+f0103dbe:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103dc1:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
+f0103dc6:	77 21                	ja     f0103de9 <_paddr+0x31>
+		_panic(file, line, "PADDR called with invalid kva %08lx", kva);
+f0103dc8:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103dcb:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0103dcf:	c7 44 24 08 48 7b 10 	movl   $0xf0107b48,0x8(%esp)
+f0103dd6:	f0 
+f0103dd7:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0103dda:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0103dde:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103de1:	89 04 24             	mov    %eax,(%esp)
+f0103de4:	e8 cc c2 ff ff       	call   f01000b5 <_panic>
+	return (physaddr_t)kva - KERNBASE;
+f0103de9:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103dec:	05 00 00 00 10       	add    $0x10000000,%eax
+}
+f0103df1:	c9                   	leave  
+f0103df2:	c3                   	ret    
+
+f0103df3 <_kaddr>:
+ * virtual address.  It panics if you pass an invalid physical address. */
+#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)
+
+static inline void*
+_kaddr(const char *file, int line, physaddr_t pa)
+{
+f0103df3:	55                   	push   %ebp
+f0103df4:	89 e5                	mov    %esp,%ebp
+f0103df6:	83 ec 18             	sub    $0x18,%esp
+	if (PGNUM(pa) >= npages)
+f0103df9:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103dfc:	c1 e8 0c             	shr    $0xc,%eax
+f0103dff:	89 c2                	mov    %eax,%edx
+f0103e01:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f0103e06:	39 c2                	cmp    %eax,%edx
+f0103e08:	72 21                	jb     f0103e2b <_kaddr+0x38>
+		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
+f0103e0a:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103e0d:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0103e11:	c7 44 24 08 6c 7b 10 	movl   $0xf0107b6c,0x8(%esp)
+f0103e18:	f0 
+f0103e19:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0103e1c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0103e20:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103e23:	89 04 24             	mov    %eax,(%esp)
+f0103e26:	e8 8a c2 ff ff       	call   f01000b5 <_panic>
+	return (void *)(pa + KERNBASE);
+f0103e2b:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103e2e:	2d 00 00 00 10       	sub    $0x10000000,%eax
+}
+f0103e33:	c9                   	leave  
+f0103e34:	c3                   	ret    
+
+f0103e35 <page2pa>:
+int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
+void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);
+
+static inline physaddr_t
+page2pa(struct PageInfo *pp)
+{
+f0103e35:	55                   	push   %ebp
+f0103e36:	89 e5                	mov    %esp,%ebp
+	return (pp - pages) << PGSHIFT;
+f0103e38:	8b 55 08             	mov    0x8(%ebp),%edx
+f0103e3b:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0103e40:	29 c2                	sub    %eax,%edx
+f0103e42:	89 d0                	mov    %edx,%eax
+f0103e44:	c1 f8 03             	sar    $0x3,%eax
+f0103e47:	c1 e0 0c             	shl    $0xc,%eax
+}
+f0103e4a:	5d                   	pop    %ebp
+f0103e4b:	c3                   	ret    
+
+f0103e4c <pa2page>:
+
+static inline struct PageInfo*
+pa2page(physaddr_t pa)
+{
+f0103e4c:	55                   	push   %ebp
+f0103e4d:	89 e5                	mov    %esp,%ebp
+f0103e4f:	83 ec 18             	sub    $0x18,%esp
+	if (PGNUM(pa) >= npages)
+f0103e52:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103e55:	c1 e8 0c             	shr    $0xc,%eax
+f0103e58:	89 c2                	mov    %eax,%edx
+f0103e5a:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f0103e5f:	39 c2                	cmp    %eax,%edx
+f0103e61:	72 1c                	jb     f0103e7f <pa2page+0x33>
+		panic("pa2page called with invalid pa");
+f0103e63:	c7 44 24 08 90 7b 10 	movl   $0xf0107b90,0x8(%esp)
+f0103e6a:	f0 
+f0103e6b:	c7 44 24 04 4f 00 00 	movl   $0x4f,0x4(%esp)
+f0103e72:	00 
+f0103e73:	c7 04 24 af 7b 10 f0 	movl   $0xf0107baf,(%esp)
+f0103e7a:	e8 36 c2 ff ff       	call   f01000b5 <_panic>
+	return &pages[PGNUM(pa)];
+f0103e7f:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f0103e84:	8b 55 08             	mov    0x8(%ebp),%edx
+f0103e87:	c1 ea 0c             	shr    $0xc,%edx
+f0103e8a:	c1 e2 03             	shl    $0x3,%edx
+f0103e8d:	01 d0                	add    %edx,%eax
+}
+f0103e8f:	c9                   	leave  
+f0103e90:	c3                   	ret    
+
+f0103e91 <page2kva>:
+
+static inline void*
+page2kva(struct PageInfo *pp)
+{
+f0103e91:	55                   	push   %ebp
+f0103e92:	89 e5                	mov    %esp,%ebp
+f0103e94:	83 ec 18             	sub    $0x18,%esp
+	return KADDR(page2pa(pp));
+f0103e97:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103e9a:	89 04 24             	mov    %eax,(%esp)
+f0103e9d:	e8 93 ff ff ff       	call   f0103e35 <page2pa>
+f0103ea2:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0103ea6:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
+f0103ead:	00 
+f0103eae:	c7 04 24 af 7b 10 f0 	movl   $0xf0107baf,(%esp)
+f0103eb5:	e8 39 ff ff ff       	call   f0103df3 <_kaddr>
+}
+f0103eba:	c9                   	leave  
+f0103ebb:	c3                   	ret    
+
+f0103ebc <envid2env>:
+//   On success, sets *env_store to the environment.
+//   On error, sets *env_store to NULL.
+//
+    int
+envid2env(envid_t envid, struct Env **env_store, bool checkperm)
+{
+f0103ebc:	55                   	push   %ebp
+f0103ebd:	89 e5                	mov    %esp,%ebp
+f0103ebf:	83 ec 14             	sub    $0x14,%esp
+f0103ec2:	8b 45 10             	mov    0x10(%ebp),%eax
+f0103ec5:	88 45 ec             	mov    %al,-0x14(%ebp)
+    struct Env *e;
+
+    // If envid is zero, return the current environment.
+    if (envid == 0) {
+f0103ec8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+f0103ecc:	75 15                	jne    f0103ee3 <envid2env+0x27>
+	*env_store = curenv;
+f0103ece:	8b 15 20 eb 18 f0    	mov    0xf018eb20,%edx
+f0103ed4:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0103ed7:	89 10                	mov    %edx,(%eax)
+	return 0;
+f0103ed9:	b8 00 00 00 00       	mov    $0x0,%eax
+f0103ede:	e9 82 00 00 00       	jmp    f0103f65 <envid2env+0xa9>
+    // Look up the Env structure via the index part of the envid,
+    // then check the env_id field in that struct Env
+    // to ensure that the envid is not stale
+    // (i.e., does not refer to a _previous_ environment
+    // that used the same slot in the envs[] array).
+    e = &envs[ENVX(envid)];
+f0103ee3:	8b 0d 1c eb 18 f0    	mov    0xf018eb1c,%ecx
+f0103ee9:	8b 45 08             	mov    0x8(%ebp),%eax
+f0103eec:	25 ff 03 00 00       	and    $0x3ff,%eax
+f0103ef1:	89 c2                	mov    %eax,%edx
+f0103ef3:	89 d0                	mov    %edx,%eax
+f0103ef5:	01 c0                	add    %eax,%eax
+f0103ef7:	01 d0                	add    %edx,%eax
+f0103ef9:	c1 e0 05             	shl    $0x5,%eax
+f0103efc:	01 c8                	add    %ecx,%eax
+f0103efe:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    if (e->env_status == ENV_FREE || e->env_id != envid) {
+f0103f01:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0103f04:	8b 40 54             	mov    0x54(%eax),%eax
+f0103f07:	85 c0                	test   %eax,%eax
+f0103f09:	74 0b                	je     f0103f16 <envid2env+0x5a>
+f0103f0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0103f0e:	8b 40 48             	mov    0x48(%eax),%eax
+f0103f11:	3b 45 08             	cmp    0x8(%ebp),%eax
+f0103f14:	74 10                	je     f0103f26 <envid2env+0x6a>
+	*env_store = 0;
+f0103f16:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0103f19:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	return -E_BAD_ENV;
+f0103f1f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
+f0103f24:	eb 3f                	jmp    f0103f65 <envid2env+0xa9>
+    // Check that the calling environment has legitimate permission
+    // to manipulate the specified environment.
+    // If checkperm is set, the specified environment
+    // must be either the current environment
+    // or an immediate child of the current environment.
+    if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
+f0103f26:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
+f0103f2a:	74 2c                	je     f0103f58 <envid2env+0x9c>
+f0103f2c:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0103f31:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+f0103f34:	74 22                	je     f0103f58 <envid2env+0x9c>
+f0103f36:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0103f39:	8b 50 4c             	mov    0x4c(%eax),%edx
+f0103f3c:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0103f41:	8b 40 48             	mov    0x48(%eax),%eax
+f0103f44:	39 c2                	cmp    %eax,%edx
+f0103f46:	74 10                	je     f0103f58 <envid2env+0x9c>
+	*env_store = 0;
+f0103f48:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0103f4b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	return -E_BAD_ENV;
+f0103f51:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
+f0103f56:	eb 0d                	jmp    f0103f65 <envid2env+0xa9>
+    }
+
+    *env_store = e;
+f0103f58:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0103f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
+f0103f5e:	89 10                	mov    %edx,(%eax)
+    return 0;
+f0103f60:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0103f65:	c9                   	leave  
+f0103f66:	c3                   	ret    
+
+f0103f67 <env_init>:
+// they are in the envs array (i.e., so that the first call to
+// env_alloc() returns envs[0]).
+//
+    void
+env_init(void)
+{
+f0103f67:	55                   	push   %ebp
+f0103f68:	89 e5                	mov    %esp,%ebp
+f0103f6a:	83 ec 18             	sub    $0x18,%esp
+    // Set up envs array
+    // LAB 3: Your code here.
+    int i;
+    env_free_list = NULL;
+f0103f6d:	c7 05 24 eb 18 f0 00 	movl   $0x0,0xf018eb24
+f0103f74:	00 00 00 
+    for (i = NENV - 1; i >= 0; i--) {
+f0103f77:	c7 45 f4 ff 03 00 00 	movl   $0x3ff,-0xc(%ebp)
+f0103f7e:	eb 55                	jmp    f0103fd5 <env_init+0x6e>
+	envs[i].env_id = 0;
+f0103f80:	8b 0d 1c eb 18 f0    	mov    0xf018eb1c,%ecx
+f0103f86:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0103f89:	89 d0                	mov    %edx,%eax
+f0103f8b:	01 c0                	add    %eax,%eax
+f0103f8d:	01 d0                	add    %edx,%eax
+f0103f8f:	c1 e0 05             	shl    $0x5,%eax
+f0103f92:	01 c8                	add    %ecx,%eax
+f0103f94:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
+	envs[i].env_link = env_free_list;
+f0103f9b:	8b 0d 1c eb 18 f0    	mov    0xf018eb1c,%ecx
+f0103fa1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0103fa4:	89 d0                	mov    %edx,%eax
+f0103fa6:	01 c0                	add    %eax,%eax
+f0103fa8:	01 d0                	add    %edx,%eax
+f0103faa:	c1 e0 05             	shl    $0x5,%eax
+f0103fad:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+f0103fb0:	a1 24 eb 18 f0       	mov    0xf018eb24,%eax
+f0103fb5:	89 42 44             	mov    %eax,0x44(%edx)
+	env_free_list = &(envs[i]);
+f0103fb8:	8b 0d 1c eb 18 f0    	mov    0xf018eb1c,%ecx
+f0103fbe:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0103fc1:	89 d0                	mov    %edx,%eax
+f0103fc3:	01 c0                	add    %eax,%eax
+f0103fc5:	01 d0                	add    %edx,%eax
+f0103fc7:	c1 e0 05             	shl    $0x5,%eax
+f0103fca:	01 c8                	add    %ecx,%eax
+f0103fcc:	a3 24 eb 18 f0       	mov    %eax,0xf018eb24
+{
+    // Set up envs array
+    // LAB 3: Your code here.
+    int i;
+    env_free_list = NULL;
+    for (i = NENV - 1; i >= 0; i--) {
+f0103fd1:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+f0103fd5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0103fd9:	79 a5                	jns    f0103f80 <env_init+0x19>
+	envs[i].env_link = env_free_list;
+	env_free_list = &(envs[i]);
+    }
+
+    // Per-CPU part of the initialization
+    env_init_percpu();
+f0103fdb:	e8 02 00 00 00       	call   f0103fe2 <env_init_percpu>
+}
+f0103fe0:	c9                   	leave  
+f0103fe1:	c3                   	ret    
+
+f0103fe2 <env_init_percpu>:
+
+// Load GDT and segment descriptors.
+    void
+env_init_percpu(void)
+{
+f0103fe2:	55                   	push   %ebp
+f0103fe3:	89 e5                	mov    %esp,%ebp
+f0103fe5:	83 ec 04             	sub    $0x4,%esp
+    lgdt(&gdt_pd);
+f0103fe8:	c7 04 24 b0 f5 11 f0 	movl   $0xf011f5b0,(%esp)
+f0103fef:	e8 98 fd ff ff       	call   f0103d8c <lgdt>
+    // The kernel never uses GS or FS, so we leave those set to
+    // the user data segment.
+    asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
+f0103ff4:	b8 23 00 00 00       	mov    $0x23,%eax
+f0103ff9:	8e e8                	mov    %eax,%gs
+    asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
+f0103ffb:	b8 23 00 00 00       	mov    $0x23,%eax
+f0104000:	8e e0                	mov    %eax,%fs
+    // The kernel does use ES, DS, and SS.  We'll change between
+    // the kernel and user data segments as needed.
+    asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
+f0104002:	b8 10 00 00 00       	mov    $0x10,%eax
+f0104007:	8e c0                	mov    %eax,%es
+    asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
+f0104009:	b8 10 00 00 00       	mov    $0x10,%eax
+f010400e:	8e d8                	mov    %eax,%ds
+    asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
+f0104010:	b8 10 00 00 00       	mov    $0x10,%eax
+f0104015:	8e d0                	mov    %eax,%ss
+    // Load the kernel text segment into CS.
+    asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
+f0104017:	ea 1e 40 10 f0 08 00 	ljmp   $0x8,$0xf010401e
+    // For good measure, clear the local descriptor table (LDT),
+    // since we don't use it.
+    lldt(0);
+f010401e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0104025:	e8 6d fd ff ff       	call   f0103d97 <lldt>
+}
+f010402a:	c9                   	leave  
+f010402b:	c3                   	ret    
+
+f010402c <boot_map_region>:
+
+
+
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+f010402c:	55                   	push   %ebp
+f010402d:	89 e5                	mov    %esp,%ebp
+f010402f:	83 ec 28             	sub    $0x28,%esp
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+f0104032:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f0104039:	eb 46                	jmp    f0104081 <boot_map_region+0x55>
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+f010403b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f010403e:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0104041:	01 d0                	add    %edx,%eax
+f0104043:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+f010404a:	00 
+f010404b:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010404f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104052:	89 04 24             	mov    %eax,(%esp)
+f0104055:	e8 25 d9 ff ff       	call   f010197f <pgdir_walk>
+f010405a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+f010405d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0104061:	74 17                	je     f010407a <boot_map_region+0x4e>
+f0104063:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0104066:	8b 45 14             	mov    0x14(%ebp),%eax
+f0104069:	01 c2                	add    %eax,%edx
+f010406b:	8b 45 18             	mov    0x18(%ebp),%eax
+f010406e:	09 d0                	or     %edx,%eax
+f0104070:	83 c8 01             	or     $0x1,%eax
+f0104073:	89 c2                	mov    %eax,%edx
+f0104075:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104078:	89 10                	mov    %edx,(%eax)
+
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+f010407a:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f0104081:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104084:	3b 45 10             	cmp    0x10(%ebp),%eax
+f0104087:	72 b2                	jb     f010403b <boot_map_region+0xf>
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+f0104089:	c9                   	leave  
+f010408a:	c3                   	ret    
+
+f010408b <env_setup_vm>:
+// Returns 0 on success, < 0 on error.  Errors include:
+//	-E_NO_MEM if page directory or table could not be allocated.
+//
+    static int
+env_setup_vm(struct Env *e)
+{
+f010408b:	55                   	push   %ebp
+f010408c:	89 e5                	mov    %esp,%ebp
+f010408e:	53                   	push   %ebx
+f010408f:	83 ec 44             	sub    $0x44,%esp
+    int i;
+    struct PageInfo *p = NULL;
+f0104092:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    // Allocate a page for the page directory
+    if (!(p = page_alloc(ALLOC_ZERO)))
+f0104099:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+f01040a0:	e8 02 d8 ff ff       	call   f01018a7 <page_alloc>
+f01040a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01040a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f01040ac:	75 0a                	jne    f01040b8 <env_setup_vm+0x2d>
+	return -E_NO_MEM;
+f01040ae:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+f01040b3:	e9 ce 01 00 00       	jmp    f0104286 <env_setup_vm+0x1fb>
+    //	is an exception -- you need to increment env_pgdir's
+    //	pp_ref for env_free to work correctly.
+    //    - The functions in kern/pmap.h are handy.
+
+    // LAB 3: Your code here.
+    p->pp_ref++;
+f01040b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01040bb:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+f01040bf:	8d 50 01             	lea    0x1(%eax),%edx
+f01040c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01040c5:	66 89 50 04          	mov    %dx,0x4(%eax)
+    e->env_pgdir = (pde_t*)page2kva(p);
+f01040c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01040cc:	89 04 24             	mov    %eax,(%esp)
+f01040cf:	e8 bd fd ff ff       	call   f0103e91 <page2kva>
+f01040d4:	8b 55 08             	mov    0x8(%ebp),%edx
+f01040d7:	89 42 5c             	mov    %eax,0x5c(%edx)
+    boot_map_region(e->env_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo) * npages, PGSIZE), PADDR(pages), PTE_U);
+f01040da:	a1 d8 f7 18 f0       	mov    0xf018f7d8,%eax
+f01040df:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01040e3:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
+f01040ea:	00 
+f01040eb:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f01040f2:	e8 c1 fc ff ff       	call   f0103db8 <_paddr>
+f01040f7:	89 c1                	mov    %eax,%ecx
+f01040f9:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+f0104100:	a1 d0 f7 18 f0       	mov    0xf018f7d0,%eax
+f0104105:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+f010410c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010410f:	01 d0                	add    %edx,%eax
+f0104111:	83 e8 01             	sub    $0x1,%eax
+f0104114:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f0104117:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f010411a:	ba 00 00 00 00       	mov    $0x0,%edx
+f010411f:	f7 75 f0             	divl   -0x10(%ebp)
+f0104122:	89 d0                	mov    %edx,%eax
+f0104124:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0104127:	29 c2                	sub    %eax,%edx
+f0104129:	8b 45 08             	mov    0x8(%ebp),%eax
+f010412c:	8b 40 5c             	mov    0x5c(%eax),%eax
+f010412f:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
+f0104136:	00 
+f0104137:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f010413b:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010413f:	c7 44 24 04 00 00 00 	movl   $0xef000000,0x4(%esp)
+f0104146:	ef 
+f0104147:	89 04 24             	mov    %eax,(%esp)
+f010414a:	e8 dd fe ff ff       	call   f010402c <boot_map_region>
+    boot_map_region(e->env_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);
+f010414f:	a1 1c eb 18 f0       	mov    0xf018eb1c,%eax
+f0104154:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0104158:	c7 44 24 04 cd 00 00 	movl   $0xcd,0x4(%esp)
+f010415f:	00 
+f0104160:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f0104167:	e8 4c fc ff ff       	call   f0103db8 <_paddr>
+f010416c:	89 c1                	mov    %eax,%ecx
+f010416e:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
+f0104175:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0104178:	05 ff 7f 01 00       	add    $0x17fff,%eax
+f010417d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f0104180:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0104183:	ba 00 00 00 00       	mov    $0x0,%edx
+f0104188:	f7 75 e8             	divl   -0x18(%ebp)
+f010418b:	89 d0                	mov    %edx,%eax
+f010418d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+f0104190:	29 c2                	sub    %eax,%edx
+f0104192:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104195:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104198:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
+f010419f:	00 
+f01041a0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f01041a4:	89 54 24 08          	mov    %edx,0x8(%esp)
+f01041a8:	c7 44 24 04 00 00 c0 	movl   $0xeec00000,0x4(%esp)
+f01041af:	ee 
+f01041b0:	89 04 24             	mov    %eax,(%esp)
+f01041b3:	e8 74 fe ff ff       	call   f010402c <boot_map_region>
+    boot_map_region(e->env_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+f01041b8:	c7 44 24 08 00 50 11 	movl   $0xf0115000,0x8(%esp)
+f01041bf:	f0 
+f01041c0:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
+f01041c7:	00 
+f01041c8:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f01041cf:	e8 e4 fb ff ff       	call   f0103db8 <_paddr>
+f01041d4:	89 c1                	mov    %eax,%ecx
+f01041d6:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
+f01041dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f01041e0:	05 ff 7f 00 00       	add    $0x7fff,%eax
+f01041e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
+f01041e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f01041eb:	ba 00 00 00 00       	mov    $0x0,%edx
+f01041f0:	f7 75 e0             	divl   -0x20(%ebp)
+f01041f3:	89 d0                	mov    %edx,%eax
+f01041f5:	8b 55 dc             	mov    -0x24(%ebp),%edx
+f01041f8:	29 c2                	sub    %eax,%edx
+f01041fa:	89 d0                	mov    %edx,%eax
+f01041fc:	89 c2                	mov    %eax,%edx
+f01041fe:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104201:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104204:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+f010420b:	00 
+f010420c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f0104210:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0104214:	c7 44 24 04 00 80 ff 	movl   $0xefff8000,0x4(%esp)
+f010421b:	ef 
+f010421c:	89 04 24             	mov    %eax,(%esp)
+f010421f:	e8 08 fe ff ff       	call   f010402c <boot_map_region>
+    boot_map_region(e->env_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+f0104224:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104227:	8b 40 5c             	mov    0x5c(%eax),%eax
+f010422a:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+f0104231:	00 
+f0104232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+f0104239:	00 
+f010423a:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
+f0104241:	10 
+f0104242:	c7 44 24 04 00 00 00 	movl   $0xf0000000,0x4(%esp)
+f0104249:	f0 
+f010424a:	89 04 24             	mov    %eax,(%esp)
+f010424d:	e8 da fd ff ff       	call   f010402c <boot_map_region>
+
+    // UVPT maps the env's own page table read-only.
+    // Permissions: kernel R, user R
+    e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+f0104252:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104255:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104258:	8d 98 f4 0e 00 00    	lea    0xef4(%eax),%ebx
+f010425e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104261:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104264:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0104268:	c7 44 24 04 d3 00 00 	movl   $0xd3,0x4(%esp)
+f010426f:	00 
+f0104270:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f0104277:	e8 3c fb ff ff       	call   f0103db8 <_paddr>
+f010427c:	83 c8 05             	or     $0x5,%eax
+f010427f:	89 03                	mov    %eax,(%ebx)
+
+    return 0;
+f0104281:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0104286:	83 c4 44             	add    $0x44,%esp
+f0104289:	5b                   	pop    %ebx
+f010428a:	5d                   	pop    %ebp
+f010428b:	c3                   	ret    
+
+f010428c <env_alloc>:
+//	-E_NO_FREE_ENV if all NENVS environments are allocated
+//	-E_NO_MEM on memory exhaustion
+//
+    int
+env_alloc(struct Env **newenv_store, envid_t parent_id)
+{
+f010428c:	55                   	push   %ebp
+f010428d:	89 e5                	mov    %esp,%ebp
+f010428f:	83 ec 28             	sub    $0x28,%esp
+    int32_t generation;
+    int r;
+    struct Env *e;
+
+    if (!(e = env_free_list))
+f0104292:	a1 24 eb 18 f0       	mov    0xf018eb24,%eax
+f0104297:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f010429a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f010429e:	75 0a                	jne    f01042aa <env_alloc+0x1e>
+	return -E_NO_FREE_ENV;
+f01042a0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
+f01042a5:	e9 16 01 00 00       	jmp    f01043c0 <env_alloc+0x134>
+
+    // Allocate and set up the page directory for this environment.
+    if ((r = env_setup_vm(e)) < 0)
+f01042aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01042ad:	89 04 24             	mov    %eax,(%esp)
+f01042b0:	e8 d6 fd ff ff       	call   f010408b <env_setup_vm>
+f01042b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f01042b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f01042bc:	79 08                	jns    f01042c6 <env_alloc+0x3a>
+	return r;
+f01042be:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01042c1:	e9 fa 00 00 00       	jmp    f01043c0 <env_alloc+0x134>
+
+    // Generate an env_id for this environment.
+    generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+f01042c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01042c9:	8b 40 48             	mov    0x48(%eax),%eax
+f01042cc:	05 00 10 00 00       	add    $0x1000,%eax
+f01042d1:	25 00 fc ff ff       	and    $0xfffffc00,%eax
+f01042d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (generation <= 0)	// Don't create a negative env_id.
+f01042d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f01042dd:	7f 07                	jg     f01042e6 <env_alloc+0x5a>
+	generation = 1 << ENVGENSHIFT;
+f01042df:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
+    e->env_id = generation | (e - envs);
+f01042e6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01042e9:	a1 1c eb 18 f0       	mov    0xf018eb1c,%eax
+f01042ee:	29 c2                	sub    %eax,%edx
+f01042f0:	89 d0                	mov    %edx,%eax
+f01042f2:	c1 f8 05             	sar    $0x5,%eax
+f01042f5:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+f01042fb:	0b 45 f4             	or     -0xc(%ebp),%eax
+f01042fe:	89 c2                	mov    %eax,%edx
+f0104300:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104303:	89 50 48             	mov    %edx,0x48(%eax)
+
+    // Set the basic status variables.
+    e->env_parent_id = parent_id;
+f0104306:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104309:	8b 55 0c             	mov    0xc(%ebp),%edx
+f010430c:	89 50 4c             	mov    %edx,0x4c(%eax)
+    e->env_type = ENV_TYPE_USER;
+f010430f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104312:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
+    e->env_status = ENV_RUNNABLE;
+f0104319:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010431c:	c7 40 54 02 00 00 00 	movl   $0x2,0x54(%eax)
+    e->env_runs = 0;
+f0104323:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104326:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
+
+    // Clear out all the saved register state,
+    // to prevent the register values
+    // of a prior environment inhabiting this Env structure
+    // from "leaking" into our new environment.
+    memset(&e->env_tf, 0, sizeof(e->env_tf));
+f010432d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104330:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
+f0104337:	00 
+f0104338:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010433f:	00 
+f0104340:	89 04 24             	mov    %eax,(%esp)
+f0104343:	e8 9a 21 00 00       	call   f01064e2 <memset>
+    // The low 2 bits of each segment register contains the
+    // Requestor Privilege Level (RPL); 3 means user mode.  When
+    // we switch privilege levels, the hardware does various
+    // checks involving the RPL and the Descriptor Privilege Level
+    // (DPL) stored in the descriptors themselves.
+    e->env_tf.tf_ds = GD_UD | 3;
+f0104348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010434b:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
+    e->env_tf.tf_es = GD_UD | 3;
+f0104351:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104354:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
+    e->env_tf.tf_ss = GD_UD | 3;
+f010435a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010435d:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
+    e->env_tf.tf_esp = USTACKTOP;
+f0104363:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104366:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
+    e->env_tf.tf_cs = GD_UT | 3;
+f010436d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104370:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
+    // You will set e->env_tf.tf_eip later.
+
+    // commit the allocation
+    env_free_list = e->env_link;
+f0104376:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104379:	8b 40 44             	mov    0x44(%eax),%eax
+f010437c:	a3 24 eb 18 f0       	mov    %eax,0xf018eb24
+    *newenv_store = e;
+f0104381:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104384:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0104387:	89 10                	mov    %edx,(%eax)
+
+    cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+f0104389:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010438c:	8b 50 48             	mov    0x48(%eax),%edx
+f010438f:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0104394:	85 c0                	test   %eax,%eax
+f0104396:	74 0a                	je     f01043a2 <env_alloc+0x116>
+f0104398:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010439d:	8b 40 48             	mov    0x48(%eax),%eax
+f01043a0:	eb 05                	jmp    f01043a7 <env_alloc+0x11b>
+f01043a2:	b8 00 00 00 00       	mov    $0x0,%eax
+f01043a7:	89 54 24 08          	mov    %edx,0x8(%esp)
+f01043ab:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01043af:	c7 04 24 c8 7b 10 f0 	movl   $0xf0107bc8,(%esp)
+f01043b6:	e8 d2 05 00 00       	call   f010498d <cprintf>
+    return 0;
+f01043bb:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f01043c0:	c9                   	leave  
+f01043c1:	c3                   	ret    
+
+f01043c2 <region_alloc>:
+// Pages should be writable by user and kernel.
+// Panic if any allocation attempt fails.
+//
+    static void
+region_alloc(struct Env *e, void *va, size_t len)
+{
+f01043c2:	55                   	push   %ebp
+f01043c3:	89 e5                	mov    %esp,%ebp
+f01043c5:	83 ec 38             	sub    $0x38,%esp
+    //
+    // Hint: It is easier to use region_alloc if the caller can pass
+    //   'va' and 'len' values that are not page-aligned.
+    //   You should round va down, and round (va + len) up.
+    //   (Watch out for corner-cases!)
+    int l = 0, va_ = (uintptr_t)va;
+f01043c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f01043cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01043d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    struct PageInfo *p;
+    va = (void*)ROUNDDOWN(va_, PGSIZE);
+f01043d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01043d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f01043db:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01043de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f01043e3:	89 45 0c             	mov    %eax,0xc(%ebp)
+    len = ROUNDUP(va_ + len, PGSIZE) - (uintptr_t)va;
+f01043e6:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
+f01043ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01043f0:	8b 45 10             	mov    0x10(%ebp),%eax
+f01043f3:	01 c2                	add    %eax,%edx
+f01043f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f01043f8:	01 d0                	add    %edx,%eax
+f01043fa:	83 e8 01             	sub    $0x1,%eax
+f01043fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f0104400:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0104403:	ba 00 00 00 00       	mov    $0x0,%edx
+f0104408:	f7 75 e8             	divl   -0x18(%ebp)
+f010440b:	89 d0                	mov    %edx,%eax
+f010440d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+f0104410:	29 c2                	sub    %eax,%edx
+f0104412:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0104415:	29 c2                	sub    %eax,%edx
+f0104417:	89 d0                	mov    %edx,%eax
+f0104419:	89 45 10             	mov    %eax,0x10(%ebp)
+    for (; l < len; l += PGSIZE) {
+f010441c:	e9 81 00 00 00       	jmp    f01044a2 <region_alloc+0xe0>
+	p = page_alloc(0);
+f0104421:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0104428:	e8 7a d4 ff ff       	call   f01018a7 <page_alloc>
+f010442d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+	if (!p) panic("Panic: region_alloc()\n");
+f0104430:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0104434:	75 1c                	jne    f0104452 <region_alloc+0x90>
+f0104436:	c7 44 24 08 dd 7b 10 	movl   $0xf0107bdd,0x8(%esp)
+f010443d:	f0 
+f010443e:	c7 44 24 04 2e 01 00 	movl   $0x12e,0x4(%esp)
+f0104445:	00 
+f0104446:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f010444d:	e8 63 bc ff ff       	call   f01000b5 <_panic>
+	if (page_insert(e->env_pgdir, p, va + l, PTE_U | PTE_W))
+f0104452:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0104455:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0104458:	01 c2                	add    %eax,%edx
+f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010445d:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104460:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
+f0104467:	00 
+f0104468:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010446c:	8b 55 e0             	mov    -0x20(%ebp),%edx
+f010446f:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0104473:	89 04 24             	mov    %eax,(%esp)
+f0104476:	e8 25 d6 ff ff       	call   f0101aa0 <page_insert>
+f010447b:	85 c0                	test   %eax,%eax
+f010447d:	74 1c                	je     f010449b <region_alloc+0xd9>
+	    panic("Panic: region_alloc()\n");
+f010447f:	c7 44 24 08 dd 7b 10 	movl   $0xf0107bdd,0x8(%esp)
+f0104486:	f0 
+f0104487:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
+f010448e:	00 
+f010448f:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f0104496:	e8 1a bc ff ff       	call   f01000b5 <_panic>
+    //   (Watch out for corner-cases!)
+    int l = 0, va_ = (uintptr_t)va;
+    struct PageInfo *p;
+    va = (void*)ROUNDDOWN(va_, PGSIZE);
+    len = ROUNDUP(va_ + len, PGSIZE) - (uintptr_t)va;
+    for (; l < len; l += PGSIZE) {
+f010449b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+f01044a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01044a5:	3b 45 10             	cmp    0x10(%ebp),%eax
+f01044a8:	0f 82 73 ff ff ff    	jb     f0104421 <region_alloc+0x5f>
+	p = page_alloc(0);
+	if (!p) panic("Panic: region_alloc()\n");
+	if (page_insert(e->env_pgdir, p, va + l, PTE_U | PTE_W))
+	    panic("Panic: region_alloc()\n");
+    }
+}
+f01044ae:	c9                   	leave  
+f01044af:	c3                   	ret    
+
+f01044b0 <load_icode>:
+// load_icode panics if it encounters problems.
+//  - How might load_icode fail?  What might be wrong with the given input?
+//
+    static void
+load_icode(struct Env *e, uint8_t *binary)
+{
+f01044b0:	55                   	push   %ebp
+f01044b1:	89 e5                	mov    %esp,%ebp
+f01044b3:	83 ec 28             	sub    $0x28,%esp
+    //  You must also do something with the program's entry point,
+    //  to make sure that the environment starts executing there.
+    //  What?  (See env_run() and env_pop_tf() below.)
+
+    // LAB 3: Your code here.
+    struct Elf *elf = (struct Elf*)binary;
+f01044b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01044b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    struct Proghdr *ph, *eph;
+    struct PageInfo *pp;
+    unsigned i, va, sz, delta;
+
+    if (elf->e_magic != ELF_MAGIC) 
+f01044bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01044bf:	8b 00                	mov    (%eax),%eax
+f01044c1:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
+f01044c6:	74 1c                	je     f01044e4 <load_icode+0x34>
+	panic("Panic: load_icode() ELF_MAGIC\n");
+f01044c8:	c7 44 24 08 f4 7b 10 	movl   $0xf0107bf4,0x8(%esp)
+f01044cf:	f0 
+f01044d0:	c7 44 24 04 70 01 00 	movl   $0x170,0x4(%esp)
+f01044d7:	00 
+f01044d8:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f01044df:	e8 d1 bb ff ff       	call   f01000b5 <_panic>
+    ph = (struct Proghdr*)(binary + elf->e_phoff);
+f01044e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01044e7:	8b 50 1c             	mov    0x1c(%eax),%edx
+f01044ea:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01044ed:	01 d0                	add    %edx,%eax
+f01044ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    eph = ph + elf->e_phnum;
+f01044f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01044f5:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+f01044f9:	0f b7 c0             	movzwl %ax,%eax
+f01044fc:	c1 e0 05             	shl    $0x5,%eax
+f01044ff:	89 c2                	mov    %eax,%edx
+f0104501:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104504:	01 d0                	add    %edx,%eax
+f0104506:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    lcr3(PADDR(e->env_pgdir));
+f0104509:	8b 45 08             	mov    0x8(%ebp),%eax
+f010450c:	8b 40 5c             	mov    0x5c(%eax),%eax
+f010450f:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0104513:	c7 44 24 04 73 01 00 	movl   $0x173,0x4(%esp)
+f010451a:	00 
+f010451b:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f0104522:	e8 91 f8 ff ff       	call   f0103db8 <_paddr>
+f0104527:	89 04 24             	mov    %eax,(%esp)
+f010452a:	e8 7e f8 ff ff       	call   f0103dad <lcr3>
+    for (; ph < eph; ph++) {
+f010452f:	eb 76                	jmp    f01045a7 <load_icode+0xf7>
+	if (ph->p_type != ELF_PROG_LOAD) continue;
+f0104531:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104534:	8b 00                	mov    (%eax),%eax
+f0104536:	83 f8 01             	cmp    $0x1,%eax
+f0104539:	74 02                	je     f010453d <load_icode+0x8d>
+f010453b:	eb 66                	jmp    f01045a3 <load_icode+0xf3>
+	region_alloc(e, (void*)ph->p_va, ph->p_memsz);
+f010453d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104540:	8b 50 14             	mov    0x14(%eax),%edx
+f0104543:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104546:	8b 40 08             	mov    0x8(%eax),%eax
+f0104549:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010454d:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104551:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104554:	89 04 24             	mov    %eax,(%esp)
+f0104557:	e8 66 fe ff ff       	call   f01043c2 <region_alloc>
+	memset((void*)ph->p_va, 0, ph->p_memsz);
+f010455c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010455f:	8b 50 14             	mov    0x14(%eax),%edx
+f0104562:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104565:	8b 40 08             	mov    0x8(%eax),%eax
+f0104568:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010456c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f0104573:	00 
+f0104574:	89 04 24             	mov    %eax,(%esp)
+f0104577:	e8 66 1f 00 00       	call   f01064e2 <memset>
+	memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+f010457c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010457f:	8b 50 10             	mov    0x10(%eax),%edx
+f0104582:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104585:	8b 48 04             	mov    0x4(%eax),%ecx
+f0104588:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010458b:	01 c1                	add    %eax,%ecx
+f010458d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104590:	8b 40 08             	mov    0x8(%eax),%eax
+f0104593:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0104597:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+f010459b:	89 04 24             	mov    %eax,(%esp)
+f010459e:	e8 87 20 00 00       	call   f010662a <memcpy>
+    if (elf->e_magic != ELF_MAGIC) 
+	panic("Panic: load_icode() ELF_MAGIC\n");
+    ph = (struct Proghdr*)(binary + elf->e_phoff);
+    eph = ph + elf->e_phnum;
+    lcr3(PADDR(e->env_pgdir));
+    for (; ph < eph; ph++) {
+f01045a3:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+f01045a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01045aa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+f01045ad:	72 82                	jb     f0104531 <load_icode+0x81>
+	if (ph->p_type != ELF_PROG_LOAD) continue;
+	region_alloc(e, (void*)ph->p_va, ph->p_memsz);
+	memset((void*)ph->p_va, 0, ph->p_memsz);
+	memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+    }
+    lcr3(PADDR(kern_pgdir));
+f01045af:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f01045b4:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01045b8:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
+f01045bf:	00 
+f01045c0:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f01045c7:	e8 ec f7 ff ff       	call   f0103db8 <_paddr>
+f01045cc:	89 04 24             	mov    %eax,(%esp)
+f01045cf:	e8 d9 f7 ff ff       	call   f0103dad <lcr3>
+    e->env_tf.tf_eip = elf->e_entry;
+f01045d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01045d7:	8b 50 18             	mov    0x18(%eax),%edx
+f01045da:	8b 45 08             	mov    0x8(%ebp),%eax
+f01045dd:	89 50 30             	mov    %edx,0x30(%eax)
+
+    // Now map one page for the program's initial stack
+    // at virtual address USTACKTOP - PGSIZE.
+
+    // LAB 3: Your code here.
+    region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
+f01045e0:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+f01045e7:	00 
+f01045e8:	c7 44 24 04 00 d0 bf 	movl   $0xeebfd000,0x4(%esp)
+f01045ef:	ee 
+f01045f0:	8b 45 08             	mov    0x8(%ebp),%eax
+f01045f3:	89 04 24             	mov    %eax,(%esp)
+f01045f6:	e8 c7 fd ff ff       	call   f01043c2 <region_alloc>
+}
+f01045fb:	c9                   	leave  
+f01045fc:	c3                   	ret    
+
+f01045fd <env_create>:
+// before running the first user-mode environment.
+// The new env's parent ID is set to 0.
+//
+    void
+env_create(uint8_t *binary, enum EnvType type)
+{
+f01045fd:	55                   	push   %ebp
+f01045fe:	89 e5                	mov    %esp,%ebp
+f0104600:	83 ec 28             	sub    $0x28,%esp
+    // LAB 3: Your code here.
+    struct Env *e;
+    env_alloc(&e, 0);
+f0104603:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+f010460a:	00 
+f010460b:	8d 45 f4             	lea    -0xc(%ebp),%eax
+f010460e:	89 04 24             	mov    %eax,(%esp)
+f0104611:	e8 76 fc ff ff       	call   f010428c <env_alloc>
+    load_icode(e, binary);
+f0104616:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104619:	8b 55 08             	mov    0x8(%ebp),%edx
+f010461c:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0104620:	89 04 24             	mov    %eax,(%esp)
+f0104623:	e8 88 fe ff ff       	call   f01044b0 <load_icode>
+    e->env_type = type;
+f0104628:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010462b:	8b 55 0c             	mov    0xc(%ebp),%edx
+f010462e:	89 50 50             	mov    %edx,0x50(%eax)
+}
+f0104631:	c9                   	leave  
+f0104632:	c3                   	ret    
+
+f0104633 <env_free>:
+//
+// Frees env e and all memory it uses.
+//
+    void
+env_free(struct Env *e)
+{
+f0104633:	55                   	push   %ebp
+f0104634:	89 e5                	mov    %esp,%ebp
+f0104636:	83 ec 28             	sub    $0x28,%esp
+    physaddr_t pa;
+
+    // If freeing the current environment, switch to kern_pgdir
+    // before freeing the page directory, just in case the page
+    // gets reused.
+    if (e == curenv)
+f0104639:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010463e:	39 45 08             	cmp    %eax,0x8(%ebp)
+f0104641:	75 25                	jne    f0104668 <env_free+0x35>
+	lcr3(PADDR(kern_pgdir));
+f0104643:	a1 d4 f7 18 f0       	mov    0xf018f7d4,%eax
+f0104648:	89 44 24 08          	mov    %eax,0x8(%esp)
+f010464c:	c7 44 24 04 a3 01 00 	movl   $0x1a3,0x4(%esp)
+f0104653:	00 
+f0104654:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f010465b:	e8 58 f7 ff ff       	call   f0103db8 <_paddr>
+f0104660:	89 04 24             	mov    %eax,(%esp)
+f0104663:	e8 45 f7 ff ff       	call   f0103dad <lcr3>
+
+    // Note the environment's demise.
+    cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+f0104668:	8b 45 08             	mov    0x8(%ebp),%eax
+f010466b:	8b 50 48             	mov    0x48(%eax),%edx
+f010466e:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0104673:	85 c0                	test   %eax,%eax
+f0104675:	74 0a                	je     f0104681 <env_free+0x4e>
+f0104677:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010467c:	8b 40 48             	mov    0x48(%eax),%eax
+f010467f:	eb 05                	jmp    f0104686 <env_free+0x53>
+f0104681:	b8 00 00 00 00       	mov    $0x0,%eax
+f0104686:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010468a:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010468e:	c7 04 24 13 7c 10 f0 	movl   $0xf0107c13,(%esp)
+f0104695:	e8 f3 02 00 00       	call   f010498d <cprintf>
+
+    // Flush all mapped pages in the user portion of the address space
+    static_assert(UTOP % PTSIZE == 0);
+    for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
+f010469a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f01046a1:	e9 cf 00 00 00       	jmp    f0104775 <env_free+0x142>
+
+	// only look at mapped page tables
+	if (!(e->env_pgdir[pdeno] & PTE_P))
+f01046a6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01046a9:	8b 40 5c             	mov    0x5c(%eax),%eax
+f01046ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01046af:	c1 e2 02             	shl    $0x2,%edx
+f01046b2:	01 d0                	add    %edx,%eax
+f01046b4:	8b 00                	mov    (%eax),%eax
+f01046b6:	83 e0 01             	and    $0x1,%eax
+f01046b9:	85 c0                	test   %eax,%eax
+f01046bb:	75 05                	jne    f01046c2 <env_free+0x8f>
+	    continue;
+f01046bd:	e9 af 00 00 00       	jmp    f0104771 <env_free+0x13e>
+
+	// find the pa and va of the page table
+	pa = PTE_ADDR(e->env_pgdir[pdeno]);
+f01046c2:	8b 45 08             	mov    0x8(%ebp),%eax
+f01046c5:	8b 40 5c             	mov    0x5c(%eax),%eax
+f01046c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01046cb:	c1 e2 02             	shl    $0x2,%edx
+f01046ce:	01 d0                	add    %edx,%eax
+f01046d0:	8b 00                	mov    (%eax),%eax
+f01046d2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+f01046d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	pt = (pte_t*) KADDR(pa);
+f01046da:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01046dd:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01046e1:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
+f01046e8:	00 
+f01046e9:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f01046f0:	e8 fe f6 ff ff       	call   f0103df3 <_kaddr>
+f01046f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+	// unmap all PTEs in this page table
+	for (pteno = 0; pteno <= PTX(~0); pteno++) {
+f01046f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+f01046ff:	eb 40                	jmp    f0104741 <env_free+0x10e>
+	    if (pt[pteno] & PTE_P)
+f0104701:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104704:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+f010470b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010470e:	01 d0                	add    %edx,%eax
+f0104710:	8b 00                	mov    (%eax),%eax
+f0104712:	83 e0 01             	and    $0x1,%eax
+f0104715:	85 c0                	test   %eax,%eax
+f0104717:	74 24                	je     f010473d <env_free+0x10a>
+		page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
+f0104719:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010471c:	c1 e0 16             	shl    $0x16,%eax
+f010471f:	89 c2                	mov    %eax,%edx
+f0104721:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0104724:	c1 e0 0c             	shl    $0xc,%eax
+f0104727:	09 d0                	or     %edx,%eax
+f0104729:	89 c2                	mov    %eax,%edx
+f010472b:	8b 45 08             	mov    0x8(%ebp),%eax
+f010472e:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104731:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0104735:	89 04 24             	mov    %eax,(%esp)
+f0104738:	e8 89 d4 ff ff       	call   f0101bc6 <page_remove>
+	// find the pa and va of the page table
+	pa = PTE_ADDR(e->env_pgdir[pdeno]);
+	pt = (pte_t*) KADDR(pa);
+
+	// unmap all PTEs in this page table
+	for (pteno = 0; pteno <= PTX(~0); pteno++) {
+f010473d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+f0104741:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
+f0104748:	76 b7                	jbe    f0104701 <env_free+0xce>
+	    if (pt[pteno] & PTE_P)
+		page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
+	}
+
+	// free the page table itself
+	e->env_pgdir[pdeno] = 0;
+f010474a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010474d:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104750:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0104753:	c1 e2 02             	shl    $0x2,%edx
+f0104756:	01 d0                	add    %edx,%eax
+f0104758:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	page_decref(pa2page(pa));
+f010475e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0104761:	89 04 24             	mov    %eax,(%esp)
+f0104764:	e8 e3 f6 ff ff       	call   f0103e4c <pa2page>
+f0104769:	89 04 24             	mov    %eax,(%esp)
+f010476c:	e8 de d1 ff ff       	call   f010194f <page_decref>
+    // Note the environment's demise.
+    cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+
+    // Flush all mapped pages in the user portion of the address space
+    static_assert(UTOP % PTSIZE == 0);
+    for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
+f0104771:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f0104775:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
+f010477c:	0f 86 24 ff ff ff    	jbe    f01046a6 <env_free+0x73>
+	e->env_pgdir[pdeno] = 0;
+	page_decref(pa2page(pa));
+    }
+
+    // free the page directory
+    pa = PADDR(e->env_pgdir);
+f0104782:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104785:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104788:	89 44 24 08          	mov    %eax,0x8(%esp)
+f010478c:	c7 44 24 04 c0 01 00 	movl   $0x1c0,0x4(%esp)
+f0104793:	00 
+f0104794:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f010479b:	e8 18 f6 ff ff       	call   f0103db8 <_paddr>
+f01047a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    e->env_pgdir = 0;
+f01047a3:	8b 45 08             	mov    0x8(%ebp),%eax
+f01047a6:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
+    page_decref(pa2page(pa));
+f01047ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01047b0:	89 04 24             	mov    %eax,(%esp)
+f01047b3:	e8 94 f6 ff ff       	call   f0103e4c <pa2page>
+f01047b8:	89 04 24             	mov    %eax,(%esp)
+f01047bb:	e8 8f d1 ff ff       	call   f010194f <page_decref>
+
+    // return the environment to the free list
+    e->env_status = ENV_FREE;
+f01047c0:	8b 45 08             	mov    0x8(%ebp),%eax
+f01047c3:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
+    e->env_link = env_free_list;
+f01047ca:	8b 15 24 eb 18 f0    	mov    0xf018eb24,%edx
+f01047d0:	8b 45 08             	mov    0x8(%ebp),%eax
+f01047d3:	89 50 44             	mov    %edx,0x44(%eax)
+    env_free_list = e;
+f01047d6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01047d9:	a3 24 eb 18 f0       	mov    %eax,0xf018eb24
+}
+f01047de:	c9                   	leave  
+f01047df:	c3                   	ret    
+
+f01047e0 <env_destroy>:
+//
+// Frees environment e.
+//
+    void
+env_destroy(struct Env *e)
+{
+f01047e0:	55                   	push   %ebp
+f01047e1:	89 e5                	mov    %esp,%ebp
+f01047e3:	83 ec 18             	sub    $0x18,%esp
+    env_free(e);
+f01047e6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01047e9:	89 04 24             	mov    %eax,(%esp)
+f01047ec:	e8 42 fe ff ff       	call   f0104633 <env_free>
+
+    cprintf("Destroyed the only environment - nothing more to do!\n");
+f01047f1:	c7 04 24 2c 7c 10 f0 	movl   $0xf0107c2c,(%esp)
+f01047f8:	e8 90 01 00 00       	call   f010498d <cprintf>
+    while (1)
+	monitor(NULL);
+f01047fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f0104804:	e8 49 c9 ff ff       	call   f0101152 <monitor>
+f0104809:	eb f2                	jmp    f01047fd <env_destroy+0x1d>
+
+f010480b <env_pop_tf>:
+//
+// This function does not return.
+//
+    void
+env_pop_tf(struct Trapframe *tf)
+{
+f010480b:	55                   	push   %ebp
+f010480c:	89 e5                	mov    %esp,%ebp
+f010480e:	83 ec 18             	sub    $0x18,%esp
+    asm volatile(
+f0104811:	8b 65 08             	mov    0x8(%ebp),%esp
+f0104814:	61                   	popa   
+f0104815:	07                   	pop    %es
+f0104816:	1f                   	pop    %ds
+f0104817:	83 c4 08             	add    $0x8,%esp
+f010481a:	cf                   	iret   
+	    "\tpopl %%es\n"
+	    "\tpopl %%ds\n"
+	    "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
+	    "\tiret\n"
+	    : : "g" (tf) : "memory");
+    panic("iret failed");  /* mostly to placate the compiler */
+f010481b:	c7 44 24 08 62 7c 10 	movl   $0xf0107c62,0x8(%esp)
+f0104822:	f0 
+f0104823:	c7 44 24 04 e9 01 00 	movl   $0x1e9,0x4(%esp)
+f010482a:	00 
+f010482b:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f0104832:	e8 7e b8 ff ff       	call   f01000b5 <_panic>
+
+f0104837 <env_run>:
+//
+// This function does not return.
+//
+    void
+env_run(struct Env *e)
+{
+f0104837:	55                   	push   %ebp
+f0104838:	89 e5                	mov    %esp,%ebp
+f010483a:	83 ec 18             	sub    $0x18,%esp
+    //	e->env_tf.  Go back through the code you wrote above
+    //	and make sure you have set the relevant parts of
+    //	e->env_tf to sensible values.
+
+    // LAB 3: Your code here.
+    if (curenv) {
+f010483d:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0104842:	85 c0                	test   %eax,%eax
+f0104844:	74 19                	je     f010485f <env_run+0x28>
+	if (curenv->env_status == ENV_RUNNING)
+f0104846:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010484b:	8b 40 54             	mov    0x54(%eax),%eax
+f010484e:	83 f8 03             	cmp    $0x3,%eax
+f0104851:	75 0c                	jne    f010485f <env_run+0x28>
+	    curenv->env_status = ENV_RUNNABLE;
+f0104853:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0104858:	c7 40 54 02 00 00 00 	movl   $0x2,0x54(%eax)
+    }
+    curenv = e;
+f010485f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104862:	a3 20 eb 18 f0       	mov    %eax,0xf018eb20
+    curenv->env_status = ENV_RUNNING;
+f0104867:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010486c:	c7 40 54 03 00 00 00 	movl   $0x3,0x54(%eax)
+    curenv->env_runs++;
+f0104873:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0104878:	8b 50 58             	mov    0x58(%eax),%edx
+f010487b:	83 c2 01             	add    $0x1,%edx
+f010487e:	89 50 58             	mov    %edx,0x58(%eax)
+    lcr3(PADDR(e->env_pgdir));
+f0104881:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104884:	8b 40 5c             	mov    0x5c(%eax),%eax
+f0104887:	89 44 24 08          	mov    %eax,0x8(%esp)
+f010488b:	c7 44 24 04 0e 02 00 	movl   $0x20e,0x4(%esp)
+f0104892:	00 
+f0104893:	c7 04 24 bd 7b 10 f0 	movl   $0xf0107bbd,(%esp)
+f010489a:	e8 19 f5 ff ff       	call   f0103db8 <_paddr>
+f010489f:	89 04 24             	mov    %eax,(%esp)
+f01048a2:	e8 06 f5 ff ff       	call   f0103dad <lcr3>
+
+    env_pop_tf(&e->env_tf);
+f01048a7:	8b 45 08             	mov    0x8(%ebp),%eax
+f01048aa:	89 04 24             	mov    %eax,(%esp)
+f01048ad:	e8 59 ff ff ff       	call   f010480b <env_pop_tf>
+
+f01048b2 <inb>:
+	asm volatile("int3");
+}
+
+static inline uint8_t
+inb(int port)
+{
+f01048b2:	55                   	push   %ebp
+f01048b3:	89 e5                	mov    %esp,%ebp
+f01048b5:	83 ec 10             	sub    $0x10,%esp
+	uint8_t data;
+	asm volatile("inb %w1,%0" : "=a" (data) : "d" (port));
+f01048b8:	8b 45 08             	mov    0x8(%ebp),%eax
+f01048bb:	89 c2                	mov    %eax,%edx
+f01048bd:	ec                   	in     (%dx),%al
+f01048be:	88 45 ff             	mov    %al,-0x1(%ebp)
+	return data;
+f01048c1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+f01048c5:	c9                   	leave  
+f01048c6:	c3                   	ret    
+
+f01048c7 <outb>:
+		     : "memory", "cc");
+}
+
+static inline void
+outb(int port, uint8_t data)
+{
+f01048c7:	55                   	push   %ebp
+f01048c8:	89 e5                	mov    %esp,%ebp
+f01048ca:	83 ec 04             	sub    $0x4,%esp
+f01048cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01048d0:	88 45 fc             	mov    %al,-0x4(%ebp)
+	asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
+f01048d3:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
+f01048d7:	8b 55 08             	mov    0x8(%ebp),%edx
+f01048da:	ee                   	out    %al,(%dx)
+}
+f01048db:	c9                   	leave  
+f01048dc:	c3                   	ret    
+
+f01048dd <mc146818_read>:
+#include <kern/kclock.h>
+
+
+unsigned
+mc146818_read(unsigned reg)
+{
+f01048dd:	55                   	push   %ebp
+f01048de:	89 e5                	mov    %esp,%ebp
+f01048e0:	83 ec 08             	sub    $0x8,%esp
+	outb(IO_RTC, reg);
+f01048e3:	8b 45 08             	mov    0x8(%ebp),%eax
+f01048e6:	0f b6 c0             	movzbl %al,%eax
+f01048e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01048ed:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
+f01048f4:	e8 ce ff ff ff       	call   f01048c7 <outb>
+	return inb(IO_RTC+1);
+f01048f9:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
+f0104900:	e8 ad ff ff ff       	call   f01048b2 <inb>
+f0104905:	0f b6 c0             	movzbl %al,%eax
+}
+f0104908:	c9                   	leave  
+f0104909:	c3                   	ret    
+
+f010490a <mc146818_write>:
+
+void
+mc146818_write(unsigned reg, unsigned datum)
+{
+f010490a:	55                   	push   %ebp
+f010490b:	89 e5                	mov    %esp,%ebp
+f010490d:	83 ec 08             	sub    $0x8,%esp
+	outb(IO_RTC, reg);
+f0104910:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104913:	0f b6 c0             	movzbl %al,%eax
+f0104916:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010491a:	c7 04 24 70 00 00 00 	movl   $0x70,(%esp)
+f0104921:	e8 a1 ff ff ff       	call   f01048c7 <outb>
+	outb(IO_RTC+1, datum);
+f0104926:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0104929:	0f b6 c0             	movzbl %al,%eax
+f010492c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104930:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
+f0104937:	e8 8b ff ff ff       	call   f01048c7 <outb>
+}
+f010493c:	c9                   	leave  
+f010493d:	c3                   	ret    
+
+f010493e <putch>:
+#include <inc/stdarg.h>
+
+
+static void
+putch(int ch, int *cnt)
+{
+f010493e:	55                   	push   %ebp
+f010493f:	89 e5                	mov    %esp,%ebp
+f0104941:	83 ec 18             	sub    $0x18,%esp
+	cputchar(ch);
+f0104944:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104947:	89 04 24             	mov    %eax,(%esp)
+f010494a:	e8 c7 bf ff ff       	call   f0100916 <cputchar>
+	*cnt++;
+f010494f:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0104952:	83 c0 04             	add    $0x4,%eax
+f0104955:	89 45 0c             	mov    %eax,0xc(%ebp)
+}
+f0104958:	c9                   	leave  
+f0104959:	c3                   	ret    
+
+f010495a <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+f010495a:	55                   	push   %ebp
+f010495b:	89 e5                	mov    %esp,%ebp
+f010495d:	83 ec 28             	sub    $0x28,%esp
+	int cnt = 0;
+f0104960:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	vprintfmt((void*)putch, &cnt, fmt, ap);
+f0104967:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010496a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f010496e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104971:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0104975:	8d 45 f4             	lea    -0xc(%ebp),%eax
+f0104978:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010497c:	c7 04 24 3e 49 10 f0 	movl   $0xf010493e,(%esp)
+f0104983:	e8 e5 11 00 00       	call   f0105b6d <vprintfmt>
+	return cnt;
+f0104988:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+f010498b:	c9                   	leave  
+f010498c:	c3                   	ret    
+
+f010498d <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+f010498d:	55                   	push   %ebp
+f010498e:	89 e5                	mov    %esp,%ebp
+f0104990:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+f0104993:	8d 45 0c             	lea    0xc(%ebp),%eax
+f0104996:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+f0104999:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010499c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01049a0:	8b 45 08             	mov    0x8(%ebp),%eax
+f01049a3:	89 04 24             	mov    %eax,(%esp)
+f01049a6:	e8 af ff ff ff       	call   f010495a <vcprintf>
+f01049ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+f01049ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+f01049b1:	c9                   	leave  
+f01049b2:	c3                   	ret    
+
+f01049b3 <lidt>:
+	asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
+}
+
+static inline void
+lidt(void *p)
+{
+f01049b3:	55                   	push   %ebp
+f01049b4:	89 e5                	mov    %esp,%ebp
+	asm volatile("lidt (%0)" : : "r" (p));
+f01049b6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01049b9:	0f 01 18             	lidtl  (%eax)
+}
+f01049bc:	5d                   	pop    %ebp
+f01049bd:	c3                   	ret    
+
+f01049be <ltr>:
+	asm volatile("lldt %0" : : "r" (sel));
+}
+
+static inline void
+ltr(uint16_t sel)
+{
+f01049be:	55                   	push   %ebp
+f01049bf:	89 e5                	mov    %esp,%ebp
+f01049c1:	83 ec 04             	sub    $0x4,%esp
+f01049c4:	8b 45 08             	mov    0x8(%ebp),%eax
+f01049c7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+	asm volatile("ltr %0" : : "r" (sel));
+f01049cb:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+f01049cf:	0f 00 d8             	ltr    %ax
+}
+f01049d2:	c9                   	leave  
+f01049d3:	c3                   	ret    
+
+f01049d4 <rcr2>:
+	return val;
+}
+
+static inline uint32_t
+rcr2(void)
+{
+f01049d4:	55                   	push   %ebp
+f01049d5:	89 e5                	mov    %esp,%ebp
+f01049d7:	83 ec 10             	sub    $0x10,%esp
+	uint32_t val;
+	asm volatile("movl %%cr2,%0" : "=r" (val));
+f01049da:	0f 20 d0             	mov    %cr2,%eax
+f01049dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	return val;
+f01049e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f01049e3:	c9                   	leave  
+f01049e4:	c3                   	ret    
+
+f01049e5 <read_eflags>:
+	asm volatile("movl %0,%%cr3" : : "r" (cr3));
+}
+
+static inline uint32_t
+read_eflags(void)
+{
+f01049e5:	55                   	push   %ebp
+f01049e6:	89 e5                	mov    %esp,%ebp
+f01049e8:	83 ec 10             	sub    $0x10,%esp
+	uint32_t eflags;
+	asm volatile("pushfl; popl %0" : "=r" (eflags));
+f01049eb:	9c                   	pushf  
+f01049ec:	58                   	pop    %eax
+f01049ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	return eflags;
+f01049f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f01049f3:	c9                   	leave  
+f01049f4:	c3                   	ret    
+
+f01049f5 <trapname>:
+    sizeof(idt) - 1, (uint32_t) idt
+};
+
+
+static const char *trapname(int trapno)
+{
+f01049f5:	55                   	push   %ebp
+f01049f6:	89 e5                	mov    %esp,%ebp
+	"Alignment Check",
+	"Machine-Check",
+	"SIMD Floating-Point Exception"
+    };
+
+    if (trapno < ARRAY_SIZE(excnames))
+f01049f8:	8b 45 08             	mov    0x8(%ebp),%eax
+f01049fb:	83 f8 13             	cmp    $0x13,%eax
+f01049fe:	77 0c                	ja     f0104a0c <trapname+0x17>
+	return excnames[trapno];
+f0104a00:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104a03:	8b 04 85 40 80 10 f0 	mov    -0xfef7fc0(,%eax,4),%eax
+f0104a0a:	eb 12                	jmp    f0104a1e <trapname+0x29>
+    if (trapno == T_SYSCALL)
+f0104a0c:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
+f0104a10:	75 07                	jne    f0104a19 <trapname+0x24>
+	return "System call";
+f0104a12:	b8 80 7c 10 f0       	mov    $0xf0107c80,%eax
+f0104a17:	eb 05                	jmp    f0104a1e <trapname+0x29>
+    return "(unknown trap)";
+f0104a19:	b8 8c 7c 10 f0       	mov    $0xf0107c8c,%eax
+}
+f0104a1e:	5d                   	pop    %ebp
+f0104a1f:	c3                   	ret    
+
+f0104a20 <trap_init>:
+
+
+    void
+trap_init(void)
+{
+f0104a20:	55                   	push   %ebp
+f0104a21:	89 e5                	mov    %esp,%ebp
+f0104a23:	83 ec 18             	sub    $0x18,%esp
+    extern struct Segdesc gdt[];
+    extern long vectors[];
+    int i;
+
+    // LAB 3: Your code here.
+    for (i = 0; i <= 0x30; ++i) {
+f0104a26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+f0104a2d:	e9 98 01 00 00       	jmp    f0104bca <trap_init+0x1aa>
+	switch (i) {
+f0104a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a35:	83 f8 03             	cmp    $0x3,%eax
+f0104a38:	74 09                	je     f0104a43 <trap_init+0x23>
+f0104a3a:	83 f8 30             	cmp    $0x30,%eax
+f0104a3d:	0f 85 c4 00 00 00    	jne    f0104b07 <trap_init+0xe7>
+	    case T_BRKPT:
+	    case T_SYSCALL:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 3);
+f0104a43:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a46:	8b 04 85 bc f5 11 f0 	mov    -0xfee0a44(,%eax,4),%eax
+f0104a4d:	89 c2                	mov    %eax,%edx
+f0104a4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a52:	66 89 14 c5 40 eb 18 	mov    %dx,-0xfe714c0(,%eax,8)
+f0104a59:	f0 
+f0104a5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a5d:	66 c7 04 c5 42 eb 18 	movw   $0x8,-0xfe714be(,%eax,8)
+f0104a64:	f0 08 00 
+f0104a67:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a6a:	0f b6 14 c5 44 eb 18 	movzbl -0xfe714bc(,%eax,8),%edx
+f0104a71:	f0 
+f0104a72:	83 e2 e0             	and    $0xffffffe0,%edx
+f0104a75:	88 14 c5 44 eb 18 f0 	mov    %dl,-0xfe714bc(,%eax,8)
+f0104a7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a7f:	0f b6 14 c5 44 eb 18 	movzbl -0xfe714bc(,%eax,8),%edx
+f0104a86:	f0 
+f0104a87:	83 e2 1f             	and    $0x1f,%edx
+f0104a8a:	88 14 c5 44 eb 18 f0 	mov    %dl,-0xfe714bc(,%eax,8)
+f0104a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104a94:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104a9b:	f0 
+f0104a9c:	83 e2 f0             	and    $0xfffffff0,%edx
+f0104a9f:	83 ca 0e             	or     $0xe,%edx
+f0104aa2:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104aac:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104ab3:	f0 
+f0104ab4:	83 e2 ef             	and    $0xffffffef,%edx
+f0104ab7:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104abe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104ac1:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104ac8:	f0 
+f0104ac9:	83 ca 60             	or     $0x60,%edx
+f0104acc:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104ad6:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104add:	f0 
+f0104ade:	83 ca 80             	or     $0xffffff80,%edx
+f0104ae1:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104ae8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104aeb:	8b 04 85 bc f5 11 f0 	mov    -0xfee0a44(,%eax,4),%eax
+f0104af2:	c1 e8 10             	shr    $0x10,%eax
+f0104af5:	89 c2                	mov    %eax,%edx
+f0104af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104afa:	66 89 14 c5 46 eb 18 	mov    %dx,-0xfe714ba(,%eax,8)
+f0104b01:	f0 
+		break;
+f0104b02:	e9 bf 00 00 00       	jmp    f0104bc6 <trap_init+0x1a6>
+	    default:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 0);
+f0104b07:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b0a:	8b 04 85 bc f5 11 f0 	mov    -0xfee0a44(,%eax,4),%eax
+f0104b11:	89 c2                	mov    %eax,%edx
+f0104b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b16:	66 89 14 c5 40 eb 18 	mov    %dx,-0xfe714c0(,%eax,8)
+f0104b1d:	f0 
+f0104b1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b21:	66 c7 04 c5 42 eb 18 	movw   $0x8,-0xfe714be(,%eax,8)
+f0104b28:	f0 08 00 
+f0104b2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b2e:	0f b6 14 c5 44 eb 18 	movzbl -0xfe714bc(,%eax,8),%edx
+f0104b35:	f0 
+f0104b36:	83 e2 e0             	and    $0xffffffe0,%edx
+f0104b39:	88 14 c5 44 eb 18 f0 	mov    %dl,-0xfe714bc(,%eax,8)
+f0104b40:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b43:	0f b6 14 c5 44 eb 18 	movzbl -0xfe714bc(,%eax,8),%edx
+f0104b4a:	f0 
+f0104b4b:	83 e2 1f             	and    $0x1f,%edx
+f0104b4e:	88 14 c5 44 eb 18 f0 	mov    %dl,-0xfe714bc(,%eax,8)
+f0104b55:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b58:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104b5f:	f0 
+f0104b60:	83 e2 f0             	and    $0xfffffff0,%edx
+f0104b63:	83 ca 0e             	or     $0xe,%edx
+f0104b66:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104b6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b70:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104b77:	f0 
+f0104b78:	83 e2 ef             	and    $0xffffffef,%edx
+f0104b7b:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104b82:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b85:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104b8c:	f0 
+f0104b8d:	83 e2 9f             	and    $0xffffff9f,%edx
+f0104b90:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104b97:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104b9a:	0f b6 14 c5 45 eb 18 	movzbl -0xfe714bb(,%eax,8),%edx
+f0104ba1:	f0 
+f0104ba2:	83 ca 80             	or     $0xffffff80,%edx
+f0104ba5:	88 14 c5 45 eb 18 f0 	mov    %dl,-0xfe714bb(,%eax,8)
+f0104bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104baf:	8b 04 85 bc f5 11 f0 	mov    -0xfee0a44(,%eax,4),%eax
+f0104bb6:	c1 e8 10             	shr    $0x10,%eax
+f0104bb9:	89 c2                	mov    %eax,%edx
+f0104bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0104bbe:	66 89 14 c5 46 eb 18 	mov    %dx,-0xfe714ba(,%eax,8)
+f0104bc5:	f0 
+    extern struct Segdesc gdt[];
+    extern long vectors[];
+    int i;
+
+    // LAB 3: Your code here.
+    for (i = 0; i <= 0x30; ++i) {
+f0104bc6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+f0104bca:	83 7d f4 30          	cmpl   $0x30,-0xc(%ebp)
+f0104bce:	0f 8e 5e fe ff ff    	jle    f0104a32 <trap_init+0x12>
+	    default:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 0);
+	}
+    }
+    // Per-CPU setup 
+    trap_init_percpu();
+f0104bd4:	e8 02 00 00 00       	call   f0104bdb <trap_init_percpu>
+}
+f0104bd9:	c9                   	leave  
+f0104bda:	c3                   	ret    
+
+f0104bdb <trap_init_percpu>:
+
+// Initialize and load the per-CPU TSS and IDT
+    void
+trap_init_percpu(void)
+{
+f0104bdb:	55                   	push   %ebp
+f0104bdc:	89 e5                	mov    %esp,%ebp
+f0104bde:	83 ec 04             	sub    $0x4,%esp
+    // Setup a TSS so that we get the right stack
+    // when we trap to the kernel.
+    ts.ts_esp0 = KSTACKTOP;
+f0104be1:	c7 05 44 f3 18 f0 00 	movl   $0xf0000000,0xf018f344
+f0104be8:	00 00 f0 
+    ts.ts_ss0 = GD_KD;
+f0104beb:	66 c7 05 48 f3 18 f0 	movw   $0x10,0xf018f348
+f0104bf2:	10 00 
+
+    // Initialize the TSS slot of the gdt.
+    gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
+f0104bf4:	66 c7 05 a8 f5 11 f0 	movw   $0x67,0xf011f5a8
+f0104bfb:	67 00 
+f0104bfd:	b8 40 f3 18 f0       	mov    $0xf018f340,%eax
+f0104c02:	66 a3 aa f5 11 f0    	mov    %ax,0xf011f5aa
+f0104c08:	b8 40 f3 18 f0       	mov    $0xf018f340,%eax
+f0104c0d:	c1 e8 10             	shr    $0x10,%eax
+f0104c10:	a2 ac f5 11 f0       	mov    %al,0xf011f5ac
+f0104c15:	0f b6 05 ad f5 11 f0 	movzbl 0xf011f5ad,%eax
+f0104c1c:	83 e0 f0             	and    $0xfffffff0,%eax
+f0104c1f:	83 c8 09             	or     $0x9,%eax
+f0104c22:	a2 ad f5 11 f0       	mov    %al,0xf011f5ad
+f0104c27:	0f b6 05 ad f5 11 f0 	movzbl 0xf011f5ad,%eax
+f0104c2e:	83 c8 10             	or     $0x10,%eax
+f0104c31:	a2 ad f5 11 f0       	mov    %al,0xf011f5ad
+f0104c36:	0f b6 05 ad f5 11 f0 	movzbl 0xf011f5ad,%eax
+f0104c3d:	83 e0 9f             	and    $0xffffff9f,%eax
+f0104c40:	a2 ad f5 11 f0       	mov    %al,0xf011f5ad
+f0104c45:	0f b6 05 ad f5 11 f0 	movzbl 0xf011f5ad,%eax
+f0104c4c:	83 c8 80             	or     $0xffffff80,%eax
+f0104c4f:	a2 ad f5 11 f0       	mov    %al,0xf011f5ad
+f0104c54:	0f b6 05 ae f5 11 f0 	movzbl 0xf011f5ae,%eax
+f0104c5b:	83 e0 f0             	and    $0xfffffff0,%eax
+f0104c5e:	a2 ae f5 11 f0       	mov    %al,0xf011f5ae
+f0104c63:	0f b6 05 ae f5 11 f0 	movzbl 0xf011f5ae,%eax
+f0104c6a:	83 e0 ef             	and    $0xffffffef,%eax
+f0104c6d:	a2 ae f5 11 f0       	mov    %al,0xf011f5ae
+f0104c72:	0f b6 05 ae f5 11 f0 	movzbl 0xf011f5ae,%eax
+f0104c79:	83 e0 df             	and    $0xffffffdf,%eax
+f0104c7c:	a2 ae f5 11 f0       	mov    %al,0xf011f5ae
+f0104c81:	0f b6 05 ae f5 11 f0 	movzbl 0xf011f5ae,%eax
+f0104c88:	83 c8 40             	or     $0x40,%eax
+f0104c8b:	a2 ae f5 11 f0       	mov    %al,0xf011f5ae
+f0104c90:	0f b6 05 ae f5 11 f0 	movzbl 0xf011f5ae,%eax
+f0104c97:	83 e0 7f             	and    $0x7f,%eax
+f0104c9a:	a2 ae f5 11 f0       	mov    %al,0xf011f5ae
+f0104c9f:	b8 40 f3 18 f0       	mov    $0xf018f340,%eax
+f0104ca4:	c1 e8 18             	shr    $0x18,%eax
+f0104ca7:	a2 af f5 11 f0       	mov    %al,0xf011f5af
+	    sizeof(struct Taskstate) - 1, 0);
+    gdt[GD_TSS0 >> 3].sd_s = 0;
+f0104cac:	0f b6 05 ad f5 11 f0 	movzbl 0xf011f5ad,%eax
+f0104cb3:	83 e0 ef             	and    $0xffffffef,%eax
+f0104cb6:	a2 ad f5 11 f0       	mov    %al,0xf011f5ad
+
+    // Load the TSS selector (like other segment selectors, the
+    // bottom three bits are special; we leave them 0)
+    ltr(GD_TSS0);
+f0104cbb:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
+f0104cc2:	e8 f7 fc ff ff       	call   f01049be <ltr>
+
+    // Load the IDT
+    lidt(&idt_pd);
+f0104cc7:	c7 04 24 b6 f5 11 f0 	movl   $0xf011f5b6,(%esp)
+f0104cce:	e8 e0 fc ff ff       	call   f01049b3 <lidt>
+}
+f0104cd3:	c9                   	leave  
+f0104cd4:	c3                   	ret    
+
+f0104cd5 <print_trapframe>:
+
+    void
+print_trapframe(struct Trapframe *tf)
+{
+f0104cd5:	55                   	push   %ebp
+f0104cd6:	89 e5                	mov    %esp,%ebp
+f0104cd8:	83 ec 18             	sub    $0x18,%esp
+    cprintf("TRAP frame at %p\n", tf);
+f0104cdb:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104cde:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104ce2:	c7 04 24 9b 7c 10 f0 	movl   $0xf0107c9b,(%esp)
+f0104ce9:	e8 9f fc ff ff       	call   f010498d <cprintf>
+    print_regs(&tf->tf_regs);
+f0104cee:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104cf1:	89 04 24             	mov    %eax,(%esp)
+f0104cf4:	e8 a1 01 00 00       	call   f0104e9a <print_regs>
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+f0104cf9:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104cfc:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+f0104d00:	0f b7 c0             	movzwl %ax,%eax
+f0104d03:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104d07:	c7 04 24 ad 7c 10 f0 	movl   $0xf0107cad,(%esp)
+f0104d0e:	e8 7a fc ff ff       	call   f010498d <cprintf>
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+f0104d13:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104d16:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+f0104d1a:	0f b7 c0             	movzwl %ax,%eax
+f0104d1d:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104d21:	c7 04 24 c0 7c 10 f0 	movl   $0xf0107cc0,(%esp)
+f0104d28:	e8 60 fc ff ff       	call   f010498d <cprintf>
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+f0104d2d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104d30:	8b 40 28             	mov    0x28(%eax),%eax
+f0104d33:	89 04 24             	mov    %eax,(%esp)
+f0104d36:	e8 ba fc ff ff       	call   f01049f5 <trapname>
+f0104d3b:	8b 55 08             	mov    0x8(%ebp),%edx
+f0104d3e:	8b 52 28             	mov    0x28(%edx),%edx
+f0104d41:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0104d45:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0104d49:	c7 04 24 d3 7c 10 f0 	movl   $0xf0107cd3,(%esp)
+f0104d50:	e8 38 fc ff ff       	call   f010498d <cprintf>
+    // If this trap was a page fault that just happened
+    // (so %cr2 is meaningful), print the faulting linear address.
+    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
+f0104d55:	a1 a8 f3 18 f0       	mov    0xf018f3a8,%eax
+f0104d5a:	39 45 08             	cmp    %eax,0x8(%ebp)
+f0104d5d:	75 20                	jne    f0104d7f <print_trapframe+0xaa>
+f0104d5f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104d62:	8b 40 28             	mov    0x28(%eax),%eax
+f0104d65:	83 f8 0e             	cmp    $0xe,%eax
+f0104d68:	75 15                	jne    f0104d7f <print_trapframe+0xaa>
+	cprintf("  cr2  0x%08x\n", rcr2());
+f0104d6a:	e8 65 fc ff ff       	call   f01049d4 <rcr2>
+f0104d6f:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104d73:	c7 04 24 e5 7c 10 f0 	movl   $0xf0107ce5,(%esp)
+f0104d7a:	e8 0e fc ff ff       	call   f010498d <cprintf>
+    cprintf("  err  0x%08x", tf->tf_err);
+f0104d7f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104d82:	8b 40 2c             	mov    0x2c(%eax),%eax
+f0104d85:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104d89:	c7 04 24 f4 7c 10 f0 	movl   $0xf0107cf4,(%esp)
+f0104d90:	e8 f8 fb ff ff       	call   f010498d <cprintf>
+    // For page faults, print decoded fault error code:
+    // U/K=fault occurred in user/kernel mode
+    // W/R=a write/read caused the fault
+    // PR=a protection violation caused the fault (NP=page not present).
+    if (tf->tf_trapno == T_PGFLT)
+f0104d95:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104d98:	8b 40 28             	mov    0x28(%eax),%eax
+f0104d9b:	83 f8 0e             	cmp    $0xe,%eax
+f0104d9e:	75 65                	jne    f0104e05 <print_trapframe+0x130>
+	cprintf(" [%s, %s, %s]\n",
+		tf->tf_err & 4 ? "user" : "kernel",
+		tf->tf_err & 2 ? "write" : "read",
+		tf->tf_err & 1 ? "protection" : "not-present");
+f0104da0:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104da3:	8b 40 2c             	mov    0x2c(%eax),%eax
+f0104da6:	83 e0 01             	and    $0x1,%eax
+    // For page faults, print decoded fault error code:
+    // U/K=fault occurred in user/kernel mode
+    // W/R=a write/read caused the fault
+    // PR=a protection violation caused the fault (NP=page not present).
+    if (tf->tf_trapno == T_PGFLT)
+	cprintf(" [%s, %s, %s]\n",
+f0104da9:	85 c0                	test   %eax,%eax
+f0104dab:	74 07                	je     f0104db4 <print_trapframe+0xdf>
+f0104dad:	b9 02 7d 10 f0       	mov    $0xf0107d02,%ecx
+f0104db2:	eb 05                	jmp    f0104db9 <print_trapframe+0xe4>
+f0104db4:	b9 0d 7d 10 f0       	mov    $0xf0107d0d,%ecx
+		tf->tf_err & 4 ? "user" : "kernel",
+		tf->tf_err & 2 ? "write" : "read",
+f0104db9:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104dbc:	8b 40 2c             	mov    0x2c(%eax),%eax
+f0104dbf:	83 e0 02             	and    $0x2,%eax
+    // For page faults, print decoded fault error code:
+    // U/K=fault occurred in user/kernel mode
+    // W/R=a write/read caused the fault
+    // PR=a protection violation caused the fault (NP=page not present).
+    if (tf->tf_trapno == T_PGFLT)
+	cprintf(" [%s, %s, %s]\n",
+f0104dc2:	85 c0                	test   %eax,%eax
+f0104dc4:	74 07                	je     f0104dcd <print_trapframe+0xf8>
+f0104dc6:	ba 19 7d 10 f0       	mov    $0xf0107d19,%edx
+f0104dcb:	eb 05                	jmp    f0104dd2 <print_trapframe+0xfd>
+f0104dcd:	ba 1f 7d 10 f0       	mov    $0xf0107d1f,%edx
+		tf->tf_err & 4 ? "user" : "kernel",
+f0104dd2:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104dd5:	8b 40 2c             	mov    0x2c(%eax),%eax
+f0104dd8:	83 e0 04             	and    $0x4,%eax
+    // For page faults, print decoded fault error code:
+    // U/K=fault occurred in user/kernel mode
+    // W/R=a write/read caused the fault
+    // PR=a protection violation caused the fault (NP=page not present).
+    if (tf->tf_trapno == T_PGFLT)
+	cprintf(" [%s, %s, %s]\n",
+f0104ddb:	85 c0                	test   %eax,%eax
+f0104ddd:	74 07                	je     f0104de6 <print_trapframe+0x111>
+f0104ddf:	b8 24 7d 10 f0       	mov    $0xf0107d24,%eax
+f0104de4:	eb 05                	jmp    f0104deb <print_trapframe+0x116>
+f0104de6:	b8 29 7d 10 f0       	mov    $0xf0107d29,%eax
+f0104deb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+f0104def:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0104df3:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104df7:	c7 04 24 30 7d 10 f0 	movl   $0xf0107d30,(%esp)
+f0104dfe:	e8 8a fb ff ff       	call   f010498d <cprintf>
+f0104e03:	eb 0c                	jmp    f0104e11 <print_trapframe+0x13c>
+		tf->tf_err & 4 ? "user" : "kernel",
+		tf->tf_err & 2 ? "write" : "read",
+		tf->tf_err & 1 ? "protection" : "not-present");
+    else
+	cprintf("\n");
+f0104e05:	c7 04 24 3f 7d 10 f0 	movl   $0xf0107d3f,(%esp)
+f0104e0c:	e8 7c fb ff ff       	call   f010498d <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+f0104e11:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104e14:	8b 40 30             	mov    0x30(%eax),%eax
+f0104e17:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104e1b:	c7 04 24 41 7d 10 f0 	movl   $0xf0107d41,(%esp)
+f0104e22:	e8 66 fb ff ff       	call   f010498d <cprintf>
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+f0104e27:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104e2a:	0f b7 40 34          	movzwl 0x34(%eax),%eax
+f0104e2e:	0f b7 c0             	movzwl %ax,%eax
+f0104e31:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104e35:	c7 04 24 50 7d 10 f0 	movl   $0xf0107d50,(%esp)
+f0104e3c:	e8 4c fb ff ff       	call   f010498d <cprintf>
+    cprintf("  flag 0x%08x\n", tf->tf_eflags);
+f0104e41:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104e44:	8b 40 38             	mov    0x38(%eax),%eax
+f0104e47:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104e4b:	c7 04 24 63 7d 10 f0 	movl   $0xf0107d63,(%esp)
+f0104e52:	e8 36 fb ff ff       	call   f010498d <cprintf>
+    if ((tf->tf_cs & 3) != 0) {
+f0104e57:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104e5a:	0f b7 40 34          	movzwl 0x34(%eax),%eax
+f0104e5e:	0f b7 c0             	movzwl %ax,%eax
+f0104e61:	83 e0 03             	and    $0x3,%eax
+f0104e64:	85 c0                	test   %eax,%eax
+f0104e66:	74 30                	je     f0104e98 <print_trapframe+0x1c3>
+	cprintf("  esp  0x%08x\n", tf->tf_esp);
+f0104e68:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104e6b:	8b 40 3c             	mov    0x3c(%eax),%eax
+f0104e6e:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104e72:	c7 04 24 72 7d 10 f0 	movl   $0xf0107d72,(%esp)
+f0104e79:	e8 0f fb ff ff       	call   f010498d <cprintf>
+	cprintf("  ss   0x----%04x\n", tf->tf_ss);
+f0104e7e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104e81:	0f b7 40 40          	movzwl 0x40(%eax),%eax
+f0104e85:	0f b7 c0             	movzwl %ax,%eax
+f0104e88:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104e8c:	c7 04 24 81 7d 10 f0 	movl   $0xf0107d81,(%esp)
+f0104e93:	e8 f5 fa ff ff       	call   f010498d <cprintf>
+    }
+}
+f0104e98:	c9                   	leave  
+f0104e99:	c3                   	ret    
+
+f0104e9a <print_regs>:
+
+    void
+print_regs(struct PushRegs *regs)
+{
+f0104e9a:	55                   	push   %ebp
+f0104e9b:	89 e5                	mov    %esp,%ebp
+f0104e9d:	83 ec 18             	sub    $0x18,%esp
+
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+f0104ea0:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104ea3:	8b 40 04             	mov    0x4(%eax),%eax
+f0104ea6:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104eaa:	c7 04 24 94 7d 10 f0 	movl   $0xf0107d94,(%esp)
+f0104eb1:	e8 d7 fa ff ff       	call   f010498d <cprintf>
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+f0104eb6:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104eb9:	8b 40 08             	mov    0x8(%eax),%eax
+f0104ebc:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104ec0:	c7 04 24 a3 7d 10 f0 	movl   $0xf0107da3,(%esp)
+f0104ec7:	e8 c1 fa ff ff       	call   f010498d <cprintf>
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+f0104ecc:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104ecf:	8b 40 0c             	mov    0xc(%eax),%eax
+f0104ed2:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104ed6:	c7 04 24 b2 7d 10 f0 	movl   $0xf0107db2,(%esp)
+f0104edd:	e8 ab fa ff ff       	call   f010498d <cprintf>
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+f0104ee2:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104ee5:	8b 40 10             	mov    0x10(%eax),%eax
+f0104ee8:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104eec:	c7 04 24 c1 7d 10 f0 	movl   $0xf0107dc1,(%esp)
+f0104ef3:	e8 95 fa ff ff       	call   f010498d <cprintf>
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+f0104ef8:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104efb:	8b 40 14             	mov    0x14(%eax),%eax
+f0104efe:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104f02:	c7 04 24 d0 7d 10 f0 	movl   $0xf0107dd0,(%esp)
+f0104f09:	e8 7f fa ff ff       	call   f010498d <cprintf>
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+f0104f0e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f11:	8b 40 18             	mov    0x18(%eax),%eax
+f0104f14:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104f18:	c7 04 24 df 7d 10 f0 	movl   $0xf0107ddf,(%esp)
+f0104f1f:	e8 69 fa ff ff       	call   f010498d <cprintf>
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+f0104f24:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f27:	8b 40 1c             	mov    0x1c(%eax),%eax
+f0104f2a:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0104f2e:	c7 04 24 ee 7d 10 f0 	movl   $0xf0107dee,(%esp)
+f0104f35:	e8 53 fa ff ff       	call   f010498d <cprintf>
+}
+f0104f3a:	c9                   	leave  
+f0104f3b:	c3                   	ret    
+
+f0104f3c <trap_dispatch>:
+
+    static void
+trap_dispatch(struct Trapframe *tf)
+{
+f0104f3c:	55                   	push   %ebp
+f0104f3d:	89 e5                	mov    %esp,%ebp
+f0104f3f:	57                   	push   %edi
+f0104f40:	56                   	push   %esi
+f0104f41:	53                   	push   %ebx
+f0104f42:	83 ec 2c             	sub    $0x2c,%esp
+    // Handle processor exceptions.
+    // LAB 3: Your code here.
+    switch (tf->tf_trapno) {
+f0104f45:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f48:	8b 40 28             	mov    0x28(%eax),%eax
+f0104f4b:	83 f8 03             	cmp    $0x3,%eax
+f0104f4e:	74 18                	je     f0104f68 <trap_dispatch+0x2c>
+f0104f50:	83 f8 03             	cmp    $0x3,%eax
+f0104f53:	77 07                	ja     f0104f5c <trap_dispatch+0x20>
+f0104f55:	83 f8 01             	cmp    $0x1,%eax
+f0104f58:	74 0e                	je     f0104f68 <trap_dispatch+0x2c>
+f0104f5a:	eb 75                	jmp    f0104fd1 <trap_dispatch+0x95>
+f0104f5c:	83 f8 0e             	cmp    $0xe,%eax
+f0104f5f:	74 17                	je     f0104f78 <trap_dispatch+0x3c>
+f0104f61:	83 f8 30             	cmp    $0x30,%eax
+f0104f64:	74 22                	je     f0104f88 <trap_dispatch+0x4c>
+f0104f66:	eb 69                	jmp    f0104fd1 <trap_dispatch+0x95>
+	case T_DEBUG:
+	case T_BRKPT:
+	    monitor(tf);
+f0104f68:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f6b:	89 04 24             	mov    %eax,(%esp)
+f0104f6e:	e8 df c1 ff ff       	call   f0101152 <monitor>
+	    break;
+f0104f73:	e9 9b 00 00 00       	jmp    f0105013 <trap_dispatch+0xd7>
+	case T_PGFLT:
+	    page_fault_handler(tf);
+f0104f78:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f7b:	89 04 24             	mov    %eax,(%esp)
+f0104f7e:	e8 a0 01 00 00       	call   f0105123 <page_fault_handler>
+	    break;
+f0104f83:	e9 8b 00 00 00       	jmp    f0105013 <trap_dispatch+0xd7>
+	case T_SYSCALL:
+	    tf->tf_regs.reg_eax = 
+		syscall(tf->tf_regs.reg_eax, tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi, tf->tf_regs.reg_esi);
+f0104f88:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f8b:	8b 78 04             	mov    0x4(%eax),%edi
+f0104f8e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f91:	8b 30                	mov    (%eax),%esi
+f0104f93:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f96:	8b 58 10             	mov    0x10(%eax),%ebx
+f0104f99:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104f9c:	8b 48 18             	mov    0x18(%eax),%ecx
+f0104f9f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104fa2:	8b 50 14             	mov    0x14(%eax),%edx
+f0104fa5:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104fa8:	8b 40 1c             	mov    0x1c(%eax),%eax
+f0104fab:	89 7c 24 14          	mov    %edi,0x14(%esp)
+f0104faf:	89 74 24 10          	mov    %esi,0x10(%esp)
+f0104fb3:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+f0104fb7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+f0104fbb:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0104fbf:	89 04 24             	mov    %eax,(%esp)
+f0104fc2:	e8 72 04 00 00       	call   f0105439 <syscall>
+	    break;
+	case T_PGFLT:
+	    page_fault_handler(tf);
+	    break;
+	case T_SYSCALL:
+	    tf->tf_regs.reg_eax = 
+f0104fc7:	89 c2                	mov    %eax,%edx
+f0104fc9:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104fcc:	89 50 1c             	mov    %edx,0x1c(%eax)
+		syscall(tf->tf_regs.reg_eax, tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi, tf->tf_regs.reg_esi);
+	    break;
+f0104fcf:	eb 42                	jmp    f0105013 <trap_dispatch+0xd7>
+	default:
+	    // Unexpected trap: The user process or the kernel has a bug.
+	    print_trapframe(tf);
+f0104fd1:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104fd4:	89 04 24             	mov    %eax,(%esp)
+f0104fd7:	e8 f9 fc ff ff       	call   f0104cd5 <print_trapframe>
+	    if (tf->tf_cs == GD_KT)
+f0104fdc:	8b 45 08             	mov    0x8(%ebp),%eax
+f0104fdf:	0f b7 40 34          	movzwl 0x34(%eax),%eax
+f0104fe3:	66 83 f8 08          	cmp    $0x8,%ax
+f0104fe7:	75 1c                	jne    f0105005 <trap_dispatch+0xc9>
+		panic("unhandled trap in kernel");
+f0104fe9:	c7 44 24 08 fd 7d 10 	movl   $0xf0107dfd,0x8(%esp)
+f0104ff0:	f0 
+f0104ff1:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
+f0104ff8:	00 
+f0104ff9:	c7 04 24 16 7e 10 f0 	movl   $0xf0107e16,(%esp)
+f0105000:	e8 b0 b0 ff ff       	call   f01000b5 <_panic>
+	    else {
+		env_destroy(curenv);
+f0105005:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010500a:	89 04 24             	mov    %eax,(%esp)
+f010500d:	e8 ce f7 ff ff       	call   f01047e0 <env_destroy>
+		return;
+f0105012:	90                   	nop
+	    }
+    }
+}
+f0105013:	83 c4 2c             	add    $0x2c,%esp
+f0105016:	5b                   	pop    %ebx
+f0105017:	5e                   	pop    %esi
+f0105018:	5f                   	pop    %edi
+f0105019:	5d                   	pop    %ebp
+f010501a:	c3                   	ret    
+
+f010501b <trap>:
+    void
+trap(struct Trapframe *tf)
+{
+f010501b:	55                   	push   %ebp
+f010501c:	89 e5                	mov    %esp,%ebp
+f010501e:	57                   	push   %edi
+f010501f:	56                   	push   %esi
+f0105020:	53                   	push   %ebx
+f0105021:	83 ec 1c             	sub    $0x1c,%esp
+    // The environment may have set DF and some versions
+    // of GCC rely on DF being clear
+    asm volatile("cld" ::: "cc");
+f0105024:	fc                   	cld    
+
+    // Check that interrupts are disabled.  If this assertion
+    // fails, DO NOT be tempted to fix it by inserting a "cli" in
+    // the interrupt path.
+    assert(!(read_eflags() & FL_IF));
+f0105025:	e8 bb f9 ff ff       	call   f01049e5 <read_eflags>
+f010502a:	25 00 02 00 00       	and    $0x200,%eax
+f010502f:	85 c0                	test   %eax,%eax
+f0105031:	74 24                	je     f0105057 <trap+0x3c>
+f0105033:	c7 44 24 0c 22 7e 10 	movl   $0xf0107e22,0xc(%esp)
+f010503a:	f0 
+f010503b:	c7 44 24 08 3b 7e 10 	movl   $0xf0107e3b,0x8(%esp)
+f0105042:	f0 
+f0105043:	c7 44 24 04 bf 00 00 	movl   $0xbf,0x4(%esp)
+f010504a:	00 
+f010504b:	c7 04 24 16 7e 10 f0 	movl   $0xf0107e16,(%esp)
+f0105052:	e8 5e b0 ff ff       	call   f01000b5 <_panic>
+
+    cprintf("Incoming TRAP frame at %p\n", tf);
+f0105057:	8b 45 08             	mov    0x8(%ebp),%eax
+f010505a:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010505e:	c7 04 24 50 7e 10 f0 	movl   $0xf0107e50,(%esp)
+f0105065:	e8 23 f9 ff ff       	call   f010498d <cprintf>
+
+    if ((tf->tf_cs & 3) == 3) {
+f010506a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010506d:	0f b7 40 34          	movzwl 0x34(%eax),%eax
+f0105071:	0f b7 c0             	movzwl %ax,%eax
+f0105074:	83 e0 03             	and    $0x3,%eax
+f0105077:	83 f8 03             	cmp    $0x3,%eax
+f010507a:	75 4d                	jne    f01050c9 <trap+0xae>
+	// Trapped from user mode.
+	assert(curenv);
+f010507c:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0105081:	85 c0                	test   %eax,%eax
+f0105083:	75 24                	jne    f01050a9 <trap+0x8e>
+f0105085:	c7 44 24 0c 6b 7e 10 	movl   $0xf0107e6b,0xc(%esp)
+f010508c:	f0 
+f010508d:	c7 44 24 08 3b 7e 10 	movl   $0xf0107e3b,0x8(%esp)
+f0105094:	f0 
+f0105095:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
+f010509c:	00 
+f010509d:	c7 04 24 16 7e 10 f0 	movl   $0xf0107e16,(%esp)
+f01050a4:	e8 0c b0 ff ff       	call   f01000b5 <_panic>
+
+	// Copy trap frame (which is currently on the stack)
+	// into 'curenv->env_tf', so that running the environment
+	// will restart at the trap point.
+	curenv->env_tf = *tf;
+f01050a9:	8b 15 20 eb 18 f0    	mov    0xf018eb20,%edx
+f01050af:	8b 45 08             	mov    0x8(%ebp),%eax
+f01050b2:	89 c3                	mov    %eax,%ebx
+f01050b4:	b8 11 00 00 00       	mov    $0x11,%eax
+f01050b9:	89 d7                	mov    %edx,%edi
+f01050bb:	89 de                	mov    %ebx,%esi
+f01050bd:	89 c1                	mov    %eax,%ecx
+f01050bf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+	// The trapframe on the stack should be ignored from here on.
+	tf = &curenv->env_tf;
+f01050c1:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01050c6:	89 45 08             	mov    %eax,0x8(%ebp)
+    }
+
+    // Record that tf is the last real trapframe so
+    // print_trapframe can print some additional information.
+    last_tf = tf;
+f01050c9:	8b 45 08             	mov    0x8(%ebp),%eax
+f01050cc:	a3 a8 f3 18 f0       	mov    %eax,0xf018f3a8
+
+    // Dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+f01050d1:	8b 45 08             	mov    0x8(%ebp),%eax
+f01050d4:	89 04 24             	mov    %eax,(%esp)
+f01050d7:	e8 60 fe ff ff       	call   f0104f3c <trap_dispatch>
+
+    // Return to the current environment, which should be running.
+    assert(curenv && curenv->env_status == ENV_RUNNING);
+f01050dc:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01050e1:	85 c0                	test   %eax,%eax
+f01050e3:	74 0d                	je     f01050f2 <trap+0xd7>
+f01050e5:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01050ea:	8b 40 54             	mov    0x54(%eax),%eax
+f01050ed:	83 f8 03             	cmp    $0x3,%eax
+f01050f0:	74 24                	je     f0105116 <trap+0xfb>
+f01050f2:	c7 44 24 0c 74 7e 10 	movl   $0xf0107e74,0xc(%esp)
+f01050f9:	f0 
+f01050fa:	c7 44 24 08 3b 7e 10 	movl   $0xf0107e3b,0x8(%esp)
+f0105101:	f0 
+f0105102:	c7 44 24 04 d7 00 00 	movl   $0xd7,0x4(%esp)
+f0105109:	00 
+f010510a:	c7 04 24 16 7e 10 f0 	movl   $0xf0107e16,(%esp)
+f0105111:	e8 9f af ff ff       	call   f01000b5 <_panic>
+    env_run(curenv);
+f0105116:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010511b:	89 04 24             	mov    %eax,(%esp)
+f010511e:	e8 14 f7 ff ff       	call   f0104837 <env_run>
+
+f0105123 <page_fault_handler>:
+}
+
+
+    void
+page_fault_handler(struct Trapframe *tf)
+{
+f0105123:	55                   	push   %ebp
+f0105124:	89 e5                	mov    %esp,%ebp
+f0105126:	83 ec 28             	sub    $0x28,%esp
+    uint32_t fault_va;
+
+    // Read processor's CR2 register to find the faulting address
+    fault_va = rcr2();
+f0105129:	e8 a6 f8 ff ff       	call   f01049d4 <rcr2>
+f010512e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+    // Handle kernel-mode page faults.
+
+    // LAB 3: Your code here.
+    if (!(tf->tf_cs & 3))
+f0105131:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105134:	0f b7 40 34          	movzwl 0x34(%eax),%eax
+f0105138:	0f b7 c0             	movzwl %ax,%eax
+f010513b:	83 e0 03             	and    $0x3,%eax
+f010513e:	85 c0                	test   %eax,%eax
+f0105140:	75 1c                	jne    f010515e <page_fault_handler+0x3b>
+	panic("a page fault happens in kernel mode\n");
+f0105142:	c7 44 24 08 a0 7e 10 	movl   $0xf0107ea0,0x8(%esp)
+f0105149:	f0 
+f010514a:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
+f0105151:	00 
+f0105152:	c7 04 24 16 7e 10 f0 	movl   $0xf0107e16,(%esp)
+f0105159:	e8 57 af ff ff       	call   f01000b5 <_panic>
+
+    // We've already handled kernel-mode exceptions, so if we get here,
+    // the page fault happened in user mode.
+
+    // Destroy the environment that caused the fault.
+    cprintf("[%08x] user fault va %08x ip %08x\n",
+f010515e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105161:	8b 50 30             	mov    0x30(%eax),%edx
+	    curenv->env_id, fault_va, tf->tf_eip);
+f0105164:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+
+    // We've already handled kernel-mode exceptions, so if we get here,
+    // the page fault happened in user mode.
+
+    // Destroy the environment that caused the fault.
+    cprintf("[%08x] user fault va %08x ip %08x\n",
+f0105169:	8b 40 48             	mov    0x48(%eax),%eax
+f010516c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+f0105170:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0105173:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0105177:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010517b:	c7 04 24 c8 7e 10 f0 	movl   $0xf0107ec8,(%esp)
+f0105182:	e8 06 f8 ff ff       	call   f010498d <cprintf>
+	    curenv->env_id, fault_va, tf->tf_eip);
+    print_trapframe(tf);
+f0105187:	8b 45 08             	mov    0x8(%ebp),%eax
+f010518a:	89 04 24             	mov    %eax,(%esp)
+f010518d:	e8 43 fb ff ff       	call   f0104cd5 <print_trapframe>
+    env_destroy(curenv);
+f0105192:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0105197:	89 04 24             	mov    %eax,(%esp)
+f010519a:	e8 41 f6 ff ff       	call   f01047e0 <env_destroy>
+}
+f010519f:	c9                   	leave  
+f01051a0:	c3                   	ret    
+f01051a1:	90                   	nop
+
+f01051a2 <vector0>:
+     * Lab 3: Your code here for _alltraps
+     */
+.data
+.global vectors
+vectors:
+TRAPHANDLER(vector0, 0)
+f01051a2:	6a 00                	push   $0x0
+f01051a4:	6a 00                	push   $0x0
+f01051a6:	e9 7b 01 00 00       	jmp    f0105326 <_alltraps>
+f01051ab:	90                   	nop
+
+f01051ac <vector1>:
+    TRAPHANDLER(vector1, 1)
+f01051ac:	6a 00                	push   $0x0
+f01051ae:	6a 01                	push   $0x1
+f01051b0:	e9 71 01 00 00       	jmp    f0105326 <_alltraps>
+f01051b5:	90                   	nop
+
+f01051b6 <vector2>:
+    TRAPHANDLER(vector2, 2)
+f01051b6:	6a 00                	push   $0x0
+f01051b8:	6a 02                	push   $0x2
+f01051ba:	e9 67 01 00 00       	jmp    f0105326 <_alltraps>
+f01051bf:	90                   	nop
+
+f01051c0 <vector3>:
+    TRAPHANDLER(vector3, 3)
+f01051c0:	6a 00                	push   $0x0
+f01051c2:	6a 03                	push   $0x3
+f01051c4:	e9 5d 01 00 00       	jmp    f0105326 <_alltraps>
+f01051c9:	90                   	nop
+
+f01051ca <vector4>:
+    TRAPHANDLER(vector4, 4)
+f01051ca:	6a 00                	push   $0x0
+f01051cc:	6a 04                	push   $0x4
+f01051ce:	e9 53 01 00 00       	jmp    f0105326 <_alltraps>
+f01051d3:	90                   	nop
+
+f01051d4 <vector5>:
+    TRAPHANDLER(vector5, 5)
+f01051d4:	6a 00                	push   $0x0
+f01051d6:	6a 05                	push   $0x5
+f01051d8:	e9 49 01 00 00       	jmp    f0105326 <_alltraps>
+f01051dd:	90                   	nop
+
+f01051de <vector6>:
+    TRAPHANDLER(vector6, 6)
+f01051de:	6a 00                	push   $0x0
+f01051e0:	6a 06                	push   $0x6
+f01051e2:	e9 3f 01 00 00       	jmp    f0105326 <_alltraps>
+f01051e7:	90                   	nop
+
+f01051e8 <vector7>:
+    TRAPHANDLER(vector7, 7)
+f01051e8:	6a 00                	push   $0x0
+f01051ea:	6a 07                	push   $0x7
+f01051ec:	e9 35 01 00 00       	jmp    f0105326 <_alltraps>
+f01051f1:	90                   	nop
+
+f01051f2 <vector8>:
+    TRAPHANDLER(vector8, 8)
+f01051f2:	6a 08                	push   $0x8
+f01051f4:	e9 2d 01 00 00       	jmp    f0105326 <_alltraps>
+f01051f9:	90                   	nop
+
+f01051fa <vector9>:
+    TRAPHANDLER(vector9, 9)
+f01051fa:	6a 00                	push   $0x0
+f01051fc:	6a 09                	push   $0x9
+f01051fe:	e9 23 01 00 00       	jmp    f0105326 <_alltraps>
+f0105203:	90                   	nop
+
+f0105204 <vector10>:
+    TRAPHANDLER(vector10, 10)
+f0105204:	6a 0a                	push   $0xa
+f0105206:	e9 1b 01 00 00       	jmp    f0105326 <_alltraps>
+f010520b:	90                   	nop
+
+f010520c <vector11>:
+    TRAPHANDLER(vector11, 11)
+f010520c:	6a 0b                	push   $0xb
+f010520e:	e9 13 01 00 00       	jmp    f0105326 <_alltraps>
+f0105213:	90                   	nop
+
+f0105214 <vector12>:
+    TRAPHANDLER(vector12, 12)
+f0105214:	6a 0c                	push   $0xc
+f0105216:	e9 0b 01 00 00       	jmp    f0105326 <_alltraps>
+f010521b:	90                   	nop
+
+f010521c <vector13>:
+    TRAPHANDLER(vector13, 13)
+f010521c:	6a 0d                	push   $0xd
+f010521e:	e9 03 01 00 00       	jmp    f0105326 <_alltraps>
+f0105223:	90                   	nop
+
+f0105224 <vector14>:
+    TRAPHANDLER(vector14, 14)
+f0105224:	6a 0e                	push   $0xe
+f0105226:	e9 fb 00 00 00       	jmp    f0105326 <_alltraps>
+f010522b:	90                   	nop
+
+f010522c <vector15>:
+    TRAPHANDLER(vector15, 15)
+f010522c:	6a 00                	push   $0x0
+f010522e:	6a 0f                	push   $0xf
+f0105230:	e9 f1 00 00 00       	jmp    f0105326 <_alltraps>
+f0105235:	90                   	nop
+
+f0105236 <vector16>:
+    TRAPHANDLER(vector16, 16)
+f0105236:	6a 00                	push   $0x0
+f0105238:	6a 10                	push   $0x10
+f010523a:	e9 e7 00 00 00       	jmp    f0105326 <_alltraps>
+f010523f:	90                   	nop
+
+f0105240 <vector17>:
+    TRAPHANDLER(vector17, 17)
+f0105240:	6a 11                	push   $0x11
+f0105242:	e9 df 00 00 00       	jmp    f0105326 <_alltraps>
+f0105247:	90                   	nop
+
+f0105248 <vector18>:
+    TRAPHANDLER(vector18, 18)
+f0105248:	6a 00                	push   $0x0
+f010524a:	6a 12                	push   $0x12
+f010524c:	e9 d5 00 00 00       	jmp    f0105326 <_alltraps>
+f0105251:	90                   	nop
+
+f0105252 <vector19>:
+    TRAPHANDLER(vector19, 19)
+f0105252:	6a 00                	push   $0x0
+f0105254:	6a 13                	push   $0x13
+f0105256:	e9 cb 00 00 00       	jmp    f0105326 <_alltraps>
+f010525b:	90                   	nop
+
+f010525c <vector20>:
+    TRAPHANDLER(vector20, 20)
+f010525c:	6a 00                	push   $0x0
+f010525e:	6a 14                	push   $0x14
+f0105260:	e9 c1 00 00 00       	jmp    f0105326 <_alltraps>
+f0105265:	90                   	nop
+
+f0105266 <vector21>:
+    TRAPHANDLER(vector21, 21)
+f0105266:	6a 00                	push   $0x0
+f0105268:	6a 15                	push   $0x15
+f010526a:	e9 b7 00 00 00       	jmp    f0105326 <_alltraps>
+f010526f:	90                   	nop
+
+f0105270 <vector22>:
+    TRAPHANDLER(vector22, 22)
+f0105270:	6a 00                	push   $0x0
+f0105272:	6a 16                	push   $0x16
+f0105274:	e9 ad 00 00 00       	jmp    f0105326 <_alltraps>
+f0105279:	90                   	nop
+
+f010527a <vector23>:
+    TRAPHANDLER(vector23, 23)
+f010527a:	6a 00                	push   $0x0
+f010527c:	6a 17                	push   $0x17
+f010527e:	e9 a3 00 00 00       	jmp    f0105326 <_alltraps>
+f0105283:	90                   	nop
+
+f0105284 <vector24>:
+    TRAPHANDLER(vector24, 24)
+f0105284:	6a 00                	push   $0x0
+f0105286:	6a 18                	push   $0x18
+f0105288:	e9 99 00 00 00       	jmp    f0105326 <_alltraps>
+f010528d:	90                   	nop
+
+f010528e <vector25>:
+    TRAPHANDLER(vector25, 25)
+f010528e:	6a 00                	push   $0x0
+f0105290:	6a 19                	push   $0x19
+f0105292:	e9 8f 00 00 00       	jmp    f0105326 <_alltraps>
+f0105297:	90                   	nop
+
+f0105298 <vector26>:
+    TRAPHANDLER(vector26, 26)
+f0105298:	6a 00                	push   $0x0
+f010529a:	6a 1a                	push   $0x1a
+f010529c:	e9 85 00 00 00       	jmp    f0105326 <_alltraps>
+f01052a1:	90                   	nop
+
+f01052a2 <vector27>:
+    TRAPHANDLER(vector27, 27)
+f01052a2:	6a 00                	push   $0x0
+f01052a4:	6a 1b                	push   $0x1b
+f01052a6:	eb 7e                	jmp    f0105326 <_alltraps>
+
+f01052a8 <vector28>:
+    TRAPHANDLER(vector28, 28)
+f01052a8:	6a 00                	push   $0x0
+f01052aa:	6a 1c                	push   $0x1c
+f01052ac:	eb 78                	jmp    f0105326 <_alltraps>
+
+f01052ae <vector29>:
+    TRAPHANDLER(vector29, 29)
+f01052ae:	6a 00                	push   $0x0
+f01052b0:	6a 1d                	push   $0x1d
+f01052b2:	eb 72                	jmp    f0105326 <_alltraps>
+
+f01052b4 <vector30>:
+    TRAPHANDLER(vector30, 30)
+f01052b4:	6a 00                	push   $0x0
+f01052b6:	6a 1e                	push   $0x1e
+f01052b8:	eb 6c                	jmp    f0105326 <_alltraps>
+
+f01052ba <vector31>:
+    TRAPHANDLER(vector31, 31)
+f01052ba:	6a 00                	push   $0x0
+f01052bc:	6a 1f                	push   $0x1f
+f01052be:	eb 66                	jmp    f0105326 <_alltraps>
+
+f01052c0 <vector32>:
+    TRAPHANDLER(vector32, 32)
+f01052c0:	6a 00                	push   $0x0
+f01052c2:	6a 20                	push   $0x20
+f01052c4:	eb 60                	jmp    f0105326 <_alltraps>
+
+f01052c6 <vector33>:
+    TRAPHANDLER(vector33, 33)
+f01052c6:	6a 00                	push   $0x0
+f01052c8:	6a 21                	push   $0x21
+f01052ca:	eb 5a                	jmp    f0105326 <_alltraps>
+
+f01052cc <vector34>:
+    TRAPHANDLER(vector34, 34)
+f01052cc:	6a 00                	push   $0x0
+f01052ce:	6a 22                	push   $0x22
+f01052d0:	eb 54                	jmp    f0105326 <_alltraps>
+
+f01052d2 <vector35>:
+    TRAPHANDLER(vector35, 35)
+f01052d2:	6a 00                	push   $0x0
+f01052d4:	6a 23                	push   $0x23
+f01052d6:	eb 4e                	jmp    f0105326 <_alltraps>
+
+f01052d8 <vector36>:
+    TRAPHANDLER(vector36, 36)
+f01052d8:	6a 00                	push   $0x0
+f01052da:	6a 24                	push   $0x24
+f01052dc:	eb 48                	jmp    f0105326 <_alltraps>
+
+f01052de <vector37>:
+    TRAPHANDLER(vector37, 37)
+f01052de:	6a 00                	push   $0x0
+f01052e0:	6a 25                	push   $0x25
+f01052e2:	eb 42                	jmp    f0105326 <_alltraps>
+
+f01052e4 <vector38>:
+    TRAPHANDLER(vector38, 38)
+f01052e4:	6a 00                	push   $0x0
+f01052e6:	6a 26                	push   $0x26
+f01052e8:	eb 3c                	jmp    f0105326 <_alltraps>
+
+f01052ea <vector39>:
+    TRAPHANDLER(vector39, 39)
+f01052ea:	6a 00                	push   $0x0
+f01052ec:	6a 27                	push   $0x27
+f01052ee:	eb 36                	jmp    f0105326 <_alltraps>
+
+f01052f0 <vector40>:
+    TRAPHANDLER(vector40, 40)
+f01052f0:	6a 00                	push   $0x0
+f01052f2:	6a 28                	push   $0x28
+f01052f4:	eb 30                	jmp    f0105326 <_alltraps>
+
+f01052f6 <vector41>:
+    TRAPHANDLER(vector41, 41)
+f01052f6:	6a 00                	push   $0x0
+f01052f8:	6a 29                	push   $0x29
+f01052fa:	eb 2a                	jmp    f0105326 <_alltraps>
+
+f01052fc <vector42>:
+    TRAPHANDLER(vector42, 42)
+f01052fc:	6a 00                	push   $0x0
+f01052fe:	6a 2a                	push   $0x2a
+f0105300:	eb 24                	jmp    f0105326 <_alltraps>
+
+f0105302 <vector43>:
+    TRAPHANDLER(vector43, 43)
+f0105302:	6a 00                	push   $0x0
+f0105304:	6a 2b                	push   $0x2b
+f0105306:	eb 1e                	jmp    f0105326 <_alltraps>
+
+f0105308 <vector44>:
+    TRAPHANDLER(vector44, 44)
+f0105308:	6a 00                	push   $0x0
+f010530a:	6a 2c                	push   $0x2c
+f010530c:	eb 18                	jmp    f0105326 <_alltraps>
+
+f010530e <vector45>:
+    TRAPHANDLER(vector45, 45)
+f010530e:	6a 00                	push   $0x0
+f0105310:	6a 2d                	push   $0x2d
+f0105312:	eb 12                	jmp    f0105326 <_alltraps>
+
+f0105314 <vector46>:
+    TRAPHANDLER(vector46, 46)
+f0105314:	6a 00                	push   $0x0
+f0105316:	6a 2e                	push   $0x2e
+f0105318:	eb 0c                	jmp    f0105326 <_alltraps>
+
+f010531a <vector47>:
+    TRAPHANDLER(vector47, 47)
+f010531a:	6a 00                	push   $0x0
+f010531c:	6a 2f                	push   $0x2f
+f010531e:	eb 06                	jmp    f0105326 <_alltraps>
+
+f0105320 <vector48>:
+    TRAPHANDLER(vector48, 48)
+f0105320:	6a 00                	push   $0x0
+f0105322:	6a 30                	push   $0x30
+f0105324:	eb 00                	jmp    f0105326 <_alltraps>
+
+f0105326 <_alltraps>:
+
+    .text
+    _alltraps:
+    pushw $0x0
+f0105326:	66 6a 00             	pushw  $0x0
+    pushw %ds
+f0105329:	66 1e                	pushw  %ds
+    pushw $0x0
+f010532b:	66 6a 00             	pushw  $0x0
+    pushw %es
+f010532e:	66 06                	pushw  %es
+    pushal
+f0105330:	60                   	pusha  
+
+    movw $GD_KD, %ax
+f0105331:	66 b8 10 00          	mov    $0x10,%ax
+    movw %ax, %ds
+f0105335:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+f0105337:	8e c0                	mov    %eax,%es
+    pushl %esp
+f0105339:	54                   	push   %esp
+    call trap
+f010533a:	e8 dc fc ff ff       	call   f010501b <trap>
+
+f010533f <sys_cputs>:
+// Print a string to the system console.
+// The string is exactly 'len' characters long.
+// Destroys the environment on memory errors.
+    static void
+sys_cputs(const char *s, size_t len)
+{
+f010533f:	55                   	push   %ebp
+f0105340:	89 e5                	mov    %esp,%ebp
+f0105342:	83 ec 18             	sub    $0x18,%esp
+    // Check that the user has permission to read memory [s, s+len).
+    // Destroy the environment if not.
+
+    // LAB 3: Your code here.
+    if (curenv->env_tf.tf_cs & 3)
+f0105345:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010534a:	0f b7 40 34          	movzwl 0x34(%eax),%eax
+f010534e:	0f b7 c0             	movzwl %ax,%eax
+f0105351:	83 e0 03             	and    $0x3,%eax
+f0105354:	85 c0                	test   %eax,%eax
+f0105356:	74 23                	je     f010537b <sys_cputs+0x3c>
+	user_mem_assert(curenv, s, len, 0);
+f0105358:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010535d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+f0105364:	00 
+f0105365:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0105368:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010536c:	8b 55 08             	mov    0x8(%ebp),%edx
+f010536f:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105373:	89 04 24             	mov    %eax,(%esp)
+f0105376:	e8 6e c9 ff ff       	call   f0101ce9 <user_mem_assert>
+
+    // Print the string supplied by the user.
+    cprintf("%.*s", len, s);
+f010537b:	8b 45 08             	mov    0x8(%ebp),%eax
+f010537e:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0105382:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105385:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105389:	c7 04 24 90 80 10 f0 	movl   $0xf0108090,(%esp)
+f0105390:	e8 f8 f5 ff ff       	call   f010498d <cprintf>
+}
+f0105395:	c9                   	leave  
+f0105396:	c3                   	ret    
+
+f0105397 <sys_cgetc>:
+
+// Read a character from the system console without blocking.
+// Returns the character, or 0 if there is no input waiting.
+    static int
+sys_cgetc(void)
+{
+f0105397:	55                   	push   %ebp
+f0105398:	89 e5                	mov    %esp,%ebp
+f010539a:	83 ec 08             	sub    $0x8,%esp
+    return cons_getc();
+f010539d:	e8 be b4 ff ff       	call   f0100860 <cons_getc>
+}
+f01053a2:	c9                   	leave  
+f01053a3:	c3                   	ret    
+
+f01053a4 <sys_getenvid>:
+
+// Returns the current environment's envid.
+    static envid_t
+sys_getenvid(void)
+{
+f01053a4:	55                   	push   %ebp
+f01053a5:	89 e5                	mov    %esp,%ebp
+    return curenv->env_id;
+f01053a7:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01053ac:	8b 40 48             	mov    0x48(%eax),%eax
+}
+f01053af:	5d                   	pop    %ebp
+f01053b0:	c3                   	ret    
+
+f01053b1 <sys_env_destroy>:
+// Returns 0 on success, < 0 on error.  Errors are:
+//	-E_BAD_ENV if environment envid doesn't currently exist,
+//		or the caller doesn't have permission to change envid.
+    static int
+sys_env_destroy(envid_t envid)
+{
+f01053b1:	55                   	push   %ebp
+f01053b2:	89 e5                	mov    %esp,%ebp
+f01053b4:	83 ec 28             	sub    $0x28,%esp
+    int r;
+    struct Env *e;
+
+    if ((r = envid2env(envid, &e, 1)) < 0)
+f01053b7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+f01053be:	00 
+f01053bf:	8d 45 f0             	lea    -0x10(%ebp),%eax
+f01053c2:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01053c6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01053c9:	89 04 24             	mov    %eax,(%esp)
+f01053cc:	e8 eb ea ff ff       	call   f0103ebc <envid2env>
+f01053d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01053d4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f01053d8:	79 05                	jns    f01053df <sys_env_destroy+0x2e>
+	return r;
+f01053da:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01053dd:	eb 58                	jmp    f0105437 <sys_env_destroy+0x86>
+    if (e == curenv)
+f01053df:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01053e2:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01053e7:	39 c2                	cmp    %eax,%edx
+f01053e9:	75 1a                	jne    f0105405 <sys_env_destroy+0x54>
+	cprintf("[%08x] exiting gracefully\n", curenv->env_id);
+f01053eb:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01053f0:	8b 40 48             	mov    0x48(%eax),%eax
+f01053f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01053f7:	c7 04 24 95 80 10 f0 	movl   $0xf0108095,(%esp)
+f01053fe:	e8 8a f5 ff ff       	call   f010498d <cprintf>
+f0105403:	eb 22                	jmp    f0105427 <sys_env_destroy+0x76>
+    else
+	cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
+f0105405:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105408:	8b 50 48             	mov    0x48(%eax),%edx
+f010540b:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0105410:	8b 40 48             	mov    0x48(%eax),%eax
+f0105413:	89 54 24 08          	mov    %edx,0x8(%esp)
+f0105417:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010541b:	c7 04 24 b0 80 10 f0 	movl   $0xf01080b0,(%esp)
+f0105422:	e8 66 f5 ff ff       	call   f010498d <cprintf>
+    env_destroy(e);
+f0105427:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010542a:	89 04 24             	mov    %eax,(%esp)
+f010542d:	e8 ae f3 ff ff       	call   f01047e0 <env_destroy>
+    return 0;
+f0105432:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f0105437:	c9                   	leave  
+f0105438:	c3                   	ret    
+
+f0105439 <syscall>:
+
+// Dispatches to the correct kernel function, passing the arguments.
+    int32_t
+syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+f0105439:	55                   	push   %ebp
+f010543a:	89 e5                	mov    %esp,%ebp
+f010543c:	83 ec 18             	sub    $0x18,%esp
+    // Return any appropriate return value.
+    // LAB 3: Your code here.
+
+    //panic("syscall not implemented");
+
+    switch (syscallno) {
+f010543f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105442:	83 f8 01             	cmp    $0x1,%eax
+f0105445:	74 2a                	je     f0105471 <syscall+0x38>
+f0105447:	83 f8 01             	cmp    $0x1,%eax
+f010544a:	72 0c                	jb     f0105458 <syscall+0x1f>
+f010544c:	83 f8 02             	cmp    $0x2,%eax
+f010544f:	74 27                	je     f0105478 <syscall+0x3f>
+f0105451:	83 f8 03             	cmp    $0x3,%eax
+f0105454:	74 29                	je     f010547f <syscall+0x46>
+f0105456:	eb 34                	jmp    f010548c <syscall+0x53>
+	case SYS_cputs:
+	    sys_cputs((const char*)a1, (size_t)a2);
+f0105458:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010545b:	8b 55 10             	mov    0x10(%ebp),%edx
+f010545e:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105462:	89 04 24             	mov    %eax,(%esp)
+f0105465:	e8 d5 fe ff ff       	call   f010533f <sys_cputs>
+	    return 0;
+f010546a:	b8 00 00 00 00       	mov    $0x0,%eax
+f010546f:	eb 20                	jmp    f0105491 <syscall+0x58>
+	case SYS_cgetc:
+	    return sys_cgetc();
+f0105471:	e8 21 ff ff ff       	call   f0105397 <sys_cgetc>
+f0105476:	eb 19                	jmp    f0105491 <syscall+0x58>
+	case SYS_getenvid:
+	    return sys_getenvid();
+f0105478:	e8 27 ff ff ff       	call   f01053a4 <sys_getenvid>
+f010547d:	eb 12                	jmp    f0105491 <syscall+0x58>
+	case SYS_env_destroy:
+	    return sys_env_destroy((envid_t)a1);
+f010547f:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105482:	89 04 24             	mov    %eax,(%esp)
+f0105485:	e8 27 ff ff ff       	call   f01053b1 <sys_env_destroy>
+f010548a:	eb 05                	jmp    f0105491 <syscall+0x58>
+	default:
+	    return -E_INVAL;
+f010548c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+    }
+}
+f0105491:	c9                   	leave  
+f0105492:	c3                   	ret    
+
+f0105493 <stab_binsearch>:
+//	will exit setting left = 118, right = 554.
+//
+    static void
+stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
+	int type, uintptr_t addr)
+{
+f0105493:	55                   	push   %ebp
+f0105494:	89 e5                	mov    %esp,%ebp
+f0105496:	83 ec 20             	sub    $0x20,%esp
+    int l = *region_left, r = *region_right, any_matches = 0;
+f0105499:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010549c:	8b 00                	mov    (%eax),%eax
+f010549e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+f01054a1:	8b 45 10             	mov    0x10(%ebp),%eax
+f01054a4:	8b 00                	mov    (%eax),%eax
+f01054a6:	89 45 f8             	mov    %eax,-0x8(%ebp)
+f01054a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    while (l <= r) {
+f01054b0:	e9 d2 00 00 00       	jmp    f0105587 <stab_binsearch+0xf4>
+	int true_m = (l + r) / 2, m = true_m;
+f01054b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+f01054b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
+f01054bb:	01 d0                	add    %edx,%eax
+f01054bd:	89 c2                	mov    %eax,%edx
+f01054bf:	c1 ea 1f             	shr    $0x1f,%edx
+f01054c2:	01 d0                	add    %edx,%eax
+f01054c4:	d1 f8                	sar    %eax
+f01054c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f01054c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01054cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+	// search for earliest stab with right type
+	while (m >= l && stabs[m].n_type != type)
+f01054cf:	eb 04                	jmp    f01054d5 <stab_binsearch+0x42>
+	    m--;
+f01054d1:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+
+    while (l <= r) {
+	int true_m = (l + r) / 2, m = true_m;
+
+	// search for earliest stab with right type
+	while (m >= l && stabs[m].n_type != type)
+f01054d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01054d8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+f01054db:	7c 1f                	jl     f01054fc <stab_binsearch+0x69>
+f01054dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01054e0:	89 d0                	mov    %edx,%eax
+f01054e2:	01 c0                	add    %eax,%eax
+f01054e4:	01 d0                	add    %edx,%eax
+f01054e6:	c1 e0 02             	shl    $0x2,%eax
+f01054e9:	89 c2                	mov    %eax,%edx
+f01054eb:	8b 45 08             	mov    0x8(%ebp),%eax
+f01054ee:	01 d0                	add    %edx,%eax
+f01054f0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+f01054f4:	0f b6 c0             	movzbl %al,%eax
+f01054f7:	3b 45 14             	cmp    0x14(%ebp),%eax
+f01054fa:	75 d5                	jne    f01054d1 <stab_binsearch+0x3e>
+	    m--;
+	if (m < l) {	// no match in [l, m]
+f01054fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01054ff:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+f0105502:	7d 0b                	jge    f010550f <stab_binsearch+0x7c>
+	    l = true_m + 1;
+f0105504:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0105507:	83 c0 01             	add    $0x1,%eax
+f010550a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	    continue;
+f010550d:	eb 78                	jmp    f0105587 <stab_binsearch+0xf4>
+	}
+
+	// actual binary search
+	any_matches = 1;
+f010550f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+	if (stabs[m].n_value < addr) {
+f0105516:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0105519:	89 d0                	mov    %edx,%eax
+f010551b:	01 c0                	add    %eax,%eax
+f010551d:	01 d0                	add    %edx,%eax
+f010551f:	c1 e0 02             	shl    $0x2,%eax
+f0105522:	89 c2                	mov    %eax,%edx
+f0105524:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105527:	01 d0                	add    %edx,%eax
+f0105529:	8b 40 08             	mov    0x8(%eax),%eax
+f010552c:	3b 45 18             	cmp    0x18(%ebp),%eax
+f010552f:	73 13                	jae    f0105544 <stab_binsearch+0xb1>
+	    *region_left = m;
+f0105531:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105534:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0105537:	89 10                	mov    %edx,(%eax)
+	    l = true_m + 1;
+f0105539:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f010553c:	83 c0 01             	add    $0x1,%eax
+f010553f:	89 45 fc             	mov    %eax,-0x4(%ebp)
+f0105542:	eb 43                	jmp    f0105587 <stab_binsearch+0xf4>
+	} else if (stabs[m].n_value > addr) {
+f0105544:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0105547:	89 d0                	mov    %edx,%eax
+f0105549:	01 c0                	add    %eax,%eax
+f010554b:	01 d0                	add    %edx,%eax
+f010554d:	c1 e0 02             	shl    $0x2,%eax
+f0105550:	89 c2                	mov    %eax,%edx
+f0105552:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105555:	01 d0                	add    %edx,%eax
+f0105557:	8b 40 08             	mov    0x8(%eax),%eax
+f010555a:	3b 45 18             	cmp    0x18(%ebp),%eax
+f010555d:	76 16                	jbe    f0105575 <stab_binsearch+0xe2>
+	    *region_right = m - 1;
+f010555f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105562:	8d 50 ff             	lea    -0x1(%eax),%edx
+f0105565:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105568:	89 10                	mov    %edx,(%eax)
+	    r = m - 1;
+f010556a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010556d:	83 e8 01             	sub    $0x1,%eax
+f0105570:	89 45 f8             	mov    %eax,-0x8(%ebp)
+f0105573:	eb 12                	jmp    f0105587 <stab_binsearch+0xf4>
+	} else {
+	    // exact match for 'addr', but continue loop to find
+	    // *region_right
+	    *region_left = m;
+f0105575:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105578:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f010557b:	89 10                	mov    %edx,(%eax)
+	    l = m;
+f010557d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105580:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	    addr++;
+f0105583:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
+	int type, uintptr_t addr)
+{
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+f0105587:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f010558a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+f010558d:	0f 8e 22 ff ff ff    	jle    f01054b5 <stab_binsearch+0x22>
+	    l = m;
+	    addr++;
+	}
+    }
+
+    if (!any_matches)
+f0105593:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f0105597:	75 0f                	jne    f01055a8 <stab_binsearch+0x115>
+	*region_right = *region_left - 1;
+f0105599:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010559c:	8b 00                	mov    (%eax),%eax
+f010559e:	8d 50 ff             	lea    -0x1(%eax),%edx
+f01055a1:	8b 45 10             	mov    0x10(%ebp),%eax
+f01055a4:	89 10                	mov    %edx,(%eax)
+f01055a6:	eb 3f                	jmp    f01055e7 <stab_binsearch+0x154>
+    else {
+	// find rightmost region containing 'addr'
+	for (l = *region_right;
+f01055a8:	8b 45 10             	mov    0x10(%ebp),%eax
+f01055ab:	8b 00                	mov    (%eax),%eax
+f01055ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
+f01055b0:	eb 04                	jmp    f01055b6 <stab_binsearch+0x123>
+		l > *region_left && stabs[l].n_type != type;
+		l--)
+f01055b2:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+    if (!any_matches)
+	*region_right = *region_left - 1;
+    else {
+	// find rightmost region containing 'addr'
+	for (l = *region_right;
+		l > *region_left && stabs[l].n_type != type;
+f01055b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01055b9:	8b 00                	mov    (%eax),%eax
+
+    if (!any_matches)
+	*region_right = *region_left - 1;
+    else {
+	// find rightmost region containing 'addr'
+	for (l = *region_right;
+f01055bb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+f01055be:	7d 1f                	jge    f01055df <stab_binsearch+0x14c>
+		l > *region_left && stabs[l].n_type != type;
+f01055c0:	8b 55 fc             	mov    -0x4(%ebp),%edx
+f01055c3:	89 d0                	mov    %edx,%eax
+f01055c5:	01 c0                	add    %eax,%eax
+f01055c7:	01 d0                	add    %edx,%eax
+f01055c9:	c1 e0 02             	shl    $0x2,%eax
+f01055cc:	89 c2                	mov    %eax,%edx
+f01055ce:	8b 45 08             	mov    0x8(%ebp),%eax
+f01055d1:	01 d0                	add    %edx,%eax
+f01055d3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+f01055d7:	0f b6 c0             	movzbl %al,%eax
+f01055da:	3b 45 14             	cmp    0x14(%ebp),%eax
+f01055dd:	75 d3                	jne    f01055b2 <stab_binsearch+0x11f>
+		l--)
+	    /* do nothing */;
+	*region_left = l;
+f01055df:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01055e2:	8b 55 fc             	mov    -0x4(%ebp),%edx
+f01055e5:	89 10                	mov    %edx,(%eax)
+    }
+}
+f01055e7:	c9                   	leave  
+f01055e8:	c3                   	ret    
+
+f01055e9 <debuginfo_eip>:
+//	negative if not.  But even if it returns negative it has stored some
+//	information into '*info'.
+//
+    int
+debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
+{
+f01055e9:	55                   	push   %ebp
+f01055ea:	89 e5                	mov    %esp,%ebp
+f01055ec:	83 ec 58             	sub    $0x58,%esp
+    const struct Stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+    int lfile, rfile, lfun, rfun, lline, rline;
+
+    // Initialize *info
+    info->eip_file = "<unknown>";
+f01055ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01055f2:	c7 00 c8 80 10 f0    	movl   $0xf01080c8,(%eax)
+    info->eip_line = 0;
+f01055f8:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01055fb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    info->eip_fn_name = "<unknown>";
+f0105602:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105605:	c7 40 08 c8 80 10 f0 	movl   $0xf01080c8,0x8(%eax)
+    info->eip_fn_namelen = 9;
+f010560c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010560f:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+    info->eip_fn_addr = addr;
+f0105616:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105619:	8b 55 08             	mov    0x8(%ebp),%edx
+f010561c:	89 50 10             	mov    %edx,0x10(%eax)
+    info->eip_fn_narg = 0;
+f010561f:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105622:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+
+    // Find the relevant set of stabs
+    if (addr >= ULIM) {
+f0105629:	81 7d 08 ff ff 7f ef 	cmpl   $0xef7fffff,0x8(%ebp)
+f0105630:	76 21                	jbe    f0105653 <debuginfo_eip+0x6a>
+	stabs = __STAB_BEGIN__;
+f0105632:	c7 45 f4 ec 82 10 f0 	movl   $0xf01082ec,-0xc(%ebp)
+	stab_end = __STAB_END__;
+f0105639:	c7 45 f0 e8 16 11 f0 	movl   $0xf01116e8,-0x10(%ebp)
+	stabstr = __STABSTR_BEGIN__;
+f0105640:	c7 45 ec e9 16 11 f0 	movl   $0xf01116e9,-0x14(%ebp)
+	stabstr_end = __STABSTR_END__;
+f0105647:	c7 45 e8 3c 46 11 f0 	movl   $0xf011463c,-0x18(%ebp)
+f010564e:	e9 d9 00 00 00       	jmp    f010572c <debuginfo_eip+0x143>
+	// The user-application linker script, user/user.ld,
+	// puts information about the application's stabs (equivalent
+	// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
+	// __STABSTR_END__) in a structure located at virtual address
+	// USTABDATA.
+	const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
+f0105653:	c7 45 e4 00 00 20 00 	movl   $0x200000,-0x1c(%ebp)
+
+	// Make sure this memory is valid.
+	// Return -1 if it is not.  Hint: Call user_mem_check.
+	// LAB 3: Your code here.
+	if (user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U) < 0)
+f010565a:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f010565f:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
+f0105666:	00 
+f0105667:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
+f010566e:	00 
+f010566f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+f0105672:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105676:	89 04 24             	mov    %eax,(%esp)
+f0105679:	e8 cf c5 ff ff       	call   f0101c4d <user_mem_check>
+f010567e:	85 c0                	test   %eax,%eax
+f0105680:	79 0a                	jns    f010568c <debuginfo_eip+0xa3>
+	    return -1;
+f0105682:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f0105687:	e9 6b 03 00 00       	jmp    f01059f7 <debuginfo_eip+0x40e>
+
+	stabs = usd->stabs;
+f010568c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f010568f:	8b 00                	mov    (%eax),%eax
+f0105691:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	stab_end = usd->stab_end;
+f0105694:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f0105697:	8b 40 04             	mov    0x4(%eax),%eax
+f010569a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	stabstr = usd->stabstr;
+f010569d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f01056a0:	8b 40 08             	mov    0x8(%eax),%eax
+f01056a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	stabstr_end = usd->stabstr_end;
+f01056a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+f01056a9:	8b 40 0c             	mov    0xc(%eax),%eax
+f01056ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+	// Make sure the STABS and string table memory is valid.
+	// LAB 3: Your code here.
+	if (user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) < 0) return -1;
+f01056af:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01056b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01056b5:	29 c2                	sub    %eax,%edx
+f01056b7:	89 d0                	mov    %edx,%eax
+f01056b9:	c1 f8 02             	sar    $0x2,%eax
+f01056bc:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+f01056c2:	89 c2                	mov    %eax,%edx
+f01056c4:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f01056c9:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
+f01056d0:	00 
+f01056d1:	89 54 24 08          	mov    %edx,0x8(%esp)
+f01056d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f01056d8:	89 54 24 04          	mov    %edx,0x4(%esp)
+f01056dc:	89 04 24             	mov    %eax,(%esp)
+f01056df:	e8 69 c5 ff ff       	call   f0101c4d <user_mem_check>
+f01056e4:	85 c0                	test   %eax,%eax
+f01056e6:	79 0a                	jns    f01056f2 <debuginfo_eip+0x109>
+f01056e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f01056ed:	e9 05 03 00 00       	jmp    f01059f7 <debuginfo_eip+0x40e>
+	if (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) < 0) return -1;
+f01056f2:	8b 55 e8             	mov    -0x18(%ebp),%edx
+f01056f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01056f8:	29 c2                	sub    %eax,%edx
+f01056fa:	89 d0                	mov    %edx,%eax
+f01056fc:	89 c2                	mov    %eax,%edx
+f01056fe:	a1 20 eb 18 f0       	mov    0xf018eb20,%eax
+f0105703:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
+f010570a:	00 
+f010570b:	89 54 24 08          	mov    %edx,0x8(%esp)
+f010570f:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0105712:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105716:	89 04 24             	mov    %eax,(%esp)
+f0105719:	e8 2f c5 ff ff       	call   f0101c4d <user_mem_check>
+f010571e:	85 c0                	test   %eax,%eax
+f0105720:	79 0a                	jns    f010572c <debuginfo_eip+0x143>
+f0105722:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f0105727:	e9 cb 02 00 00       	jmp    f01059f7 <debuginfo_eip+0x40e>
+    }
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
+f010572c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f010572f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+f0105732:	76 0d                	jbe    f0105741 <debuginfo_eip+0x158>
+f0105734:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0105737:	83 e8 01             	sub    $0x1,%eax
+f010573a:	0f b6 00             	movzbl (%eax),%eax
+f010573d:	84 c0                	test   %al,%al
+f010573f:	74 0a                	je     f010574b <debuginfo_eip+0x162>
+	return -1;
+f0105741:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f0105746:	e9 ac 02 00 00       	jmp    f01059f7 <debuginfo_eip+0x40e>
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    lfile = 0;
+f010574b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+    rfile = (stab_end - stabs) - 1;
+f0105752:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0105755:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0105758:	29 c2                	sub    %eax,%edx
+f010575a:	89 d0                	mov    %edx,%eax
+f010575c:	c1 f8 02             	sar    $0x2,%eax
+f010575f:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+f0105765:	83 e8 01             	sub    $0x1,%eax
+f0105768:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+f010576b:	8b 45 08             	mov    0x8(%ebp),%eax
+f010576e:	89 44 24 10          	mov    %eax,0x10(%esp)
+f0105772:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)
+f0105779:	00 
+f010577a:	8d 45 dc             	lea    -0x24(%ebp),%eax
+f010577d:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0105781:	8d 45 e0             	lea    -0x20(%ebp),%eax
+f0105784:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105788:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010578b:	89 04 24             	mov    %eax,(%esp)
+f010578e:	e8 00 fd ff ff       	call   f0105493 <stab_binsearch>
+    if (lfile == 0)
+f0105793:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0105796:	85 c0                	test   %eax,%eax
+f0105798:	75 0a                	jne    f01057a4 <debuginfo_eip+0x1bb>
+	return -1;
+f010579a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f010579f:	e9 53 02 00 00       	jmp    f01059f7 <debuginfo_eip+0x40e>
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    lfun = lfile;
+f01057a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f01057a7:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    rfun = rfile;
+f01057aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f01057ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+f01057b0:	8b 45 08             	mov    0x8(%ebp),%eax
+f01057b3:	89 44 24 10          	mov    %eax,0x10(%esp)
+f01057b7:	c7 44 24 0c 24 00 00 	movl   $0x24,0xc(%esp)
+f01057be:	00 
+f01057bf:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+f01057c2:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01057c6:	8d 45 d8             	lea    -0x28(%ebp),%eax
+f01057c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01057cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01057d0:	89 04 24             	mov    %eax,(%esp)
+f01057d3:	e8 bb fc ff ff       	call   f0105493 <stab_binsearch>
+
+    if (lfun <= rfun) {
+f01057d8:	8b 55 d8             	mov    -0x28(%ebp),%edx
+f01057db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+f01057de:	39 c2                	cmp    %eax,%edx
+f01057e0:	7f 7c                	jg     f010585e <debuginfo_eip+0x275>
+	// stabs[lfun] points to the function name
+	// in the string table, but check bounds just in case.
+	if (stabs[lfun].n_strx < stabstr_end - stabstr)
+f01057e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f01057e5:	89 c2                	mov    %eax,%edx
+f01057e7:	89 d0                	mov    %edx,%eax
+f01057e9:	01 c0                	add    %eax,%eax
+f01057eb:	01 d0                	add    %edx,%eax
+f01057ed:	c1 e0 02             	shl    $0x2,%eax
+f01057f0:	89 c2                	mov    %eax,%edx
+f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01057f5:	01 d0                	add    %edx,%eax
+f01057f7:	8b 10                	mov    (%eax),%edx
+f01057f9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+f01057fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01057ff:	29 c1                	sub    %eax,%ecx
+f0105801:	89 c8                	mov    %ecx,%eax
+f0105803:	39 c2                	cmp    %eax,%edx
+f0105805:	73 22                	jae    f0105829 <debuginfo_eip+0x240>
+	    info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+f0105807:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f010580a:	89 c2                	mov    %eax,%edx
+f010580c:	89 d0                	mov    %edx,%eax
+f010580e:	01 c0                	add    %eax,%eax
+f0105810:	01 d0                	add    %edx,%eax
+f0105812:	c1 e0 02             	shl    $0x2,%eax
+f0105815:	89 c2                	mov    %eax,%edx
+f0105817:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010581a:	01 d0                	add    %edx,%eax
+f010581c:	8b 10                	mov    (%eax),%edx
+f010581e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0105821:	01 c2                	add    %eax,%edx
+f0105823:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105826:	89 50 08             	mov    %edx,0x8(%eax)
+	info->eip_fn_addr = stabs[lfun].n_value;
+f0105829:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f010582c:	89 c2                	mov    %eax,%edx
+f010582e:	89 d0                	mov    %edx,%eax
+f0105830:	01 c0                	add    %eax,%eax
+f0105832:	01 d0                	add    %edx,%eax
+f0105834:	c1 e0 02             	shl    $0x2,%eax
+f0105837:	89 c2                	mov    %eax,%edx
+f0105839:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010583c:	01 d0                	add    %edx,%eax
+f010583e:	8b 50 08             	mov    0x8(%eax),%edx
+f0105841:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105844:	89 50 10             	mov    %edx,0x10(%eax)
+	addr -= info->eip_fn_addr;
+f0105847:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010584a:	8b 40 10             	mov    0x10(%eax),%eax
+f010584d:	29 45 08             	sub    %eax,0x8(%ebp)
+	// Search within the function definition for the line number.
+	lline = lfun;
+f0105850:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f0105853:	89 45 d0             	mov    %eax,-0x30(%ebp)
+	rline = rfun;
+f0105856:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+f0105859:	89 45 cc             	mov    %eax,-0x34(%ebp)
+f010585c:	eb 15                	jmp    f0105873 <debuginfo_eip+0x28a>
+    } else {
+	// Couldn't find function stab!  Maybe we're in an assembly
+	// file.  Search the whole file for the line number.
+	info->eip_fn_addr = addr;
+f010585e:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105861:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105864:	89 50 10             	mov    %edx,0x10(%eax)
+	lline = lfile;
+f0105867:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f010586a:	89 45 d0             	mov    %eax,-0x30(%ebp)
+	rline = rfile;
+f010586d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+f0105870:	89 45 cc             	mov    %eax,-0x34(%ebp)
+    }
+    // Ignore stuff after the colon.
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+f0105873:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105876:	8b 40 08             	mov    0x8(%eax),%eax
+f0105879:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
+f0105880:	00 
+f0105881:	89 04 24             	mov    %eax,(%esp)
+f0105884:	e8 2b 0c 00 00       	call   f01064b4 <strfind>
+f0105889:	89 c2                	mov    %eax,%edx
+f010588b:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010588e:	8b 40 08             	mov    0x8(%eax),%eax
+f0105891:	29 c2                	sub    %eax,%edx
+f0105893:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105896:	89 50 0c             	mov    %edx,0xc(%eax)
+    // Hint:
+    //	There's a particular stabs type used for line numbers.
+    //	Look at the STABS documentation and <inc/stab.h> to find
+    //	which one.
+    // Your code here.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+f0105899:	8b 45 08             	mov    0x8(%ebp),%eax
+f010589c:	89 44 24 10          	mov    %eax,0x10(%esp)
+f01058a0:	c7 44 24 0c 44 00 00 	movl   $0x44,0xc(%esp)
+f01058a7:	00 
+f01058a8:	8d 45 cc             	lea    -0x34(%ebp),%eax
+f01058ab:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01058af:	8d 45 d0             	lea    -0x30(%ebp),%eax
+f01058b2:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01058b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01058b9:	89 04 24             	mov    %eax,(%esp)
+f01058bc:	e8 d2 fb ff ff       	call   f0105493 <stab_binsearch>
+    if (lline <= rline) info->eip_line = lline - lfun;
+f01058c1:	8b 55 d0             	mov    -0x30(%ebp),%edx
+f01058c4:	8b 45 cc             	mov    -0x34(%ebp),%eax
+f01058c7:	39 c2                	cmp    %eax,%edx
+f01058c9:	7f 10                	jg     f01058db <debuginfo_eip+0x2f2>
+f01058cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+f01058ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f01058d1:	29 c2                	sub    %eax,%edx
+f01058d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01058d6:	89 50 04             	mov    %edx,0x4(%eax)
+    // Search backwards from the line number for the relevant filename
+    // stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+f01058d9:	eb 13                	jmp    f01058ee <debuginfo_eip+0x305>
+    //	Look at the STABS documentation and <inc/stab.h> to find
+    //	which one.
+    // Your code here.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) info->eip_line = lline - lfun;
+    else return -1;
+f01058db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+f01058e0:	e9 12 01 00 00       	jmp    f01059f7 <debuginfo_eip+0x40e>
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+	    && stabs[lline].n_type != N_SOL
+	    && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
+	lline--;
+f01058e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f01058e8:	83 e8 01             	sub    $0x1,%eax
+f01058eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    // Search backwards from the line number for the relevant filename
+    // stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+f01058ee:	8b 55 d0             	mov    -0x30(%ebp),%edx
+f01058f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f01058f4:	39 c2                	cmp    %eax,%edx
+f01058f6:	7c 56                	jl     f010594e <debuginfo_eip+0x365>
+	    && stabs[lline].n_type != N_SOL
+f01058f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f01058fb:	89 c2                	mov    %eax,%edx
+f01058fd:	89 d0                	mov    %edx,%eax
+f01058ff:	01 c0                	add    %eax,%eax
+f0105901:	01 d0                	add    %edx,%eax
+f0105903:	c1 e0 02             	shl    $0x2,%eax
+f0105906:	89 c2                	mov    %eax,%edx
+f0105908:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010590b:	01 d0                	add    %edx,%eax
+f010590d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+f0105911:	3c 84                	cmp    $0x84,%al
+f0105913:	74 39                	je     f010594e <debuginfo_eip+0x365>
+	    && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
+f0105915:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f0105918:	89 c2                	mov    %eax,%edx
+f010591a:	89 d0                	mov    %edx,%eax
+f010591c:	01 c0                	add    %eax,%eax
+f010591e:	01 d0                	add    %edx,%eax
+f0105920:	c1 e0 02             	shl    $0x2,%eax
+f0105923:	89 c2                	mov    %eax,%edx
+f0105925:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0105928:	01 d0                	add    %edx,%eax
+f010592a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+f010592e:	3c 64                	cmp    $0x64,%al
+f0105930:	75 b3                	jne    f01058e5 <debuginfo_eip+0x2fc>
+f0105932:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f0105935:	89 c2                	mov    %eax,%edx
+f0105937:	89 d0                	mov    %edx,%eax
+f0105939:	01 c0                	add    %eax,%eax
+f010593b:	01 d0                	add    %edx,%eax
+f010593d:	c1 e0 02             	shl    $0x2,%eax
+f0105940:	89 c2                	mov    %eax,%edx
+f0105942:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0105945:	01 d0                	add    %edx,%eax
+f0105947:	8b 40 08             	mov    0x8(%eax),%eax
+f010594a:	85 c0                	test   %eax,%eax
+f010594c:	74 97                	je     f01058e5 <debuginfo_eip+0x2fc>
+	lline--;
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
+f010594e:	8b 55 d0             	mov    -0x30(%ebp),%edx
+f0105951:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0105954:	39 c2                	cmp    %eax,%edx
+f0105956:	7c 46                	jl     f010599e <debuginfo_eip+0x3b5>
+f0105958:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f010595b:	89 c2                	mov    %eax,%edx
+f010595d:	89 d0                	mov    %edx,%eax
+f010595f:	01 c0                	add    %eax,%eax
+f0105961:	01 d0                	add    %edx,%eax
+f0105963:	c1 e0 02             	shl    $0x2,%eax
+f0105966:	89 c2                	mov    %eax,%edx
+f0105968:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010596b:	01 d0                	add    %edx,%eax
+f010596d:	8b 10                	mov    (%eax),%edx
+f010596f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+f0105972:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0105975:	29 c1                	sub    %eax,%ecx
+f0105977:	89 c8                	mov    %ecx,%eax
+f0105979:	39 c2                	cmp    %eax,%edx
+f010597b:	73 21                	jae    f010599e <debuginfo_eip+0x3b5>
+	info->eip_file = stabstr + stabs[lline].n_strx;
+f010597d:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f0105980:	89 c2                	mov    %eax,%edx
+f0105982:	89 d0                	mov    %edx,%eax
+f0105984:	01 c0                	add    %eax,%eax
+f0105986:	01 d0                	add    %edx,%eax
+f0105988:	c1 e0 02             	shl    $0x2,%eax
+f010598b:	89 c2                	mov    %eax,%edx
+f010598d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0105990:	01 d0                	add    %edx,%eax
+f0105992:	8b 10                	mov    (%eax),%edx
+f0105994:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0105997:	01 c2                	add    %eax,%edx
+f0105999:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010599c:	89 10                	mov    %edx,(%eax)
+
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun)
+f010599e:	8b 55 d8             	mov    -0x28(%ebp),%edx
+f01059a1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+f01059a4:	39 c2                	cmp    %eax,%edx
+f01059a6:	7d 4a                	jge    f01059f2 <debuginfo_eip+0x409>
+	for (lline = lfun + 1;
+f01059a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
+f01059ab:	83 c0 01             	add    $0x1,%eax
+f01059ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
+f01059b1:	eb 18                	jmp    f01059cb <debuginfo_eip+0x3e2>
+		lline < rfun && stabs[lline].n_type == N_PSYM;
+		lline++)
+	    info->eip_fn_narg++;
+f01059b3:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01059b6:	8b 40 14             	mov    0x14(%eax),%eax
+f01059b9:	8d 50 01             	lea    0x1(%eax),%edx
+f01059bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01059bf:	89 50 14             	mov    %edx,0x14(%eax)
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun)
+	for (lline = lfun + 1;
+		lline < rfun && stabs[lline].n_type == N_PSYM;
+		lline++)
+f01059c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f01059c5:	83 c0 01             	add    $0x1,%eax
+f01059c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun)
+	for (lline = lfun + 1;
+		lline < rfun && stabs[lline].n_type == N_PSYM;
+f01059cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
+f01059ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun)
+	for (lline = lfun + 1;
+f01059d1:	39 c2                	cmp    %eax,%edx
+f01059d3:	7d 1d                	jge    f01059f2 <debuginfo_eip+0x409>
+		lline < rfun && stabs[lline].n_type == N_PSYM;
+f01059d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+f01059d8:	89 c2                	mov    %eax,%edx
+f01059da:	89 d0                	mov    %edx,%eax
+f01059dc:	01 c0                	add    %eax,%eax
+f01059de:	01 d0                	add    %edx,%eax
+f01059e0:	c1 e0 02             	shl    $0x2,%eax
+f01059e3:	89 c2                	mov    %eax,%edx
+f01059e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01059e8:	01 d0                	add    %edx,%eax
+f01059ea:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+f01059ee:	3c a0                	cmp    $0xa0,%al
+f01059f0:	74 c1                	je     f01059b3 <debuginfo_eip+0x3ca>
+		lline++)
+	    info->eip_fn_narg++;
+
+    return 0;
+f01059f2:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f01059f7:	c9                   	leave  
+f01059f8:	c3                   	ret    
+
+f01059f9 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+f01059f9:	55                   	push   %ebp
+f01059fa:	89 e5                	mov    %esp,%ebp
+f01059fc:	53                   	push   %ebx
+f01059fd:	83 ec 34             	sub    $0x34,%esp
+f0105a00:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105a03:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0105a06:	8b 45 14             	mov    0x14(%ebp),%eax
+f0105a09:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+f0105a0c:	8b 45 18             	mov    0x18(%ebp),%eax
+f0105a0f:	ba 00 00 00 00       	mov    $0x0,%edx
+f0105a14:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+f0105a17:	77 72                	ja     f0105a8b <printnum+0x92>
+f0105a19:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+f0105a1c:	72 05                	jb     f0105a23 <printnum+0x2a>
+f0105a1e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+f0105a21:	77 68                	ja     f0105a8b <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+f0105a23:	8b 45 1c             	mov    0x1c(%ebp),%eax
+f0105a26:	8d 58 ff             	lea    -0x1(%eax),%ebx
+f0105a29:	8b 45 18             	mov    0x18(%ebp),%eax
+f0105a2c:	ba 00 00 00 00       	mov    $0x0,%edx
+f0105a31:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0105a35:	89 54 24 0c          	mov    %edx,0xc(%esp)
+f0105a39:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105a3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0105a3f:	89 04 24             	mov    %eax,(%esp)
+f0105a42:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105a46:	e8 f5 0d 00 00       	call   f0106840 <__udivdi3>
+f0105a4b:	8b 4d 20             	mov    0x20(%ebp),%ecx
+f0105a4e:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+f0105a52:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+f0105a56:	8b 4d 18             	mov    0x18(%ebp),%ecx
+f0105a59:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+f0105a5d:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0105a61:	89 54 24 0c          	mov    %edx,0xc(%esp)
+f0105a65:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105a68:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105a6c:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105a6f:	89 04 24             	mov    %eax,(%esp)
+f0105a72:	e8 82 ff ff ff       	call   f01059f9 <printnum>
+f0105a77:	eb 1c                	jmp    f0105a95 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+f0105a79:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105a7c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105a80:	8b 45 20             	mov    0x20(%ebp),%eax
+f0105a83:	89 04 24             	mov    %eax,(%esp)
+f0105a86:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105a89:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+f0105a8b:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+f0105a8f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+f0105a93:	7f e4                	jg     f0105a79 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+f0105a95:	8b 4d 18             	mov    0x18(%ebp),%ecx
+f0105a98:	bb 00 00 00 00       	mov    $0x0,%ebx
+f0105a9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105aa0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0105aa3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+f0105aa7:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+f0105aab:	89 04 24             	mov    %eax,(%esp)
+f0105aae:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105ab2:	e8 b9 0e 00 00       	call   f0106970 <__umoddi3>
+f0105ab7:	05 5c 81 10 f0       	add    $0xf010815c,%eax
+f0105abc:	0f b6 00             	movzbl (%eax),%eax
+f0105abf:	0f be c0             	movsbl %al,%eax
+f0105ac2:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0105ac5:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105ac9:	89 04 24             	mov    %eax,(%esp)
+f0105acc:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105acf:	ff d0                	call   *%eax
+}
+f0105ad1:	83 c4 34             	add    $0x34,%esp
+f0105ad4:	5b                   	pop    %ebx
+f0105ad5:	5d                   	pop    %ebp
+f0105ad6:	c3                   	ret    
+
+f0105ad7 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+f0105ad7:	55                   	push   %ebp
+f0105ad8:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+f0105ada:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+f0105ade:	7e 14                	jle    f0105af4 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+f0105ae0:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105ae3:	8b 00                	mov    (%eax),%eax
+f0105ae5:	8d 48 08             	lea    0x8(%eax),%ecx
+f0105ae8:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105aeb:	89 0a                	mov    %ecx,(%edx)
+f0105aed:	8b 50 04             	mov    0x4(%eax),%edx
+f0105af0:	8b 00                	mov    (%eax),%eax
+f0105af2:	eb 30                	jmp    f0105b24 <getuint+0x4d>
+	else if (lflag)
+f0105af4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+f0105af8:	74 16                	je     f0105b10 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+f0105afa:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105afd:	8b 00                	mov    (%eax),%eax
+f0105aff:	8d 48 04             	lea    0x4(%eax),%ecx
+f0105b02:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105b05:	89 0a                	mov    %ecx,(%edx)
+f0105b07:	8b 00                	mov    (%eax),%eax
+f0105b09:	ba 00 00 00 00       	mov    $0x0,%edx
+f0105b0e:	eb 14                	jmp    f0105b24 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+f0105b10:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105b13:	8b 00                	mov    (%eax),%eax
+f0105b15:	8d 48 04             	lea    0x4(%eax),%ecx
+f0105b18:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105b1b:	89 0a                	mov    %ecx,(%edx)
+f0105b1d:	8b 00                	mov    (%eax),%eax
+f0105b1f:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+f0105b24:	5d                   	pop    %ebp
+f0105b25:	c3                   	ret    
+
+f0105b26 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+f0105b26:	55                   	push   %ebp
+f0105b27:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+f0105b29:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+f0105b2d:	7e 14                	jle    f0105b43 <getint+0x1d>
+		return va_arg(*ap, long long);
+f0105b2f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105b32:	8b 00                	mov    (%eax),%eax
+f0105b34:	8d 48 08             	lea    0x8(%eax),%ecx
+f0105b37:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105b3a:	89 0a                	mov    %ecx,(%edx)
+f0105b3c:	8b 50 04             	mov    0x4(%eax),%edx
+f0105b3f:	8b 00                	mov    (%eax),%eax
+f0105b41:	eb 28                	jmp    f0105b6b <getint+0x45>
+	else if (lflag)
+f0105b43:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+f0105b47:	74 12                	je     f0105b5b <getint+0x35>
+		return va_arg(*ap, long);
+f0105b49:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105b4c:	8b 00                	mov    (%eax),%eax
+f0105b4e:	8d 48 04             	lea    0x4(%eax),%ecx
+f0105b51:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105b54:	89 0a                	mov    %ecx,(%edx)
+f0105b56:	8b 00                	mov    (%eax),%eax
+f0105b58:	99                   	cltd   
+f0105b59:	eb 10                	jmp    f0105b6b <getint+0x45>
+	else
+		return va_arg(*ap, int);
+f0105b5b:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105b5e:	8b 00                	mov    (%eax),%eax
+f0105b60:	8d 48 04             	lea    0x4(%eax),%ecx
+f0105b63:	8b 55 08             	mov    0x8(%ebp),%edx
+f0105b66:	89 0a                	mov    %ecx,(%edx)
+f0105b68:	8b 00                	mov    (%eax),%eax
+f0105b6a:	99                   	cltd   
+}
+f0105b6b:	5d                   	pop    %ebp
+f0105b6c:	c3                   	ret    
+
+f0105b6d <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+f0105b6d:	55                   	push   %ebp
+f0105b6e:	89 e5                	mov    %esp,%ebp
+f0105b70:	56                   	push   %esi
+f0105b71:	53                   	push   %ebx
+f0105b72:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+f0105b75:	e9 72 01 00 00       	jmp    f0105cec <vprintfmt+0x17f>
+			if (ch == '\0')
+f0105b7a:	85 db                	test   %ebx,%ebx
+f0105b7c:	75 05                	jne    f0105b83 <vprintfmt+0x16>
+				return;
+f0105b7e:	e9 2a 05 00 00       	jmp    f01060ad <vprintfmt+0x540>
+			else if(ch == '\033'){
+f0105b83:	83 fb 1b             	cmp    $0x1b,%ebx
+f0105b86:	0f 85 51 01 00 00    	jne    f0105cdd <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+f0105b8c:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105b8f:	8d 50 01             	lea    0x1(%eax),%edx
+f0105b92:	89 55 10             	mov    %edx,0x10(%ebp)
+f0105b95:	0f b6 00             	movzbl (%eax),%eax
+f0105b98:	0f b6 d8             	movzbl %al,%ebx
+f0105b9b:	83 fb 5b             	cmp    $0x5b,%ebx
+f0105b9e:	74 14                	je     f0105bb4 <vprintfmt+0x47>
+				    putch(ch, putdat);
+f0105ba0:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105ba3:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105ba7:	89 1c 24             	mov    %ebx,(%esp)
+f0105baa:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105bad:	ff d0                	call   *%eax
+				    continue;
+f0105baf:	e9 38 01 00 00       	jmp    f0105cec <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+f0105bb4:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105bb7:	8d 50 01             	lea    0x1(%eax),%edx
+f0105bba:	89 55 10             	mov    %edx,0x10(%ebp)
+f0105bbd:	0f b6 00             	movzbl (%eax),%eax
+f0105bc0:	0f b6 c0             	movzbl %al,%eax
+f0105bc3:	a3 c4 f7 18 f0       	mov    %eax,0xf018f7c4
+				FG_COLOR = *(unsigned char *) fmt++;
+f0105bc8:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105bcb:	8d 50 01             	lea    0x1(%eax),%edx
+f0105bce:	89 55 10             	mov    %edx,0x10(%ebp)
+f0105bd1:	0f b6 00             	movzbl (%eax),%eax
+f0105bd4:	0f b6 c0             	movzbl %al,%eax
+f0105bd7:	a3 cc f7 18 f0       	mov    %eax,0xf018f7cc
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+f0105bdc:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105be1:	83 f8 2f             	cmp    $0x2f,%eax
+f0105be4:	7e 19                	jle    f0105bff <vprintfmt+0x92>
+f0105be6:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105beb:	83 f8 39             	cmp    $0x39,%eax
+f0105bee:	7f 0f                	jg     f0105bff <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+f0105bf0:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105bf5:	83 e8 30             	sub    $0x30,%eax
+f0105bf8:	a3 c4 f7 18 f0       	mov    %eax,0xf018f7c4
+f0105bfd:	eb 50                	jmp    f0105c4f <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+f0105bff:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105c04:	83 f8 60             	cmp    $0x60,%eax
+f0105c07:	7e 19                	jle    f0105c22 <vprintfmt+0xb5>
+f0105c09:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105c0e:	83 f8 66             	cmp    $0x66,%eax
+f0105c11:	7f 0f                	jg     f0105c22 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+f0105c13:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105c18:	83 e8 57             	sub    $0x57,%eax
+f0105c1b:	a3 c4 f7 18 f0       	mov    %eax,0xf018f7c4
+f0105c20:	eb 2d                	jmp    f0105c4f <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+f0105c22:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105c27:	83 f8 40             	cmp    $0x40,%eax
+f0105c2a:	7e 19                	jle    f0105c45 <vprintfmt+0xd8>
+f0105c2c:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105c31:	83 f8 46             	cmp    $0x46,%eax
+f0105c34:	7f 0f                	jg     f0105c45 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+f0105c36:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105c3b:	83 e8 37             	sub    $0x37,%eax
+f0105c3e:	a3 c4 f7 18 f0       	mov    %eax,0xf018f7c4
+f0105c43:	eb 0a                	jmp    f0105c4f <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+f0105c45:	c7 05 c4 f7 18 f0 00 	movl   $0x0,0xf018f7c4
+f0105c4c:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+f0105c4f:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c54:	83 f8 2f             	cmp    $0x2f,%eax
+f0105c57:	7e 19                	jle    f0105c72 <vprintfmt+0x105>
+f0105c59:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c5e:	83 f8 39             	cmp    $0x39,%eax
+f0105c61:	7f 0f                	jg     f0105c72 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+f0105c63:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c68:	83 e8 30             	sub    $0x30,%eax
+f0105c6b:	a3 cc f7 18 f0       	mov    %eax,0xf018f7cc
+f0105c70:	eb 50                	jmp    f0105cc2 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+f0105c72:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c77:	83 f8 60             	cmp    $0x60,%eax
+f0105c7a:	7e 19                	jle    f0105c95 <vprintfmt+0x128>
+f0105c7c:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c81:	83 f8 66             	cmp    $0x66,%eax
+f0105c84:	7f 0f                	jg     f0105c95 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+f0105c86:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c8b:	83 e8 57             	sub    $0x57,%eax
+f0105c8e:	a3 cc f7 18 f0       	mov    %eax,0xf018f7cc
+f0105c93:	eb 2d                	jmp    f0105cc2 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+f0105c95:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105c9a:	83 f8 40             	cmp    $0x40,%eax
+f0105c9d:	7e 19                	jle    f0105cb8 <vprintfmt+0x14b>
+f0105c9f:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105ca4:	83 f8 46             	cmp    $0x46,%eax
+f0105ca7:	7f 0f                	jg     f0105cb8 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+f0105ca9:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105cae:	83 e8 37             	sub    $0x37,%eax
+f0105cb1:	a3 cc f7 18 f0       	mov    %eax,0xf018f7cc
+f0105cb6:	eb 0a                	jmp    f0105cc2 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+f0105cb8:	c7 05 c4 f7 18 f0 07 	movl   $0x7,0xf018f7c4
+f0105cbf:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+f0105cc2:	a1 c4 f7 18 f0       	mov    0xf018f7c4,%eax
+f0105cc7:	c1 e0 0c             	shl    $0xc,%eax
+f0105cca:	89 c2                	mov    %eax,%edx
+f0105ccc:	a1 cc f7 18 f0       	mov    0xf018f7cc,%eax
+f0105cd1:	c1 e0 08             	shl    $0x8,%eax
+f0105cd4:	09 d0                	or     %edx,%eax
+f0105cd6:	a3 c8 f7 18 f0       	mov    %eax,0xf018f7c8
+				continue;
+f0105cdb:	eb 0f                	jmp    f0105cec <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+f0105cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105ce0:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105ce4:	89 1c 24             	mov    %ebx,(%esp)
+f0105ce7:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105cea:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+f0105cec:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105cef:	8d 50 01             	lea    0x1(%eax),%edx
+f0105cf2:	89 55 10             	mov    %edx,0x10(%ebp)
+f0105cf5:	0f b6 00             	movzbl (%eax),%eax
+f0105cf8:	0f b6 d8             	movzbl %al,%ebx
+f0105cfb:	83 fb 25             	cmp    $0x25,%ebx
+f0105cfe:	0f 85 76 fe ff ff    	jne    f0105b7a <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+f0105d04:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+f0105d08:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+f0105d0f:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+f0105d16:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+f0105d1d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+f0105d24:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105d27:	8d 50 01             	lea    0x1(%eax),%edx
+f0105d2a:	89 55 10             	mov    %edx,0x10(%ebp)
+f0105d2d:	0f b6 00             	movzbl (%eax),%eax
+f0105d30:	0f b6 d8             	movzbl %al,%ebx
+f0105d33:	8d 43 dd             	lea    -0x23(%ebx),%eax
+f0105d36:	83 f8 55             	cmp    $0x55,%eax
+f0105d39:	0f 87 3d 03 00 00    	ja     f010607c <vprintfmt+0x50f>
+f0105d3f:	8b 04 85 80 81 10 f0 	mov    -0xfef7e80(,%eax,4),%eax
+f0105d46:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+f0105d48:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+f0105d4c:	eb d6                	jmp    f0105d24 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+f0105d4e:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+f0105d52:	eb d0                	jmp    f0105d24 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+f0105d54:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+f0105d5b:	8b 55 e0             	mov    -0x20(%ebp),%edx
+f0105d5e:	89 d0                	mov    %edx,%eax
+f0105d60:	c1 e0 02             	shl    $0x2,%eax
+f0105d63:	01 d0                	add    %edx,%eax
+f0105d65:	01 c0                	add    %eax,%eax
+f0105d67:	01 d8                	add    %ebx,%eax
+f0105d69:	83 e8 30             	sub    $0x30,%eax
+f0105d6c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+f0105d6f:	8b 45 10             	mov    0x10(%ebp),%eax
+f0105d72:	0f b6 00             	movzbl (%eax),%eax
+f0105d75:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+f0105d78:	83 fb 2f             	cmp    $0x2f,%ebx
+f0105d7b:	7e 0b                	jle    f0105d88 <vprintfmt+0x21b>
+f0105d7d:	83 fb 39             	cmp    $0x39,%ebx
+f0105d80:	7f 06                	jg     f0105d88 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+f0105d82:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+f0105d86:	eb d3                	jmp    f0105d5b <vprintfmt+0x1ee>
+			goto process_precision;
+f0105d88:	eb 33                	jmp    f0105dbd <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+f0105d8a:	8b 45 14             	mov    0x14(%ebp),%eax
+f0105d8d:	8d 50 04             	lea    0x4(%eax),%edx
+f0105d90:	89 55 14             	mov    %edx,0x14(%ebp)
+f0105d93:	8b 00                	mov    (%eax),%eax
+f0105d95:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+f0105d98:	eb 23                	jmp    f0105dbd <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+f0105d9a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f0105d9e:	79 0c                	jns    f0105dac <vprintfmt+0x23f>
+				width = 0;
+f0105da0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+f0105da7:	e9 78 ff ff ff       	jmp    f0105d24 <vprintfmt+0x1b7>
+f0105dac:	e9 73 ff ff ff       	jmp    f0105d24 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+f0105db1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+f0105db8:	e9 67 ff ff ff       	jmp    f0105d24 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+f0105dbd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f0105dc1:	79 12                	jns    f0105dd5 <vprintfmt+0x268>
+				width = precision, precision = -1;
+f0105dc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0105dc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+f0105dc9:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+f0105dd0:	e9 4f ff ff ff       	jmp    f0105d24 <vprintfmt+0x1b7>
+f0105dd5:	e9 4a ff ff ff       	jmp    f0105d24 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+f0105dda:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+f0105dde:	e9 41 ff ff ff       	jmp    f0105d24 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+f0105de3:	8b 45 14             	mov    0x14(%ebp),%eax
+f0105de6:	8d 50 04             	lea    0x4(%eax),%edx
+f0105de9:	89 55 14             	mov    %edx,0x14(%ebp)
+f0105dec:	8b 00                	mov    (%eax),%eax
+f0105dee:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0105df1:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105df5:	89 04 24             	mov    %eax,(%esp)
+f0105df8:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105dfb:	ff d0                	call   *%eax
+			break;
+f0105dfd:	e9 a5 02 00 00       	jmp    f01060a7 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+f0105e02:	8b 45 14             	mov    0x14(%ebp),%eax
+f0105e05:	8d 50 04             	lea    0x4(%eax),%edx
+f0105e08:	89 55 14             	mov    %edx,0x14(%ebp)
+f0105e0b:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+f0105e0d:	85 db                	test   %ebx,%ebx
+f0105e0f:	79 02                	jns    f0105e13 <vprintfmt+0x2a6>
+				err = -err;
+f0105e11:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+f0105e13:	83 fb 06             	cmp    $0x6,%ebx
+f0105e16:	7f 0b                	jg     f0105e23 <vprintfmt+0x2b6>
+f0105e18:	8b 34 9d 40 81 10 f0 	mov    -0xfef7ec0(,%ebx,4),%esi
+f0105e1f:	85 f6                	test   %esi,%esi
+f0105e21:	75 23                	jne    f0105e46 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+f0105e23:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+f0105e27:	c7 44 24 08 6d 81 10 	movl   $0xf010816d,0x8(%esp)
+f0105e2e:	f0 
+f0105e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105e32:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105e36:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105e39:	89 04 24             	mov    %eax,(%esp)
+f0105e3c:	e8 73 02 00 00       	call   f01060b4 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+f0105e41:	e9 61 02 00 00       	jmp    f01060a7 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+f0105e46:	89 74 24 0c          	mov    %esi,0xc(%esp)
+f0105e4a:	c7 44 24 08 76 81 10 	movl   $0xf0108176,0x8(%esp)
+f0105e51:	f0 
+f0105e52:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105e55:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105e59:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105e5c:	89 04 24             	mov    %eax,(%esp)
+f0105e5f:	e8 50 02 00 00       	call   f01060b4 <printfmt>
+			break;
+f0105e64:	e9 3e 02 00 00       	jmp    f01060a7 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+f0105e69:	8b 45 14             	mov    0x14(%ebp),%eax
+f0105e6c:	8d 50 04             	lea    0x4(%eax),%edx
+f0105e6f:	89 55 14             	mov    %edx,0x14(%ebp)
+f0105e72:	8b 30                	mov    (%eax),%esi
+f0105e74:	85 f6                	test   %esi,%esi
+f0105e76:	75 05                	jne    f0105e7d <vprintfmt+0x310>
+				p = "(null)";
+f0105e78:	be 79 81 10 f0       	mov    $0xf0108179,%esi
+			if (width > 0 && padc != '-')
+f0105e7d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f0105e81:	7e 37                	jle    f0105eba <vprintfmt+0x34d>
+f0105e83:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+f0105e87:	74 31                	je     f0105eba <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+f0105e89:	8b 45 e0             	mov    -0x20(%ebp),%eax
+f0105e8c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105e90:	89 34 24             	mov    %esi,(%esp)
+f0105e93:	e8 2e 04 00 00       	call   f01062c6 <strnlen>
+f0105e98:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+f0105e9b:	eb 17                	jmp    f0105eb4 <vprintfmt+0x347>
+					putch(padc, putdat);
+f0105e9d:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+f0105ea1:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0105ea4:	89 54 24 04          	mov    %edx,0x4(%esp)
+f0105ea8:	89 04 24             	mov    %eax,(%esp)
+f0105eab:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105eae:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+f0105eb0:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+f0105eb4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f0105eb8:	7f e3                	jg     f0105e9d <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+f0105eba:	eb 38                	jmp    f0105ef4 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+f0105ebc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+f0105ec0:	74 1f                	je     f0105ee1 <vprintfmt+0x374>
+f0105ec2:	83 fb 1f             	cmp    $0x1f,%ebx
+f0105ec5:	7e 05                	jle    f0105ecc <vprintfmt+0x35f>
+f0105ec7:	83 fb 7e             	cmp    $0x7e,%ebx
+f0105eca:	7e 15                	jle    f0105ee1 <vprintfmt+0x374>
+					putch('?', putdat);
+f0105ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105ecf:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105ed3:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+f0105eda:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105edd:	ff d0                	call   *%eax
+f0105edf:	eb 0f                	jmp    f0105ef0 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+f0105ee1:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105ee4:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105ee8:	89 1c 24             	mov    %ebx,(%esp)
+f0105eeb:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105eee:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+f0105ef0:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+f0105ef4:	89 f0                	mov    %esi,%eax
+f0105ef6:	8d 70 01             	lea    0x1(%eax),%esi
+f0105ef9:	0f b6 00             	movzbl (%eax),%eax
+f0105efc:	0f be d8             	movsbl %al,%ebx
+f0105eff:	85 db                	test   %ebx,%ebx
+f0105f01:	74 10                	je     f0105f13 <vprintfmt+0x3a6>
+f0105f03:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0105f07:	78 b3                	js     f0105ebc <vprintfmt+0x34f>
+f0105f09:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+f0105f0d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+f0105f11:	79 a9                	jns    f0105ebc <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+f0105f13:	eb 17                	jmp    f0105f2c <vprintfmt+0x3bf>
+				putch(' ', putdat);
+f0105f15:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105f18:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105f1c:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+f0105f23:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105f26:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+f0105f28:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+f0105f2c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+f0105f30:	7f e3                	jg     f0105f15 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+f0105f32:	e9 70 01 00 00       	jmp    f01060a7 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+f0105f37:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0105f3a:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105f3e:	8d 45 14             	lea    0x14(%ebp),%eax
+f0105f41:	89 04 24             	mov    %eax,(%esp)
+f0105f44:	e8 dd fb ff ff       	call   f0105b26 <getint>
+f0105f49:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0105f4c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+f0105f4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105f52:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0105f55:	85 d2                	test   %edx,%edx
+f0105f57:	79 26                	jns    f0105f7f <vprintfmt+0x412>
+				putch('-', putdat);
+f0105f59:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105f5c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105f60:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+f0105f67:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105f6a:	ff d0                	call   *%eax
+				num = -(long long) num;
+f0105f6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0105f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f0105f72:	f7 d8                	neg    %eax
+f0105f74:	83 d2 00             	adc    $0x0,%edx
+f0105f77:	f7 da                	neg    %edx
+f0105f79:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0105f7c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+f0105f7f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+f0105f86:	e9 a8 00 00 00       	jmp    f0106033 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+f0105f8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0105f8e:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105f92:	8d 45 14             	lea    0x14(%ebp),%eax
+f0105f95:	89 04 24             	mov    %eax,(%esp)
+f0105f98:	e8 3a fb ff ff       	call   f0105ad7 <getuint>
+f0105f9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0105fa0:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+f0105fa3:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+f0105faa:	e9 84 00 00 00       	jmp    f0106033 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+f0105faf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0105fb2:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105fb6:	8d 45 14             	lea    0x14(%ebp),%eax
+f0105fb9:	89 04 24             	mov    %eax,(%esp)
+f0105fbc:	e8 16 fb ff ff       	call   f0105ad7 <getuint>
+f0105fc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0105fc4:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+f0105fc7:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+f0105fce:	eb 63                	jmp    f0106033 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+f0105fd0:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105fd3:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105fd7:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+f0105fde:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105fe1:	ff d0                	call   *%eax
+			putch('x', putdat);
+f0105fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0105fe6:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0105fea:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+f0105ff1:	8b 45 08             	mov    0x8(%ebp),%eax
+f0105ff4:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+f0105ff6:	8b 45 14             	mov    0x14(%ebp),%eax
+f0105ff9:	8d 50 04             	lea    0x4(%eax),%edx
+f0105ffc:	89 55 14             	mov    %edx,0x14(%ebp)
+f0105fff:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+f0106001:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0106004:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+f010600b:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+f0106012:	eb 1f                	jmp    f0106033 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+f0106014:	8b 45 e8             	mov    -0x18(%ebp),%eax
+f0106017:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010601b:	8d 45 14             	lea    0x14(%ebp),%eax
+f010601e:	89 04 24             	mov    %eax,(%esp)
+f0106021:	e8 b1 fa ff ff       	call   f0105ad7 <getuint>
+f0106026:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0106029:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+f010602c:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+f0106033:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+f0106037:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f010603a:	89 54 24 18          	mov    %edx,0x18(%esp)
+f010603e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+f0106041:	89 54 24 14          	mov    %edx,0x14(%esp)
+f0106045:	89 44 24 10          	mov    %eax,0x10(%esp)
+f0106049:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f010604c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+f010604f:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0106053:	89 54 24 0c          	mov    %edx,0xc(%esp)
+f0106057:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010605a:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010605e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106061:	89 04 24             	mov    %eax,(%esp)
+f0106064:	e8 90 f9 ff ff       	call   f01059f9 <printnum>
+			break;
+f0106069:	eb 3c                	jmp    f01060a7 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+f010606b:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010606e:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106072:	89 1c 24             	mov    %ebx,(%esp)
+f0106075:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106078:	ff d0                	call   *%eax
+			break;			
+f010607a:	eb 2b                	jmp    f01060a7 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+f010607c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010607f:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106083:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+f010608a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010608d:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+f010608f:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+f0106093:	eb 04                	jmp    f0106099 <vprintfmt+0x52c>
+f0106095:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+f0106099:	8b 45 10             	mov    0x10(%ebp),%eax
+f010609c:	83 e8 01             	sub    $0x1,%eax
+f010609f:	0f b6 00             	movzbl (%eax),%eax
+f01060a2:	3c 25                	cmp    $0x25,%al
+f01060a4:	75 ef                	jne    f0106095 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+f01060a6:	90                   	nop
+		}
+	}
+f01060a7:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+f01060a8:	e9 3f fc ff ff       	jmp    f0105cec <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+f01060ad:	83 c4 40             	add    $0x40,%esp
+f01060b0:	5b                   	pop    %ebx
+f01060b1:	5e                   	pop    %esi
+f01060b2:	5d                   	pop    %ebp
+f01060b3:	c3                   	ret    
+
+f01060b4 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+f01060b4:	55                   	push   %ebp
+f01060b5:	89 e5                	mov    %esp,%ebp
+f01060b7:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+f01060ba:	8d 45 14             	lea    0x14(%ebp),%eax
+f01060bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+f01060c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01060c3:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f01060c7:	8b 45 10             	mov    0x10(%ebp),%eax
+f01060ca:	89 44 24 08          	mov    %eax,0x8(%esp)
+f01060ce:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01060d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01060d5:	8b 45 08             	mov    0x8(%ebp),%eax
+f01060d8:	89 04 24             	mov    %eax,(%esp)
+f01060db:	e8 8d fa ff ff       	call   f0105b6d <vprintfmt>
+	va_end(ap);
+}
+f01060e0:	c9                   	leave  
+f01060e1:	c3                   	ret    
+
+f01060e2 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+f01060e2:	55                   	push   %ebp
+f01060e3:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+f01060e5:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01060e8:	8b 40 08             	mov    0x8(%eax),%eax
+f01060eb:	8d 50 01             	lea    0x1(%eax),%edx
+f01060ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01060f1:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+f01060f4:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01060f7:	8b 10                	mov    (%eax),%edx
+f01060f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01060fc:	8b 40 04             	mov    0x4(%eax),%eax
+f01060ff:	39 c2                	cmp    %eax,%edx
+f0106101:	73 12                	jae    f0106115 <sprintputch+0x33>
+		*b->buf++ = ch;
+f0106103:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106106:	8b 00                	mov    (%eax),%eax
+f0106108:	8d 48 01             	lea    0x1(%eax),%ecx
+f010610b:	8b 55 0c             	mov    0xc(%ebp),%edx
+f010610e:	89 0a                	mov    %ecx,(%edx)
+f0106110:	8b 55 08             	mov    0x8(%ebp),%edx
+f0106113:	88 10                	mov    %dl,(%eax)
+}
+f0106115:	5d                   	pop    %ebp
+f0106116:	c3                   	ret    
+
+f0106117 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+f0106117:	55                   	push   %ebp
+f0106118:	89 e5                	mov    %esp,%ebp
+f010611a:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+f010611d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106120:	89 45 ec             	mov    %eax,-0x14(%ebp)
+f0106123:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106126:	8d 50 ff             	lea    -0x1(%eax),%edx
+f0106129:	8b 45 08             	mov    0x8(%ebp),%eax
+f010612c:	01 d0                	add    %edx,%eax
+f010612e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+f0106131:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+f0106138:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+f010613c:	74 06                	je     f0106144 <vsnprintf+0x2d>
+f010613e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+f0106142:	7f 07                	jg     f010614b <vsnprintf+0x34>
+		return -E_INVAL;
+f0106144:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+f0106149:	eb 2a                	jmp    f0106175 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+f010614b:	8b 45 14             	mov    0x14(%ebp),%eax
+f010614e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f0106152:	8b 45 10             	mov    0x10(%ebp),%eax
+f0106155:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0106159:	8d 45 ec             	lea    -0x14(%ebp),%eax
+f010615c:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106160:	c7 04 24 e2 60 10 f0 	movl   $0xf01060e2,(%esp)
+f0106167:	e8 01 fa ff ff       	call   f0105b6d <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+f010616c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f010616f:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+f0106172:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+f0106175:	c9                   	leave  
+f0106176:	c3                   	ret    
+
+f0106177 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+f0106177:	55                   	push   %ebp
+f0106178:	89 e5                	mov    %esp,%ebp
+f010617a:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+f010617d:	8d 45 14             	lea    0x14(%ebp),%eax
+f0106180:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+f0106183:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0106186:	89 44 24 0c          	mov    %eax,0xc(%esp)
+f010618a:	8b 45 10             	mov    0x10(%ebp),%eax
+f010618d:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0106191:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106194:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106198:	8b 45 08             	mov    0x8(%ebp),%eax
+f010619b:	89 04 24             	mov    %eax,(%esp)
+f010619e:	e8 74 ff ff ff       	call   f0106117 <vsnprintf>
+f01061a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+f01061a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+f01061a9:	c9                   	leave  
+f01061aa:	c3                   	ret    
+
+f01061ab <readline>:
+#define BUFLEN 1024
+static char buf[BUFLEN];
+
+char *
+readline(const char *prompt)
+{
+f01061ab:	55                   	push   %ebp
+f01061ac:	89 e5                	mov    %esp,%ebp
+f01061ae:	83 ec 28             	sub    $0x28,%esp
+	int i, c, echoing;
+
+	if (prompt != NULL)
+f01061b1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+f01061b5:	74 13                	je     f01061ca <readline+0x1f>
+		cprintf("%s", prompt);
+f01061b7:	8b 45 08             	mov    0x8(%ebp),%eax
+f01061ba:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01061be:	c7 04 24 d8 82 10 f0 	movl   $0xf01082d8,(%esp)
+f01061c5:	e8 c3 e7 ff ff       	call   f010498d <cprintf>
+
+	i = 0;
+f01061ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+	echoing = iscons(0);
+f01061d1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+f01061d8:	e8 65 a7 ff ff       	call   f0100942 <iscons>
+f01061dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	while (1) {
+		c = getchar();
+f01061e0:	e8 44 a7 ff ff       	call   f0100929 <getchar>
+f01061e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+		if (c < 0) {
+f01061e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+f01061ec:	79 1d                	jns    f010620b <readline+0x60>
+			cprintf("read error: %e\n", c);
+f01061ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01061f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+f01061f5:	c7 04 24 db 82 10 f0 	movl   $0xf01082db,(%esp)
+f01061fc:	e8 8c e7 ff ff       	call   f010498d <cprintf>
+			return NULL;
+f0106201:	b8 00 00 00 00       	mov    $0x0,%eax
+f0106206:	e9 93 00 00 00       	jmp    f010629e <readline+0xf3>
+		} else if ((c == '\b' || c == '\x7f') && i > 0) {
+f010620b:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
+f010620f:	74 06                	je     f0106217 <readline+0x6c>
+f0106211:	83 7d ec 7f          	cmpl   $0x7f,-0x14(%ebp)
+f0106215:	75 1e                	jne    f0106235 <readline+0x8a>
+f0106217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+f010621b:	7e 18                	jle    f0106235 <readline+0x8a>
+			if (echoing)
+f010621d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0106221:	74 0c                	je     f010622f <readline+0x84>
+				cputchar('\b');
+f0106223:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+f010622a:	e8 e7 a6 ff ff       	call   f0100916 <cputchar>
+			i--;
+f010622f:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+f0106233:	eb 64                	jmp    f0106299 <readline+0xee>
+		} else if (c >= ' ' && i < BUFLEN-1) {
+f0106235:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
+f0106239:	7e 2e                	jle    f0106269 <readline+0xbe>
+f010623b:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+f0106242:	7f 25                	jg     f0106269 <readline+0xbe>
+			if (echoing)
+f0106244:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0106248:	74 0b                	je     f0106255 <readline+0xaa>
+				cputchar(c);
+f010624a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f010624d:	89 04 24             	mov    %eax,(%esp)
+f0106250:	e8 c1 a6 ff ff       	call   f0100916 <cputchar>
+			buf[i++] = c;
+f0106255:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f0106258:	8d 50 01             	lea    0x1(%eax),%edx
+f010625b:	89 55 f4             	mov    %edx,-0xc(%ebp)
+f010625e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+f0106261:	88 90 c0 f3 18 f0    	mov    %dl,-0xfe70c40(%eax)
+f0106267:	eb 30                	jmp    f0106299 <readline+0xee>
+		} else if (c == '\n' || c == '\r') {
+f0106269:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
+f010626d:	74 06                	je     f0106275 <readline+0xca>
+f010626f:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
+f0106273:	75 24                	jne    f0106299 <readline+0xee>
+			if (echoing)
+f0106275:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+f0106279:	74 0c                	je     f0106287 <readline+0xdc>
+				cputchar('\n');
+f010627b:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+f0106282:	e8 8f a6 ff ff       	call   f0100916 <cputchar>
+			buf[i] = 0;
+f0106287:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010628a:	05 c0 f3 18 f0       	add    $0xf018f3c0,%eax
+f010628f:	c6 00 00             	movb   $0x0,(%eax)
+			return buf;
+f0106292:	b8 c0 f3 18 f0       	mov    $0xf018f3c0,%eax
+f0106297:	eb 05                	jmp    f010629e <readline+0xf3>
+		}
+	}
+f0106299:	e9 42 ff ff ff       	jmp    f01061e0 <readline+0x35>
+}
+f010629e:	c9                   	leave  
+f010629f:	c3                   	ret    
+
+f01062a0 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+f01062a0:	55                   	push   %ebp
+f01062a1:	89 e5                	mov    %esp,%ebp
+f01062a3:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+f01062a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+f01062ad:	eb 08                	jmp    f01062b7 <strlen+0x17>
+		n++;
+f01062af:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+f01062b3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01062b7:	8b 45 08             	mov    0x8(%ebp),%eax
+f01062ba:	0f b6 00             	movzbl (%eax),%eax
+f01062bd:	84 c0                	test   %al,%al
+f01062bf:	75 ee                	jne    f01062af <strlen+0xf>
+		n++;
+	return n;
+f01062c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f01062c4:	c9                   	leave  
+f01062c5:	c3                   	ret    
+
+f01062c6 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+f01062c6:	55                   	push   %ebp
+f01062c7:	89 e5                	mov    %esp,%ebp
+f01062c9:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+f01062cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+f01062d3:	eb 0c                	jmp    f01062e1 <strnlen+0x1b>
+		n++;
+f01062d5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+f01062d9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01062dd:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+f01062e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+f01062e5:	74 0a                	je     f01062f1 <strnlen+0x2b>
+f01062e7:	8b 45 08             	mov    0x8(%ebp),%eax
+f01062ea:	0f b6 00             	movzbl (%eax),%eax
+f01062ed:	84 c0                	test   %al,%al
+f01062ef:	75 e4                	jne    f01062d5 <strnlen+0xf>
+		n++;
+	return n;
+f01062f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f01062f4:	c9                   	leave  
+f01062f5:	c3                   	ret    
+
+f01062f6 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+f01062f6:	55                   	push   %ebp
+f01062f7:	89 e5                	mov    %esp,%ebp
+f01062f9:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+f01062fc:	8b 45 08             	mov    0x8(%ebp),%eax
+f01062ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+f0106302:	90                   	nop
+f0106303:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106306:	8d 50 01             	lea    0x1(%eax),%edx
+f0106309:	89 55 08             	mov    %edx,0x8(%ebp)
+f010630c:	8b 55 0c             	mov    0xc(%ebp),%edx
+f010630f:	8d 4a 01             	lea    0x1(%edx),%ecx
+f0106312:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+f0106315:	0f b6 12             	movzbl (%edx),%edx
+f0106318:	88 10                	mov    %dl,(%eax)
+f010631a:	0f b6 00             	movzbl (%eax),%eax
+f010631d:	84 c0                	test   %al,%al
+f010631f:	75 e2                	jne    f0106303 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+f0106321:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+f0106324:	c9                   	leave  
+f0106325:	c3                   	ret    
+
+f0106326 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+f0106326:	55                   	push   %ebp
+f0106327:	89 e5                	mov    %esp,%ebp
+f0106329:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+f010632c:	8b 45 08             	mov    0x8(%ebp),%eax
+f010632f:	89 04 24             	mov    %eax,(%esp)
+f0106332:	e8 69 ff ff ff       	call   f01062a0 <strlen>
+f0106337:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+f010633a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+f010633d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106340:	01 c2                	add    %eax,%edx
+f0106342:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106345:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106349:	89 14 24             	mov    %edx,(%esp)
+f010634c:	e8 a5 ff ff ff       	call   f01062f6 <strcpy>
+	return dst;
+f0106351:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+f0106354:	c9                   	leave  
+f0106355:	c3                   	ret    
+
+f0106356 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+f0106356:	55                   	push   %ebp
+f0106357:	89 e5                	mov    %esp,%ebp
+f0106359:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+f010635c:	8b 45 08             	mov    0x8(%ebp),%eax
+f010635f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+f0106362:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+f0106369:	eb 23                	jmp    f010638e <strncpy+0x38>
+		*dst++ = *src;
+f010636b:	8b 45 08             	mov    0x8(%ebp),%eax
+f010636e:	8d 50 01             	lea    0x1(%eax),%edx
+f0106371:	89 55 08             	mov    %edx,0x8(%ebp)
+f0106374:	8b 55 0c             	mov    0xc(%ebp),%edx
+f0106377:	0f b6 12             	movzbl (%edx),%edx
+f010637a:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+f010637c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010637f:	0f b6 00             	movzbl (%eax),%eax
+f0106382:	84 c0                	test   %al,%al
+f0106384:	74 04                	je     f010638a <strncpy+0x34>
+			src++;
+f0106386:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+f010638a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+f010638e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0106391:	3b 45 10             	cmp    0x10(%ebp),%eax
+f0106394:	72 d5                	jb     f010636b <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+f0106396:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+f0106399:	c9                   	leave  
+f010639a:	c3                   	ret    
+
+f010639b <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+f010639b:	55                   	push   %ebp
+f010639c:	89 e5                	mov    %esp,%ebp
+f010639e:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+f01063a1:	8b 45 08             	mov    0x8(%ebp),%eax
+f01063a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+f01063a7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f01063ab:	74 33                	je     f01063e0 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+f01063ad:	eb 17                	jmp    f01063c6 <strlcpy+0x2b>
+			*dst++ = *src++;
+f01063af:	8b 45 08             	mov    0x8(%ebp),%eax
+f01063b2:	8d 50 01             	lea    0x1(%eax),%edx
+f01063b5:	89 55 08             	mov    %edx,0x8(%ebp)
+f01063b8:	8b 55 0c             	mov    0xc(%ebp),%edx
+f01063bb:	8d 4a 01             	lea    0x1(%edx),%ecx
+f01063be:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+f01063c1:	0f b6 12             	movzbl (%edx),%edx
+f01063c4:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+f01063c6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+f01063ca:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f01063ce:	74 0a                	je     f01063da <strlcpy+0x3f>
+f01063d0:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01063d3:	0f b6 00             	movzbl (%eax),%eax
+f01063d6:	84 c0                	test   %al,%al
+f01063d8:	75 d5                	jne    f01063af <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+f01063da:	8b 45 08             	mov    0x8(%ebp),%eax
+f01063dd:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+f01063e0:	8b 55 08             	mov    0x8(%ebp),%edx
+f01063e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f01063e6:	29 c2                	sub    %eax,%edx
+f01063e8:	89 d0                	mov    %edx,%eax
+}
+f01063ea:	c9                   	leave  
+f01063eb:	c3                   	ret    
+
+f01063ec <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+f01063ec:	55                   	push   %ebp
+f01063ed:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+f01063ef:	eb 08                	jmp    f01063f9 <strcmp+0xd>
+		p++, q++;
+f01063f1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01063f5:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+f01063f9:	8b 45 08             	mov    0x8(%ebp),%eax
+f01063fc:	0f b6 00             	movzbl (%eax),%eax
+f01063ff:	84 c0                	test   %al,%al
+f0106401:	74 10                	je     f0106413 <strcmp+0x27>
+f0106403:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106406:	0f b6 10             	movzbl (%eax),%edx
+f0106409:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010640c:	0f b6 00             	movzbl (%eax),%eax
+f010640f:	38 c2                	cmp    %al,%dl
+f0106411:	74 de                	je     f01063f1 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+f0106413:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106416:	0f b6 00             	movzbl (%eax),%eax
+f0106419:	0f b6 d0             	movzbl %al,%edx
+f010641c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010641f:	0f b6 00             	movzbl (%eax),%eax
+f0106422:	0f b6 c0             	movzbl %al,%eax
+f0106425:	29 c2                	sub    %eax,%edx
+f0106427:	89 d0                	mov    %edx,%eax
+}
+f0106429:	5d                   	pop    %ebp
+f010642a:	c3                   	ret    
+
+f010642b <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+f010642b:	55                   	push   %ebp
+f010642c:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+f010642e:	eb 0c                	jmp    f010643c <strncmp+0x11>
+		n--, p++, q++;
+f0106430:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+f0106434:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f0106438:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+f010643c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f0106440:	74 1a                	je     f010645c <strncmp+0x31>
+f0106442:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106445:	0f b6 00             	movzbl (%eax),%eax
+f0106448:	84 c0                	test   %al,%al
+f010644a:	74 10                	je     f010645c <strncmp+0x31>
+f010644c:	8b 45 08             	mov    0x8(%ebp),%eax
+f010644f:	0f b6 10             	movzbl (%eax),%edx
+f0106452:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106455:	0f b6 00             	movzbl (%eax),%eax
+f0106458:	38 c2                	cmp    %al,%dl
+f010645a:	74 d4                	je     f0106430 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+f010645c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f0106460:	75 07                	jne    f0106469 <strncmp+0x3e>
+		return 0;
+f0106462:	b8 00 00 00 00       	mov    $0x0,%eax
+f0106467:	eb 16                	jmp    f010647f <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+f0106469:	8b 45 08             	mov    0x8(%ebp),%eax
+f010646c:	0f b6 00             	movzbl (%eax),%eax
+f010646f:	0f b6 d0             	movzbl %al,%edx
+f0106472:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106475:	0f b6 00             	movzbl (%eax),%eax
+f0106478:	0f b6 c0             	movzbl %al,%eax
+f010647b:	29 c2                	sub    %eax,%edx
+f010647d:	89 d0                	mov    %edx,%eax
+}
+f010647f:	5d                   	pop    %ebp
+f0106480:	c3                   	ret    
+
+f0106481 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+f0106481:	55                   	push   %ebp
+f0106482:	89 e5                	mov    %esp,%ebp
+f0106484:	83 ec 04             	sub    $0x4,%esp
+f0106487:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010648a:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+f010648d:	eb 14                	jmp    f01064a3 <strchr+0x22>
+		if (*s == c)
+f010648f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106492:	0f b6 00             	movzbl (%eax),%eax
+f0106495:	3a 45 fc             	cmp    -0x4(%ebp),%al
+f0106498:	75 05                	jne    f010649f <strchr+0x1e>
+			return (char *) s;
+f010649a:	8b 45 08             	mov    0x8(%ebp),%eax
+f010649d:	eb 13                	jmp    f01064b2 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+f010649f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01064a3:	8b 45 08             	mov    0x8(%ebp),%eax
+f01064a6:	0f b6 00             	movzbl (%eax),%eax
+f01064a9:	84 c0                	test   %al,%al
+f01064ab:	75 e2                	jne    f010648f <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+f01064ad:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f01064b2:	c9                   	leave  
+f01064b3:	c3                   	ret    
+
+f01064b4 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+f01064b4:	55                   	push   %ebp
+f01064b5:	89 e5                	mov    %esp,%ebp
+f01064b7:	83 ec 04             	sub    $0x4,%esp
+f01064ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01064bd:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+f01064c0:	eb 11                	jmp    f01064d3 <strfind+0x1f>
+		if (*s == c)
+f01064c2:	8b 45 08             	mov    0x8(%ebp),%eax
+f01064c5:	0f b6 00             	movzbl (%eax),%eax
+f01064c8:	3a 45 fc             	cmp    -0x4(%ebp),%al
+f01064cb:	75 02                	jne    f01064cf <strfind+0x1b>
+			break;
+f01064cd:	eb 0e                	jmp    f01064dd <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+f01064cf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01064d3:	8b 45 08             	mov    0x8(%ebp),%eax
+f01064d6:	0f b6 00             	movzbl (%eax),%eax
+f01064d9:	84 c0                	test   %al,%al
+f01064db:	75 e5                	jne    f01064c2 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+f01064dd:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+f01064e0:	c9                   	leave  
+f01064e1:	c3                   	ret    
+
+f01064e2 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+f01064e2:	55                   	push   %ebp
+f01064e3:	89 e5                	mov    %esp,%ebp
+f01064e5:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+f01064e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f01064ea:	75 05                	jne    f01064f1 <memset+0xf>
+		return v;
+f01064ec:	8b 45 08             	mov    0x8(%ebp),%eax
+f01064ef:	eb 5c                	jmp    f010654d <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+f01064f1:	8b 45 08             	mov    0x8(%ebp),%eax
+f01064f4:	83 e0 03             	and    $0x3,%eax
+f01064f7:	85 c0                	test   %eax,%eax
+f01064f9:	75 41                	jne    f010653c <memset+0x5a>
+f01064fb:	8b 45 10             	mov    0x10(%ebp),%eax
+f01064fe:	83 e0 03             	and    $0x3,%eax
+f0106501:	85 c0                	test   %eax,%eax
+f0106503:	75 37                	jne    f010653c <memset+0x5a>
+		c &= 0xFF;
+f0106505:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+f010650c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010650f:	c1 e0 18             	shl    $0x18,%eax
+f0106512:	89 c2                	mov    %eax,%edx
+f0106514:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106517:	c1 e0 10             	shl    $0x10,%eax
+f010651a:	09 c2                	or     %eax,%edx
+f010651c:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010651f:	c1 e0 08             	shl    $0x8,%eax
+f0106522:	09 d0                	or     %edx,%eax
+f0106524:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+f0106527:	8b 45 10             	mov    0x10(%ebp),%eax
+f010652a:	c1 e8 02             	shr    $0x2,%eax
+f010652d:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+f010652f:	8b 55 08             	mov    0x8(%ebp),%edx
+f0106532:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106535:	89 d7                	mov    %edx,%edi
+f0106537:	fc                   	cld    
+f0106538:	f3 ab                	rep stos %eax,%es:(%edi)
+f010653a:	eb 0e                	jmp    f010654a <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+f010653c:	8b 55 08             	mov    0x8(%ebp),%edx
+f010653f:	8b 45 0c             	mov    0xc(%ebp),%eax
+f0106542:	8b 4d 10             	mov    0x10(%ebp),%ecx
+f0106545:	89 d7                	mov    %edx,%edi
+f0106547:	fc                   	cld    
+f0106548:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+f010654a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+f010654d:	5f                   	pop    %edi
+f010654e:	5d                   	pop    %ebp
+f010654f:	c3                   	ret    
+
+f0106550 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+f0106550:	55                   	push   %ebp
+f0106551:	89 e5                	mov    %esp,%ebp
+f0106553:	57                   	push   %edi
+f0106554:	56                   	push   %esi
+f0106555:	53                   	push   %ebx
+f0106556:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+f0106559:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010655c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+f010655f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106562:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+f0106565:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0106568:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+f010656b:	73 6d                	jae    f01065da <memmove+0x8a>
+f010656d:	8b 45 10             	mov    0x10(%ebp),%eax
+f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0106573:	01 d0                	add    %edx,%eax
+f0106575:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+f0106578:	76 60                	jbe    f01065da <memmove+0x8a>
+		s += n;
+f010657a:	8b 45 10             	mov    0x10(%ebp),%eax
+f010657d:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+f0106580:	8b 45 10             	mov    0x10(%ebp),%eax
+f0106583:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+f0106586:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f0106589:	83 e0 03             	and    $0x3,%eax
+f010658c:	85 c0                	test   %eax,%eax
+f010658e:	75 2f                	jne    f01065bf <memmove+0x6f>
+f0106590:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0106593:	83 e0 03             	and    $0x3,%eax
+f0106596:	85 c0                	test   %eax,%eax
+f0106598:	75 25                	jne    f01065bf <memmove+0x6f>
+f010659a:	8b 45 10             	mov    0x10(%ebp),%eax
+f010659d:	83 e0 03             	and    $0x3,%eax
+f01065a0:	85 c0                	test   %eax,%eax
+f01065a2:	75 1b                	jne    f01065bf <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+f01065a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01065a7:	83 e8 04             	sub    $0x4,%eax
+f01065aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f01065ad:	83 ea 04             	sub    $0x4,%edx
+f01065b0:	8b 4d 10             	mov    0x10(%ebp),%ecx
+f01065b3:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+f01065b6:	89 c7                	mov    %eax,%edi
+f01065b8:	89 d6                	mov    %edx,%esi
+f01065ba:	fd                   	std    
+f01065bb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+f01065bd:	eb 18                	jmp    f01065d7 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+f01065bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01065c2:	8d 50 ff             	lea    -0x1(%eax),%edx
+f01065c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01065c8:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+f01065cb:	8b 45 10             	mov    0x10(%ebp),%eax
+f01065ce:	89 d7                	mov    %edx,%edi
+f01065d0:	89 de                	mov    %ebx,%esi
+f01065d2:	89 c1                	mov    %eax,%ecx
+f01065d4:	fd                   	std    
+f01065d5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+f01065d7:	fc                   	cld    
+f01065d8:	eb 45                	jmp    f010661f <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+f01065da:	8b 45 f0             	mov    -0x10(%ebp),%eax
+f01065dd:	83 e0 03             	and    $0x3,%eax
+f01065e0:	85 c0                	test   %eax,%eax
+f01065e2:	75 2b                	jne    f010660f <memmove+0xbf>
+f01065e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f01065e7:	83 e0 03             	and    $0x3,%eax
+f01065ea:	85 c0                	test   %eax,%eax
+f01065ec:	75 21                	jne    f010660f <memmove+0xbf>
+f01065ee:	8b 45 10             	mov    0x10(%ebp),%eax
+f01065f1:	83 e0 03             	and    $0x3,%eax
+f01065f4:	85 c0                	test   %eax,%eax
+f01065f6:	75 17                	jne    f010660f <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+f01065f8:	8b 45 10             	mov    0x10(%ebp),%eax
+f01065fb:	c1 e8 02             	shr    $0x2,%eax
+f01065fe:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+f0106600:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0106603:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0106606:	89 c7                	mov    %eax,%edi
+f0106608:	89 d6                	mov    %edx,%esi
+f010660a:	fc                   	cld    
+f010660b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+f010660d:	eb 10                	jmp    f010661f <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+f010660f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+f0106612:	8b 55 f0             	mov    -0x10(%ebp),%edx
+f0106615:	8b 4d 10             	mov    0x10(%ebp),%ecx
+f0106618:	89 c7                	mov    %eax,%edi
+f010661a:	89 d6                	mov    %edx,%esi
+f010661c:	fc                   	cld    
+f010661d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+f010661f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+f0106622:	83 c4 10             	add    $0x10,%esp
+f0106625:	5b                   	pop    %ebx
+f0106626:	5e                   	pop    %esi
+f0106627:	5f                   	pop    %edi
+f0106628:	5d                   	pop    %ebp
+f0106629:	c3                   	ret    
+
+f010662a <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+f010662a:	55                   	push   %ebp
+f010662b:	89 e5                	mov    %esp,%ebp
+f010662d:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+f0106630:	8b 45 10             	mov    0x10(%ebp),%eax
+f0106633:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0106637:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010663a:	89 44 24 04          	mov    %eax,0x4(%esp)
+f010663e:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106641:	89 04 24             	mov    %eax,(%esp)
+f0106644:	e8 07 ff ff ff       	call   f0106550 <memmove>
+}
+f0106649:	c9                   	leave  
+f010664a:	c3                   	ret    
+
+f010664b <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+f010664b:	55                   	push   %ebp
+f010664c:	89 e5                	mov    %esp,%ebp
+f010664e:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+f0106651:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106654:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+f0106657:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010665a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+f010665d:	eb 30                	jmp    f010668f <memcmp+0x44>
+		if (*s1 != *s2)
+f010665f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0106662:	0f b6 10             	movzbl (%eax),%edx
+f0106665:	8b 45 f8             	mov    -0x8(%ebp),%eax
+f0106668:	0f b6 00             	movzbl (%eax),%eax
+f010666b:	38 c2                	cmp    %al,%dl
+f010666d:	74 18                	je     f0106687 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+f010666f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+f0106672:	0f b6 00             	movzbl (%eax),%eax
+f0106675:	0f b6 d0             	movzbl %al,%edx
+f0106678:	8b 45 f8             	mov    -0x8(%ebp),%eax
+f010667b:	0f b6 00             	movzbl (%eax),%eax
+f010667e:	0f b6 c0             	movzbl %al,%eax
+f0106681:	29 c2                	sub    %eax,%edx
+f0106683:	89 d0                	mov    %edx,%eax
+f0106685:	eb 1a                	jmp    f01066a1 <memcmp+0x56>
+		s1++, s2++;
+f0106687:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+f010668b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+f010668f:	8b 45 10             	mov    0x10(%ebp),%eax
+f0106692:	8d 50 ff             	lea    -0x1(%eax),%edx
+f0106695:	89 55 10             	mov    %edx,0x10(%ebp)
+f0106698:	85 c0                	test   %eax,%eax
+f010669a:	75 c3                	jne    f010665f <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+f010669c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+f01066a1:	c9                   	leave  
+f01066a2:	c3                   	ret    
+
+f01066a3 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+f01066a3:	55                   	push   %ebp
+f01066a4:	89 e5                	mov    %esp,%ebp
+f01066a6:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+f01066a9:	8b 45 10             	mov    0x10(%ebp),%eax
+f01066ac:	8b 55 08             	mov    0x8(%ebp),%edx
+f01066af:	01 d0                	add    %edx,%eax
+f01066b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+f01066b4:	eb 13                	jmp    f01066c9 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+f01066b6:	8b 45 08             	mov    0x8(%ebp),%eax
+f01066b9:	0f b6 10             	movzbl (%eax),%edx
+f01066bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+f01066bf:	38 c2                	cmp    %al,%dl
+f01066c1:	75 02                	jne    f01066c5 <memfind+0x22>
+			break;
+f01066c3:	eb 0c                	jmp    f01066d1 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+f01066c5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01066c9:	8b 45 08             	mov    0x8(%ebp),%eax
+f01066cc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+f01066cf:	72 e5                	jb     f01066b6 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+f01066d1:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+f01066d4:	c9                   	leave  
+f01066d5:	c3                   	ret    
+
+f01066d6 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+f01066d6:	55                   	push   %ebp
+f01066d7:	89 e5                	mov    %esp,%ebp
+f01066d9:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+f01066dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+f01066e3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+f01066ea:	eb 04                	jmp    f01066f0 <strtol+0x1a>
+		s++;
+f01066ec:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+f01066f0:	8b 45 08             	mov    0x8(%ebp),%eax
+f01066f3:	0f b6 00             	movzbl (%eax),%eax
+f01066f6:	3c 20                	cmp    $0x20,%al
+f01066f8:	74 f2                	je     f01066ec <strtol+0x16>
+f01066fa:	8b 45 08             	mov    0x8(%ebp),%eax
+f01066fd:	0f b6 00             	movzbl (%eax),%eax
+f0106700:	3c 09                	cmp    $0x9,%al
+f0106702:	74 e8                	je     f01066ec <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+f0106704:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106707:	0f b6 00             	movzbl (%eax),%eax
+f010670a:	3c 2b                	cmp    $0x2b,%al
+f010670c:	75 06                	jne    f0106714 <strtol+0x3e>
+		s++;
+f010670e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f0106712:	eb 15                	jmp    f0106729 <strtol+0x53>
+	else if (*s == '-')
+f0106714:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106717:	0f b6 00             	movzbl (%eax),%eax
+f010671a:	3c 2d                	cmp    $0x2d,%al
+f010671c:	75 0b                	jne    f0106729 <strtol+0x53>
+		s++, neg = 1;
+f010671e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f0106722:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+f0106729:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f010672d:	74 06                	je     f0106735 <strtol+0x5f>
+f010672f:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+f0106733:	75 24                	jne    f0106759 <strtol+0x83>
+f0106735:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106738:	0f b6 00             	movzbl (%eax),%eax
+f010673b:	3c 30                	cmp    $0x30,%al
+f010673d:	75 1a                	jne    f0106759 <strtol+0x83>
+f010673f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106742:	83 c0 01             	add    $0x1,%eax
+f0106745:	0f b6 00             	movzbl (%eax),%eax
+f0106748:	3c 78                	cmp    $0x78,%al
+f010674a:	75 0d                	jne    f0106759 <strtol+0x83>
+		s += 2, base = 16;
+f010674c:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+f0106750:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+f0106757:	eb 2a                	jmp    f0106783 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+f0106759:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f010675d:	75 17                	jne    f0106776 <strtol+0xa0>
+f010675f:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106762:	0f b6 00             	movzbl (%eax),%eax
+f0106765:	3c 30                	cmp    $0x30,%al
+f0106767:	75 0d                	jne    f0106776 <strtol+0xa0>
+		s++, base = 8;
+f0106769:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f010676d:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+f0106774:	eb 0d                	jmp    f0106783 <strtol+0xad>
+	else if (base == 0)
+f0106776:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+f010677a:	75 07                	jne    f0106783 <strtol+0xad>
+		base = 10;
+f010677c:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+f0106783:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106786:	0f b6 00             	movzbl (%eax),%eax
+f0106789:	3c 2f                	cmp    $0x2f,%al
+f010678b:	7e 1b                	jle    f01067a8 <strtol+0xd2>
+f010678d:	8b 45 08             	mov    0x8(%ebp),%eax
+f0106790:	0f b6 00             	movzbl (%eax),%eax
+f0106793:	3c 39                	cmp    $0x39,%al
+f0106795:	7f 11                	jg     f01067a8 <strtol+0xd2>
+			dig = *s - '0';
+f0106797:	8b 45 08             	mov    0x8(%ebp),%eax
+f010679a:	0f b6 00             	movzbl (%eax),%eax
+f010679d:	0f be c0             	movsbl %al,%eax
+f01067a0:	83 e8 30             	sub    $0x30,%eax
+f01067a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01067a6:	eb 48                	jmp    f01067f0 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+f01067a8:	8b 45 08             	mov    0x8(%ebp),%eax
+f01067ab:	0f b6 00             	movzbl (%eax),%eax
+f01067ae:	3c 60                	cmp    $0x60,%al
+f01067b0:	7e 1b                	jle    f01067cd <strtol+0xf7>
+f01067b2:	8b 45 08             	mov    0x8(%ebp),%eax
+f01067b5:	0f b6 00             	movzbl (%eax),%eax
+f01067b8:	3c 7a                	cmp    $0x7a,%al
+f01067ba:	7f 11                	jg     f01067cd <strtol+0xf7>
+			dig = *s - 'a' + 10;
+f01067bc:	8b 45 08             	mov    0x8(%ebp),%eax
+f01067bf:	0f b6 00             	movzbl (%eax),%eax
+f01067c2:	0f be c0             	movsbl %al,%eax
+f01067c5:	83 e8 57             	sub    $0x57,%eax
+f01067c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+f01067cb:	eb 23                	jmp    f01067f0 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+f01067cd:	8b 45 08             	mov    0x8(%ebp),%eax
+f01067d0:	0f b6 00             	movzbl (%eax),%eax
+f01067d3:	3c 40                	cmp    $0x40,%al
+f01067d5:	7e 3d                	jle    f0106814 <strtol+0x13e>
+f01067d7:	8b 45 08             	mov    0x8(%ebp),%eax
+f01067da:	0f b6 00             	movzbl (%eax),%eax
+f01067dd:	3c 5a                	cmp    $0x5a,%al
+f01067df:	7f 33                	jg     f0106814 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+f01067e1:	8b 45 08             	mov    0x8(%ebp),%eax
+f01067e4:	0f b6 00             	movzbl (%eax),%eax
+f01067e7:	0f be c0             	movsbl %al,%eax
+f01067ea:	83 e8 37             	sub    $0x37,%eax
+f01067ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+f01067f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f01067f3:	3b 45 10             	cmp    0x10(%ebp),%eax
+f01067f6:	7c 02                	jl     f01067fa <strtol+0x124>
+			break;
+f01067f8:	eb 1a                	jmp    f0106814 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+f01067fa:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+f01067fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
+f0106801:	0f af 45 10          	imul   0x10(%ebp),%eax
+f0106805:	89 c2                	mov    %eax,%edx
+f0106807:	8b 45 f4             	mov    -0xc(%ebp),%eax
+f010680a:	01 d0                	add    %edx,%eax
+f010680c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+f010680f:	e9 6f ff ff ff       	jmp    f0106783 <strtol+0xad>
+
+	if (endptr)
+f0106814:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+f0106818:	74 08                	je     f0106822 <strtol+0x14c>
+		*endptr = (char *) s;
+f010681a:	8b 45 0c             	mov    0xc(%ebp),%eax
+f010681d:	8b 55 08             	mov    0x8(%ebp),%edx
+f0106820:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+f0106822:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+f0106826:	74 07                	je     f010682f <strtol+0x159>
+f0106828:	8b 45 f8             	mov    -0x8(%ebp),%eax
+f010682b:	f7 d8                	neg    %eax
+f010682d:	eb 03                	jmp    f0106832 <strtol+0x15c>
+f010682f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+f0106832:	c9                   	leave  
+f0106833:	c3                   	ret    
+f0106834:	66 90                	xchg   %ax,%ax
+f0106836:	66 90                	xchg   %ax,%ax
+f0106838:	66 90                	xchg   %ax,%ax
+f010683a:	66 90                	xchg   %ax,%ax
+f010683c:	66 90                	xchg   %ax,%ax
+f010683e:	66 90                	xchg   %ax,%ax
+
+f0106840 <__udivdi3>:
+f0106840:	55                   	push   %ebp
+f0106841:	57                   	push   %edi
+f0106842:	56                   	push   %esi
+f0106843:	83 ec 0c             	sub    $0xc,%esp
+f0106846:	8b 44 24 28          	mov    0x28(%esp),%eax
+f010684a:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+f010684e:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+f0106852:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+f0106856:	85 c0                	test   %eax,%eax
+f0106858:	89 7c 24 04          	mov    %edi,0x4(%esp)
+f010685c:	89 ea                	mov    %ebp,%edx
+f010685e:	89 0c 24             	mov    %ecx,(%esp)
+f0106861:	75 2d                	jne    f0106890 <__udivdi3+0x50>
+f0106863:	39 e9                	cmp    %ebp,%ecx
+f0106865:	77 61                	ja     f01068c8 <__udivdi3+0x88>
+f0106867:	85 c9                	test   %ecx,%ecx
+f0106869:	89 ce                	mov    %ecx,%esi
+f010686b:	75 0b                	jne    f0106878 <__udivdi3+0x38>
+f010686d:	b8 01 00 00 00       	mov    $0x1,%eax
+f0106872:	31 d2                	xor    %edx,%edx
+f0106874:	f7 f1                	div    %ecx
+f0106876:	89 c6                	mov    %eax,%esi
+f0106878:	31 d2                	xor    %edx,%edx
+f010687a:	89 e8                	mov    %ebp,%eax
+f010687c:	f7 f6                	div    %esi
+f010687e:	89 c5                	mov    %eax,%ebp
+f0106880:	89 f8                	mov    %edi,%eax
+f0106882:	f7 f6                	div    %esi
+f0106884:	89 ea                	mov    %ebp,%edx
+f0106886:	83 c4 0c             	add    $0xc,%esp
+f0106889:	5e                   	pop    %esi
+f010688a:	5f                   	pop    %edi
+f010688b:	5d                   	pop    %ebp
+f010688c:	c3                   	ret    
+f010688d:	8d 76 00             	lea    0x0(%esi),%esi
+f0106890:	39 e8                	cmp    %ebp,%eax
+f0106892:	77 24                	ja     f01068b8 <__udivdi3+0x78>
+f0106894:	0f bd e8             	bsr    %eax,%ebp
+f0106897:	83 f5 1f             	xor    $0x1f,%ebp
+f010689a:	75 3c                	jne    f01068d8 <__udivdi3+0x98>
+f010689c:	8b 74 24 04          	mov    0x4(%esp),%esi
+f01068a0:	39 34 24             	cmp    %esi,(%esp)
+f01068a3:	0f 86 9f 00 00 00    	jbe    f0106948 <__udivdi3+0x108>
+f01068a9:	39 d0                	cmp    %edx,%eax
+f01068ab:	0f 82 97 00 00 00    	jb     f0106948 <__udivdi3+0x108>
+f01068b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+f01068b8:	31 d2                	xor    %edx,%edx
+f01068ba:	31 c0                	xor    %eax,%eax
+f01068bc:	83 c4 0c             	add    $0xc,%esp
+f01068bf:	5e                   	pop    %esi
+f01068c0:	5f                   	pop    %edi
+f01068c1:	5d                   	pop    %ebp
+f01068c2:	c3                   	ret    
+f01068c3:	90                   	nop
+f01068c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+f01068c8:	89 f8                	mov    %edi,%eax
+f01068ca:	f7 f1                	div    %ecx
+f01068cc:	31 d2                	xor    %edx,%edx
+f01068ce:	83 c4 0c             	add    $0xc,%esp
+f01068d1:	5e                   	pop    %esi
+f01068d2:	5f                   	pop    %edi
+f01068d3:	5d                   	pop    %ebp
+f01068d4:	c3                   	ret    
+f01068d5:	8d 76 00             	lea    0x0(%esi),%esi
+f01068d8:	89 e9                	mov    %ebp,%ecx
+f01068da:	8b 3c 24             	mov    (%esp),%edi
+f01068dd:	d3 e0                	shl    %cl,%eax
+f01068df:	89 c6                	mov    %eax,%esi
+f01068e1:	b8 20 00 00 00       	mov    $0x20,%eax
+f01068e6:	29 e8                	sub    %ebp,%eax
+f01068e8:	89 c1                	mov    %eax,%ecx
+f01068ea:	d3 ef                	shr    %cl,%edi
+f01068ec:	89 e9                	mov    %ebp,%ecx
+f01068ee:	89 7c 24 08          	mov    %edi,0x8(%esp)
+f01068f2:	8b 3c 24             	mov    (%esp),%edi
+f01068f5:	09 74 24 08          	or     %esi,0x8(%esp)
+f01068f9:	89 d6                	mov    %edx,%esi
+f01068fb:	d3 e7                	shl    %cl,%edi
+f01068fd:	89 c1                	mov    %eax,%ecx
+f01068ff:	89 3c 24             	mov    %edi,(%esp)
+f0106902:	8b 7c 24 04          	mov    0x4(%esp),%edi
+f0106906:	d3 ee                	shr    %cl,%esi
+f0106908:	89 e9                	mov    %ebp,%ecx
+f010690a:	d3 e2                	shl    %cl,%edx
+f010690c:	89 c1                	mov    %eax,%ecx
+f010690e:	d3 ef                	shr    %cl,%edi
+f0106910:	09 d7                	or     %edx,%edi
+f0106912:	89 f2                	mov    %esi,%edx
+f0106914:	89 f8                	mov    %edi,%eax
+f0106916:	f7 74 24 08          	divl   0x8(%esp)
+f010691a:	89 d6                	mov    %edx,%esi
+f010691c:	89 c7                	mov    %eax,%edi
+f010691e:	f7 24 24             	mull   (%esp)
+f0106921:	39 d6                	cmp    %edx,%esi
+f0106923:	89 14 24             	mov    %edx,(%esp)
+f0106926:	72 30                	jb     f0106958 <__udivdi3+0x118>
+f0106928:	8b 54 24 04          	mov    0x4(%esp),%edx
+f010692c:	89 e9                	mov    %ebp,%ecx
+f010692e:	d3 e2                	shl    %cl,%edx
+f0106930:	39 c2                	cmp    %eax,%edx
+f0106932:	73 05                	jae    f0106939 <__udivdi3+0xf9>
+f0106934:	3b 34 24             	cmp    (%esp),%esi
+f0106937:	74 1f                	je     f0106958 <__udivdi3+0x118>
+f0106939:	89 f8                	mov    %edi,%eax
+f010693b:	31 d2                	xor    %edx,%edx
+f010693d:	e9 7a ff ff ff       	jmp    f01068bc <__udivdi3+0x7c>
+f0106942:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+f0106948:	31 d2                	xor    %edx,%edx
+f010694a:	b8 01 00 00 00       	mov    $0x1,%eax
+f010694f:	e9 68 ff ff ff       	jmp    f01068bc <__udivdi3+0x7c>
+f0106954:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+f0106958:	8d 47 ff             	lea    -0x1(%edi),%eax
+f010695b:	31 d2                	xor    %edx,%edx
+f010695d:	83 c4 0c             	add    $0xc,%esp
+f0106960:	5e                   	pop    %esi
+f0106961:	5f                   	pop    %edi
+f0106962:	5d                   	pop    %ebp
+f0106963:	c3                   	ret    
+f0106964:	66 90                	xchg   %ax,%ax
+f0106966:	66 90                	xchg   %ax,%ax
+f0106968:	66 90                	xchg   %ax,%ax
+f010696a:	66 90                	xchg   %ax,%ax
+f010696c:	66 90                	xchg   %ax,%ax
+f010696e:	66 90                	xchg   %ax,%ax
+
+f0106970 <__umoddi3>:
+f0106970:	55                   	push   %ebp
+f0106971:	57                   	push   %edi
+f0106972:	56                   	push   %esi
+f0106973:	83 ec 14             	sub    $0x14,%esp
+f0106976:	8b 44 24 28          	mov    0x28(%esp),%eax
+f010697a:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+f010697e:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+f0106982:	89 c7                	mov    %eax,%edi
+f0106984:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106988:	8b 44 24 30          	mov    0x30(%esp),%eax
+f010698c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+f0106990:	89 34 24             	mov    %esi,(%esp)
+f0106993:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+f0106997:	85 c0                	test   %eax,%eax
+f0106999:	89 c2                	mov    %eax,%edx
+f010699b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+f010699f:	75 17                	jne    f01069b8 <__umoddi3+0x48>
+f01069a1:	39 fe                	cmp    %edi,%esi
+f01069a3:	76 4b                	jbe    f01069f0 <__umoddi3+0x80>
+f01069a5:	89 c8                	mov    %ecx,%eax
+f01069a7:	89 fa                	mov    %edi,%edx
+f01069a9:	f7 f6                	div    %esi
+f01069ab:	89 d0                	mov    %edx,%eax
+f01069ad:	31 d2                	xor    %edx,%edx
+f01069af:	83 c4 14             	add    $0x14,%esp
+f01069b2:	5e                   	pop    %esi
+f01069b3:	5f                   	pop    %edi
+f01069b4:	5d                   	pop    %ebp
+f01069b5:	c3                   	ret    
+f01069b6:	66 90                	xchg   %ax,%ax
+f01069b8:	39 f8                	cmp    %edi,%eax
+f01069ba:	77 54                	ja     f0106a10 <__umoddi3+0xa0>
+f01069bc:	0f bd e8             	bsr    %eax,%ebp
+f01069bf:	83 f5 1f             	xor    $0x1f,%ebp
+f01069c2:	75 5c                	jne    f0106a20 <__umoddi3+0xb0>
+f01069c4:	8b 7c 24 08          	mov    0x8(%esp),%edi
+f01069c8:	39 3c 24             	cmp    %edi,(%esp)
+f01069cb:	0f 87 e7 00 00 00    	ja     f0106ab8 <__umoddi3+0x148>
+f01069d1:	8b 7c 24 04          	mov    0x4(%esp),%edi
+f01069d5:	29 f1                	sub    %esi,%ecx
+f01069d7:	19 c7                	sbb    %eax,%edi
+f01069d9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+f01069dd:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+f01069e1:	8b 44 24 08          	mov    0x8(%esp),%eax
+f01069e5:	8b 54 24 0c          	mov    0xc(%esp),%edx
+f01069e9:	83 c4 14             	add    $0x14,%esp
+f01069ec:	5e                   	pop    %esi
+f01069ed:	5f                   	pop    %edi
+f01069ee:	5d                   	pop    %ebp
+f01069ef:	c3                   	ret    
+f01069f0:	85 f6                	test   %esi,%esi
+f01069f2:	89 f5                	mov    %esi,%ebp
+f01069f4:	75 0b                	jne    f0106a01 <__umoddi3+0x91>
+f01069f6:	b8 01 00 00 00       	mov    $0x1,%eax
+f01069fb:	31 d2                	xor    %edx,%edx
+f01069fd:	f7 f6                	div    %esi
+f01069ff:	89 c5                	mov    %eax,%ebp
+f0106a01:	8b 44 24 04          	mov    0x4(%esp),%eax
+f0106a05:	31 d2                	xor    %edx,%edx
+f0106a07:	f7 f5                	div    %ebp
+f0106a09:	89 c8                	mov    %ecx,%eax
+f0106a0b:	f7 f5                	div    %ebp
+f0106a0d:	eb 9c                	jmp    f01069ab <__umoddi3+0x3b>
+f0106a0f:	90                   	nop
+f0106a10:	89 c8                	mov    %ecx,%eax
+f0106a12:	89 fa                	mov    %edi,%edx
+f0106a14:	83 c4 14             	add    $0x14,%esp
+f0106a17:	5e                   	pop    %esi
+f0106a18:	5f                   	pop    %edi
+f0106a19:	5d                   	pop    %ebp
+f0106a1a:	c3                   	ret    
+f0106a1b:	90                   	nop
+f0106a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+f0106a20:	8b 04 24             	mov    (%esp),%eax
+f0106a23:	be 20 00 00 00       	mov    $0x20,%esi
+f0106a28:	89 e9                	mov    %ebp,%ecx
+f0106a2a:	29 ee                	sub    %ebp,%esi
+f0106a2c:	d3 e2                	shl    %cl,%edx
+f0106a2e:	89 f1                	mov    %esi,%ecx
+f0106a30:	d3 e8                	shr    %cl,%eax
+f0106a32:	89 e9                	mov    %ebp,%ecx
+f0106a34:	89 44 24 04          	mov    %eax,0x4(%esp)
+f0106a38:	8b 04 24             	mov    (%esp),%eax
+f0106a3b:	09 54 24 04          	or     %edx,0x4(%esp)
+f0106a3f:	89 fa                	mov    %edi,%edx
+f0106a41:	d3 e0                	shl    %cl,%eax
+f0106a43:	89 f1                	mov    %esi,%ecx
+f0106a45:	89 44 24 08          	mov    %eax,0x8(%esp)
+f0106a49:	8b 44 24 10          	mov    0x10(%esp),%eax
+f0106a4d:	d3 ea                	shr    %cl,%edx
+f0106a4f:	89 e9                	mov    %ebp,%ecx
+f0106a51:	d3 e7                	shl    %cl,%edi
+f0106a53:	89 f1                	mov    %esi,%ecx
+f0106a55:	d3 e8                	shr    %cl,%eax
+f0106a57:	89 e9                	mov    %ebp,%ecx
+f0106a59:	09 f8                	or     %edi,%eax
+f0106a5b:	8b 7c 24 10          	mov    0x10(%esp),%edi
+f0106a5f:	f7 74 24 04          	divl   0x4(%esp)
+f0106a63:	d3 e7                	shl    %cl,%edi
+f0106a65:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+f0106a69:	89 d7                	mov    %edx,%edi
+f0106a6b:	f7 64 24 08          	mull   0x8(%esp)
+f0106a6f:	39 d7                	cmp    %edx,%edi
+f0106a71:	89 c1                	mov    %eax,%ecx
+f0106a73:	89 14 24             	mov    %edx,(%esp)
+f0106a76:	72 2c                	jb     f0106aa4 <__umoddi3+0x134>
+f0106a78:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+f0106a7c:	72 22                	jb     f0106aa0 <__umoddi3+0x130>
+f0106a7e:	8b 44 24 0c          	mov    0xc(%esp),%eax
+f0106a82:	29 c8                	sub    %ecx,%eax
+f0106a84:	19 d7                	sbb    %edx,%edi
+f0106a86:	89 e9                	mov    %ebp,%ecx
+f0106a88:	89 fa                	mov    %edi,%edx
+f0106a8a:	d3 e8                	shr    %cl,%eax
+f0106a8c:	89 f1                	mov    %esi,%ecx
+f0106a8e:	d3 e2                	shl    %cl,%edx
+f0106a90:	89 e9                	mov    %ebp,%ecx
+f0106a92:	d3 ef                	shr    %cl,%edi
+f0106a94:	09 d0                	or     %edx,%eax
+f0106a96:	89 fa                	mov    %edi,%edx
+f0106a98:	83 c4 14             	add    $0x14,%esp
+f0106a9b:	5e                   	pop    %esi
+f0106a9c:	5f                   	pop    %edi
+f0106a9d:	5d                   	pop    %ebp
+f0106a9e:	c3                   	ret    
+f0106a9f:	90                   	nop
+f0106aa0:	39 d7                	cmp    %edx,%edi
+f0106aa2:	75 da                	jne    f0106a7e <__umoddi3+0x10e>
+f0106aa4:	8b 14 24             	mov    (%esp),%edx
+f0106aa7:	89 c1                	mov    %eax,%ecx
+f0106aa9:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+f0106aad:	1b 54 24 04          	sbb    0x4(%esp),%edx
+f0106ab1:	eb cb                	jmp    f0106a7e <__umoddi3+0x10e>
+f0106ab3:	90                   	nop
+f0106ab4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+f0106ab8:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+f0106abc:	0f 82 0f ff ff ff    	jb     f01069d1 <__umoddi3+0x61>
+f0106ac2:	e9 1a ff ff ff       	jmp    f01069e1 <__umoddi3+0x71>
diff --git a/obj/kern/kernel.img b/obj/kern/kernel.img
new file mode 100644
index 0000000..b7091c4
Binary files /dev/null and b/obj/kern/kernel.img differ
diff --git a/obj/kern/kernel.sym b/obj/kern/kernel.sym
new file mode 100644
index 0000000..6fd40dd
--- /dev/null
+++ b/obj/kern/kernel.sym
@@ -0,0 +1,282 @@
+000088c1 A _binary_obj_user_hello_size
+000088c3 A _binary_obj_user_softint_size
+000088c5 A _binary_obj_user_evilhello_size
+000088c5 A _binary_obj_user_faultread_size
+000088c6 A _binary_obj_user_badsegment_size
+000088c6 A _binary_obj_user_breakpoint_size
+000088c6 A _binary_obj_user_buggyhello_size
+000088c6 A _binary_obj_user_faultwrite_size
+000088cb A _binary_obj_user_faultreadkernel_size
+000088cc A _binary_obj_user_faultwritekernel_size
+000088d8 A _binary_obj_user_divzero_size
+000088dc A _binary_obj_user_testbss_size
+000088e1 A _binary_obj_user_buggyhello2_size
+0010000c T _start
+f010000c T entry
+f010002f t relocated
+f010003e t spin
+f0100040 T i386_init
+f01000b5 T _panic
+f010011c T _warn
+f0100162 t inb
+f0100177 t outb
+f010018d t delay
+f01001c5 t serial_proc_data
+f01001f9 T serial_intr
+f0100218 t serial_putc
+f0100267 t serial_init
+f0100329 t lpt_putc
+f010039a t cga_init
+f0100458 t cga_putc
+f0100667 t kbd_proc_data
+f01007fa T kbd_intr
+f010080e t kbd_init
+f0100813 t cons_intr
+f0100860 T cons_getc
+f01008bc t cons_putc
+f01008e5 T cons_init
+f0100916 T cputchar
+f0100929 T getchar
+f0100942 T iscons
+f010094c t read_ebp
+f010095c t _kaddr
+f010099e t page2pa
+f01009b5 T mon_help
+f0100a12 T mon_kerninfo
+f0100aff T mon_backtrace
+f0100c36 T mon_pgmap
+f0100dd2 T mon_pgperm
+f0100edc T mon_memdump
+f0100ff8 t runcmd
+f0101152 T monitor
+f01011b2 T mon_continue
+f01011f1 T mon_stepins
+f0101230 t invlpg
+f010123b t lcr0
+f0101246 t rcr0
+f0101257 t lcr3
+f0101262 t _paddr
+f010129d t _kaddr
+f01012df t page2pa
+f01012f6 t pa2page
+f010133b t page2kva
+f0101366 t nvram_read
+f0101393 t i386_detect_memory
+f0101435 t boot_alloc
+f0101519 T mem_init
+f01017b9 T page_init
+f01018a7 T page_alloc
+f010190a T page_free
+f010194f T page_decref
+f010197f T pgdir_walk
+f0101a41 t boot_map_region
+f0101aa0 T page_insert
+f0101b68 T page_lookup
+f0101bc6 T page_remove
+f0101c3a T tlb_invalidate
+f0101c4d T user_mem_check
+f0101ce9 T user_mem_assert
+f0101d43 t check_page_free_list
+f01020b1 t check_page_alloc
+f0102663 t check_kern_pgdir
+f0102a1d t check_va2pa
+f0102aae t check_page
+f0103a13 t check_page_installed_pgdir
+f0103d8c t lgdt
+f0103d97 t lldt
+f0103dad t lcr3
+f0103db8 t _paddr
+f0103df3 t _kaddr
+f0103e35 t page2pa
+f0103e4c t pa2page
+f0103e91 t page2kva
+f0103ebc T envid2env
+f0103f67 T env_init
+f0103fe2 T env_init_percpu
+f010402c t boot_map_region
+f010408b t env_setup_vm
+f010428c T env_alloc
+f01043c2 t region_alloc
+f01044b0 t load_icode
+f01045fd T env_create
+f0104633 T env_free
+f01047e0 T env_destroy
+f010480b T env_pop_tf
+f0104837 T env_run
+f01048b2 t inb
+f01048c7 t outb
+f01048dd T mc146818_read
+f010490a T mc146818_write
+f010493e t putch
+f010495a T vcprintf
+f010498d T cprintf
+f01049b3 t lidt
+f01049be t ltr
+f01049d4 t rcr2
+f01049e5 t read_eflags
+f01049f5 t trapname
+f0104a20 T trap_init
+f0104bdb T trap_init_percpu
+f0104cd5 T print_trapframe
+f0104e9a T print_regs
+f0104f3c t trap_dispatch
+f010501b T trap
+f0105123 T page_fault_handler
+f01051a2 T vector0
+f01051ac T vector1
+f01051b6 T vector2
+f01051c0 T vector3
+f01051ca T vector4
+f01051d4 T vector5
+f01051de T vector6
+f01051e8 T vector7
+f01051f2 T vector8
+f01051fa T vector9
+f0105204 T vector10
+f010520c T vector11
+f0105214 T vector12
+f010521c T vector13
+f0105224 T vector14
+f010522c T vector15
+f0105236 T vector16
+f0105240 T vector17
+f0105248 T vector18
+f0105252 T vector19
+f010525c T vector20
+f0105266 T vector21
+f0105270 T vector22
+f010527a T vector23
+f0105284 T vector24
+f010528e T vector25
+f0105298 T vector26
+f01052a2 T vector27
+f01052a8 T vector28
+f01052ae T vector29
+f01052b4 T vector30
+f01052ba T vector31
+f01052c0 T vector32
+f01052c6 T vector33
+f01052cc T vector34
+f01052d2 T vector35
+f01052d8 T vector36
+f01052de T vector37
+f01052e4 T vector38
+f01052ea T vector39
+f01052f0 T vector40
+f01052f6 T vector41
+f01052fc T vector42
+f0105302 T vector43
+f0105308 T vector44
+f010530e T vector45
+f0105314 T vector46
+f010531a T vector47
+f0105320 T vector48
+f0105326 t _alltraps
+f010533f t sys_cputs
+f0105397 t sys_cgetc
+f01053a4 t sys_getenvid
+f01053b1 t sys_env_destroy
+f0105439 T syscall
+f0105493 t stab_binsearch
+f01055e9 T debuginfo_eip
+f01059f9 t printnum
+f0105ad7 t getuint
+f0105b26 t getint
+f0105b6d T vprintfmt
+f01060b4 T printfmt
+f01060e2 t sprintputch
+f0106117 T vsnprintf
+f0106177 T snprintf
+f01061ab T readline
+f01062a0 T strlen
+f01062c6 T strnlen
+f01062f6 T strcpy
+f0106326 T strcat
+f0106356 T strncpy
+f010639b T strlcpy
+f01063ec T strcmp
+f010642b T strncmp
+f0106481 T strchr
+f01064b4 T strfind
+f01064e2 T memset
+f0106550 T memmove
+f010662a T memcpy
+f010664b T memcmp
+f01066a3 T memfind
+f01066d6 T strtol
+f0106840 T __udivdi3
+f0106970 T __umoddi3
+f0106ac7 T etext
+f0108040 r excnames.1391
+f0108140 r error_string
+f01082ec R __STAB_BEGIN__
+f01116e8 R __STAB_END__
+f01116e9 R __STABSTR_BEGIN__
+f011463c R __STABSTR_END__
+f0115000 D bootstack
+f011d000 D bootstacktop
+f011d000 D entry_pgtable
+f011e000 D entry_pgdir
+f011f000 d shiftcode
+f011f100 d togglecode
+f011f200 d normalmap
+f011f300 d shiftmap
+f011f400 d ctlmap
+f011f500 d charcode
+f011f520 d commands
+f011f580 D gdt
+f011f5b0 D gdt_pd
+f011f5b6 D idt_pd
+f011f5bc D vectors
+f011f680 D _binary_obj_user_hello_start
+f0127f41 D _binary_obj_user_buggyhello_start
+f0127f41 D _binary_obj_user_hello_end
+f0130807 D _binary_obj_user_buggyhello2_start
+f0130807 D _binary_obj_user_buggyhello_end
+f01390e8 D _binary_obj_user_buggyhello2_end
+f01390e8 D _binary_obj_user_evilhello_start
+f01419ad D _binary_obj_user_evilhello_end
+f01419ad D _binary_obj_user_testbss_start
+f014a289 D _binary_obj_user_divzero_start
+f014a289 D _binary_obj_user_testbss_end
+f0152b61 D _binary_obj_user_breakpoint_start
+f0152b61 D _binary_obj_user_divzero_end
+f015b427 D _binary_obj_user_breakpoint_end
+f015b427 D _binary_obj_user_softint_start
+f0163cea D _binary_obj_user_badsegment_start
+f0163cea D _binary_obj_user_softint_end
+f016c5b0 D _binary_obj_user_badsegment_end
+f016c5b0 D _binary_obj_user_faultread_start
+f0174e75 D _binary_obj_user_faultread_end
+f0174e75 D _binary_obj_user_faultreadkernel_start
+f017d740 D _binary_obj_user_faultreadkernel_end
+f017d740 D _binary_obj_user_faultwrite_start
+f0186006 D _binary_obj_user_faultwrite_end
+f0186006 D _binary_obj_user_faultwritekernel_start
+f018e8d2 D _binary_obj_user_faultwritekernel_end
+f018e8d2 D edata
+f018e8e0 b serial_exists
+f018e8e4 b addr_6845
+f018e8e8 b crt_buf
+f018e8ec b crt_pos
+f018e900 b cons
+f018eb08 b shift.1336
+f018eb0c b npages_basemem
+f018eb10 b page_free_list
+f018eb14 b user_mem_check_addr
+f018eb18 b nextfree.1441
+f018eb1c B envs
+f018eb20 B curenv
+f018eb24 b env_free_list
+f018eb40 B idt
+f018f340 b ts
+f018f3a8 b last_tf
+f018f3c0 b buf
+f018f7c0 B panicstr
+f018f7c4 B BG_COLOR
+f018f7c8 B COLOR
+f018f7cc B FG_COLOR
+f018f7d0 B npages
+f018f7d4 B kern_pgdir
+f018f7d8 B pages
+f018f7dc B end
diff --git a/obj/kern/monitor.o b/obj/kern/monitor.o
new file mode 100644
index 0000000..c254487
Binary files /dev/null and b/obj/kern/monitor.o differ
diff --git a/obj/kern/pmap.o b/obj/kern/pmap.o
new file mode 100644
index 0000000..7ffab84
Binary files /dev/null and b/obj/kern/pmap.o differ
diff --git a/obj/kern/printf.o b/obj/kern/printf.o
new file mode 100644
index 0000000..0a376ec
Binary files /dev/null and b/obj/kern/printf.o differ
diff --git a/obj/kern/printfmt.o b/obj/kern/printfmt.o
new file mode 100644
index 0000000..cf5ad8e
Binary files /dev/null and b/obj/kern/printfmt.o differ
diff --git a/obj/kern/readline.o b/obj/kern/readline.o
new file mode 100644
index 0000000..0310640
Binary files /dev/null and b/obj/kern/readline.o differ
diff --git a/obj/kern/string.o b/obj/kern/string.o
new file mode 100644
index 0000000..e94d3b4
Binary files /dev/null and b/obj/kern/string.o differ
diff --git a/obj/kern/syscall.o b/obj/kern/syscall.o
new file mode 100644
index 0000000..d1db33c
Binary files /dev/null and b/obj/kern/syscall.o differ
diff --git a/obj/kern/trap.o b/obj/kern/trap.o
new file mode 100644
index 0000000..c145c12
Binary files /dev/null and b/obj/kern/trap.o differ
diff --git a/obj/kern/trapentry.o b/obj/kern/trapentry.o
new file mode 100644
index 0000000..c8bfcc7
Binary files /dev/null and b/obj/kern/trapentry.o differ
diff --git a/obj/lib/console.o b/obj/lib/console.o
new file mode 100644
index 0000000..7696db8
Binary files /dev/null and b/obj/lib/console.o differ
diff --git a/obj/lib/entry.o b/obj/lib/entry.o
new file mode 100644
index 0000000..60d4654
Binary files /dev/null and b/obj/lib/entry.o differ
diff --git a/obj/lib/exit.o b/obj/lib/exit.o
new file mode 100644
index 0000000..ea7f5ec
Binary files /dev/null and b/obj/lib/exit.o differ
diff --git a/obj/lib/libjos.a b/obj/lib/libjos.a
new file mode 100644
index 0000000..a70172b
Binary files /dev/null and b/obj/lib/libjos.a differ
diff --git a/obj/lib/libmain.o b/obj/lib/libmain.o
new file mode 100644
index 0000000..9d00253
Binary files /dev/null and b/obj/lib/libmain.o differ
diff --git a/obj/lib/panic.o b/obj/lib/panic.o
new file mode 100644
index 0000000..6fe2e61
Binary files /dev/null and b/obj/lib/panic.o differ
diff --git a/obj/lib/printf.o b/obj/lib/printf.o
new file mode 100644
index 0000000..b9abe98
Binary files /dev/null and b/obj/lib/printf.o differ
diff --git a/obj/lib/printfmt.o b/obj/lib/printfmt.o
new file mode 100644
index 0000000..cf5ad8e
Binary files /dev/null and b/obj/lib/printfmt.o differ
diff --git a/obj/lib/readline.o b/obj/lib/readline.o
new file mode 100644
index 0000000..0310640
Binary files /dev/null and b/obj/lib/readline.o differ
diff --git a/obj/lib/string.o b/obj/lib/string.o
new file mode 100644
index 0000000..e94d3b4
Binary files /dev/null and b/obj/lib/string.o differ
diff --git a/obj/lib/syscall.o b/obj/lib/syscall.o
new file mode 100644
index 0000000..4f0c6aa
Binary files /dev/null and b/obj/lib/syscall.o differ
diff --git a/obj/user/badsegment b/obj/user/badsegment
new file mode 100755
index 0000000..5c3eabd
Binary files /dev/null and b/obj/user/badsegment differ
diff --git a/obj/user/badsegment.asm b/obj/user/badsegment.asm
new file mode 100644
index 0000000..8da39d9
--- /dev/null
+++ b/obj/user/badsegment.asm
@@ -0,0 +1,2627 @@
+
+obj/user/badsegment:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 0d 00 00 00       	call   80003e <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+	// Try to load the kernel's TSS selector into the DS register.
+	asm volatile("movw $0x28,%ax; movw %ax,%ds");
+  800036:	66 b8 28 00          	mov    $0x28,%ax
+  80003a:	8e d8                	mov    %eax,%ds
+}
+  80003c:	5d                   	pop    %ebp
+  80003d:	c3                   	ret    
+
+0080003e <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80003e:	55                   	push   %ebp
+  80003f:	89 e5                	mov    %esp,%ebp
+  800041:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800044:	e8 81 01 00 00       	call   8001ca <sys_getenvid>
+  800049:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80004e:	89 c2                	mov    %eax,%edx
+  800050:	89 d0                	mov    %edx,%eax
+  800052:	01 c0                	add    %eax,%eax
+  800054:	01 d0                	add    %edx,%eax
+  800056:	c1 e0 05             	shl    $0x5,%eax
+  800059:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80005e:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800063:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800067:	7e 0a                	jle    800073 <libmain+0x35>
+		binaryname = argv[0];
+  800069:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80006c:	8b 00                	mov    (%eax),%eax
+  80006e:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800073:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800076:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80007a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80007d:	89 04 24             	mov    %eax,(%esp)
+  800080:	e8 ae ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800085:	e8 02 00 00 00       	call   80008c <exit>
+}
+  80008a:	c9                   	leave  
+  80008b:	c3                   	ret    
+
+0080008c <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  80008c:	55                   	push   %ebp
+  80008d:	89 e5                	mov    %esp,%ebp
+  80008f:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  800092:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800099:	e8 e9 00 00 00       	call   800187 <sys_env_destroy>
+}
+  80009e:	c9                   	leave  
+  80009f:	c3                   	ret    
+
+008000a0 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000a0:	55                   	push   %ebp
+  8000a1:	89 e5                	mov    %esp,%ebp
+  8000a3:	57                   	push   %edi
+  8000a4:	56                   	push   %esi
+  8000a5:	53                   	push   %ebx
+  8000a6:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000ac:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000af:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000b2:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000b5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000b8:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000bb:	cd 30                	int    $0x30
+  8000bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000c4:	74 30                	je     8000f6 <syscall+0x56>
+  8000c6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000ca:	7e 2a                	jle    8000f6 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000cf:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000d3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000da:	c7 44 24 08 32 13 80 	movl   $0x801332,0x8(%esp)
+  8000e1:	00 
+  8000e2:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000e9:	00 
+  8000ea:	c7 04 24 4f 13 80 00 	movl   $0x80134f,(%esp)
+  8000f1:	e8 18 01 00 00       	call   80020e <_panic>
+
+	return ret;
+  8000f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  8000f9:	83 c4 3c             	add    $0x3c,%esp
+  8000fc:	5b                   	pop    %ebx
+  8000fd:	5e                   	pop    %esi
+  8000fe:	5f                   	pop    %edi
+  8000ff:	5d                   	pop    %ebp
+  800100:	c3                   	ret    
+
+00800101 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800101:	55                   	push   %ebp
+  800102:	89 e5                	mov    %esp,%ebp
+  800104:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800107:	8b 45 08             	mov    0x8(%ebp),%eax
+  80010a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800111:	00 
+  800112:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800119:	00 
+  80011a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800121:	00 
+  800122:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800125:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800129:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80012d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800134:	00 
+  800135:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80013c:	e8 5f ff ff ff       	call   8000a0 <syscall>
+}
+  800141:	c9                   	leave  
+  800142:	c3                   	ret    
+
+00800143 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800143:	55                   	push   %ebp
+  800144:	89 e5                	mov    %esp,%ebp
+  800146:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800149:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800150:	00 
+  800151:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800158:	00 
+  800159:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800160:	00 
+  800161:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800168:	00 
+  800169:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800170:	00 
+  800171:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800178:	00 
+  800179:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800180:	e8 1b ff ff ff       	call   8000a0 <syscall>
+}
+  800185:	c9                   	leave  
+  800186:	c3                   	ret    
+
+00800187 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800187:	55                   	push   %ebp
+  800188:	89 e5                	mov    %esp,%ebp
+  80018a:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  80018d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800190:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800197:	00 
+  800198:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80019f:	00 
+  8001a0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001a7:	00 
+  8001a8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001af:	00 
+  8001b0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001b4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001bb:	00 
+  8001bc:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001c3:	e8 d8 fe ff ff       	call   8000a0 <syscall>
+}
+  8001c8:	c9                   	leave  
+  8001c9:	c3                   	ret    
+
+008001ca <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001ca:	55                   	push   %ebp
+  8001cb:	89 e5                	mov    %esp,%ebp
+  8001cd:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001d0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001d7:	00 
+  8001d8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001df:	00 
+  8001e0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001e7:	00 
+  8001e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001ef:	00 
+  8001f0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  8001f7:	00 
+  8001f8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  8001ff:	00 
+  800200:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  800207:	e8 94 fe ff ff       	call   8000a0 <syscall>
+}
+  80020c:	c9                   	leave  
+  80020d:	c3                   	ret    
+
+0080020e <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80020e:	55                   	push   %ebp
+  80020f:	89 e5                	mov    %esp,%ebp
+  800211:	53                   	push   %ebx
+  800212:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800215:	8d 45 14             	lea    0x14(%ebp),%eax
+  800218:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80021b:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  800221:	e8 a4 ff ff ff       	call   8001ca <sys_getenvid>
+  800226:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800229:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80022d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800230:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800234:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  800238:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80023c:	c7 04 24 60 13 80 00 	movl   $0x801360,(%esp)
+  800243:	e8 e1 00 00 00       	call   800329 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  800248:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80024b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80024f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800252:	89 04 24             	mov    %eax,(%esp)
+  800255:	e8 6b 00 00 00       	call   8002c5 <vcprintf>
+	cprintf("\n");
+  80025a:	c7 04 24 83 13 80 00 	movl   $0x801383,(%esp)
+  800261:	e8 c3 00 00 00       	call   800329 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  800266:	cc                   	int3   
+  800267:	eb fd                	jmp    800266 <_panic+0x58>
+
+00800269 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  800269:	55                   	push   %ebp
+  80026a:	89 e5                	mov    %esp,%ebp
+  80026c:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  80026f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800272:	8b 00                	mov    (%eax),%eax
+  800274:	8d 48 01             	lea    0x1(%eax),%ecx
+  800277:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80027a:	89 0a                	mov    %ecx,(%edx)
+  80027c:	8b 55 08             	mov    0x8(%ebp),%edx
+  80027f:	89 d1                	mov    %edx,%ecx
+  800281:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800284:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  800288:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80028b:	8b 00                	mov    (%eax),%eax
+  80028d:	3d ff 00 00 00       	cmp    $0xff,%eax
+  800292:	75 20                	jne    8002b4 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  800294:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800297:	8b 00                	mov    (%eax),%eax
+  800299:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80029c:	83 c2 08             	add    $0x8,%edx
+  80029f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002a3:	89 14 24             	mov    %edx,(%esp)
+  8002a6:	e8 56 fe ff ff       	call   800101 <sys_cputs>
+		b->idx = 0;
+  8002ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002b4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002b7:	8b 40 04             	mov    0x4(%eax),%eax
+  8002ba:	8d 50 01             	lea    0x1(%eax),%edx
+  8002bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c0:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002c3:	c9                   	leave  
+  8002c4:	c3                   	ret    
+
+008002c5 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002c5:	55                   	push   %ebp
+  8002c6:	89 e5                	mov    %esp,%ebp
+  8002c8:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002ce:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002d5:	00 00 00 
+	b.cnt = 0;
+  8002d8:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002df:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002e5:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002e9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002ec:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8002f0:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  8002f6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002fa:	c7 04 24 69 02 80 00 	movl   $0x800269,(%esp)
+  800301:	e8 bd 01 00 00       	call   8004c3 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800306:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  80030c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800310:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800316:	83 c0 08             	add    $0x8,%eax
+  800319:	89 04 24             	mov    %eax,(%esp)
+  80031c:	e8 e0 fd ff ff       	call   800101 <sys_cputs>
+
+	return b.cnt;
+  800321:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800327:	c9                   	leave  
+  800328:	c3                   	ret    
+
+00800329 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800329:	55                   	push   %ebp
+  80032a:	89 e5                	mov    %esp,%ebp
+  80032c:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  80032f:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800332:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800335:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800338:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80033c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80033f:	89 04 24             	mov    %eax,(%esp)
+  800342:	e8 7e ff ff ff       	call   8002c5 <vcprintf>
+  800347:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  80034a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80034d:	c9                   	leave  
+  80034e:	c3                   	ret    
+
+0080034f <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  80034f:	55                   	push   %ebp
+  800350:	89 e5                	mov    %esp,%ebp
+  800352:	53                   	push   %ebx
+  800353:	83 ec 34             	sub    $0x34,%esp
+  800356:	8b 45 10             	mov    0x10(%ebp),%eax
+  800359:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80035c:	8b 45 14             	mov    0x14(%ebp),%eax
+  80035f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800362:	8b 45 18             	mov    0x18(%ebp),%eax
+  800365:	ba 00 00 00 00       	mov    $0x0,%edx
+  80036a:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  80036d:	77 72                	ja     8003e1 <printnum+0x92>
+  80036f:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800372:	72 05                	jb     800379 <printnum+0x2a>
+  800374:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  800377:	77 68                	ja     8003e1 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  800379:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  80037c:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  80037f:	8b 45 18             	mov    0x18(%ebp),%eax
+  800382:	ba 00 00 00 00       	mov    $0x0,%edx
+  800387:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80038b:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80038f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800392:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800395:	89 04 24             	mov    %eax,(%esp)
+  800398:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80039c:	e8 ff 0c 00 00       	call   8010a0 <__udivdi3>
+  8003a1:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003a4:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003a8:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003ac:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003af:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003b3:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003b7:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003bb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003be:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c5:	89 04 24             	mov    %eax,(%esp)
+  8003c8:	e8 82 ff ff ff       	call   80034f <printnum>
+  8003cd:	eb 1c                	jmp    8003eb <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003d2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003d6:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003d9:	89 04 24             	mov    %eax,(%esp)
+  8003dc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003df:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003e1:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003e5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003e9:	7f e4                	jg     8003cf <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003eb:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003ee:	bb 00 00 00 00       	mov    $0x0,%ebx
+  8003f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003f9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8003fd:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800401:	89 04 24             	mov    %eax,(%esp)
+  800404:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800408:	e8 c3 0d 00 00       	call   8011d0 <__umoddi3>
+  80040d:	05 10 14 80 00       	add    $0x801410,%eax
+  800412:	0f b6 00             	movzbl (%eax),%eax
+  800415:	0f be c0             	movsbl %al,%eax
+  800418:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80041b:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80041f:	89 04 24             	mov    %eax,(%esp)
+  800422:	8b 45 08             	mov    0x8(%ebp),%eax
+  800425:	ff d0                	call   *%eax
+}
+  800427:	83 c4 34             	add    $0x34,%esp
+  80042a:	5b                   	pop    %ebx
+  80042b:	5d                   	pop    %ebp
+  80042c:	c3                   	ret    
+
+0080042d <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  80042d:	55                   	push   %ebp
+  80042e:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800430:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800434:	7e 14                	jle    80044a <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800436:	8b 45 08             	mov    0x8(%ebp),%eax
+  800439:	8b 00                	mov    (%eax),%eax
+  80043b:	8d 48 08             	lea    0x8(%eax),%ecx
+  80043e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800441:	89 0a                	mov    %ecx,(%edx)
+  800443:	8b 50 04             	mov    0x4(%eax),%edx
+  800446:	8b 00                	mov    (%eax),%eax
+  800448:	eb 30                	jmp    80047a <getuint+0x4d>
+	else if (lflag)
+  80044a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80044e:	74 16                	je     800466 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  800450:	8b 45 08             	mov    0x8(%ebp),%eax
+  800453:	8b 00                	mov    (%eax),%eax
+  800455:	8d 48 04             	lea    0x4(%eax),%ecx
+  800458:	8b 55 08             	mov    0x8(%ebp),%edx
+  80045b:	89 0a                	mov    %ecx,(%edx)
+  80045d:	8b 00                	mov    (%eax),%eax
+  80045f:	ba 00 00 00 00       	mov    $0x0,%edx
+  800464:	eb 14                	jmp    80047a <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  800466:	8b 45 08             	mov    0x8(%ebp),%eax
+  800469:	8b 00                	mov    (%eax),%eax
+  80046b:	8d 48 04             	lea    0x4(%eax),%ecx
+  80046e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800471:	89 0a                	mov    %ecx,(%edx)
+  800473:	8b 00                	mov    (%eax),%eax
+  800475:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  80047a:	5d                   	pop    %ebp
+  80047b:	c3                   	ret    
+
+0080047c <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  80047c:	55                   	push   %ebp
+  80047d:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80047f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800483:	7e 14                	jle    800499 <getint+0x1d>
+		return va_arg(*ap, long long);
+  800485:	8b 45 08             	mov    0x8(%ebp),%eax
+  800488:	8b 00                	mov    (%eax),%eax
+  80048a:	8d 48 08             	lea    0x8(%eax),%ecx
+  80048d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800490:	89 0a                	mov    %ecx,(%edx)
+  800492:	8b 50 04             	mov    0x4(%eax),%edx
+  800495:	8b 00                	mov    (%eax),%eax
+  800497:	eb 28                	jmp    8004c1 <getint+0x45>
+	else if (lflag)
+  800499:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80049d:	74 12                	je     8004b1 <getint+0x35>
+		return va_arg(*ap, long);
+  80049f:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a2:	8b 00                	mov    (%eax),%eax
+  8004a4:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004a7:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004aa:	89 0a                	mov    %ecx,(%edx)
+  8004ac:	8b 00                	mov    (%eax),%eax
+  8004ae:	99                   	cltd   
+  8004af:	eb 10                	jmp    8004c1 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004b1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b4:	8b 00                	mov    (%eax),%eax
+  8004b6:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004b9:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004bc:	89 0a                	mov    %ecx,(%edx)
+  8004be:	8b 00                	mov    (%eax),%eax
+  8004c0:	99                   	cltd   
+}
+  8004c1:	5d                   	pop    %ebp
+  8004c2:	c3                   	ret    
+
+008004c3 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004c3:	55                   	push   %ebp
+  8004c4:	89 e5                	mov    %esp,%ebp
+  8004c6:	56                   	push   %esi
+  8004c7:	53                   	push   %ebx
+  8004c8:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004cb:	e9 72 01 00 00       	jmp    800642 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004d0:	85 db                	test   %ebx,%ebx
+  8004d2:	75 05                	jne    8004d9 <vprintfmt+0x16>
+				return;
+  8004d4:	e9 2a 05 00 00       	jmp    800a03 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004d9:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004dc:	0f 85 51 01 00 00    	jne    800633 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004e2:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004e5:	8d 50 01             	lea    0x1(%eax),%edx
+  8004e8:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004eb:	0f b6 00             	movzbl (%eax),%eax
+  8004ee:	0f b6 d8             	movzbl %al,%ebx
+  8004f1:	83 fb 5b             	cmp    $0x5b,%ebx
+  8004f4:	74 14                	je     80050a <vprintfmt+0x47>
+				    putch(ch, putdat);
+  8004f6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8004fd:	89 1c 24             	mov    %ebx,(%esp)
+  800500:	8b 45 08             	mov    0x8(%ebp),%eax
+  800503:	ff d0                	call   *%eax
+				    continue;
+  800505:	e9 38 01 00 00       	jmp    800642 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  80050a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80050d:	8d 50 01             	lea    0x1(%eax),%edx
+  800510:	89 55 10             	mov    %edx,0x10(%ebp)
+  800513:	0f b6 00             	movzbl (%eax),%eax
+  800516:	0f b6 c0             	movzbl %al,%eax
+  800519:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  80051e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800521:	8d 50 01             	lea    0x1(%eax),%edx
+  800524:	89 55 10             	mov    %edx,0x10(%ebp)
+  800527:	0f b6 00             	movzbl (%eax),%eax
+  80052a:	0f b6 c0             	movzbl %al,%eax
+  80052d:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800532:	a1 08 20 80 00       	mov    0x802008,%eax
+  800537:	83 f8 2f             	cmp    $0x2f,%eax
+  80053a:	7e 19                	jle    800555 <vprintfmt+0x92>
+  80053c:	a1 08 20 80 00       	mov    0x802008,%eax
+  800541:	83 f8 39             	cmp    $0x39,%eax
+  800544:	7f 0f                	jg     800555 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800546:	a1 08 20 80 00       	mov    0x802008,%eax
+  80054b:	83 e8 30             	sub    $0x30,%eax
+  80054e:	a3 08 20 80 00       	mov    %eax,0x802008
+  800553:	eb 50                	jmp    8005a5 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  800555:	a1 08 20 80 00       	mov    0x802008,%eax
+  80055a:	83 f8 60             	cmp    $0x60,%eax
+  80055d:	7e 19                	jle    800578 <vprintfmt+0xb5>
+  80055f:	a1 08 20 80 00       	mov    0x802008,%eax
+  800564:	83 f8 66             	cmp    $0x66,%eax
+  800567:	7f 0f                	jg     800578 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  800569:	a1 08 20 80 00       	mov    0x802008,%eax
+  80056e:	83 e8 57             	sub    $0x57,%eax
+  800571:	a3 08 20 80 00       	mov    %eax,0x802008
+  800576:	eb 2d                	jmp    8005a5 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  800578:	a1 08 20 80 00       	mov    0x802008,%eax
+  80057d:	83 f8 40             	cmp    $0x40,%eax
+  800580:	7e 19                	jle    80059b <vprintfmt+0xd8>
+  800582:	a1 08 20 80 00       	mov    0x802008,%eax
+  800587:	83 f8 46             	cmp    $0x46,%eax
+  80058a:	7f 0f                	jg     80059b <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  80058c:	a1 08 20 80 00       	mov    0x802008,%eax
+  800591:	83 e8 37             	sub    $0x37,%eax
+  800594:	a3 08 20 80 00       	mov    %eax,0x802008
+  800599:	eb 0a                	jmp    8005a5 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  80059b:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8005a2:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005a5:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005aa:	83 f8 2f             	cmp    $0x2f,%eax
+  8005ad:	7e 19                	jle    8005c8 <vprintfmt+0x105>
+  8005af:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005b4:	83 f8 39             	cmp    $0x39,%eax
+  8005b7:	7f 0f                	jg     8005c8 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005b9:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005be:	83 e8 30             	sub    $0x30,%eax
+  8005c1:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005c6:	eb 50                	jmp    800618 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005c8:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005cd:	83 f8 60             	cmp    $0x60,%eax
+  8005d0:	7e 19                	jle    8005eb <vprintfmt+0x128>
+  8005d2:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005d7:	83 f8 66             	cmp    $0x66,%eax
+  8005da:	7f 0f                	jg     8005eb <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005dc:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005e1:	83 e8 57             	sub    $0x57,%eax
+  8005e4:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005e9:	eb 2d                	jmp    800618 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005eb:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f0:	83 f8 40             	cmp    $0x40,%eax
+  8005f3:	7e 19                	jle    80060e <vprintfmt+0x14b>
+  8005f5:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005fa:	83 f8 46             	cmp    $0x46,%eax
+  8005fd:	7f 0f                	jg     80060e <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  8005ff:	a1 10 20 80 00       	mov    0x802010,%eax
+  800604:	83 e8 37             	sub    $0x37,%eax
+  800607:	a3 10 20 80 00       	mov    %eax,0x802010
+  80060c:	eb 0a                	jmp    800618 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80060e:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800615:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800618:	a1 08 20 80 00       	mov    0x802008,%eax
+  80061d:	c1 e0 0c             	shl    $0xc,%eax
+  800620:	89 c2                	mov    %eax,%edx
+  800622:	a1 10 20 80 00       	mov    0x802010,%eax
+  800627:	c1 e0 08             	shl    $0x8,%eax
+  80062a:	09 d0                	or     %edx,%eax
+  80062c:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800631:	eb 0f                	jmp    800642 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800633:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800636:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80063a:	89 1c 24             	mov    %ebx,(%esp)
+  80063d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800640:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800642:	8b 45 10             	mov    0x10(%ebp),%eax
+  800645:	8d 50 01             	lea    0x1(%eax),%edx
+  800648:	89 55 10             	mov    %edx,0x10(%ebp)
+  80064b:	0f b6 00             	movzbl (%eax),%eax
+  80064e:	0f b6 d8             	movzbl %al,%ebx
+  800651:	83 fb 25             	cmp    $0x25,%ebx
+  800654:	0f 85 76 fe ff ff    	jne    8004d0 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  80065a:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  80065e:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  800665:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  80066c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800673:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  80067a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80067d:	8d 50 01             	lea    0x1(%eax),%edx
+  800680:	89 55 10             	mov    %edx,0x10(%ebp)
+  800683:	0f b6 00             	movzbl (%eax),%eax
+  800686:	0f b6 d8             	movzbl %al,%ebx
+  800689:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  80068c:	83 f8 55             	cmp    $0x55,%eax
+  80068f:	0f 87 3d 03 00 00    	ja     8009d2 <vprintfmt+0x50f>
+  800695:	8b 04 85 34 14 80 00 	mov    0x801434(,%eax,4),%eax
+  80069c:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  80069e:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006a2:	eb d6                	jmp    80067a <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006a4:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006a8:	eb d0                	jmp    80067a <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006b1:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006b4:	89 d0                	mov    %edx,%eax
+  8006b6:	c1 e0 02             	shl    $0x2,%eax
+  8006b9:	01 d0                	add    %edx,%eax
+  8006bb:	01 c0                	add    %eax,%eax
+  8006bd:	01 d8                	add    %ebx,%eax
+  8006bf:	83 e8 30             	sub    $0x30,%eax
+  8006c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006c5:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006c8:	0f b6 00             	movzbl (%eax),%eax
+  8006cb:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006ce:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006d1:	7e 0b                	jle    8006de <vprintfmt+0x21b>
+  8006d3:	83 fb 39             	cmp    $0x39,%ebx
+  8006d6:	7f 06                	jg     8006de <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006d8:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006dc:	eb d3                	jmp    8006b1 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006de:	eb 33                	jmp    800713 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006e0:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006e3:	8d 50 04             	lea    0x4(%eax),%edx
+  8006e6:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006e9:	8b 00                	mov    (%eax),%eax
+  8006eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006ee:	eb 23                	jmp    800713 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  8006f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006f4:	79 0c                	jns    800702 <vprintfmt+0x23f>
+				width = 0;
+  8006f6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  8006fd:	e9 78 ff ff ff       	jmp    80067a <vprintfmt+0x1b7>
+  800702:	e9 73 ff ff ff       	jmp    80067a <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800707:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80070e:	e9 67 ff ff ff       	jmp    80067a <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800713:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800717:	79 12                	jns    80072b <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800719:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80071c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80071f:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800726:	e9 4f ff ff ff       	jmp    80067a <vprintfmt+0x1b7>
+  80072b:	e9 4a ff ff ff       	jmp    80067a <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800730:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800734:	e9 41 ff ff ff       	jmp    80067a <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800739:	8b 45 14             	mov    0x14(%ebp),%eax
+  80073c:	8d 50 04             	lea    0x4(%eax),%edx
+  80073f:	89 55 14             	mov    %edx,0x14(%ebp)
+  800742:	8b 00                	mov    (%eax),%eax
+  800744:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800747:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80074b:	89 04 24             	mov    %eax,(%esp)
+  80074e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800751:	ff d0                	call   *%eax
+			break;
+  800753:	e9 a5 02 00 00       	jmp    8009fd <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  800758:	8b 45 14             	mov    0x14(%ebp),%eax
+  80075b:	8d 50 04             	lea    0x4(%eax),%edx
+  80075e:	89 55 14             	mov    %edx,0x14(%ebp)
+  800761:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800763:	85 db                	test   %ebx,%ebx
+  800765:	79 02                	jns    800769 <vprintfmt+0x2a6>
+				err = -err;
+  800767:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  800769:	83 fb 06             	cmp    $0x6,%ebx
+  80076c:	7f 0b                	jg     800779 <vprintfmt+0x2b6>
+  80076e:	8b 34 9d f4 13 80 00 	mov    0x8013f4(,%ebx,4),%esi
+  800775:	85 f6                	test   %esi,%esi
+  800777:	75 23                	jne    80079c <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  800779:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80077d:	c7 44 24 08 21 14 80 	movl   $0x801421,0x8(%esp)
+  800784:	00 
+  800785:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800788:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80078c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80078f:	89 04 24             	mov    %eax,(%esp)
+  800792:	e8 73 02 00 00       	call   800a0a <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  800797:	e9 61 02 00 00       	jmp    8009fd <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  80079c:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007a0:	c7 44 24 08 2a 14 80 	movl   $0x80142a,0x8(%esp)
+  8007a7:	00 
+  8007a8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007ab:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007af:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007b2:	89 04 24             	mov    %eax,(%esp)
+  8007b5:	e8 50 02 00 00       	call   800a0a <printfmt>
+			break;
+  8007ba:	e9 3e 02 00 00       	jmp    8009fd <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007bf:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007c2:	8d 50 04             	lea    0x4(%eax),%edx
+  8007c5:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007c8:	8b 30                	mov    (%eax),%esi
+  8007ca:	85 f6                	test   %esi,%esi
+  8007cc:	75 05                	jne    8007d3 <vprintfmt+0x310>
+				p = "(null)";
+  8007ce:	be 2d 14 80 00       	mov    $0x80142d,%esi
+			if (width > 0 && padc != '-')
+  8007d3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007d7:	7e 37                	jle    800810 <vprintfmt+0x34d>
+  8007d9:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007dd:	74 31                	je     800810 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007df:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007e2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007e6:	89 34 24             	mov    %esi,(%esp)
+  8007e9:	e8 39 03 00 00       	call   800b27 <strnlen>
+  8007ee:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  8007f1:	eb 17                	jmp    80080a <vprintfmt+0x347>
+					putch(padc, putdat);
+  8007f3:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  8007f7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8007fa:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8007fe:	89 04 24             	mov    %eax,(%esp)
+  800801:	8b 45 08             	mov    0x8(%ebp),%eax
+  800804:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800806:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80080a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80080e:	7f e3                	jg     8007f3 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800810:	eb 38                	jmp    80084a <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800812:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800816:	74 1f                	je     800837 <vprintfmt+0x374>
+  800818:	83 fb 1f             	cmp    $0x1f,%ebx
+  80081b:	7e 05                	jle    800822 <vprintfmt+0x35f>
+  80081d:	83 fb 7e             	cmp    $0x7e,%ebx
+  800820:	7e 15                	jle    800837 <vprintfmt+0x374>
+					putch('?', putdat);
+  800822:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800825:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800829:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800830:	8b 45 08             	mov    0x8(%ebp),%eax
+  800833:	ff d0                	call   *%eax
+  800835:	eb 0f                	jmp    800846 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800837:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80083a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80083e:	89 1c 24             	mov    %ebx,(%esp)
+  800841:	8b 45 08             	mov    0x8(%ebp),%eax
+  800844:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800846:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80084a:	89 f0                	mov    %esi,%eax
+  80084c:	8d 70 01             	lea    0x1(%eax),%esi
+  80084f:	0f b6 00             	movzbl (%eax),%eax
+  800852:	0f be d8             	movsbl %al,%ebx
+  800855:	85 db                	test   %ebx,%ebx
+  800857:	74 10                	je     800869 <vprintfmt+0x3a6>
+  800859:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80085d:	78 b3                	js     800812 <vprintfmt+0x34f>
+  80085f:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800863:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800867:	79 a9                	jns    800812 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  800869:	eb 17                	jmp    800882 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  80086b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80086e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800872:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  800879:	8b 45 08             	mov    0x8(%ebp),%eax
+  80087c:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80087e:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800882:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800886:	7f e3                	jg     80086b <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  800888:	e9 70 01 00 00       	jmp    8009fd <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  80088d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800890:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800894:	8d 45 14             	lea    0x14(%ebp),%eax
+  800897:	89 04 24             	mov    %eax,(%esp)
+  80089a:	e8 dd fb ff ff       	call   80047c <getint>
+  80089f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008a2:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008ab:	85 d2                	test   %edx,%edx
+  8008ad:	79 26                	jns    8008d5 <vprintfmt+0x412>
+				putch('-', putdat);
+  8008af:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008b2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008b6:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008bd:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008c0:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008c8:	f7 d8                	neg    %eax
+  8008ca:	83 d2 00             	adc    $0x0,%edx
+  8008cd:	f7 da                	neg    %edx
+  8008cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008d2:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008d5:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008dc:	e9 a8 00 00 00       	jmp    800989 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008e8:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008eb:	89 04 24             	mov    %eax,(%esp)
+  8008ee:	e8 3a fb ff ff       	call   80042d <getuint>
+  8008f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008f6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  8008f9:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800900:	e9 84 00 00 00       	jmp    800989 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800905:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800908:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80090c:	8d 45 14             	lea    0x14(%ebp),%eax
+  80090f:	89 04 24             	mov    %eax,(%esp)
+  800912:	e8 16 fb ff ff       	call   80042d <getuint>
+  800917:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80091a:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  80091d:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800924:	eb 63                	jmp    800989 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800926:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800929:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80092d:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800934:	8b 45 08             	mov    0x8(%ebp),%eax
+  800937:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800939:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80093c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800940:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800947:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094a:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  80094c:	8b 45 14             	mov    0x14(%ebp),%eax
+  80094f:	8d 50 04             	lea    0x4(%eax),%edx
+  800952:	89 55 14             	mov    %edx,0x14(%ebp)
+  800955:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  800957:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80095a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800961:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  800968:	eb 1f                	jmp    800989 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  80096a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80096d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800971:	8d 45 14             	lea    0x14(%ebp),%eax
+  800974:	89 04 24             	mov    %eax,(%esp)
+  800977:	e8 b1 fa ff ff       	call   80042d <getuint>
+  80097c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80097f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800982:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  800989:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  80098d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800990:	89 54 24 18          	mov    %edx,0x18(%esp)
+  800994:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800997:	89 54 24 14          	mov    %edx,0x14(%esp)
+  80099b:	89 44 24 10          	mov    %eax,0x10(%esp)
+  80099f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009a5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009a9:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009ad:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009b7:	89 04 24             	mov    %eax,(%esp)
+  8009ba:	e8 90 f9 ff ff       	call   80034f <printnum>
+			break;
+  8009bf:	eb 3c                	jmp    8009fd <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009c8:	89 1c 24             	mov    %ebx,(%esp)
+  8009cb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ce:	ff d0                	call   *%eax
+			break;			
+  8009d0:	eb 2b                	jmp    8009fd <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009d2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009d9:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e3:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009e5:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009e9:	eb 04                	jmp    8009ef <vprintfmt+0x52c>
+  8009eb:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009ef:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f2:	83 e8 01             	sub    $0x1,%eax
+  8009f5:	0f b6 00             	movzbl (%eax),%eax
+  8009f8:	3c 25                	cmp    $0x25,%al
+  8009fa:	75 ef                	jne    8009eb <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  8009fc:	90                   	nop
+		}
+	}
+  8009fd:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8009fe:	e9 3f fc ff ff       	jmp    800642 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a03:	83 c4 40             	add    $0x40,%esp
+  800a06:	5b                   	pop    %ebx
+  800a07:	5e                   	pop    %esi
+  800a08:	5d                   	pop    %ebp
+  800a09:	c3                   	ret    
+
+00800a0a <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a0a:	55                   	push   %ebp
+  800a0b:	89 e5                	mov    %esp,%ebp
+  800a0d:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a10:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a13:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a16:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a19:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a1d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a20:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a24:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a27:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a2b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a2e:	89 04 24             	mov    %eax,(%esp)
+  800a31:	e8 8d fa ff ff       	call   8004c3 <vprintfmt>
+	va_end(ap);
+}
+  800a36:	c9                   	leave  
+  800a37:	c3                   	ret    
+
+00800a38 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a38:	55                   	push   %ebp
+  800a39:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a3e:	8b 40 08             	mov    0x8(%eax),%eax
+  800a41:	8d 50 01             	lea    0x1(%eax),%edx
+  800a44:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a47:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4d:	8b 10                	mov    (%eax),%edx
+  800a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a52:	8b 40 04             	mov    0x4(%eax),%eax
+  800a55:	39 c2                	cmp    %eax,%edx
+  800a57:	73 12                	jae    800a6b <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a59:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a5c:	8b 00                	mov    (%eax),%eax
+  800a5e:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a61:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a64:	89 0a                	mov    %ecx,(%edx)
+  800a66:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a69:	88 10                	mov    %dl,(%eax)
+}
+  800a6b:	5d                   	pop    %ebp
+  800a6c:	c3                   	ret    
+
+00800a6d <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a6d:	55                   	push   %ebp
+  800a6e:	89 e5                	mov    %esp,%ebp
+  800a70:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a73:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a76:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a79:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a7c:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a7f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a82:	01 d0                	add    %edx,%eax
+  800a84:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a8e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800a92:	74 06                	je     800a9a <vsnprintf+0x2d>
+  800a94:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800a98:	7f 07                	jg     800aa1 <vsnprintf+0x34>
+		return -E_INVAL;
+  800a9a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800a9f:	eb 2a                	jmp    800acb <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800aa1:	8b 45 14             	mov    0x14(%ebp),%eax
+  800aa4:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800aa8:	8b 45 10             	mov    0x10(%ebp),%eax
+  800aab:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800aaf:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ab2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ab6:	c7 04 24 38 0a 80 00 	movl   $0x800a38,(%esp)
+  800abd:	e8 01 fa ff ff       	call   8004c3 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ac2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ac5:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800ac8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800acb:	c9                   	leave  
+  800acc:	c3                   	ret    
+
+00800acd <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800acd:	55                   	push   %ebp
+  800ace:	89 e5                	mov    %esp,%ebp
+  800ad0:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ad3:	8d 45 14             	lea    0x14(%ebp),%eax
+  800ad6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800ad9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800adc:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800ae0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ae3:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ae7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800aea:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800aee:	8b 45 08             	mov    0x8(%ebp),%eax
+  800af1:	89 04 24             	mov    %eax,(%esp)
+  800af4:	e8 74 ff ff ff       	call   800a6d <vsnprintf>
+  800af9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800afc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800aff:	c9                   	leave  
+  800b00:	c3                   	ret    
+
+00800b01 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b01:	55                   	push   %ebp
+  800b02:	89 e5                	mov    %esp,%ebp
+  800b04:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b07:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b0e:	eb 08                	jmp    800b18 <strlen+0x17>
+		n++;
+  800b10:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b14:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b18:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b1b:	0f b6 00             	movzbl (%eax),%eax
+  800b1e:	84 c0                	test   %al,%al
+  800b20:	75 ee                	jne    800b10 <strlen+0xf>
+		n++;
+	return n;
+  800b22:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b25:	c9                   	leave  
+  800b26:	c3                   	ret    
+
+00800b27 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b27:	55                   	push   %ebp
+  800b28:	89 e5                	mov    %esp,%ebp
+  800b2a:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b2d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b34:	eb 0c                	jmp    800b42 <strnlen+0x1b>
+		n++;
+  800b36:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b3e:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b42:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b46:	74 0a                	je     800b52 <strnlen+0x2b>
+  800b48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b4b:	0f b6 00             	movzbl (%eax),%eax
+  800b4e:	84 c0                	test   %al,%al
+  800b50:	75 e4                	jne    800b36 <strnlen+0xf>
+		n++;
+	return n;
+  800b52:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b55:	c9                   	leave  
+  800b56:	c3                   	ret    
+
+00800b57 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b57:	55                   	push   %ebp
+  800b58:	89 e5                	mov    %esp,%ebp
+  800b5a:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b5d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b60:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b63:	90                   	nop
+  800b64:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b67:	8d 50 01             	lea    0x1(%eax),%edx
+  800b6a:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b6d:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b70:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b73:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b76:	0f b6 12             	movzbl (%edx),%edx
+  800b79:	88 10                	mov    %dl,(%eax)
+  800b7b:	0f b6 00             	movzbl (%eax),%eax
+  800b7e:	84 c0                	test   %al,%al
+  800b80:	75 e2                	jne    800b64 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b82:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b85:	c9                   	leave  
+  800b86:	c3                   	ret    
+
+00800b87 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b87:	55                   	push   %ebp
+  800b88:	89 e5                	mov    %esp,%ebp
+  800b8a:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b8d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b90:	89 04 24             	mov    %eax,(%esp)
+  800b93:	e8 69 ff ff ff       	call   800b01 <strlen>
+  800b98:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800b9b:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800b9e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba1:	01 c2                	add    %eax,%edx
+  800ba3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ba6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800baa:	89 14 24             	mov    %edx,(%esp)
+  800bad:	e8 a5 ff ff ff       	call   800b57 <strcpy>
+	return dst;
+  800bb2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bb5:	c9                   	leave  
+  800bb6:	c3                   	ret    
+
+00800bb7 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bb7:	55                   	push   %ebp
+  800bb8:	89 e5                	mov    %esp,%ebp
+  800bba:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bc3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bca:	eb 23                	jmp    800bef <strncpy+0x38>
+		*dst++ = *src;
+  800bcc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bcf:	8d 50 01             	lea    0x1(%eax),%edx
+  800bd2:	89 55 08             	mov    %edx,0x8(%ebp)
+  800bd5:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800bd8:	0f b6 12             	movzbl (%edx),%edx
+  800bdb:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800bdd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800be0:	0f b6 00             	movzbl (%eax),%eax
+  800be3:	84 c0                	test   %al,%al
+  800be5:	74 04                	je     800beb <strncpy+0x34>
+			src++;
+  800be7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800beb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800bef:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800bf2:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800bf5:	72 d5                	jb     800bcc <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800bf7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800bfa:	c9                   	leave  
+  800bfb:	c3                   	ret    
+
+00800bfc <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800bfc:	55                   	push   %ebp
+  800bfd:	89 e5                	mov    %esp,%ebp
+  800bff:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c02:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c05:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c08:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c0c:	74 33                	je     800c41 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c0e:	eb 17                	jmp    800c27 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c10:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c13:	8d 50 01             	lea    0x1(%eax),%edx
+  800c16:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c19:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c1c:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c1f:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c22:	0f b6 12             	movzbl (%edx),%edx
+  800c25:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c27:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c2b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c2f:	74 0a                	je     800c3b <strlcpy+0x3f>
+  800c31:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c34:	0f b6 00             	movzbl (%eax),%eax
+  800c37:	84 c0                	test   %al,%al
+  800c39:	75 d5                	jne    800c10 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c3e:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c41:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c44:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c47:	29 c2                	sub    %eax,%edx
+  800c49:	89 d0                	mov    %edx,%eax
+}
+  800c4b:	c9                   	leave  
+  800c4c:	c3                   	ret    
+
+00800c4d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c4d:	55                   	push   %ebp
+  800c4e:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c50:	eb 08                	jmp    800c5a <strcmp+0xd>
+		p++, q++;
+  800c52:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c56:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c5a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c5d:	0f b6 00             	movzbl (%eax),%eax
+  800c60:	84 c0                	test   %al,%al
+  800c62:	74 10                	je     800c74 <strcmp+0x27>
+  800c64:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c67:	0f b6 10             	movzbl (%eax),%edx
+  800c6a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c6d:	0f b6 00             	movzbl (%eax),%eax
+  800c70:	38 c2                	cmp    %al,%dl
+  800c72:	74 de                	je     800c52 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c74:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c77:	0f b6 00             	movzbl (%eax),%eax
+  800c7a:	0f b6 d0             	movzbl %al,%edx
+  800c7d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c80:	0f b6 00             	movzbl (%eax),%eax
+  800c83:	0f b6 c0             	movzbl %al,%eax
+  800c86:	29 c2                	sub    %eax,%edx
+  800c88:	89 d0                	mov    %edx,%eax
+}
+  800c8a:	5d                   	pop    %ebp
+  800c8b:	c3                   	ret    
+
+00800c8c <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c8c:	55                   	push   %ebp
+  800c8d:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800c8f:	eb 0c                	jmp    800c9d <strncmp+0x11>
+		n--, p++, q++;
+  800c91:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c95:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c99:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800c9d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800ca1:	74 1a                	je     800cbd <strncmp+0x31>
+  800ca3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ca6:	0f b6 00             	movzbl (%eax),%eax
+  800ca9:	84 c0                	test   %al,%al
+  800cab:	74 10                	je     800cbd <strncmp+0x31>
+  800cad:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb0:	0f b6 10             	movzbl (%eax),%edx
+  800cb3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cb6:	0f b6 00             	movzbl (%eax),%eax
+  800cb9:	38 c2                	cmp    %al,%dl
+  800cbb:	74 d4                	je     800c91 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800cbd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cc1:	75 07                	jne    800cca <strncmp+0x3e>
+		return 0;
+  800cc3:	b8 00 00 00 00       	mov    $0x0,%eax
+  800cc8:	eb 16                	jmp    800ce0 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800cca:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ccd:	0f b6 00             	movzbl (%eax),%eax
+  800cd0:	0f b6 d0             	movzbl %al,%edx
+  800cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cd6:	0f b6 00             	movzbl (%eax),%eax
+  800cd9:	0f b6 c0             	movzbl %al,%eax
+  800cdc:	29 c2                	sub    %eax,%edx
+  800cde:	89 d0                	mov    %edx,%eax
+}
+  800ce0:	5d                   	pop    %ebp
+  800ce1:	c3                   	ret    
+
+00800ce2 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800ce2:	55                   	push   %ebp
+  800ce3:	89 e5                	mov    %esp,%ebp
+  800ce5:	83 ec 04             	sub    $0x4,%esp
+  800ce8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ceb:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cee:	eb 14                	jmp    800d04 <strchr+0x22>
+		if (*s == c)
+  800cf0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cf3:	0f b6 00             	movzbl (%eax),%eax
+  800cf6:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800cf9:	75 05                	jne    800d00 <strchr+0x1e>
+			return (char *) s;
+  800cfb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cfe:	eb 13                	jmp    800d13 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d00:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d04:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d07:	0f b6 00             	movzbl (%eax),%eax
+  800d0a:	84 c0                	test   %al,%al
+  800d0c:	75 e2                	jne    800cf0 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d0e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d13:	c9                   	leave  
+  800d14:	c3                   	ret    
+
+00800d15 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d15:	55                   	push   %ebp
+  800d16:	89 e5                	mov    %esp,%ebp
+  800d18:	83 ec 04             	sub    $0x4,%esp
+  800d1b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d1e:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d21:	eb 11                	jmp    800d34 <strfind+0x1f>
+		if (*s == c)
+  800d23:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d26:	0f b6 00             	movzbl (%eax),%eax
+  800d29:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d2c:	75 02                	jne    800d30 <strfind+0x1b>
+			break;
+  800d2e:	eb 0e                	jmp    800d3e <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d30:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d37:	0f b6 00             	movzbl (%eax),%eax
+  800d3a:	84 c0                	test   %al,%al
+  800d3c:	75 e5                	jne    800d23 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d3e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d41:	c9                   	leave  
+  800d42:	c3                   	ret    
+
+00800d43 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d43:	55                   	push   %ebp
+  800d44:	89 e5                	mov    %esp,%ebp
+  800d46:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d47:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d4b:	75 05                	jne    800d52 <memset+0xf>
+		return v;
+  800d4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d50:	eb 5c                	jmp    800dae <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d52:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d55:	83 e0 03             	and    $0x3,%eax
+  800d58:	85 c0                	test   %eax,%eax
+  800d5a:	75 41                	jne    800d9d <memset+0x5a>
+  800d5c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5f:	83 e0 03             	and    $0x3,%eax
+  800d62:	85 c0                	test   %eax,%eax
+  800d64:	75 37                	jne    800d9d <memset+0x5a>
+		c &= 0xFF;
+  800d66:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d6d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d70:	c1 e0 18             	shl    $0x18,%eax
+  800d73:	89 c2                	mov    %eax,%edx
+  800d75:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d78:	c1 e0 10             	shl    $0x10,%eax
+  800d7b:	09 c2                	or     %eax,%edx
+  800d7d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d80:	c1 e0 08             	shl    $0x8,%eax
+  800d83:	09 d0                	or     %edx,%eax
+  800d85:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d88:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d8b:	c1 e8 02             	shr    $0x2,%eax
+  800d8e:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800d90:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d93:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d96:	89 d7                	mov    %edx,%edi
+  800d98:	fc                   	cld    
+  800d99:	f3 ab                	rep stos %eax,%es:(%edi)
+  800d9b:	eb 0e                	jmp    800dab <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800d9d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800da6:	89 d7                	mov    %edx,%edi
+  800da8:	fc                   	cld    
+  800da9:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800dab:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800dae:	5f                   	pop    %edi
+  800daf:	5d                   	pop    %ebp
+  800db0:	c3                   	ret    
+
+00800db1 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800db1:	55                   	push   %ebp
+  800db2:	89 e5                	mov    %esp,%ebp
+  800db4:	57                   	push   %edi
+  800db5:	56                   	push   %esi
+  800db6:	53                   	push   %ebx
+  800db7:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dba:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dc0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dc9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dcc:	73 6d                	jae    800e3b <memmove+0x8a>
+  800dce:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dd1:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800dd4:	01 d0                	add    %edx,%eax
+  800dd6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dd9:	76 60                	jbe    800e3b <memmove+0x8a>
+		s += n;
+  800ddb:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dde:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800de1:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de4:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dea:	83 e0 03             	and    $0x3,%eax
+  800ded:	85 c0                	test   %eax,%eax
+  800def:	75 2f                	jne    800e20 <memmove+0x6f>
+  800df1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800df4:	83 e0 03             	and    $0x3,%eax
+  800df7:	85 c0                	test   %eax,%eax
+  800df9:	75 25                	jne    800e20 <memmove+0x6f>
+  800dfb:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dfe:	83 e0 03             	and    $0x3,%eax
+  800e01:	85 c0                	test   %eax,%eax
+  800e03:	75 1b                	jne    800e20 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e05:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e08:	83 e8 04             	sub    $0x4,%eax
+  800e0b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e0e:	83 ea 04             	sub    $0x4,%edx
+  800e11:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e14:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e17:	89 c7                	mov    %eax,%edi
+  800e19:	89 d6                	mov    %edx,%esi
+  800e1b:	fd                   	std    
+  800e1c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e1e:	eb 18                	jmp    800e38 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e20:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e23:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e26:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e29:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e2c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e2f:	89 d7                	mov    %edx,%edi
+  800e31:	89 de                	mov    %ebx,%esi
+  800e33:	89 c1                	mov    %eax,%ecx
+  800e35:	fd                   	std    
+  800e36:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e38:	fc                   	cld    
+  800e39:	eb 45                	jmp    800e80 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e3e:	83 e0 03             	and    $0x3,%eax
+  800e41:	85 c0                	test   %eax,%eax
+  800e43:	75 2b                	jne    800e70 <memmove+0xbf>
+  800e45:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e48:	83 e0 03             	and    $0x3,%eax
+  800e4b:	85 c0                	test   %eax,%eax
+  800e4d:	75 21                	jne    800e70 <memmove+0xbf>
+  800e4f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e52:	83 e0 03             	and    $0x3,%eax
+  800e55:	85 c0                	test   %eax,%eax
+  800e57:	75 17                	jne    800e70 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e59:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e5c:	c1 e8 02             	shr    $0x2,%eax
+  800e5f:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e61:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e64:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e67:	89 c7                	mov    %eax,%edi
+  800e69:	89 d6                	mov    %edx,%esi
+  800e6b:	fc                   	cld    
+  800e6c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e6e:	eb 10                	jmp    800e80 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e70:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e73:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e76:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e79:	89 c7                	mov    %eax,%edi
+  800e7b:	89 d6                	mov    %edx,%esi
+  800e7d:	fc                   	cld    
+  800e7e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e80:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e83:	83 c4 10             	add    $0x10,%esp
+  800e86:	5b                   	pop    %ebx
+  800e87:	5e                   	pop    %esi
+  800e88:	5f                   	pop    %edi
+  800e89:	5d                   	pop    %ebp
+  800e8a:	c3                   	ret    
+
+00800e8b <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e8b:	55                   	push   %ebp
+  800e8c:	89 e5                	mov    %esp,%ebp
+  800e8e:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800e91:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e94:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800e98:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800e9b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800e9f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ea2:	89 04 24             	mov    %eax,(%esp)
+  800ea5:	e8 07 ff ff ff       	call   800db1 <memmove>
+}
+  800eaa:	c9                   	leave  
+  800eab:	c3                   	ret    
+
+00800eac <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800eac:	55                   	push   %ebp
+  800ead:	89 e5                	mov    %esp,%ebp
+  800eaf:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800eb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eb5:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800eb8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ebb:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ebe:	eb 30                	jmp    800ef0 <memcmp+0x44>
+		if (*s1 != *s2)
+  800ec0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ec3:	0f b6 10             	movzbl (%eax),%edx
+  800ec6:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ec9:	0f b6 00             	movzbl (%eax),%eax
+  800ecc:	38 c2                	cmp    %al,%dl
+  800ece:	74 18                	je     800ee8 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ed0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed3:	0f b6 00             	movzbl (%eax),%eax
+  800ed6:	0f b6 d0             	movzbl %al,%edx
+  800ed9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800edc:	0f b6 00             	movzbl (%eax),%eax
+  800edf:	0f b6 c0             	movzbl %al,%eax
+  800ee2:	29 c2                	sub    %eax,%edx
+  800ee4:	89 d0                	mov    %edx,%eax
+  800ee6:	eb 1a                	jmp    800f02 <memcmp+0x56>
+		s1++, s2++;
+  800ee8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800eec:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800ef0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ef3:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800ef6:	89 55 10             	mov    %edx,0x10(%ebp)
+  800ef9:	85 c0                	test   %eax,%eax
+  800efb:	75 c3                	jne    800ec0 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800efd:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f02:	c9                   	leave  
+  800f03:	c3                   	ret    
+
+00800f04 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f04:	55                   	push   %ebp
+  800f05:	89 e5                	mov    %esp,%ebp
+  800f07:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f0a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f0d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f10:	01 d0                	add    %edx,%eax
+  800f12:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f15:	eb 13                	jmp    800f2a <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f17:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f1a:	0f b6 10             	movzbl (%eax),%edx
+  800f1d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f20:	38 c2                	cmp    %al,%dl
+  800f22:	75 02                	jne    800f26 <memfind+0x22>
+			break;
+  800f24:	eb 0c                	jmp    800f32 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f26:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f2a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f2d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f30:	72 e5                	jb     800f17 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f32:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f35:	c9                   	leave  
+  800f36:	c3                   	ret    
+
+00800f37 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f37:	55                   	push   %ebp
+  800f38:	89 e5                	mov    %esp,%ebp
+  800f3a:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f44:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f4b:	eb 04                	jmp    800f51 <strtol+0x1a>
+		s++;
+  800f4d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f51:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f54:	0f b6 00             	movzbl (%eax),%eax
+  800f57:	3c 20                	cmp    $0x20,%al
+  800f59:	74 f2                	je     800f4d <strtol+0x16>
+  800f5b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f5e:	0f b6 00             	movzbl (%eax),%eax
+  800f61:	3c 09                	cmp    $0x9,%al
+  800f63:	74 e8                	je     800f4d <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f65:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f68:	0f b6 00             	movzbl (%eax),%eax
+  800f6b:	3c 2b                	cmp    $0x2b,%al
+  800f6d:	75 06                	jne    800f75 <strtol+0x3e>
+		s++;
+  800f6f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f73:	eb 15                	jmp    800f8a <strtol+0x53>
+	else if (*s == '-')
+  800f75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f78:	0f b6 00             	movzbl (%eax),%eax
+  800f7b:	3c 2d                	cmp    $0x2d,%al
+  800f7d:	75 0b                	jne    800f8a <strtol+0x53>
+		s++, neg = 1;
+  800f7f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f83:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f8a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f8e:	74 06                	je     800f96 <strtol+0x5f>
+  800f90:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800f94:	75 24                	jne    800fba <strtol+0x83>
+  800f96:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f99:	0f b6 00             	movzbl (%eax),%eax
+  800f9c:	3c 30                	cmp    $0x30,%al
+  800f9e:	75 1a                	jne    800fba <strtol+0x83>
+  800fa0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fa3:	83 c0 01             	add    $0x1,%eax
+  800fa6:	0f b6 00             	movzbl (%eax),%eax
+  800fa9:	3c 78                	cmp    $0x78,%al
+  800fab:	75 0d                	jne    800fba <strtol+0x83>
+		s += 2, base = 16;
+  800fad:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fb1:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fb8:	eb 2a                	jmp    800fe4 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fba:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fbe:	75 17                	jne    800fd7 <strtol+0xa0>
+  800fc0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fc3:	0f b6 00             	movzbl (%eax),%eax
+  800fc6:	3c 30                	cmp    $0x30,%al
+  800fc8:	75 0d                	jne    800fd7 <strtol+0xa0>
+		s++, base = 8;
+  800fca:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fce:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fd5:	eb 0d                	jmp    800fe4 <strtol+0xad>
+	else if (base == 0)
+  800fd7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fdb:	75 07                	jne    800fe4 <strtol+0xad>
+		base = 10;
+  800fdd:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800fe4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fe7:	0f b6 00             	movzbl (%eax),%eax
+  800fea:	3c 2f                	cmp    $0x2f,%al
+  800fec:	7e 1b                	jle    801009 <strtol+0xd2>
+  800fee:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff1:	0f b6 00             	movzbl (%eax),%eax
+  800ff4:	3c 39                	cmp    $0x39,%al
+  800ff6:	7f 11                	jg     801009 <strtol+0xd2>
+			dig = *s - '0';
+  800ff8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ffb:	0f b6 00             	movzbl (%eax),%eax
+  800ffe:	0f be c0             	movsbl %al,%eax
+  801001:	83 e8 30             	sub    $0x30,%eax
+  801004:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801007:	eb 48                	jmp    801051 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  801009:	8b 45 08             	mov    0x8(%ebp),%eax
+  80100c:	0f b6 00             	movzbl (%eax),%eax
+  80100f:	3c 60                	cmp    $0x60,%al
+  801011:	7e 1b                	jle    80102e <strtol+0xf7>
+  801013:	8b 45 08             	mov    0x8(%ebp),%eax
+  801016:	0f b6 00             	movzbl (%eax),%eax
+  801019:	3c 7a                	cmp    $0x7a,%al
+  80101b:	7f 11                	jg     80102e <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  80101d:	8b 45 08             	mov    0x8(%ebp),%eax
+  801020:	0f b6 00             	movzbl (%eax),%eax
+  801023:	0f be c0             	movsbl %al,%eax
+  801026:	83 e8 57             	sub    $0x57,%eax
+  801029:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80102c:	eb 23                	jmp    801051 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  80102e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801031:	0f b6 00             	movzbl (%eax),%eax
+  801034:	3c 40                	cmp    $0x40,%al
+  801036:	7e 3d                	jle    801075 <strtol+0x13e>
+  801038:	8b 45 08             	mov    0x8(%ebp),%eax
+  80103b:	0f b6 00             	movzbl (%eax),%eax
+  80103e:	3c 5a                	cmp    $0x5a,%al
+  801040:	7f 33                	jg     801075 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801042:	8b 45 08             	mov    0x8(%ebp),%eax
+  801045:	0f b6 00             	movzbl (%eax),%eax
+  801048:	0f be c0             	movsbl %al,%eax
+  80104b:	83 e8 37             	sub    $0x37,%eax
+  80104e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801051:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801054:	3b 45 10             	cmp    0x10(%ebp),%eax
+  801057:	7c 02                	jl     80105b <strtol+0x124>
+			break;
+  801059:	eb 1a                	jmp    801075 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  80105b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80105f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801062:	0f af 45 10          	imul   0x10(%ebp),%eax
+  801066:	89 c2                	mov    %eax,%edx
+  801068:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80106b:	01 d0                	add    %edx,%eax
+  80106d:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  801070:	e9 6f ff ff ff       	jmp    800fe4 <strtol+0xad>
+
+	if (endptr)
+  801075:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  801079:	74 08                	je     801083 <strtol+0x14c>
+		*endptr = (char *) s;
+  80107b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80107e:	8b 55 08             	mov    0x8(%ebp),%edx
+  801081:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801083:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801087:	74 07                	je     801090 <strtol+0x159>
+  801089:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80108c:	f7 d8                	neg    %eax
+  80108e:	eb 03                	jmp    801093 <strtol+0x15c>
+  801090:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  801093:	c9                   	leave  
+  801094:	c3                   	ret    
+  801095:	66 90                	xchg   %ax,%ax
+  801097:	66 90                	xchg   %ax,%ax
+  801099:	66 90                	xchg   %ax,%ax
+  80109b:	66 90                	xchg   %ax,%ax
+  80109d:	66 90                	xchg   %ax,%ax
+  80109f:	90                   	nop
+
+008010a0 <__udivdi3>:
+  8010a0:	55                   	push   %ebp
+  8010a1:	57                   	push   %edi
+  8010a2:	56                   	push   %esi
+  8010a3:	83 ec 0c             	sub    $0xc,%esp
+  8010a6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010aa:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010ae:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010b2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010b6:	85 c0                	test   %eax,%eax
+  8010b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010bc:	89 ea                	mov    %ebp,%edx
+  8010be:	89 0c 24             	mov    %ecx,(%esp)
+  8010c1:	75 2d                	jne    8010f0 <__udivdi3+0x50>
+  8010c3:	39 e9                	cmp    %ebp,%ecx
+  8010c5:	77 61                	ja     801128 <__udivdi3+0x88>
+  8010c7:	85 c9                	test   %ecx,%ecx
+  8010c9:	89 ce                	mov    %ecx,%esi
+  8010cb:	75 0b                	jne    8010d8 <__udivdi3+0x38>
+  8010cd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010d2:	31 d2                	xor    %edx,%edx
+  8010d4:	f7 f1                	div    %ecx
+  8010d6:	89 c6                	mov    %eax,%esi
+  8010d8:	31 d2                	xor    %edx,%edx
+  8010da:	89 e8                	mov    %ebp,%eax
+  8010dc:	f7 f6                	div    %esi
+  8010de:	89 c5                	mov    %eax,%ebp
+  8010e0:	89 f8                	mov    %edi,%eax
+  8010e2:	f7 f6                	div    %esi
+  8010e4:	89 ea                	mov    %ebp,%edx
+  8010e6:	83 c4 0c             	add    $0xc,%esp
+  8010e9:	5e                   	pop    %esi
+  8010ea:	5f                   	pop    %edi
+  8010eb:	5d                   	pop    %ebp
+  8010ec:	c3                   	ret    
+  8010ed:	8d 76 00             	lea    0x0(%esi),%esi
+  8010f0:	39 e8                	cmp    %ebp,%eax
+  8010f2:	77 24                	ja     801118 <__udivdi3+0x78>
+  8010f4:	0f bd e8             	bsr    %eax,%ebp
+  8010f7:	83 f5 1f             	xor    $0x1f,%ebp
+  8010fa:	75 3c                	jne    801138 <__udivdi3+0x98>
+  8010fc:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801100:	39 34 24             	cmp    %esi,(%esp)
+  801103:	0f 86 9f 00 00 00    	jbe    8011a8 <__udivdi3+0x108>
+  801109:	39 d0                	cmp    %edx,%eax
+  80110b:	0f 82 97 00 00 00    	jb     8011a8 <__udivdi3+0x108>
+  801111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801118:	31 d2                	xor    %edx,%edx
+  80111a:	31 c0                	xor    %eax,%eax
+  80111c:	83 c4 0c             	add    $0xc,%esp
+  80111f:	5e                   	pop    %esi
+  801120:	5f                   	pop    %edi
+  801121:	5d                   	pop    %ebp
+  801122:	c3                   	ret    
+  801123:	90                   	nop
+  801124:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801128:	89 f8                	mov    %edi,%eax
+  80112a:	f7 f1                	div    %ecx
+  80112c:	31 d2                	xor    %edx,%edx
+  80112e:	83 c4 0c             	add    $0xc,%esp
+  801131:	5e                   	pop    %esi
+  801132:	5f                   	pop    %edi
+  801133:	5d                   	pop    %ebp
+  801134:	c3                   	ret    
+  801135:	8d 76 00             	lea    0x0(%esi),%esi
+  801138:	89 e9                	mov    %ebp,%ecx
+  80113a:	8b 3c 24             	mov    (%esp),%edi
+  80113d:	d3 e0                	shl    %cl,%eax
+  80113f:	89 c6                	mov    %eax,%esi
+  801141:	b8 20 00 00 00       	mov    $0x20,%eax
+  801146:	29 e8                	sub    %ebp,%eax
+  801148:	89 c1                	mov    %eax,%ecx
+  80114a:	d3 ef                	shr    %cl,%edi
+  80114c:	89 e9                	mov    %ebp,%ecx
+  80114e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801152:	8b 3c 24             	mov    (%esp),%edi
+  801155:	09 74 24 08          	or     %esi,0x8(%esp)
+  801159:	89 d6                	mov    %edx,%esi
+  80115b:	d3 e7                	shl    %cl,%edi
+  80115d:	89 c1                	mov    %eax,%ecx
+  80115f:	89 3c 24             	mov    %edi,(%esp)
+  801162:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801166:	d3 ee                	shr    %cl,%esi
+  801168:	89 e9                	mov    %ebp,%ecx
+  80116a:	d3 e2                	shl    %cl,%edx
+  80116c:	89 c1                	mov    %eax,%ecx
+  80116e:	d3 ef                	shr    %cl,%edi
+  801170:	09 d7                	or     %edx,%edi
+  801172:	89 f2                	mov    %esi,%edx
+  801174:	89 f8                	mov    %edi,%eax
+  801176:	f7 74 24 08          	divl   0x8(%esp)
+  80117a:	89 d6                	mov    %edx,%esi
+  80117c:	89 c7                	mov    %eax,%edi
+  80117e:	f7 24 24             	mull   (%esp)
+  801181:	39 d6                	cmp    %edx,%esi
+  801183:	89 14 24             	mov    %edx,(%esp)
+  801186:	72 30                	jb     8011b8 <__udivdi3+0x118>
+  801188:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80118c:	89 e9                	mov    %ebp,%ecx
+  80118e:	d3 e2                	shl    %cl,%edx
+  801190:	39 c2                	cmp    %eax,%edx
+  801192:	73 05                	jae    801199 <__udivdi3+0xf9>
+  801194:	3b 34 24             	cmp    (%esp),%esi
+  801197:	74 1f                	je     8011b8 <__udivdi3+0x118>
+  801199:	89 f8                	mov    %edi,%eax
+  80119b:	31 d2                	xor    %edx,%edx
+  80119d:	e9 7a ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011a8:	31 d2                	xor    %edx,%edx
+  8011aa:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011af:	e9 68 ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011b8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011bb:	31 d2                	xor    %edx,%edx
+  8011bd:	83 c4 0c             	add    $0xc,%esp
+  8011c0:	5e                   	pop    %esi
+  8011c1:	5f                   	pop    %edi
+  8011c2:	5d                   	pop    %ebp
+  8011c3:	c3                   	ret    
+  8011c4:	66 90                	xchg   %ax,%ax
+  8011c6:	66 90                	xchg   %ax,%ax
+  8011c8:	66 90                	xchg   %ax,%ax
+  8011ca:	66 90                	xchg   %ax,%ax
+  8011cc:	66 90                	xchg   %ax,%ax
+  8011ce:	66 90                	xchg   %ax,%ax
+
+008011d0 <__umoddi3>:
+  8011d0:	55                   	push   %ebp
+  8011d1:	57                   	push   %edi
+  8011d2:	56                   	push   %esi
+  8011d3:	83 ec 14             	sub    $0x14,%esp
+  8011d6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011da:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011de:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011e2:	89 c7                	mov    %eax,%edi
+  8011e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011e8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011ec:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8011f0:	89 34 24             	mov    %esi,(%esp)
+  8011f3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8011f7:	85 c0                	test   %eax,%eax
+  8011f9:	89 c2                	mov    %eax,%edx
+  8011fb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8011ff:	75 17                	jne    801218 <__umoddi3+0x48>
+  801201:	39 fe                	cmp    %edi,%esi
+  801203:	76 4b                	jbe    801250 <__umoddi3+0x80>
+  801205:	89 c8                	mov    %ecx,%eax
+  801207:	89 fa                	mov    %edi,%edx
+  801209:	f7 f6                	div    %esi
+  80120b:	89 d0                	mov    %edx,%eax
+  80120d:	31 d2                	xor    %edx,%edx
+  80120f:	83 c4 14             	add    $0x14,%esp
+  801212:	5e                   	pop    %esi
+  801213:	5f                   	pop    %edi
+  801214:	5d                   	pop    %ebp
+  801215:	c3                   	ret    
+  801216:	66 90                	xchg   %ax,%ax
+  801218:	39 f8                	cmp    %edi,%eax
+  80121a:	77 54                	ja     801270 <__umoddi3+0xa0>
+  80121c:	0f bd e8             	bsr    %eax,%ebp
+  80121f:	83 f5 1f             	xor    $0x1f,%ebp
+  801222:	75 5c                	jne    801280 <__umoddi3+0xb0>
+  801224:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801228:	39 3c 24             	cmp    %edi,(%esp)
+  80122b:	0f 87 e7 00 00 00    	ja     801318 <__umoddi3+0x148>
+  801231:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801235:	29 f1                	sub    %esi,%ecx
+  801237:	19 c7                	sbb    %eax,%edi
+  801239:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80123d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801241:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801245:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801249:	83 c4 14             	add    $0x14,%esp
+  80124c:	5e                   	pop    %esi
+  80124d:	5f                   	pop    %edi
+  80124e:	5d                   	pop    %ebp
+  80124f:	c3                   	ret    
+  801250:	85 f6                	test   %esi,%esi
+  801252:	89 f5                	mov    %esi,%ebp
+  801254:	75 0b                	jne    801261 <__umoddi3+0x91>
+  801256:	b8 01 00 00 00       	mov    $0x1,%eax
+  80125b:	31 d2                	xor    %edx,%edx
+  80125d:	f7 f6                	div    %esi
+  80125f:	89 c5                	mov    %eax,%ebp
+  801261:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801265:	31 d2                	xor    %edx,%edx
+  801267:	f7 f5                	div    %ebp
+  801269:	89 c8                	mov    %ecx,%eax
+  80126b:	f7 f5                	div    %ebp
+  80126d:	eb 9c                	jmp    80120b <__umoddi3+0x3b>
+  80126f:	90                   	nop
+  801270:	89 c8                	mov    %ecx,%eax
+  801272:	89 fa                	mov    %edi,%edx
+  801274:	83 c4 14             	add    $0x14,%esp
+  801277:	5e                   	pop    %esi
+  801278:	5f                   	pop    %edi
+  801279:	5d                   	pop    %ebp
+  80127a:	c3                   	ret    
+  80127b:	90                   	nop
+  80127c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801280:	8b 04 24             	mov    (%esp),%eax
+  801283:	be 20 00 00 00       	mov    $0x20,%esi
+  801288:	89 e9                	mov    %ebp,%ecx
+  80128a:	29 ee                	sub    %ebp,%esi
+  80128c:	d3 e2                	shl    %cl,%edx
+  80128e:	89 f1                	mov    %esi,%ecx
+  801290:	d3 e8                	shr    %cl,%eax
+  801292:	89 e9                	mov    %ebp,%ecx
+  801294:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801298:	8b 04 24             	mov    (%esp),%eax
+  80129b:	09 54 24 04          	or     %edx,0x4(%esp)
+  80129f:	89 fa                	mov    %edi,%edx
+  8012a1:	d3 e0                	shl    %cl,%eax
+  8012a3:	89 f1                	mov    %esi,%ecx
+  8012a5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012a9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012ad:	d3 ea                	shr    %cl,%edx
+  8012af:	89 e9                	mov    %ebp,%ecx
+  8012b1:	d3 e7                	shl    %cl,%edi
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	d3 e8                	shr    %cl,%eax
+  8012b7:	89 e9                	mov    %ebp,%ecx
+  8012b9:	09 f8                	or     %edi,%eax
+  8012bb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012bf:	f7 74 24 04          	divl   0x4(%esp)
+  8012c3:	d3 e7                	shl    %cl,%edi
+  8012c5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012c9:	89 d7                	mov    %edx,%edi
+  8012cb:	f7 64 24 08          	mull   0x8(%esp)
+  8012cf:	39 d7                	cmp    %edx,%edi
+  8012d1:	89 c1                	mov    %eax,%ecx
+  8012d3:	89 14 24             	mov    %edx,(%esp)
+  8012d6:	72 2c                	jb     801304 <__umoddi3+0x134>
+  8012d8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012dc:	72 22                	jb     801300 <__umoddi3+0x130>
+  8012de:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012e2:	29 c8                	sub    %ecx,%eax
+  8012e4:	19 d7                	sbb    %edx,%edi
+  8012e6:	89 e9                	mov    %ebp,%ecx
+  8012e8:	89 fa                	mov    %edi,%edx
+  8012ea:	d3 e8                	shr    %cl,%eax
+  8012ec:	89 f1                	mov    %esi,%ecx
+  8012ee:	d3 e2                	shl    %cl,%edx
+  8012f0:	89 e9                	mov    %ebp,%ecx
+  8012f2:	d3 ef                	shr    %cl,%edi
+  8012f4:	09 d0                	or     %edx,%eax
+  8012f6:	89 fa                	mov    %edi,%edx
+  8012f8:	83 c4 14             	add    $0x14,%esp
+  8012fb:	5e                   	pop    %esi
+  8012fc:	5f                   	pop    %edi
+  8012fd:	5d                   	pop    %ebp
+  8012fe:	c3                   	ret    
+  8012ff:	90                   	nop
+  801300:	39 d7                	cmp    %edx,%edi
+  801302:	75 da                	jne    8012de <__umoddi3+0x10e>
+  801304:	8b 14 24             	mov    (%esp),%edx
+  801307:	89 c1                	mov    %eax,%ecx
+  801309:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80130d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801311:	eb cb                	jmp    8012de <__umoddi3+0x10e>
+  801313:	90                   	nop
+  801314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801318:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80131c:	0f 82 0f ff ff ff    	jb     801231 <__umoddi3+0x61>
+  801322:	e9 1a ff ff ff       	jmp    801241 <__umoddi3+0x71>
diff --git a/obj/user/badsegment.o b/obj/user/badsegment.o
new file mode 100644
index 0000000..fc33608
Binary files /dev/null and b/obj/user/badsegment.o differ
diff --git a/obj/user/badsegment.sym b/obj/user/badsegment.sym
new file mode 100644
index 0000000..32a4539
--- /dev/null
+++ b/obj/user/badsegment.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040d0 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080003e T libmain
+0080008c T exit
+008000a0 t syscall
+00800101 T sys_cputs
+00800143 T sys_cgetc
+00800187 T sys_env_destroy
+008001ca T sys_getenvid
+0080020e T _panic
+00800269 t putch
+008002c5 T vcprintf
+00800329 T cprintf
+0080034f t printnum
+0080042d t getuint
+0080047c t getint
+008004c3 T vprintfmt
+00800a0a T printfmt
+00800a38 t sprintputch
+00800a6d T vsnprintf
+00800acd T snprintf
+00800b01 T strlen
+00800b27 T strnlen
+00800b57 T strcpy
+00800b87 T strcat
+00800bb7 T strncpy
+00800bfc T strlcpy
+00800c4d T strcmp
+00800c8c T strncmp
+00800ce2 T strchr
+00800d15 T strfind
+00800d43 T memset
+00800db1 T memmove
+00800e8b T memcpy
+00800eac T memcmp
+00800f04 T memfind
+00800f37 T strtol
+008010a0 T __udivdi3
+008011d0 T __umoddi3
+008013f4 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/breakpoint b/obj/user/breakpoint
new file mode 100755
index 0000000..ede6f94
Binary files /dev/null and b/obj/user/breakpoint differ
diff --git a/obj/user/breakpoint.asm b/obj/user/breakpoint.asm
new file mode 100644
index 0000000..b95ef68
--- /dev/null
+++ b/obj/user/breakpoint.asm
@@ -0,0 +1,2638 @@
+
+obj/user/breakpoint:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 1c 00 00 00       	call   80004d <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+    void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+    asm volatile("int $3");
+  800036:	cc                   	int3   
+    asm volatile("movl $0, %eax");
+  800037:	b8 00 00 00 00       	mov    $0x0,%eax
+    asm volatile("addl $1, %eax");
+  80003c:	83 c0 01             	add    $0x1,%eax
+    asm volatile("addl $1, %eax");
+  80003f:	83 c0 01             	add    $0x1,%eax
+    asm volatile("addl $1, %eax");
+  800042:	83 c0 01             	add    $0x1,%eax
+    asm volatile("addl $1, %eax");
+  800045:	83 c0 01             	add    $0x1,%eax
+    asm volatile("addl $1, %eax");
+  800048:	83 c0 01             	add    $0x1,%eax
+
+}
+  80004b:	5d                   	pop    %ebp
+  80004c:	c3                   	ret    
+
+0080004d <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80004d:	55                   	push   %ebp
+  80004e:	89 e5                	mov    %esp,%ebp
+  800050:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800053:	e8 81 01 00 00       	call   8001d9 <sys_getenvid>
+  800058:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80005d:	89 c2                	mov    %eax,%edx
+  80005f:	89 d0                	mov    %edx,%eax
+  800061:	01 c0                	add    %eax,%eax
+  800063:	01 d0                	add    %edx,%eax
+  800065:	c1 e0 05             	shl    $0x5,%eax
+  800068:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80006d:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800072:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800076:	7e 0a                	jle    800082 <libmain+0x35>
+		binaryname = argv[0];
+  800078:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80007b:	8b 00                	mov    (%eax),%eax
+  80007d:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800082:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800085:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800089:	8b 45 08             	mov    0x8(%ebp),%eax
+  80008c:	89 04 24             	mov    %eax,(%esp)
+  80008f:	e8 9f ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800094:	e8 02 00 00 00       	call   80009b <exit>
+}
+  800099:	c9                   	leave  
+  80009a:	c3                   	ret    
+
+0080009b <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  80009b:	55                   	push   %ebp
+  80009c:	89 e5                	mov    %esp,%ebp
+  80009e:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000a1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000a8:	e8 e9 00 00 00       	call   800196 <sys_env_destroy>
+}
+  8000ad:	c9                   	leave  
+  8000ae:	c3                   	ret    
+
+008000af <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000af:	55                   	push   %ebp
+  8000b0:	89 e5                	mov    %esp,%ebp
+  8000b2:	57                   	push   %edi
+  8000b3:	56                   	push   %esi
+  8000b4:	53                   	push   %ebx
+  8000b5:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000b8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000bb:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000be:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000c1:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000c4:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000c7:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000ca:	cd 30                	int    $0x30
+  8000cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000d3:	74 30                	je     800105 <syscall+0x56>
+  8000d5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000d9:	7e 2a                	jle    800105 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000de:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000e2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000e5:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000e9:	c7 44 24 08 42 13 80 	movl   $0x801342,0x8(%esp)
+  8000f0:	00 
+  8000f1:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000f8:	00 
+  8000f9:	c7 04 24 5f 13 80 00 	movl   $0x80135f,(%esp)
+  800100:	e8 18 01 00 00       	call   80021d <_panic>
+
+	return ret;
+  800105:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  800108:	83 c4 3c             	add    $0x3c,%esp
+  80010b:	5b                   	pop    %ebx
+  80010c:	5e                   	pop    %esi
+  80010d:	5f                   	pop    %edi
+  80010e:	5d                   	pop    %ebp
+  80010f:	c3                   	ret    
+
+00800110 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800110:	55                   	push   %ebp
+  800111:	89 e5                	mov    %esp,%ebp
+  800113:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800116:	8b 45 08             	mov    0x8(%ebp),%eax
+  800119:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800120:	00 
+  800121:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800128:	00 
+  800129:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800130:	00 
+  800131:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800134:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800138:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80013c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800143:	00 
+  800144:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80014b:	e8 5f ff ff ff       	call   8000af <syscall>
+}
+  800150:	c9                   	leave  
+  800151:	c3                   	ret    
+
+00800152 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800152:	55                   	push   %ebp
+  800153:	89 e5                	mov    %esp,%ebp
+  800155:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800158:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80015f:	00 
+  800160:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800167:	00 
+  800168:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  80016f:	00 
+  800170:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800177:	00 
+  800178:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  80017f:	00 
+  800180:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800187:	00 
+  800188:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  80018f:	e8 1b ff ff ff       	call   8000af <syscall>
+}
+  800194:	c9                   	leave  
+  800195:	c3                   	ret    
+
+00800196 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800196:	55                   	push   %ebp
+  800197:	89 e5                	mov    %esp,%ebp
+  800199:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  80019c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80019f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001a6:	00 
+  8001a7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001ae:	00 
+  8001af:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001b6:	00 
+  8001b7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001be:	00 
+  8001bf:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001c3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001ca:	00 
+  8001cb:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001d2:	e8 d8 fe ff ff       	call   8000af <syscall>
+}
+  8001d7:	c9                   	leave  
+  8001d8:	c3                   	ret    
+
+008001d9 <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001d9:	55                   	push   %ebp
+  8001da:	89 e5                	mov    %esp,%ebp
+  8001dc:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001df:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001e6:	00 
+  8001e7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001ee:	00 
+  8001ef:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001f6:	00 
+  8001f7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001fe:	00 
+  8001ff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800206:	00 
+  800207:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80020e:	00 
+  80020f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  800216:	e8 94 fe ff ff       	call   8000af <syscall>
+}
+  80021b:	c9                   	leave  
+  80021c:	c3                   	ret    
+
+0080021d <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80021d:	55                   	push   %ebp
+  80021e:	89 e5                	mov    %esp,%ebp
+  800220:	53                   	push   %ebx
+  800221:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800224:	8d 45 14             	lea    0x14(%ebp),%eax
+  800227:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80022a:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  800230:	e8 a4 ff ff ff       	call   8001d9 <sys_getenvid>
+  800235:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800238:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80023c:	8b 55 08             	mov    0x8(%ebp),%edx
+  80023f:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800243:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  800247:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80024b:	c7 04 24 70 13 80 00 	movl   $0x801370,(%esp)
+  800252:	e8 e1 00 00 00       	call   800338 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  800257:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80025a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80025e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800261:	89 04 24             	mov    %eax,(%esp)
+  800264:	e8 6b 00 00 00       	call   8002d4 <vcprintf>
+	cprintf("\n");
+  800269:	c7 04 24 93 13 80 00 	movl   $0x801393,(%esp)
+  800270:	e8 c3 00 00 00       	call   800338 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  800275:	cc                   	int3   
+  800276:	eb fd                	jmp    800275 <_panic+0x58>
+
+00800278 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  800278:	55                   	push   %ebp
+  800279:	89 e5                	mov    %esp,%ebp
+  80027b:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  80027e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800281:	8b 00                	mov    (%eax),%eax
+  800283:	8d 48 01             	lea    0x1(%eax),%ecx
+  800286:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800289:	89 0a                	mov    %ecx,(%edx)
+  80028b:	8b 55 08             	mov    0x8(%ebp),%edx
+  80028e:	89 d1                	mov    %edx,%ecx
+  800290:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800293:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  800297:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80029a:	8b 00                	mov    (%eax),%eax
+  80029c:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8002a1:	75 20                	jne    8002c3 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8002a3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a6:	8b 00                	mov    (%eax),%eax
+  8002a8:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8002ab:	83 c2 08             	add    $0x8,%edx
+  8002ae:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002b2:	89 14 24             	mov    %edx,(%esp)
+  8002b5:	e8 56 fe ff ff       	call   800110 <sys_cputs>
+		b->idx = 0;
+  8002ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002c3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c6:	8b 40 04             	mov    0x4(%eax),%eax
+  8002c9:	8d 50 01             	lea    0x1(%eax),%edx
+  8002cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002cf:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002d2:	c9                   	leave  
+  8002d3:	c3                   	ret    
+
+008002d4 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002d4:	55                   	push   %ebp
+  8002d5:	89 e5                	mov    %esp,%ebp
+  8002d7:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002dd:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002e4:	00 00 00 
+	b.cnt = 0;
+  8002e7:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002ee:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002f1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002fb:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8002ff:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800305:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800309:	c7 04 24 78 02 80 00 	movl   $0x800278,(%esp)
+  800310:	e8 bd 01 00 00       	call   8004d2 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800315:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  80031b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80031f:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800325:	83 c0 08             	add    $0x8,%eax
+  800328:	89 04 24             	mov    %eax,(%esp)
+  80032b:	e8 e0 fd ff ff       	call   800110 <sys_cputs>
+
+	return b.cnt;
+  800330:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800336:	c9                   	leave  
+  800337:	c3                   	ret    
+
+00800338 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800338:	55                   	push   %ebp
+  800339:	89 e5                	mov    %esp,%ebp
+  80033b:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  80033e:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800341:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800344:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800347:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80034b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80034e:	89 04 24             	mov    %eax,(%esp)
+  800351:	e8 7e ff ff ff       	call   8002d4 <vcprintf>
+  800356:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  800359:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80035c:	c9                   	leave  
+  80035d:	c3                   	ret    
+
+0080035e <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  80035e:	55                   	push   %ebp
+  80035f:	89 e5                	mov    %esp,%ebp
+  800361:	53                   	push   %ebx
+  800362:	83 ec 34             	sub    $0x34,%esp
+  800365:	8b 45 10             	mov    0x10(%ebp),%eax
+  800368:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80036b:	8b 45 14             	mov    0x14(%ebp),%eax
+  80036e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800371:	8b 45 18             	mov    0x18(%ebp),%eax
+  800374:	ba 00 00 00 00       	mov    $0x0,%edx
+  800379:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  80037c:	77 72                	ja     8003f0 <printnum+0x92>
+  80037e:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800381:	72 05                	jb     800388 <printnum+0x2a>
+  800383:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  800386:	77 68                	ja     8003f0 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  800388:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  80038b:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  80038e:	8b 45 18             	mov    0x18(%ebp),%eax
+  800391:	ba 00 00 00 00       	mov    $0x0,%edx
+  800396:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80039a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80039e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003a4:	89 04 24             	mov    %eax,(%esp)
+  8003a7:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8003ab:	e8 00 0d 00 00       	call   8010b0 <__udivdi3>
+  8003b0:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003b3:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003b7:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003bb:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003be:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003c2:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003c6:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003ca:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003d1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003d4:	89 04 24             	mov    %eax,(%esp)
+  8003d7:	e8 82 ff ff ff       	call   80035e <printnum>
+  8003dc:	eb 1c                	jmp    8003fa <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003e1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003e5:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003e8:	89 04 24             	mov    %eax,(%esp)
+  8003eb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ee:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003f0:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003f4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003f8:	7f e4                	jg     8003de <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003fa:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003fd:	bb 00 00 00 00       	mov    $0x0,%ebx
+  800402:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800405:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800408:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80040c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800410:	89 04 24             	mov    %eax,(%esp)
+  800413:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800417:	e8 c4 0d 00 00       	call   8011e0 <__umoddi3>
+  80041c:	05 20 14 80 00       	add    $0x801420,%eax
+  800421:	0f b6 00             	movzbl (%eax),%eax
+  800424:	0f be c0             	movsbl %al,%eax
+  800427:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80042a:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80042e:	89 04 24             	mov    %eax,(%esp)
+  800431:	8b 45 08             	mov    0x8(%ebp),%eax
+  800434:	ff d0                	call   *%eax
+}
+  800436:	83 c4 34             	add    $0x34,%esp
+  800439:	5b                   	pop    %ebx
+  80043a:	5d                   	pop    %ebp
+  80043b:	c3                   	ret    
+
+0080043c <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  80043c:	55                   	push   %ebp
+  80043d:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80043f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800443:	7e 14                	jle    800459 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800445:	8b 45 08             	mov    0x8(%ebp),%eax
+  800448:	8b 00                	mov    (%eax),%eax
+  80044a:	8d 48 08             	lea    0x8(%eax),%ecx
+  80044d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800450:	89 0a                	mov    %ecx,(%edx)
+  800452:	8b 50 04             	mov    0x4(%eax),%edx
+  800455:	8b 00                	mov    (%eax),%eax
+  800457:	eb 30                	jmp    800489 <getuint+0x4d>
+	else if (lflag)
+  800459:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80045d:	74 16                	je     800475 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  80045f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800462:	8b 00                	mov    (%eax),%eax
+  800464:	8d 48 04             	lea    0x4(%eax),%ecx
+  800467:	8b 55 08             	mov    0x8(%ebp),%edx
+  80046a:	89 0a                	mov    %ecx,(%edx)
+  80046c:	8b 00                	mov    (%eax),%eax
+  80046e:	ba 00 00 00 00       	mov    $0x0,%edx
+  800473:	eb 14                	jmp    800489 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  800475:	8b 45 08             	mov    0x8(%ebp),%eax
+  800478:	8b 00                	mov    (%eax),%eax
+  80047a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80047d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800480:	89 0a                	mov    %ecx,(%edx)
+  800482:	8b 00                	mov    (%eax),%eax
+  800484:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  800489:	5d                   	pop    %ebp
+  80048a:	c3                   	ret    
+
+0080048b <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  80048b:	55                   	push   %ebp
+  80048c:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80048e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800492:	7e 14                	jle    8004a8 <getint+0x1d>
+		return va_arg(*ap, long long);
+  800494:	8b 45 08             	mov    0x8(%ebp),%eax
+  800497:	8b 00                	mov    (%eax),%eax
+  800499:	8d 48 08             	lea    0x8(%eax),%ecx
+  80049c:	8b 55 08             	mov    0x8(%ebp),%edx
+  80049f:	89 0a                	mov    %ecx,(%edx)
+  8004a1:	8b 50 04             	mov    0x4(%eax),%edx
+  8004a4:	8b 00                	mov    (%eax),%eax
+  8004a6:	eb 28                	jmp    8004d0 <getint+0x45>
+	else if (lflag)
+  8004a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8004ac:	74 12                	je     8004c0 <getint+0x35>
+		return va_arg(*ap, long);
+  8004ae:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b1:	8b 00                	mov    (%eax),%eax
+  8004b3:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004b6:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004b9:	89 0a                	mov    %ecx,(%edx)
+  8004bb:	8b 00                	mov    (%eax),%eax
+  8004bd:	99                   	cltd   
+  8004be:	eb 10                	jmp    8004d0 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004c3:	8b 00                	mov    (%eax),%eax
+  8004c5:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004c8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004cb:	89 0a                	mov    %ecx,(%edx)
+  8004cd:	8b 00                	mov    (%eax),%eax
+  8004cf:	99                   	cltd   
+}
+  8004d0:	5d                   	pop    %ebp
+  8004d1:	c3                   	ret    
+
+008004d2 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004d2:	55                   	push   %ebp
+  8004d3:	89 e5                	mov    %esp,%ebp
+  8004d5:	56                   	push   %esi
+  8004d6:	53                   	push   %ebx
+  8004d7:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004da:	e9 72 01 00 00       	jmp    800651 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004df:	85 db                	test   %ebx,%ebx
+  8004e1:	75 05                	jne    8004e8 <vprintfmt+0x16>
+				return;
+  8004e3:	e9 2a 05 00 00       	jmp    800a12 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004e8:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004eb:	0f 85 51 01 00 00    	jne    800642 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004f1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004f4:	8d 50 01             	lea    0x1(%eax),%edx
+  8004f7:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004fa:	0f b6 00             	movzbl (%eax),%eax
+  8004fd:	0f b6 d8             	movzbl %al,%ebx
+  800500:	83 fb 5b             	cmp    $0x5b,%ebx
+  800503:	74 14                	je     800519 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800505:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800508:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80050c:	89 1c 24             	mov    %ebx,(%esp)
+  80050f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800512:	ff d0                	call   *%eax
+				    continue;
+  800514:	e9 38 01 00 00       	jmp    800651 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800519:	8b 45 10             	mov    0x10(%ebp),%eax
+  80051c:	8d 50 01             	lea    0x1(%eax),%edx
+  80051f:	89 55 10             	mov    %edx,0x10(%ebp)
+  800522:	0f b6 00             	movzbl (%eax),%eax
+  800525:	0f b6 c0             	movzbl %al,%eax
+  800528:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  80052d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800530:	8d 50 01             	lea    0x1(%eax),%edx
+  800533:	89 55 10             	mov    %edx,0x10(%ebp)
+  800536:	0f b6 00             	movzbl (%eax),%eax
+  800539:	0f b6 c0             	movzbl %al,%eax
+  80053c:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800541:	a1 08 20 80 00       	mov    0x802008,%eax
+  800546:	83 f8 2f             	cmp    $0x2f,%eax
+  800549:	7e 19                	jle    800564 <vprintfmt+0x92>
+  80054b:	a1 08 20 80 00       	mov    0x802008,%eax
+  800550:	83 f8 39             	cmp    $0x39,%eax
+  800553:	7f 0f                	jg     800564 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800555:	a1 08 20 80 00       	mov    0x802008,%eax
+  80055a:	83 e8 30             	sub    $0x30,%eax
+  80055d:	a3 08 20 80 00       	mov    %eax,0x802008
+  800562:	eb 50                	jmp    8005b4 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  800564:	a1 08 20 80 00       	mov    0x802008,%eax
+  800569:	83 f8 60             	cmp    $0x60,%eax
+  80056c:	7e 19                	jle    800587 <vprintfmt+0xb5>
+  80056e:	a1 08 20 80 00       	mov    0x802008,%eax
+  800573:	83 f8 66             	cmp    $0x66,%eax
+  800576:	7f 0f                	jg     800587 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  800578:	a1 08 20 80 00       	mov    0x802008,%eax
+  80057d:	83 e8 57             	sub    $0x57,%eax
+  800580:	a3 08 20 80 00       	mov    %eax,0x802008
+  800585:	eb 2d                	jmp    8005b4 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  800587:	a1 08 20 80 00       	mov    0x802008,%eax
+  80058c:	83 f8 40             	cmp    $0x40,%eax
+  80058f:	7e 19                	jle    8005aa <vprintfmt+0xd8>
+  800591:	a1 08 20 80 00       	mov    0x802008,%eax
+  800596:	83 f8 46             	cmp    $0x46,%eax
+  800599:	7f 0f                	jg     8005aa <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  80059b:	a1 08 20 80 00       	mov    0x802008,%eax
+  8005a0:	83 e8 37             	sub    $0x37,%eax
+  8005a3:	a3 08 20 80 00       	mov    %eax,0x802008
+  8005a8:	eb 0a                	jmp    8005b4 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8005aa:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8005b1:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005b4:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005b9:	83 f8 2f             	cmp    $0x2f,%eax
+  8005bc:	7e 19                	jle    8005d7 <vprintfmt+0x105>
+  8005be:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005c3:	83 f8 39             	cmp    $0x39,%eax
+  8005c6:	7f 0f                	jg     8005d7 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005c8:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005cd:	83 e8 30             	sub    $0x30,%eax
+  8005d0:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005d5:	eb 50                	jmp    800627 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005d7:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005dc:	83 f8 60             	cmp    $0x60,%eax
+  8005df:	7e 19                	jle    8005fa <vprintfmt+0x128>
+  8005e1:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005e6:	83 f8 66             	cmp    $0x66,%eax
+  8005e9:	7f 0f                	jg     8005fa <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005eb:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f0:	83 e8 57             	sub    $0x57,%eax
+  8005f3:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005f8:	eb 2d                	jmp    800627 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005fa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005ff:	83 f8 40             	cmp    $0x40,%eax
+  800602:	7e 19                	jle    80061d <vprintfmt+0x14b>
+  800604:	a1 10 20 80 00       	mov    0x802010,%eax
+  800609:	83 f8 46             	cmp    $0x46,%eax
+  80060c:	7f 0f                	jg     80061d <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  80060e:	a1 10 20 80 00       	mov    0x802010,%eax
+  800613:	83 e8 37             	sub    $0x37,%eax
+  800616:	a3 10 20 80 00       	mov    %eax,0x802010
+  80061b:	eb 0a                	jmp    800627 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80061d:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800624:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800627:	a1 08 20 80 00       	mov    0x802008,%eax
+  80062c:	c1 e0 0c             	shl    $0xc,%eax
+  80062f:	89 c2                	mov    %eax,%edx
+  800631:	a1 10 20 80 00       	mov    0x802010,%eax
+  800636:	c1 e0 08             	shl    $0x8,%eax
+  800639:	09 d0                	or     %edx,%eax
+  80063b:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800640:	eb 0f                	jmp    800651 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800642:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800645:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800649:	89 1c 24             	mov    %ebx,(%esp)
+  80064c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80064f:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800651:	8b 45 10             	mov    0x10(%ebp),%eax
+  800654:	8d 50 01             	lea    0x1(%eax),%edx
+  800657:	89 55 10             	mov    %edx,0x10(%ebp)
+  80065a:	0f b6 00             	movzbl (%eax),%eax
+  80065d:	0f b6 d8             	movzbl %al,%ebx
+  800660:	83 fb 25             	cmp    $0x25,%ebx
+  800663:	0f 85 76 fe ff ff    	jne    8004df <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  800669:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  80066d:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  800674:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  80067b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800682:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  800689:	8b 45 10             	mov    0x10(%ebp),%eax
+  80068c:	8d 50 01             	lea    0x1(%eax),%edx
+  80068f:	89 55 10             	mov    %edx,0x10(%ebp)
+  800692:	0f b6 00             	movzbl (%eax),%eax
+  800695:	0f b6 d8             	movzbl %al,%ebx
+  800698:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  80069b:	83 f8 55             	cmp    $0x55,%eax
+  80069e:	0f 87 3d 03 00 00    	ja     8009e1 <vprintfmt+0x50f>
+  8006a4:	8b 04 85 44 14 80 00 	mov    0x801444(,%eax,4),%eax
+  8006ab:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8006ad:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006b1:	eb d6                	jmp    800689 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006b3:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006b7:	eb d0                	jmp    800689 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006b9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006c0:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006c3:	89 d0                	mov    %edx,%eax
+  8006c5:	c1 e0 02             	shl    $0x2,%eax
+  8006c8:	01 d0                	add    %edx,%eax
+  8006ca:	01 c0                	add    %eax,%eax
+  8006cc:	01 d8                	add    %ebx,%eax
+  8006ce:	83 e8 30             	sub    $0x30,%eax
+  8006d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006d4:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006d7:	0f b6 00             	movzbl (%eax),%eax
+  8006da:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006dd:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006e0:	7e 0b                	jle    8006ed <vprintfmt+0x21b>
+  8006e2:	83 fb 39             	cmp    $0x39,%ebx
+  8006e5:	7f 06                	jg     8006ed <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006e7:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006eb:	eb d3                	jmp    8006c0 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006ed:	eb 33                	jmp    800722 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006ef:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006f2:	8d 50 04             	lea    0x4(%eax),%edx
+  8006f5:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006f8:	8b 00                	mov    (%eax),%eax
+  8006fa:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006fd:	eb 23                	jmp    800722 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  8006ff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800703:	79 0c                	jns    800711 <vprintfmt+0x23f>
+				width = 0;
+  800705:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  80070c:	e9 78 ff ff ff       	jmp    800689 <vprintfmt+0x1b7>
+  800711:	e9 73 ff ff ff       	jmp    800689 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800716:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80071d:	e9 67 ff ff ff       	jmp    800689 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800722:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800726:	79 12                	jns    80073a <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800728:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80072b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80072e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800735:	e9 4f ff ff ff       	jmp    800689 <vprintfmt+0x1b7>
+  80073a:	e9 4a ff ff ff       	jmp    800689 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  80073f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800743:	e9 41 ff ff ff       	jmp    800689 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800748:	8b 45 14             	mov    0x14(%ebp),%eax
+  80074b:	8d 50 04             	lea    0x4(%eax),%edx
+  80074e:	89 55 14             	mov    %edx,0x14(%ebp)
+  800751:	8b 00                	mov    (%eax),%eax
+  800753:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800756:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80075a:	89 04 24             	mov    %eax,(%esp)
+  80075d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800760:	ff d0                	call   *%eax
+			break;
+  800762:	e9 a5 02 00 00       	jmp    800a0c <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  800767:	8b 45 14             	mov    0x14(%ebp),%eax
+  80076a:	8d 50 04             	lea    0x4(%eax),%edx
+  80076d:	89 55 14             	mov    %edx,0x14(%ebp)
+  800770:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800772:	85 db                	test   %ebx,%ebx
+  800774:	79 02                	jns    800778 <vprintfmt+0x2a6>
+				err = -err;
+  800776:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  800778:	83 fb 06             	cmp    $0x6,%ebx
+  80077b:	7f 0b                	jg     800788 <vprintfmt+0x2b6>
+  80077d:	8b 34 9d 04 14 80 00 	mov    0x801404(,%ebx,4),%esi
+  800784:	85 f6                	test   %esi,%esi
+  800786:	75 23                	jne    8007ab <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  800788:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80078c:	c7 44 24 08 31 14 80 	movl   $0x801431,0x8(%esp)
+  800793:	00 
+  800794:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800797:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80079b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80079e:	89 04 24             	mov    %eax,(%esp)
+  8007a1:	e8 73 02 00 00       	call   800a19 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8007a6:	e9 61 02 00 00       	jmp    800a0c <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8007ab:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007af:	c7 44 24 08 3a 14 80 	movl   $0x80143a,0x8(%esp)
+  8007b6:	00 
+  8007b7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007ba:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007be:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007c1:	89 04 24             	mov    %eax,(%esp)
+  8007c4:	e8 50 02 00 00       	call   800a19 <printfmt>
+			break;
+  8007c9:	e9 3e 02 00 00       	jmp    800a0c <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007ce:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007d1:	8d 50 04             	lea    0x4(%eax),%edx
+  8007d4:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007d7:	8b 30                	mov    (%eax),%esi
+  8007d9:	85 f6                	test   %esi,%esi
+  8007db:	75 05                	jne    8007e2 <vprintfmt+0x310>
+				p = "(null)";
+  8007dd:	be 3d 14 80 00       	mov    $0x80143d,%esi
+			if (width > 0 && padc != '-')
+  8007e2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007e6:	7e 37                	jle    80081f <vprintfmt+0x34d>
+  8007e8:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007ec:	74 31                	je     80081f <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007f5:	89 34 24             	mov    %esi,(%esp)
+  8007f8:	e8 39 03 00 00       	call   800b36 <strnlen>
+  8007fd:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  800800:	eb 17                	jmp    800819 <vprintfmt+0x347>
+					putch(padc, putdat);
+  800802:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800806:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800809:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80080d:	89 04 24             	mov    %eax,(%esp)
+  800810:	8b 45 08             	mov    0x8(%ebp),%eax
+  800813:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800815:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800819:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80081d:	7f e3                	jg     800802 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80081f:	eb 38                	jmp    800859 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800821:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800825:	74 1f                	je     800846 <vprintfmt+0x374>
+  800827:	83 fb 1f             	cmp    $0x1f,%ebx
+  80082a:	7e 05                	jle    800831 <vprintfmt+0x35f>
+  80082c:	83 fb 7e             	cmp    $0x7e,%ebx
+  80082f:	7e 15                	jle    800846 <vprintfmt+0x374>
+					putch('?', putdat);
+  800831:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800834:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800838:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  80083f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800842:	ff d0                	call   *%eax
+  800844:	eb 0f                	jmp    800855 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800846:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800849:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80084d:	89 1c 24             	mov    %ebx,(%esp)
+  800850:	8b 45 08             	mov    0x8(%ebp),%eax
+  800853:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800855:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800859:	89 f0                	mov    %esi,%eax
+  80085b:	8d 70 01             	lea    0x1(%eax),%esi
+  80085e:	0f b6 00             	movzbl (%eax),%eax
+  800861:	0f be d8             	movsbl %al,%ebx
+  800864:	85 db                	test   %ebx,%ebx
+  800866:	74 10                	je     800878 <vprintfmt+0x3a6>
+  800868:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80086c:	78 b3                	js     800821 <vprintfmt+0x34f>
+  80086e:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800872:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800876:	79 a9                	jns    800821 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  800878:	eb 17                	jmp    800891 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  80087a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80087d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800881:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  800888:	8b 45 08             	mov    0x8(%ebp),%eax
+  80088b:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80088d:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800891:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800895:	7f e3                	jg     80087a <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  800897:	e9 70 01 00 00       	jmp    800a0c <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  80089c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80089f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008a3:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008a6:	89 04 24             	mov    %eax,(%esp)
+  8008a9:	e8 dd fb ff ff       	call   80048b <getint>
+  8008ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008b1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008ba:	85 d2                	test   %edx,%edx
+  8008bc:	79 26                	jns    8008e4 <vprintfmt+0x412>
+				putch('-', putdat);
+  8008be:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008c1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008c5:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008cc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008cf:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008d7:	f7 d8                	neg    %eax
+  8008d9:	83 d2 00             	adc    $0x0,%edx
+  8008dc:	f7 da                	neg    %edx
+  8008de:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008e1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008e4:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008eb:	e9 a8 00 00 00       	jmp    800998 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008f7:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008fa:	89 04 24             	mov    %eax,(%esp)
+  8008fd:	e8 3a fb ff ff       	call   80043c <getuint>
+  800902:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800905:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  800908:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  80090f:	e9 84 00 00 00       	jmp    800998 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800914:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800917:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80091b:	8d 45 14             	lea    0x14(%ebp),%eax
+  80091e:	89 04 24             	mov    %eax,(%esp)
+  800921:	e8 16 fb ff ff       	call   80043c <getuint>
+  800926:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800929:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  80092c:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800933:	eb 63                	jmp    800998 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800935:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800938:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80093c:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800943:	8b 45 08             	mov    0x8(%ebp),%eax
+  800946:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800948:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80094b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80094f:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800956:	8b 45 08             	mov    0x8(%ebp),%eax
+  800959:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  80095b:	8b 45 14             	mov    0x14(%ebp),%eax
+  80095e:	8d 50 04             	lea    0x4(%eax),%edx
+  800961:	89 55 14             	mov    %edx,0x14(%ebp)
+  800964:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  800966:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800969:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800970:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  800977:	eb 1f                	jmp    800998 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  800979:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80097c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800980:	8d 45 14             	lea    0x14(%ebp),%eax
+  800983:	89 04 24             	mov    %eax,(%esp)
+  800986:	e8 b1 fa ff ff       	call   80043c <getuint>
+  80098b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80098e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800991:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  800998:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  80099c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  80099f:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8009a3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8009a6:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8009aa:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8009ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009b4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009b8:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009bf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009c6:	89 04 24             	mov    %eax,(%esp)
+  8009c9:	e8 90 f9 ff ff       	call   80035e <printnum>
+			break;
+  8009ce:	eb 3c                	jmp    800a0c <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009d0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009d7:	89 1c 24             	mov    %ebx,(%esp)
+  8009da:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009dd:	ff d0                	call   *%eax
+			break;			
+  8009df:	eb 2b                	jmp    800a0c <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009e8:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009ef:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009f2:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009f4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009f8:	eb 04                	jmp    8009fe <vprintfmt+0x52c>
+  8009fa:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009fe:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a01:	83 e8 01             	sub    $0x1,%eax
+  800a04:	0f b6 00             	movzbl (%eax),%eax
+  800a07:	3c 25                	cmp    $0x25,%al
+  800a09:	75 ef                	jne    8009fa <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800a0b:	90                   	nop
+		}
+	}
+  800a0c:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800a0d:	e9 3f fc ff ff       	jmp    800651 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a12:	83 c4 40             	add    $0x40,%esp
+  800a15:	5b                   	pop    %ebx
+  800a16:	5e                   	pop    %esi
+  800a17:	5d                   	pop    %ebp
+  800a18:	c3                   	ret    
+
+00800a19 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a19:	55                   	push   %ebp
+  800a1a:	89 e5                	mov    %esp,%ebp
+  800a1c:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a1f:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a22:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a28:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a2c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a2f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a33:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a36:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a3a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a3d:	89 04 24             	mov    %eax,(%esp)
+  800a40:	e8 8d fa ff ff       	call   8004d2 <vprintfmt>
+	va_end(ap);
+}
+  800a45:	c9                   	leave  
+  800a46:	c3                   	ret    
+
+00800a47 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a47:	55                   	push   %ebp
+  800a48:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4d:	8b 40 08             	mov    0x8(%eax),%eax
+  800a50:	8d 50 01             	lea    0x1(%eax),%edx
+  800a53:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a56:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a59:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a5c:	8b 10                	mov    (%eax),%edx
+  800a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a61:	8b 40 04             	mov    0x4(%eax),%eax
+  800a64:	39 c2                	cmp    %eax,%edx
+  800a66:	73 12                	jae    800a7a <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a68:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a6b:	8b 00                	mov    (%eax),%eax
+  800a6d:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a70:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a73:	89 0a                	mov    %ecx,(%edx)
+  800a75:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a78:	88 10                	mov    %dl,(%eax)
+}
+  800a7a:	5d                   	pop    %ebp
+  800a7b:	c3                   	ret    
+
+00800a7c <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a7c:	55                   	push   %ebp
+  800a7d:	89 e5                	mov    %esp,%ebp
+  800a7f:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a82:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a85:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a88:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a8b:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a8e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a91:	01 d0                	add    %edx,%eax
+  800a93:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a9d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800aa1:	74 06                	je     800aa9 <vsnprintf+0x2d>
+  800aa3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800aa7:	7f 07                	jg     800ab0 <vsnprintf+0x34>
+		return -E_INVAL;
+  800aa9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800aae:	eb 2a                	jmp    800ada <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800ab0:	8b 45 14             	mov    0x14(%ebp),%eax
+  800ab3:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800ab7:	8b 45 10             	mov    0x10(%ebp),%eax
+  800aba:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800abe:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ac1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ac5:	c7 04 24 47 0a 80 00 	movl   $0x800a47,(%esp)
+  800acc:	e8 01 fa ff ff       	call   8004d2 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ad1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ad4:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800ad7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800ada:	c9                   	leave  
+  800adb:	c3                   	ret    
+
+00800adc <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800adc:	55                   	push   %ebp
+  800add:	89 e5                	mov    %esp,%ebp
+  800adf:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ae2:	8d 45 14             	lea    0x14(%ebp),%eax
+  800ae5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800ae8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800aeb:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800aef:	8b 45 10             	mov    0x10(%ebp),%eax
+  800af2:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800af6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800af9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800afd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b00:	89 04 24             	mov    %eax,(%esp)
+  800b03:	e8 74 ff ff ff       	call   800a7c <vsnprintf>
+  800b08:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800b0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800b0e:	c9                   	leave  
+  800b0f:	c3                   	ret    
+
+00800b10 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b10:	55                   	push   %ebp
+  800b11:	89 e5                	mov    %esp,%ebp
+  800b13:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b16:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b1d:	eb 08                	jmp    800b27 <strlen+0x17>
+		n++;
+  800b1f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b23:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b27:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b2a:	0f b6 00             	movzbl (%eax),%eax
+  800b2d:	84 c0                	test   %al,%al
+  800b2f:	75 ee                	jne    800b1f <strlen+0xf>
+		n++;
+	return n;
+  800b31:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b34:	c9                   	leave  
+  800b35:	c3                   	ret    
+
+00800b36 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b36:	55                   	push   %ebp
+  800b37:	89 e5                	mov    %esp,%ebp
+  800b39:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b43:	eb 0c                	jmp    800b51 <strnlen+0x1b>
+		n++;
+  800b45:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b49:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b4d:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b51:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b55:	74 0a                	je     800b61 <strnlen+0x2b>
+  800b57:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5a:	0f b6 00             	movzbl (%eax),%eax
+  800b5d:	84 c0                	test   %al,%al
+  800b5f:	75 e4                	jne    800b45 <strnlen+0xf>
+		n++;
+	return n;
+  800b61:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b64:	c9                   	leave  
+  800b65:	c3                   	ret    
+
+00800b66 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b66:	55                   	push   %ebp
+  800b67:	89 e5                	mov    %esp,%ebp
+  800b69:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b6c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b6f:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b72:	90                   	nop
+  800b73:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b76:	8d 50 01             	lea    0x1(%eax),%edx
+  800b79:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b7c:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b7f:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b82:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b85:	0f b6 12             	movzbl (%edx),%edx
+  800b88:	88 10                	mov    %dl,(%eax)
+  800b8a:	0f b6 00             	movzbl (%eax),%eax
+  800b8d:	84 c0                	test   %al,%al
+  800b8f:	75 e2                	jne    800b73 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b91:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b94:	c9                   	leave  
+  800b95:	c3                   	ret    
+
+00800b96 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b96:	55                   	push   %ebp
+  800b97:	89 e5                	mov    %esp,%ebp
+  800b99:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b9f:	89 04 24             	mov    %eax,(%esp)
+  800ba2:	e8 69 ff ff ff       	call   800b10 <strlen>
+  800ba7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800baa:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800bad:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bb0:	01 c2                	add    %eax,%edx
+  800bb2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bb5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800bb9:	89 14 24             	mov    %edx,(%esp)
+  800bbc:	e8 a5 ff ff ff       	call   800b66 <strcpy>
+	return dst;
+  800bc1:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bc4:	c9                   	leave  
+  800bc5:	c3                   	ret    
+
+00800bc6 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bc6:	55                   	push   %ebp
+  800bc7:	89 e5                	mov    %esp,%ebp
+  800bc9:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bcc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bcf:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bd2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bd9:	eb 23                	jmp    800bfe <strncpy+0x38>
+		*dst++ = *src;
+  800bdb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bde:	8d 50 01             	lea    0x1(%eax),%edx
+  800be1:	89 55 08             	mov    %edx,0x8(%ebp)
+  800be4:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800be7:	0f b6 12             	movzbl (%edx),%edx
+  800bea:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800bec:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bef:	0f b6 00             	movzbl (%eax),%eax
+  800bf2:	84 c0                	test   %al,%al
+  800bf4:	74 04                	je     800bfa <strncpy+0x34>
+			src++;
+  800bf6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800bfa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800bfe:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c01:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800c04:	72 d5                	jb     800bdb <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800c06:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800c09:	c9                   	leave  
+  800c0a:	c3                   	ret    
+
+00800c0b <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800c0b:	55                   	push   %ebp
+  800c0c:	89 e5                	mov    %esp,%ebp
+  800c0e:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c11:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c14:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c17:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c1b:	74 33                	je     800c50 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c1d:	eb 17                	jmp    800c36 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c1f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c22:	8d 50 01             	lea    0x1(%eax),%edx
+  800c25:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c28:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c2b:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c2e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c31:	0f b6 12             	movzbl (%edx),%edx
+  800c34:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c36:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c3a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c3e:	74 0a                	je     800c4a <strlcpy+0x3f>
+  800c40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c43:	0f b6 00             	movzbl (%eax),%eax
+  800c46:	84 c0                	test   %al,%al
+  800c48:	75 d5                	jne    800c1f <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c4a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c4d:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c50:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c53:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c56:	29 c2                	sub    %eax,%edx
+  800c58:	89 d0                	mov    %edx,%eax
+}
+  800c5a:	c9                   	leave  
+  800c5b:	c3                   	ret    
+
+00800c5c <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c5c:	55                   	push   %ebp
+  800c5d:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c5f:	eb 08                	jmp    800c69 <strcmp+0xd>
+		p++, q++;
+  800c61:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c65:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c69:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c6c:	0f b6 00             	movzbl (%eax),%eax
+  800c6f:	84 c0                	test   %al,%al
+  800c71:	74 10                	je     800c83 <strcmp+0x27>
+  800c73:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c76:	0f b6 10             	movzbl (%eax),%edx
+  800c79:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c7c:	0f b6 00             	movzbl (%eax),%eax
+  800c7f:	38 c2                	cmp    %al,%dl
+  800c81:	74 de                	je     800c61 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c83:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c86:	0f b6 00             	movzbl (%eax),%eax
+  800c89:	0f b6 d0             	movzbl %al,%edx
+  800c8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c8f:	0f b6 00             	movzbl (%eax),%eax
+  800c92:	0f b6 c0             	movzbl %al,%eax
+  800c95:	29 c2                	sub    %eax,%edx
+  800c97:	89 d0                	mov    %edx,%eax
+}
+  800c99:	5d                   	pop    %ebp
+  800c9a:	c3                   	ret    
+
+00800c9b <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c9b:	55                   	push   %ebp
+  800c9c:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800c9e:	eb 0c                	jmp    800cac <strncmp+0x11>
+		n--, p++, q++;
+  800ca0:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800ca4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ca8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800cac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cb0:	74 1a                	je     800ccc <strncmp+0x31>
+  800cb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb5:	0f b6 00             	movzbl (%eax),%eax
+  800cb8:	84 c0                	test   %al,%al
+  800cba:	74 10                	je     800ccc <strncmp+0x31>
+  800cbc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cbf:	0f b6 10             	movzbl (%eax),%edx
+  800cc2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cc5:	0f b6 00             	movzbl (%eax),%eax
+  800cc8:	38 c2                	cmp    %al,%dl
+  800cca:	74 d4                	je     800ca0 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800ccc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cd0:	75 07                	jne    800cd9 <strncmp+0x3e>
+		return 0;
+  800cd2:	b8 00 00 00 00       	mov    $0x0,%eax
+  800cd7:	eb 16                	jmp    800cef <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800cd9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cdc:	0f b6 00             	movzbl (%eax),%eax
+  800cdf:	0f b6 d0             	movzbl %al,%edx
+  800ce2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce5:	0f b6 00             	movzbl (%eax),%eax
+  800ce8:	0f b6 c0             	movzbl %al,%eax
+  800ceb:	29 c2                	sub    %eax,%edx
+  800ced:	89 d0                	mov    %edx,%eax
+}
+  800cef:	5d                   	pop    %ebp
+  800cf0:	c3                   	ret    
+
+00800cf1 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800cf1:	55                   	push   %ebp
+  800cf2:	89 e5                	mov    %esp,%ebp
+  800cf4:	83 ec 04             	sub    $0x4,%esp
+  800cf7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cfa:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cfd:	eb 14                	jmp    800d13 <strchr+0x22>
+		if (*s == c)
+  800cff:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d02:	0f b6 00             	movzbl (%eax),%eax
+  800d05:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d08:	75 05                	jne    800d0f <strchr+0x1e>
+			return (char *) s;
+  800d0a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d0d:	eb 13                	jmp    800d22 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d0f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d13:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d16:	0f b6 00             	movzbl (%eax),%eax
+  800d19:	84 c0                	test   %al,%al
+  800d1b:	75 e2                	jne    800cff <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d1d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d22:	c9                   	leave  
+  800d23:	c3                   	ret    
+
+00800d24 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d24:	55                   	push   %ebp
+  800d25:	89 e5                	mov    %esp,%ebp
+  800d27:	83 ec 04             	sub    $0x4,%esp
+  800d2a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d2d:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d30:	eb 11                	jmp    800d43 <strfind+0x1f>
+		if (*s == c)
+  800d32:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d35:	0f b6 00             	movzbl (%eax),%eax
+  800d38:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d3b:	75 02                	jne    800d3f <strfind+0x1b>
+			break;
+  800d3d:	eb 0e                	jmp    800d4d <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d3f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d43:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d46:	0f b6 00             	movzbl (%eax),%eax
+  800d49:	84 c0                	test   %al,%al
+  800d4b:	75 e5                	jne    800d32 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d4d:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d50:	c9                   	leave  
+  800d51:	c3                   	ret    
+
+00800d52 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d52:	55                   	push   %ebp
+  800d53:	89 e5                	mov    %esp,%ebp
+  800d55:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d56:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d5a:	75 05                	jne    800d61 <memset+0xf>
+		return v;
+  800d5c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d5f:	eb 5c                	jmp    800dbd <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d61:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d64:	83 e0 03             	and    $0x3,%eax
+  800d67:	85 c0                	test   %eax,%eax
+  800d69:	75 41                	jne    800dac <memset+0x5a>
+  800d6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d6e:	83 e0 03             	and    $0x3,%eax
+  800d71:	85 c0                	test   %eax,%eax
+  800d73:	75 37                	jne    800dac <memset+0x5a>
+		c &= 0xFF;
+  800d75:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7f:	c1 e0 18             	shl    $0x18,%eax
+  800d82:	89 c2                	mov    %eax,%edx
+  800d84:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d87:	c1 e0 10             	shl    $0x10,%eax
+  800d8a:	09 c2                	or     %eax,%edx
+  800d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8f:	c1 e0 08             	shl    $0x8,%eax
+  800d92:	09 d0                	or     %edx,%eax
+  800d94:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d97:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d9a:	c1 e8 02             	shr    $0x2,%eax
+  800d9d:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800d9f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da5:	89 d7                	mov    %edx,%edi
+  800da7:	fc                   	cld    
+  800da8:	f3 ab                	rep stos %eax,%es:(%edi)
+  800daa:	eb 0e                	jmp    800dba <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800dac:	8b 55 08             	mov    0x8(%ebp),%edx
+  800daf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800db2:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800db5:	89 d7                	mov    %edx,%edi
+  800db7:	fc                   	cld    
+  800db8:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800dba:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800dbd:	5f                   	pop    %edi
+  800dbe:	5d                   	pop    %ebp
+  800dbf:	c3                   	ret    
+
+00800dc0 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800dc0:	55                   	push   %ebp
+  800dc1:	89 e5                	mov    %esp,%ebp
+  800dc3:	57                   	push   %edi
+  800dc4:	56                   	push   %esi
+  800dc5:	53                   	push   %ebx
+  800dc6:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dc9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dcc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dcf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dd8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800ddb:	73 6d                	jae    800e4a <memmove+0x8a>
+  800ddd:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de0:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800de3:	01 d0                	add    %edx,%eax
+  800de5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800de8:	76 60                	jbe    800e4a <memmove+0x8a>
+		s += n;
+  800dea:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ded:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800df0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800df3:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800df6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800df9:	83 e0 03             	and    $0x3,%eax
+  800dfc:	85 c0                	test   %eax,%eax
+  800dfe:	75 2f                	jne    800e2f <memmove+0x6f>
+  800e00:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e03:	83 e0 03             	and    $0x3,%eax
+  800e06:	85 c0                	test   %eax,%eax
+  800e08:	75 25                	jne    800e2f <memmove+0x6f>
+  800e0a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e0d:	83 e0 03             	and    $0x3,%eax
+  800e10:	85 c0                	test   %eax,%eax
+  800e12:	75 1b                	jne    800e2f <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e14:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e17:	83 e8 04             	sub    $0x4,%eax
+  800e1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e1d:	83 ea 04             	sub    $0x4,%edx
+  800e20:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e23:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e26:	89 c7                	mov    %eax,%edi
+  800e28:	89 d6                	mov    %edx,%esi
+  800e2a:	fd                   	std    
+  800e2b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e2d:	eb 18                	jmp    800e47 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e32:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e35:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e38:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e3b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e3e:	89 d7                	mov    %edx,%edi
+  800e40:	89 de                	mov    %ebx,%esi
+  800e42:	89 c1                	mov    %eax,%ecx
+  800e44:	fd                   	std    
+  800e45:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e47:	fc                   	cld    
+  800e48:	eb 45                	jmp    800e8f <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e4d:	83 e0 03             	and    $0x3,%eax
+  800e50:	85 c0                	test   %eax,%eax
+  800e52:	75 2b                	jne    800e7f <memmove+0xbf>
+  800e54:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e57:	83 e0 03             	and    $0x3,%eax
+  800e5a:	85 c0                	test   %eax,%eax
+  800e5c:	75 21                	jne    800e7f <memmove+0xbf>
+  800e5e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e61:	83 e0 03             	and    $0x3,%eax
+  800e64:	85 c0                	test   %eax,%eax
+  800e66:	75 17                	jne    800e7f <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e68:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e6b:	c1 e8 02             	shr    $0x2,%eax
+  800e6e:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e70:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e73:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e76:	89 c7                	mov    %eax,%edi
+  800e78:	89 d6                	mov    %edx,%esi
+  800e7a:	fc                   	cld    
+  800e7b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e7d:	eb 10                	jmp    800e8f <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e85:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e88:	89 c7                	mov    %eax,%edi
+  800e8a:	89 d6                	mov    %edx,%esi
+  800e8c:	fc                   	cld    
+  800e8d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e8f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e92:	83 c4 10             	add    $0x10,%esp
+  800e95:	5b                   	pop    %ebx
+  800e96:	5e                   	pop    %esi
+  800e97:	5f                   	pop    %edi
+  800e98:	5d                   	pop    %ebp
+  800e99:	c3                   	ret    
+
+00800e9a <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e9a:	55                   	push   %ebp
+  800e9b:	89 e5                	mov    %esp,%ebp
+  800e9d:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800ea0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ea3:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ea7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800eaa:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800eae:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eb1:	89 04 24             	mov    %eax,(%esp)
+  800eb4:	e8 07 ff ff ff       	call   800dc0 <memmove>
+}
+  800eb9:	c9                   	leave  
+  800eba:	c3                   	ret    
+
+00800ebb <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800ebb:	55                   	push   %ebp
+  800ebc:	89 e5                	mov    %esp,%ebp
+  800ebe:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800ec1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ec4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800eca:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ecd:	eb 30                	jmp    800eff <memcmp+0x44>
+		if (*s1 != *s2)
+  800ecf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed2:	0f b6 10             	movzbl (%eax),%edx
+  800ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ed8:	0f b6 00             	movzbl (%eax),%eax
+  800edb:	38 c2                	cmp    %al,%dl
+  800edd:	74 18                	je     800ef7 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800edf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ee2:	0f b6 00             	movzbl (%eax),%eax
+  800ee5:	0f b6 d0             	movzbl %al,%edx
+  800ee8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eeb:	0f b6 00             	movzbl (%eax),%eax
+  800eee:	0f b6 c0             	movzbl %al,%eax
+  800ef1:	29 c2                	sub    %eax,%edx
+  800ef3:	89 d0                	mov    %edx,%eax
+  800ef5:	eb 1a                	jmp    800f11 <memcmp+0x56>
+		s1++, s2++;
+  800ef7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800efb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800eff:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f02:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800f05:	89 55 10             	mov    %edx,0x10(%ebp)
+  800f08:	85 c0                	test   %eax,%eax
+  800f0a:	75 c3                	jne    800ecf <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800f0c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f11:	c9                   	leave  
+  800f12:	c3                   	ret    
+
+00800f13 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f13:	55                   	push   %ebp
+  800f14:	89 e5                	mov    %esp,%ebp
+  800f16:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f19:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f1c:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f1f:	01 d0                	add    %edx,%eax
+  800f21:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f24:	eb 13                	jmp    800f39 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f26:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f29:	0f b6 10             	movzbl (%eax),%edx
+  800f2c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f2f:	38 c2                	cmp    %al,%dl
+  800f31:	75 02                	jne    800f35 <memfind+0x22>
+			break;
+  800f33:	eb 0c                	jmp    800f41 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f35:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f39:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f3c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f3f:	72 e5                	jb     800f26 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f41:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f44:	c9                   	leave  
+  800f45:	c3                   	ret    
+
+00800f46 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f46:	55                   	push   %ebp
+  800f47:	89 e5                	mov    %esp,%ebp
+  800f49:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f4c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f53:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f5a:	eb 04                	jmp    800f60 <strtol+0x1a>
+		s++;
+  800f5c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f60:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f63:	0f b6 00             	movzbl (%eax),%eax
+  800f66:	3c 20                	cmp    $0x20,%al
+  800f68:	74 f2                	je     800f5c <strtol+0x16>
+  800f6a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f6d:	0f b6 00             	movzbl (%eax),%eax
+  800f70:	3c 09                	cmp    $0x9,%al
+  800f72:	74 e8                	je     800f5c <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f74:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f77:	0f b6 00             	movzbl (%eax),%eax
+  800f7a:	3c 2b                	cmp    $0x2b,%al
+  800f7c:	75 06                	jne    800f84 <strtol+0x3e>
+		s++;
+  800f7e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f82:	eb 15                	jmp    800f99 <strtol+0x53>
+	else if (*s == '-')
+  800f84:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f87:	0f b6 00             	movzbl (%eax),%eax
+  800f8a:	3c 2d                	cmp    $0x2d,%al
+  800f8c:	75 0b                	jne    800f99 <strtol+0x53>
+		s++, neg = 1;
+  800f8e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f92:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f99:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f9d:	74 06                	je     800fa5 <strtol+0x5f>
+  800f9f:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800fa3:	75 24                	jne    800fc9 <strtol+0x83>
+  800fa5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fa8:	0f b6 00             	movzbl (%eax),%eax
+  800fab:	3c 30                	cmp    $0x30,%al
+  800fad:	75 1a                	jne    800fc9 <strtol+0x83>
+  800faf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fb2:	83 c0 01             	add    $0x1,%eax
+  800fb5:	0f b6 00             	movzbl (%eax),%eax
+  800fb8:	3c 78                	cmp    $0x78,%al
+  800fba:	75 0d                	jne    800fc9 <strtol+0x83>
+		s += 2, base = 16;
+  800fbc:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fc0:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fc7:	eb 2a                	jmp    800ff3 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fc9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fcd:	75 17                	jne    800fe6 <strtol+0xa0>
+  800fcf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fd2:	0f b6 00             	movzbl (%eax),%eax
+  800fd5:	3c 30                	cmp    $0x30,%al
+  800fd7:	75 0d                	jne    800fe6 <strtol+0xa0>
+		s++, base = 8;
+  800fd9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fdd:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fe4:	eb 0d                	jmp    800ff3 <strtol+0xad>
+	else if (base == 0)
+  800fe6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fea:	75 07                	jne    800ff3 <strtol+0xad>
+		base = 10;
+  800fec:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800ff3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff6:	0f b6 00             	movzbl (%eax),%eax
+  800ff9:	3c 2f                	cmp    $0x2f,%al
+  800ffb:	7e 1b                	jle    801018 <strtol+0xd2>
+  800ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+  801000:	0f b6 00             	movzbl (%eax),%eax
+  801003:	3c 39                	cmp    $0x39,%al
+  801005:	7f 11                	jg     801018 <strtol+0xd2>
+			dig = *s - '0';
+  801007:	8b 45 08             	mov    0x8(%ebp),%eax
+  80100a:	0f b6 00             	movzbl (%eax),%eax
+  80100d:	0f be c0             	movsbl %al,%eax
+  801010:	83 e8 30             	sub    $0x30,%eax
+  801013:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801016:	eb 48                	jmp    801060 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  801018:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101b:	0f b6 00             	movzbl (%eax),%eax
+  80101e:	3c 60                	cmp    $0x60,%al
+  801020:	7e 1b                	jle    80103d <strtol+0xf7>
+  801022:	8b 45 08             	mov    0x8(%ebp),%eax
+  801025:	0f b6 00             	movzbl (%eax),%eax
+  801028:	3c 7a                	cmp    $0x7a,%al
+  80102a:	7f 11                	jg     80103d <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  80102c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80102f:	0f b6 00             	movzbl (%eax),%eax
+  801032:	0f be c0             	movsbl %al,%eax
+  801035:	83 e8 57             	sub    $0x57,%eax
+  801038:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80103b:	eb 23                	jmp    801060 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  80103d:	8b 45 08             	mov    0x8(%ebp),%eax
+  801040:	0f b6 00             	movzbl (%eax),%eax
+  801043:	3c 40                	cmp    $0x40,%al
+  801045:	7e 3d                	jle    801084 <strtol+0x13e>
+  801047:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104a:	0f b6 00             	movzbl (%eax),%eax
+  80104d:	3c 5a                	cmp    $0x5a,%al
+  80104f:	7f 33                	jg     801084 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801051:	8b 45 08             	mov    0x8(%ebp),%eax
+  801054:	0f b6 00             	movzbl (%eax),%eax
+  801057:	0f be c0             	movsbl %al,%eax
+  80105a:	83 e8 37             	sub    $0x37,%eax
+  80105d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801060:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801063:	3b 45 10             	cmp    0x10(%ebp),%eax
+  801066:	7c 02                	jl     80106a <strtol+0x124>
+			break;
+  801068:	eb 1a                	jmp    801084 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  80106a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80106e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801071:	0f af 45 10          	imul   0x10(%ebp),%eax
+  801075:	89 c2                	mov    %eax,%edx
+  801077:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80107a:	01 d0                	add    %edx,%eax
+  80107c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  80107f:	e9 6f ff ff ff       	jmp    800ff3 <strtol+0xad>
+
+	if (endptr)
+  801084:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  801088:	74 08                	je     801092 <strtol+0x14c>
+		*endptr = (char *) s;
+  80108a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80108d:	8b 55 08             	mov    0x8(%ebp),%edx
+  801090:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801092:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801096:	74 07                	je     80109f <strtol+0x159>
+  801098:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80109b:	f7 d8                	neg    %eax
+  80109d:	eb 03                	jmp    8010a2 <strtol+0x15c>
+  80109f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  8010a2:	c9                   	leave  
+  8010a3:	c3                   	ret    
+  8010a4:	66 90                	xchg   %ax,%ax
+  8010a6:	66 90                	xchg   %ax,%ax
+  8010a8:	66 90                	xchg   %ax,%ax
+  8010aa:	66 90                	xchg   %ax,%ax
+  8010ac:	66 90                	xchg   %ax,%ax
+  8010ae:	66 90                	xchg   %ax,%ax
+
+008010b0 <__udivdi3>:
+  8010b0:	55                   	push   %ebp
+  8010b1:	57                   	push   %edi
+  8010b2:	56                   	push   %esi
+  8010b3:	83 ec 0c             	sub    $0xc,%esp
+  8010b6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ba:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010be:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010c2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010c6:	85 c0                	test   %eax,%eax
+  8010c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010cc:	89 ea                	mov    %ebp,%edx
+  8010ce:	89 0c 24             	mov    %ecx,(%esp)
+  8010d1:	75 2d                	jne    801100 <__udivdi3+0x50>
+  8010d3:	39 e9                	cmp    %ebp,%ecx
+  8010d5:	77 61                	ja     801138 <__udivdi3+0x88>
+  8010d7:	85 c9                	test   %ecx,%ecx
+  8010d9:	89 ce                	mov    %ecx,%esi
+  8010db:	75 0b                	jne    8010e8 <__udivdi3+0x38>
+  8010dd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010e2:	31 d2                	xor    %edx,%edx
+  8010e4:	f7 f1                	div    %ecx
+  8010e6:	89 c6                	mov    %eax,%esi
+  8010e8:	31 d2                	xor    %edx,%edx
+  8010ea:	89 e8                	mov    %ebp,%eax
+  8010ec:	f7 f6                	div    %esi
+  8010ee:	89 c5                	mov    %eax,%ebp
+  8010f0:	89 f8                	mov    %edi,%eax
+  8010f2:	f7 f6                	div    %esi
+  8010f4:	89 ea                	mov    %ebp,%edx
+  8010f6:	83 c4 0c             	add    $0xc,%esp
+  8010f9:	5e                   	pop    %esi
+  8010fa:	5f                   	pop    %edi
+  8010fb:	5d                   	pop    %ebp
+  8010fc:	c3                   	ret    
+  8010fd:	8d 76 00             	lea    0x0(%esi),%esi
+  801100:	39 e8                	cmp    %ebp,%eax
+  801102:	77 24                	ja     801128 <__udivdi3+0x78>
+  801104:	0f bd e8             	bsr    %eax,%ebp
+  801107:	83 f5 1f             	xor    $0x1f,%ebp
+  80110a:	75 3c                	jne    801148 <__udivdi3+0x98>
+  80110c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801110:	39 34 24             	cmp    %esi,(%esp)
+  801113:	0f 86 9f 00 00 00    	jbe    8011b8 <__udivdi3+0x108>
+  801119:	39 d0                	cmp    %edx,%eax
+  80111b:	0f 82 97 00 00 00    	jb     8011b8 <__udivdi3+0x108>
+  801121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801128:	31 d2                	xor    %edx,%edx
+  80112a:	31 c0                	xor    %eax,%eax
+  80112c:	83 c4 0c             	add    $0xc,%esp
+  80112f:	5e                   	pop    %esi
+  801130:	5f                   	pop    %edi
+  801131:	5d                   	pop    %ebp
+  801132:	c3                   	ret    
+  801133:	90                   	nop
+  801134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801138:	89 f8                	mov    %edi,%eax
+  80113a:	f7 f1                	div    %ecx
+  80113c:	31 d2                	xor    %edx,%edx
+  80113e:	83 c4 0c             	add    $0xc,%esp
+  801141:	5e                   	pop    %esi
+  801142:	5f                   	pop    %edi
+  801143:	5d                   	pop    %ebp
+  801144:	c3                   	ret    
+  801145:	8d 76 00             	lea    0x0(%esi),%esi
+  801148:	89 e9                	mov    %ebp,%ecx
+  80114a:	8b 3c 24             	mov    (%esp),%edi
+  80114d:	d3 e0                	shl    %cl,%eax
+  80114f:	89 c6                	mov    %eax,%esi
+  801151:	b8 20 00 00 00       	mov    $0x20,%eax
+  801156:	29 e8                	sub    %ebp,%eax
+  801158:	89 c1                	mov    %eax,%ecx
+  80115a:	d3 ef                	shr    %cl,%edi
+  80115c:	89 e9                	mov    %ebp,%ecx
+  80115e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801162:	8b 3c 24             	mov    (%esp),%edi
+  801165:	09 74 24 08          	or     %esi,0x8(%esp)
+  801169:	89 d6                	mov    %edx,%esi
+  80116b:	d3 e7                	shl    %cl,%edi
+  80116d:	89 c1                	mov    %eax,%ecx
+  80116f:	89 3c 24             	mov    %edi,(%esp)
+  801172:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801176:	d3 ee                	shr    %cl,%esi
+  801178:	89 e9                	mov    %ebp,%ecx
+  80117a:	d3 e2                	shl    %cl,%edx
+  80117c:	89 c1                	mov    %eax,%ecx
+  80117e:	d3 ef                	shr    %cl,%edi
+  801180:	09 d7                	or     %edx,%edi
+  801182:	89 f2                	mov    %esi,%edx
+  801184:	89 f8                	mov    %edi,%eax
+  801186:	f7 74 24 08          	divl   0x8(%esp)
+  80118a:	89 d6                	mov    %edx,%esi
+  80118c:	89 c7                	mov    %eax,%edi
+  80118e:	f7 24 24             	mull   (%esp)
+  801191:	39 d6                	cmp    %edx,%esi
+  801193:	89 14 24             	mov    %edx,(%esp)
+  801196:	72 30                	jb     8011c8 <__udivdi3+0x118>
+  801198:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80119c:	89 e9                	mov    %ebp,%ecx
+  80119e:	d3 e2                	shl    %cl,%edx
+  8011a0:	39 c2                	cmp    %eax,%edx
+  8011a2:	73 05                	jae    8011a9 <__udivdi3+0xf9>
+  8011a4:	3b 34 24             	cmp    (%esp),%esi
+  8011a7:	74 1f                	je     8011c8 <__udivdi3+0x118>
+  8011a9:	89 f8                	mov    %edi,%eax
+  8011ab:	31 d2                	xor    %edx,%edx
+  8011ad:	e9 7a ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011b8:	31 d2                	xor    %edx,%edx
+  8011ba:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011bf:	e9 68 ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011c8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011cb:	31 d2                	xor    %edx,%edx
+  8011cd:	83 c4 0c             	add    $0xc,%esp
+  8011d0:	5e                   	pop    %esi
+  8011d1:	5f                   	pop    %edi
+  8011d2:	5d                   	pop    %ebp
+  8011d3:	c3                   	ret    
+  8011d4:	66 90                	xchg   %ax,%ax
+  8011d6:	66 90                	xchg   %ax,%ax
+  8011d8:	66 90                	xchg   %ax,%ax
+  8011da:	66 90                	xchg   %ax,%ax
+  8011dc:	66 90                	xchg   %ax,%ax
+  8011de:	66 90                	xchg   %ax,%ax
+
+008011e0 <__umoddi3>:
+  8011e0:	55                   	push   %ebp
+  8011e1:	57                   	push   %edi
+  8011e2:	56                   	push   %esi
+  8011e3:	83 ec 14             	sub    $0x14,%esp
+  8011e6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011ee:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011f2:	89 c7                	mov    %eax,%edi
+  8011f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011f8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011fc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801200:	89 34 24             	mov    %esi,(%esp)
+  801203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801207:	85 c0                	test   %eax,%eax
+  801209:	89 c2                	mov    %eax,%edx
+  80120b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80120f:	75 17                	jne    801228 <__umoddi3+0x48>
+  801211:	39 fe                	cmp    %edi,%esi
+  801213:	76 4b                	jbe    801260 <__umoddi3+0x80>
+  801215:	89 c8                	mov    %ecx,%eax
+  801217:	89 fa                	mov    %edi,%edx
+  801219:	f7 f6                	div    %esi
+  80121b:	89 d0                	mov    %edx,%eax
+  80121d:	31 d2                	xor    %edx,%edx
+  80121f:	83 c4 14             	add    $0x14,%esp
+  801222:	5e                   	pop    %esi
+  801223:	5f                   	pop    %edi
+  801224:	5d                   	pop    %ebp
+  801225:	c3                   	ret    
+  801226:	66 90                	xchg   %ax,%ax
+  801228:	39 f8                	cmp    %edi,%eax
+  80122a:	77 54                	ja     801280 <__umoddi3+0xa0>
+  80122c:	0f bd e8             	bsr    %eax,%ebp
+  80122f:	83 f5 1f             	xor    $0x1f,%ebp
+  801232:	75 5c                	jne    801290 <__umoddi3+0xb0>
+  801234:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801238:	39 3c 24             	cmp    %edi,(%esp)
+  80123b:	0f 87 e7 00 00 00    	ja     801328 <__umoddi3+0x148>
+  801241:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801245:	29 f1                	sub    %esi,%ecx
+  801247:	19 c7                	sbb    %eax,%edi
+  801249:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80124d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801251:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801255:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801259:	83 c4 14             	add    $0x14,%esp
+  80125c:	5e                   	pop    %esi
+  80125d:	5f                   	pop    %edi
+  80125e:	5d                   	pop    %ebp
+  80125f:	c3                   	ret    
+  801260:	85 f6                	test   %esi,%esi
+  801262:	89 f5                	mov    %esi,%ebp
+  801264:	75 0b                	jne    801271 <__umoddi3+0x91>
+  801266:	b8 01 00 00 00       	mov    $0x1,%eax
+  80126b:	31 d2                	xor    %edx,%edx
+  80126d:	f7 f6                	div    %esi
+  80126f:	89 c5                	mov    %eax,%ebp
+  801271:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801275:	31 d2                	xor    %edx,%edx
+  801277:	f7 f5                	div    %ebp
+  801279:	89 c8                	mov    %ecx,%eax
+  80127b:	f7 f5                	div    %ebp
+  80127d:	eb 9c                	jmp    80121b <__umoddi3+0x3b>
+  80127f:	90                   	nop
+  801280:	89 c8                	mov    %ecx,%eax
+  801282:	89 fa                	mov    %edi,%edx
+  801284:	83 c4 14             	add    $0x14,%esp
+  801287:	5e                   	pop    %esi
+  801288:	5f                   	pop    %edi
+  801289:	5d                   	pop    %ebp
+  80128a:	c3                   	ret    
+  80128b:	90                   	nop
+  80128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801290:	8b 04 24             	mov    (%esp),%eax
+  801293:	be 20 00 00 00       	mov    $0x20,%esi
+  801298:	89 e9                	mov    %ebp,%ecx
+  80129a:	29 ee                	sub    %ebp,%esi
+  80129c:	d3 e2                	shl    %cl,%edx
+  80129e:	89 f1                	mov    %esi,%ecx
+  8012a0:	d3 e8                	shr    %cl,%eax
+  8012a2:	89 e9                	mov    %ebp,%ecx
+  8012a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012a8:	8b 04 24             	mov    (%esp),%eax
+  8012ab:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012af:	89 fa                	mov    %edi,%edx
+  8012b1:	d3 e0                	shl    %cl,%eax
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012b9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012bd:	d3 ea                	shr    %cl,%edx
+  8012bf:	89 e9                	mov    %ebp,%ecx
+  8012c1:	d3 e7                	shl    %cl,%edi
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	d3 e8                	shr    %cl,%eax
+  8012c7:	89 e9                	mov    %ebp,%ecx
+  8012c9:	09 f8                	or     %edi,%eax
+  8012cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012cf:	f7 74 24 04          	divl   0x4(%esp)
+  8012d3:	d3 e7                	shl    %cl,%edi
+  8012d5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012d9:	89 d7                	mov    %edx,%edi
+  8012db:	f7 64 24 08          	mull   0x8(%esp)
+  8012df:	39 d7                	cmp    %edx,%edi
+  8012e1:	89 c1                	mov    %eax,%ecx
+  8012e3:	89 14 24             	mov    %edx,(%esp)
+  8012e6:	72 2c                	jb     801314 <__umoddi3+0x134>
+  8012e8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012ec:	72 22                	jb     801310 <__umoddi3+0x130>
+  8012ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012f2:	29 c8                	sub    %ecx,%eax
+  8012f4:	19 d7                	sbb    %edx,%edi
+  8012f6:	89 e9                	mov    %ebp,%ecx
+  8012f8:	89 fa                	mov    %edi,%edx
+  8012fa:	d3 e8                	shr    %cl,%eax
+  8012fc:	89 f1                	mov    %esi,%ecx
+  8012fe:	d3 e2                	shl    %cl,%edx
+  801300:	89 e9                	mov    %ebp,%ecx
+  801302:	d3 ef                	shr    %cl,%edi
+  801304:	09 d0                	or     %edx,%eax
+  801306:	89 fa                	mov    %edi,%edx
+  801308:	83 c4 14             	add    $0x14,%esp
+  80130b:	5e                   	pop    %esi
+  80130c:	5f                   	pop    %edi
+  80130d:	5d                   	pop    %ebp
+  80130e:	c3                   	ret    
+  80130f:	90                   	nop
+  801310:	39 d7                	cmp    %edx,%edi
+  801312:	75 da                	jne    8012ee <__umoddi3+0x10e>
+  801314:	8b 14 24             	mov    (%esp),%edx
+  801317:	89 c1                	mov    %eax,%ecx
+  801319:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80131d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801321:	eb cb                	jmp    8012ee <__umoddi3+0x10e>
+  801323:	90                   	nop
+  801324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801328:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80132c:	0f 82 0f ff ff ff    	jb     801241 <__umoddi3+0x61>
+  801332:	e9 1a ff ff ff       	jmp    801251 <__umoddi3+0x71>
diff --git a/obj/user/breakpoint.o b/obj/user/breakpoint.o
new file mode 100644
index 0000000..584e2d0
Binary files /dev/null and b/obj/user/breakpoint.o differ
diff --git a/obj/user/breakpoint.sym b/obj/user/breakpoint.sym
new file mode 100644
index 0000000..59c19b8
--- /dev/null
+++ b/obj/user/breakpoint.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a58 R __STAB_END__
+00202a59 R __STABSTR_BEGIN__
+00204118 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080004d T libmain
+0080009b T exit
+008000af t syscall
+00800110 T sys_cputs
+00800152 T sys_cgetc
+00800196 T sys_env_destroy
+008001d9 T sys_getenvid
+0080021d T _panic
+00800278 t putch
+008002d4 T vcprintf
+00800338 T cprintf
+0080035e t printnum
+0080043c t getuint
+0080048b t getint
+008004d2 T vprintfmt
+00800a19 T printfmt
+00800a47 t sprintputch
+00800a7c T vsnprintf
+00800adc T snprintf
+00800b10 T strlen
+00800b36 T strnlen
+00800b66 T strcpy
+00800b96 T strcat
+00800bc6 T strncpy
+00800c0b T strlcpy
+00800c5c T strcmp
+00800c9b T strncmp
+00800cf1 T strchr
+00800d24 T strfind
+00800d52 T memset
+00800dc0 T memmove
+00800e9a T memcpy
+00800ebb T memcmp
+00800f13 T memfind
+00800f46 T strtol
+008010b0 T __udivdi3
+008011e0 T __umoddi3
+00801404 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/buggyhello b/obj/user/buggyhello
new file mode 100755
index 0000000..2a9ac20
Binary files /dev/null and b/obj/user/buggyhello differ
diff --git a/obj/user/buggyhello.asm b/obj/user/buggyhello.asm
new file mode 100644
index 0000000..42fb3ad
--- /dev/null
+++ b/obj/user/buggyhello.asm
@@ -0,0 +1,2628 @@
+
+obj/user/buggyhello:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 1e 00 00 00       	call   80004f <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	sys_cputs((char*)1, 1);
+  800039:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  800040:	00 
+  800041:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800048:	e8 c5 00 00 00       	call   800112 <sys_cputs>
+}
+  80004d:	c9                   	leave  
+  80004e:	c3                   	ret    
+
+0080004f <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80004f:	55                   	push   %ebp
+  800050:	89 e5                	mov    %esp,%ebp
+  800052:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800055:	e8 81 01 00 00       	call   8001db <sys_getenvid>
+  80005a:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80005f:	89 c2                	mov    %eax,%edx
+  800061:	89 d0                	mov    %edx,%eax
+  800063:	01 c0                	add    %eax,%eax
+  800065:	01 d0                	add    %edx,%eax
+  800067:	c1 e0 05             	shl    $0x5,%eax
+  80006a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80006f:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800074:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800078:	7e 0a                	jle    800084 <libmain+0x35>
+		binaryname = argv[0];
+  80007a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80007d:	8b 00                	mov    (%eax),%eax
+  80007f:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800084:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800087:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80008b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80008e:	89 04 24             	mov    %eax,(%esp)
+  800091:	e8 9d ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800096:	e8 02 00 00 00       	call   80009d <exit>
+}
+  80009b:	c9                   	leave  
+  80009c:	c3                   	ret    
+
+0080009d <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  80009d:	55                   	push   %ebp
+  80009e:	89 e5                	mov    %esp,%ebp
+  8000a0:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000aa:	e8 e9 00 00 00       	call   800198 <sys_env_destroy>
+}
+  8000af:	c9                   	leave  
+  8000b0:	c3                   	ret    
+
+008000b1 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000b1:	55                   	push   %ebp
+  8000b2:	89 e5                	mov    %esp,%ebp
+  8000b4:	57                   	push   %edi
+  8000b5:	56                   	push   %esi
+  8000b6:	53                   	push   %ebx
+  8000b7:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000ba:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000bd:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000c0:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000c3:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000c6:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000c9:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000cc:	cd 30                	int    $0x30
+  8000ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000d5:	74 30                	je     800107 <syscall+0x56>
+  8000d7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000db:	7e 2a                	jle    800107 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000e0:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000e4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000eb:	c7 44 24 08 42 13 80 	movl   $0x801342,0x8(%esp)
+  8000f2:	00 
+  8000f3:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000fa:	00 
+  8000fb:	c7 04 24 5f 13 80 00 	movl   $0x80135f,(%esp)
+  800102:	e8 18 01 00 00       	call   80021f <_panic>
+
+	return ret;
+  800107:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  80010a:	83 c4 3c             	add    $0x3c,%esp
+  80010d:	5b                   	pop    %ebx
+  80010e:	5e                   	pop    %esi
+  80010f:	5f                   	pop    %edi
+  800110:	5d                   	pop    %ebp
+  800111:	c3                   	ret    
+
+00800112 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800112:	55                   	push   %ebp
+  800113:	89 e5                	mov    %esp,%ebp
+  800115:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800118:	8b 45 08             	mov    0x8(%ebp),%eax
+  80011b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800122:	00 
+  800123:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80012a:	00 
+  80012b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800132:	00 
+  800133:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800136:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80013a:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80013e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800145:	00 
+  800146:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80014d:	e8 5f ff ff ff       	call   8000b1 <syscall>
+}
+  800152:	c9                   	leave  
+  800153:	c3                   	ret    
+
+00800154 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800154:	55                   	push   %ebp
+  800155:	89 e5                	mov    %esp,%ebp
+  800157:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  80015a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800161:	00 
+  800162:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800169:	00 
+  80016a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800171:	00 
+  800172:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800179:	00 
+  80017a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800181:	00 
+  800182:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800189:	00 
+  80018a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800191:	e8 1b ff ff ff       	call   8000b1 <syscall>
+}
+  800196:	c9                   	leave  
+  800197:	c3                   	ret    
+
+00800198 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800198:	55                   	push   %ebp
+  800199:	89 e5                	mov    %esp,%ebp
+  80019b:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  80019e:	8b 45 08             	mov    0x8(%ebp),%eax
+  8001a1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001a8:	00 
+  8001a9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001b0:	00 
+  8001b1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001b8:	00 
+  8001b9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001c0:	00 
+  8001c1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001c5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001cc:	00 
+  8001cd:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001d4:	e8 d8 fe ff ff       	call   8000b1 <syscall>
+}
+  8001d9:	c9                   	leave  
+  8001da:	c3                   	ret    
+
+008001db <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001db:	55                   	push   %ebp
+  8001dc:	89 e5                	mov    %esp,%ebp
+  8001de:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001e1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001e8:	00 
+  8001e9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001f0:	00 
+  8001f1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001f8:	00 
+  8001f9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800200:	00 
+  800201:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800208:	00 
+  800209:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800210:	00 
+  800211:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  800218:	e8 94 fe ff ff       	call   8000b1 <syscall>
+}
+  80021d:	c9                   	leave  
+  80021e:	c3                   	ret    
+
+0080021f <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80021f:	55                   	push   %ebp
+  800220:	89 e5                	mov    %esp,%ebp
+  800222:	53                   	push   %ebx
+  800223:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800226:	8d 45 14             	lea    0x14(%ebp),%eax
+  800229:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80022c:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  800232:	e8 a4 ff ff ff       	call   8001db <sys_getenvid>
+  800237:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80023a:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80023e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800241:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800245:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  800249:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80024d:	c7 04 24 70 13 80 00 	movl   $0x801370,(%esp)
+  800254:	e8 e1 00 00 00       	call   80033a <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  800259:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80025c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800260:	8b 45 10             	mov    0x10(%ebp),%eax
+  800263:	89 04 24             	mov    %eax,(%esp)
+  800266:	e8 6b 00 00 00       	call   8002d6 <vcprintf>
+	cprintf("\n");
+  80026b:	c7 04 24 93 13 80 00 	movl   $0x801393,(%esp)
+  800272:	e8 c3 00 00 00       	call   80033a <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  800277:	cc                   	int3   
+  800278:	eb fd                	jmp    800277 <_panic+0x58>
+
+0080027a <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  80027a:	55                   	push   %ebp
+  80027b:	89 e5                	mov    %esp,%ebp
+  80027d:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  800280:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800283:	8b 00                	mov    (%eax),%eax
+  800285:	8d 48 01             	lea    0x1(%eax),%ecx
+  800288:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80028b:	89 0a                	mov    %ecx,(%edx)
+  80028d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800290:	89 d1                	mov    %edx,%ecx
+  800292:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800295:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  800299:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80029c:	8b 00                	mov    (%eax),%eax
+  80029e:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8002a3:	75 20                	jne    8002c5 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8002a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a8:	8b 00                	mov    (%eax),%eax
+  8002aa:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8002ad:	83 c2 08             	add    $0x8,%edx
+  8002b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002b4:	89 14 24             	mov    %edx,(%esp)
+  8002b7:	e8 56 fe ff ff       	call   800112 <sys_cputs>
+		b->idx = 0;
+  8002bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002c5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c8:	8b 40 04             	mov    0x4(%eax),%eax
+  8002cb:	8d 50 01             	lea    0x1(%eax),%edx
+  8002ce:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002d1:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002d4:	c9                   	leave  
+  8002d5:	c3                   	ret    
+
+008002d6 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002d6:	55                   	push   %ebp
+  8002d7:	89 e5                	mov    %esp,%ebp
+  8002d9:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002df:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002e6:	00 00 00 
+	b.cnt = 0;
+  8002e9:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002f0:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002fd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800301:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800307:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80030b:	c7 04 24 7a 02 80 00 	movl   $0x80027a,(%esp)
+  800312:	e8 bd 01 00 00       	call   8004d4 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800317:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  80031d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800321:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800327:	83 c0 08             	add    $0x8,%eax
+  80032a:	89 04 24             	mov    %eax,(%esp)
+  80032d:	e8 e0 fd ff ff       	call   800112 <sys_cputs>
+
+	return b.cnt;
+  800332:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800338:	c9                   	leave  
+  800339:	c3                   	ret    
+
+0080033a <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  80033a:	55                   	push   %ebp
+  80033b:	89 e5                	mov    %esp,%ebp
+  80033d:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  800340:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800343:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800346:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800349:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80034d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800350:	89 04 24             	mov    %eax,(%esp)
+  800353:	e8 7e ff ff ff       	call   8002d6 <vcprintf>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  80035b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80035e:	c9                   	leave  
+  80035f:	c3                   	ret    
+
+00800360 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  800360:	55                   	push   %ebp
+  800361:	89 e5                	mov    %esp,%ebp
+  800363:	53                   	push   %ebx
+  800364:	83 ec 34             	sub    $0x34,%esp
+  800367:	8b 45 10             	mov    0x10(%ebp),%eax
+  80036a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80036d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800370:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800373:	8b 45 18             	mov    0x18(%ebp),%eax
+  800376:	ba 00 00 00 00       	mov    $0x0,%edx
+  80037b:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  80037e:	77 72                	ja     8003f2 <printnum+0x92>
+  800380:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800383:	72 05                	jb     80038a <printnum+0x2a>
+  800385:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  800388:	77 68                	ja     8003f2 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  80038a:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  80038d:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  800390:	8b 45 18             	mov    0x18(%ebp),%eax
+  800393:	ba 00 00 00 00       	mov    $0x0,%edx
+  800398:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80039c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003a6:	89 04 24             	mov    %eax,(%esp)
+  8003a9:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8003ad:	e8 fe 0c 00 00       	call   8010b0 <__udivdi3>
+  8003b2:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003b5:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003b9:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003bd:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003c0:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003c4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003c8:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003d3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003d6:	89 04 24             	mov    %eax,(%esp)
+  8003d9:	e8 82 ff ff ff       	call   800360 <printnum>
+  8003de:	eb 1c                	jmp    8003fc <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003e3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003e7:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003ea:	89 04 24             	mov    %eax,(%esp)
+  8003ed:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003f0:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003f2:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003f6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003fa:	7f e4                	jg     8003e0 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003fc:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003ff:	bb 00 00 00 00       	mov    $0x0,%ebx
+  800404:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800407:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80040a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80040e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800412:	89 04 24             	mov    %eax,(%esp)
+  800415:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800419:	e8 c2 0d 00 00       	call   8011e0 <__umoddi3>
+  80041e:	05 20 14 80 00       	add    $0x801420,%eax
+  800423:	0f b6 00             	movzbl (%eax),%eax
+  800426:	0f be c0             	movsbl %al,%eax
+  800429:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80042c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800430:	89 04 24             	mov    %eax,(%esp)
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+  800436:	ff d0                	call   *%eax
+}
+  800438:	83 c4 34             	add    $0x34,%esp
+  80043b:	5b                   	pop    %ebx
+  80043c:	5d                   	pop    %ebp
+  80043d:	c3                   	ret    
+
+0080043e <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  80043e:	55                   	push   %ebp
+  80043f:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800441:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800445:	7e 14                	jle    80045b <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800447:	8b 45 08             	mov    0x8(%ebp),%eax
+  80044a:	8b 00                	mov    (%eax),%eax
+  80044c:	8d 48 08             	lea    0x8(%eax),%ecx
+  80044f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800452:	89 0a                	mov    %ecx,(%edx)
+  800454:	8b 50 04             	mov    0x4(%eax),%edx
+  800457:	8b 00                	mov    (%eax),%eax
+  800459:	eb 30                	jmp    80048b <getuint+0x4d>
+	else if (lflag)
+  80045b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80045f:	74 16                	je     800477 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  800461:	8b 45 08             	mov    0x8(%ebp),%eax
+  800464:	8b 00                	mov    (%eax),%eax
+  800466:	8d 48 04             	lea    0x4(%eax),%ecx
+  800469:	8b 55 08             	mov    0x8(%ebp),%edx
+  80046c:	89 0a                	mov    %ecx,(%edx)
+  80046e:	8b 00                	mov    (%eax),%eax
+  800470:	ba 00 00 00 00       	mov    $0x0,%edx
+  800475:	eb 14                	jmp    80048b <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  800477:	8b 45 08             	mov    0x8(%ebp),%eax
+  80047a:	8b 00                	mov    (%eax),%eax
+  80047c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80047f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800482:	89 0a                	mov    %ecx,(%edx)
+  800484:	8b 00                	mov    (%eax),%eax
+  800486:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  80048b:	5d                   	pop    %ebp
+  80048c:	c3                   	ret    
+
+0080048d <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  80048d:	55                   	push   %ebp
+  80048e:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800490:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800494:	7e 14                	jle    8004aa <getint+0x1d>
+		return va_arg(*ap, long long);
+  800496:	8b 45 08             	mov    0x8(%ebp),%eax
+  800499:	8b 00                	mov    (%eax),%eax
+  80049b:	8d 48 08             	lea    0x8(%eax),%ecx
+  80049e:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004a1:	89 0a                	mov    %ecx,(%edx)
+  8004a3:	8b 50 04             	mov    0x4(%eax),%edx
+  8004a6:	8b 00                	mov    (%eax),%eax
+  8004a8:	eb 28                	jmp    8004d2 <getint+0x45>
+	else if (lflag)
+  8004aa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8004ae:	74 12                	je     8004c2 <getint+0x35>
+		return va_arg(*ap, long);
+  8004b0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b3:	8b 00                	mov    (%eax),%eax
+  8004b5:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004b8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004bb:	89 0a                	mov    %ecx,(%edx)
+  8004bd:	8b 00                	mov    (%eax),%eax
+  8004bf:	99                   	cltd   
+  8004c0:	eb 10                	jmp    8004d2 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004c5:	8b 00                	mov    (%eax),%eax
+  8004c7:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004ca:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004cd:	89 0a                	mov    %ecx,(%edx)
+  8004cf:	8b 00                	mov    (%eax),%eax
+  8004d1:	99                   	cltd   
+}
+  8004d2:	5d                   	pop    %ebp
+  8004d3:	c3                   	ret    
+
+008004d4 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004d4:	55                   	push   %ebp
+  8004d5:	89 e5                	mov    %esp,%ebp
+  8004d7:	56                   	push   %esi
+  8004d8:	53                   	push   %ebx
+  8004d9:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004dc:	e9 72 01 00 00       	jmp    800653 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004e1:	85 db                	test   %ebx,%ebx
+  8004e3:	75 05                	jne    8004ea <vprintfmt+0x16>
+				return;
+  8004e5:	e9 2a 05 00 00       	jmp    800a14 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004ea:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004ed:	0f 85 51 01 00 00    	jne    800644 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004f3:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004f6:	8d 50 01             	lea    0x1(%eax),%edx
+  8004f9:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004fc:	0f b6 00             	movzbl (%eax),%eax
+  8004ff:	0f b6 d8             	movzbl %al,%ebx
+  800502:	83 fb 5b             	cmp    $0x5b,%ebx
+  800505:	74 14                	je     80051b <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800507:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80050a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80050e:	89 1c 24             	mov    %ebx,(%esp)
+  800511:	8b 45 08             	mov    0x8(%ebp),%eax
+  800514:	ff d0                	call   *%eax
+				    continue;
+  800516:	e9 38 01 00 00       	jmp    800653 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  80051b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80051e:	8d 50 01             	lea    0x1(%eax),%edx
+  800521:	89 55 10             	mov    %edx,0x10(%ebp)
+  800524:	0f b6 00             	movzbl (%eax),%eax
+  800527:	0f b6 c0             	movzbl %al,%eax
+  80052a:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  80052f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800532:	8d 50 01             	lea    0x1(%eax),%edx
+  800535:	89 55 10             	mov    %edx,0x10(%ebp)
+  800538:	0f b6 00             	movzbl (%eax),%eax
+  80053b:	0f b6 c0             	movzbl %al,%eax
+  80053e:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800543:	a1 08 20 80 00       	mov    0x802008,%eax
+  800548:	83 f8 2f             	cmp    $0x2f,%eax
+  80054b:	7e 19                	jle    800566 <vprintfmt+0x92>
+  80054d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800552:	83 f8 39             	cmp    $0x39,%eax
+  800555:	7f 0f                	jg     800566 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800557:	a1 08 20 80 00       	mov    0x802008,%eax
+  80055c:	83 e8 30             	sub    $0x30,%eax
+  80055f:	a3 08 20 80 00       	mov    %eax,0x802008
+  800564:	eb 50                	jmp    8005b6 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  800566:	a1 08 20 80 00       	mov    0x802008,%eax
+  80056b:	83 f8 60             	cmp    $0x60,%eax
+  80056e:	7e 19                	jle    800589 <vprintfmt+0xb5>
+  800570:	a1 08 20 80 00       	mov    0x802008,%eax
+  800575:	83 f8 66             	cmp    $0x66,%eax
+  800578:	7f 0f                	jg     800589 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  80057a:	a1 08 20 80 00       	mov    0x802008,%eax
+  80057f:	83 e8 57             	sub    $0x57,%eax
+  800582:	a3 08 20 80 00       	mov    %eax,0x802008
+  800587:	eb 2d                	jmp    8005b6 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  800589:	a1 08 20 80 00       	mov    0x802008,%eax
+  80058e:	83 f8 40             	cmp    $0x40,%eax
+  800591:	7e 19                	jle    8005ac <vprintfmt+0xd8>
+  800593:	a1 08 20 80 00       	mov    0x802008,%eax
+  800598:	83 f8 46             	cmp    $0x46,%eax
+  80059b:	7f 0f                	jg     8005ac <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  80059d:	a1 08 20 80 00       	mov    0x802008,%eax
+  8005a2:	83 e8 37             	sub    $0x37,%eax
+  8005a5:	a3 08 20 80 00       	mov    %eax,0x802008
+  8005aa:	eb 0a                	jmp    8005b6 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8005ac:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8005b3:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005b6:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005bb:	83 f8 2f             	cmp    $0x2f,%eax
+  8005be:	7e 19                	jle    8005d9 <vprintfmt+0x105>
+  8005c0:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005c5:	83 f8 39             	cmp    $0x39,%eax
+  8005c8:	7f 0f                	jg     8005d9 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005ca:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005cf:	83 e8 30             	sub    $0x30,%eax
+  8005d2:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005d7:	eb 50                	jmp    800629 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005d9:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005de:	83 f8 60             	cmp    $0x60,%eax
+  8005e1:	7e 19                	jle    8005fc <vprintfmt+0x128>
+  8005e3:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005e8:	83 f8 66             	cmp    $0x66,%eax
+  8005eb:	7f 0f                	jg     8005fc <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005ed:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f2:	83 e8 57             	sub    $0x57,%eax
+  8005f5:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005fa:	eb 2d                	jmp    800629 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005fc:	a1 10 20 80 00       	mov    0x802010,%eax
+  800601:	83 f8 40             	cmp    $0x40,%eax
+  800604:	7e 19                	jle    80061f <vprintfmt+0x14b>
+  800606:	a1 10 20 80 00       	mov    0x802010,%eax
+  80060b:	83 f8 46             	cmp    $0x46,%eax
+  80060e:	7f 0f                	jg     80061f <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  800610:	a1 10 20 80 00       	mov    0x802010,%eax
+  800615:	83 e8 37             	sub    $0x37,%eax
+  800618:	a3 10 20 80 00       	mov    %eax,0x802010
+  80061d:	eb 0a                	jmp    800629 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80061f:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800626:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800629:	a1 08 20 80 00       	mov    0x802008,%eax
+  80062e:	c1 e0 0c             	shl    $0xc,%eax
+  800631:	89 c2                	mov    %eax,%edx
+  800633:	a1 10 20 80 00       	mov    0x802010,%eax
+  800638:	c1 e0 08             	shl    $0x8,%eax
+  80063b:	09 d0                	or     %edx,%eax
+  80063d:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800642:	eb 0f                	jmp    800653 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800644:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800647:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80064b:	89 1c 24             	mov    %ebx,(%esp)
+  80064e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800651:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800653:	8b 45 10             	mov    0x10(%ebp),%eax
+  800656:	8d 50 01             	lea    0x1(%eax),%edx
+  800659:	89 55 10             	mov    %edx,0x10(%ebp)
+  80065c:	0f b6 00             	movzbl (%eax),%eax
+  80065f:	0f b6 d8             	movzbl %al,%ebx
+  800662:	83 fb 25             	cmp    $0x25,%ebx
+  800665:	0f 85 76 fe ff ff    	jne    8004e1 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  80066b:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  80066f:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  800676:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  80067d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800684:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  80068b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80068e:	8d 50 01             	lea    0x1(%eax),%edx
+  800691:	89 55 10             	mov    %edx,0x10(%ebp)
+  800694:	0f b6 00             	movzbl (%eax),%eax
+  800697:	0f b6 d8             	movzbl %al,%ebx
+  80069a:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  80069d:	83 f8 55             	cmp    $0x55,%eax
+  8006a0:	0f 87 3d 03 00 00    	ja     8009e3 <vprintfmt+0x50f>
+  8006a6:	8b 04 85 44 14 80 00 	mov    0x801444(,%eax,4),%eax
+  8006ad:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8006af:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006b3:	eb d6                	jmp    80068b <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006b5:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006b9:	eb d0                	jmp    80068b <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006c5:	89 d0                	mov    %edx,%eax
+  8006c7:	c1 e0 02             	shl    $0x2,%eax
+  8006ca:	01 d0                	add    %edx,%eax
+  8006cc:	01 c0                	add    %eax,%eax
+  8006ce:	01 d8                	add    %ebx,%eax
+  8006d0:	83 e8 30             	sub    $0x30,%eax
+  8006d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006d6:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006d9:	0f b6 00             	movzbl (%eax),%eax
+  8006dc:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006df:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006e2:	7e 0b                	jle    8006ef <vprintfmt+0x21b>
+  8006e4:	83 fb 39             	cmp    $0x39,%ebx
+  8006e7:	7f 06                	jg     8006ef <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006e9:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006ed:	eb d3                	jmp    8006c2 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006ef:	eb 33                	jmp    800724 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006f1:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006f4:	8d 50 04             	lea    0x4(%eax),%edx
+  8006f7:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006fa:	8b 00                	mov    (%eax),%eax
+  8006fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006ff:	eb 23                	jmp    800724 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  800701:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800705:	79 0c                	jns    800713 <vprintfmt+0x23f>
+				width = 0;
+  800707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  80070e:	e9 78 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+  800713:	e9 73 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800718:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80071f:	e9 67 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800724:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800728:	79 12                	jns    80073c <vprintfmt+0x268>
+				width = precision, precision = -1;
+  80072a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80072d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800730:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800737:	e9 4f ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+  80073c:	e9 4a ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800741:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800745:	e9 41 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  80074a:	8b 45 14             	mov    0x14(%ebp),%eax
+  80074d:	8d 50 04             	lea    0x4(%eax),%edx
+  800750:	89 55 14             	mov    %edx,0x14(%ebp)
+  800753:	8b 00                	mov    (%eax),%eax
+  800755:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800758:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80075c:	89 04 24             	mov    %eax,(%esp)
+  80075f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800762:	ff d0                	call   *%eax
+			break;
+  800764:	e9 a5 02 00 00       	jmp    800a0e <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  800769:	8b 45 14             	mov    0x14(%ebp),%eax
+  80076c:	8d 50 04             	lea    0x4(%eax),%edx
+  80076f:	89 55 14             	mov    %edx,0x14(%ebp)
+  800772:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800774:	85 db                	test   %ebx,%ebx
+  800776:	79 02                	jns    80077a <vprintfmt+0x2a6>
+				err = -err;
+  800778:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  80077a:	83 fb 06             	cmp    $0x6,%ebx
+  80077d:	7f 0b                	jg     80078a <vprintfmt+0x2b6>
+  80077f:	8b 34 9d 04 14 80 00 	mov    0x801404(,%ebx,4),%esi
+  800786:	85 f6                	test   %esi,%esi
+  800788:	75 23                	jne    8007ad <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  80078a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80078e:	c7 44 24 08 31 14 80 	movl   $0x801431,0x8(%esp)
+  800795:	00 
+  800796:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800799:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80079d:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007a0:	89 04 24             	mov    %eax,(%esp)
+  8007a3:	e8 73 02 00 00       	call   800a1b <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8007a8:	e9 61 02 00 00       	jmp    800a0e <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8007ad:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007b1:	c7 44 24 08 3a 14 80 	movl   $0x80143a,0x8(%esp)
+  8007b8:	00 
+  8007b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007c3:	89 04 24             	mov    %eax,(%esp)
+  8007c6:	e8 50 02 00 00       	call   800a1b <printfmt>
+			break;
+  8007cb:	e9 3e 02 00 00       	jmp    800a0e <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007d0:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007d3:	8d 50 04             	lea    0x4(%eax),%edx
+  8007d6:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007d9:	8b 30                	mov    (%eax),%esi
+  8007db:	85 f6                	test   %esi,%esi
+  8007dd:	75 05                	jne    8007e4 <vprintfmt+0x310>
+				p = "(null)";
+  8007df:	be 3d 14 80 00       	mov    $0x80143d,%esi
+			if (width > 0 && padc != '-')
+  8007e4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007e8:	7e 37                	jle    800821 <vprintfmt+0x34d>
+  8007ea:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007ee:	74 31                	je     800821 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007f7:	89 34 24             	mov    %esi,(%esp)
+  8007fa:	e8 39 03 00 00       	call   800b38 <strnlen>
+  8007ff:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  800802:	eb 17                	jmp    80081b <vprintfmt+0x347>
+					putch(padc, putdat);
+  800804:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800808:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80080b:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80080f:	89 04 24             	mov    %eax,(%esp)
+  800812:	8b 45 08             	mov    0x8(%ebp),%eax
+  800815:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800817:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80081b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80081f:	7f e3                	jg     800804 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800821:	eb 38                	jmp    80085b <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800823:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800827:	74 1f                	je     800848 <vprintfmt+0x374>
+  800829:	83 fb 1f             	cmp    $0x1f,%ebx
+  80082c:	7e 05                	jle    800833 <vprintfmt+0x35f>
+  80082e:	83 fb 7e             	cmp    $0x7e,%ebx
+  800831:	7e 15                	jle    800848 <vprintfmt+0x374>
+					putch('?', putdat);
+  800833:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800836:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80083a:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800841:	8b 45 08             	mov    0x8(%ebp),%eax
+  800844:	ff d0                	call   *%eax
+  800846:	eb 0f                	jmp    800857 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800848:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80084b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80084f:	89 1c 24             	mov    %ebx,(%esp)
+  800852:	8b 45 08             	mov    0x8(%ebp),%eax
+  800855:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800857:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80085b:	89 f0                	mov    %esi,%eax
+  80085d:	8d 70 01             	lea    0x1(%eax),%esi
+  800860:	0f b6 00             	movzbl (%eax),%eax
+  800863:	0f be d8             	movsbl %al,%ebx
+  800866:	85 db                	test   %ebx,%ebx
+  800868:	74 10                	je     80087a <vprintfmt+0x3a6>
+  80086a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80086e:	78 b3                	js     800823 <vprintfmt+0x34f>
+  800870:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800874:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800878:	79 a9                	jns    800823 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80087a:	eb 17                	jmp    800893 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  80087c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80087f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800883:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  80088a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80088d:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80088f:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800893:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800897:	7f e3                	jg     80087c <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  800899:	e9 70 01 00 00       	jmp    800a0e <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  80089e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008a1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008a5:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008a8:	89 04 24             	mov    %eax,(%esp)
+  8008ab:	e8 dd fb ff ff       	call   80048d <getint>
+  8008b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008bc:	85 d2                	test   %edx,%edx
+  8008be:	79 26                	jns    8008e6 <vprintfmt+0x412>
+				putch('-', putdat);
+  8008c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008c3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008c7:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008d1:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008d9:	f7 d8                	neg    %eax
+  8008db:	83 d2 00             	adc    $0x0,%edx
+  8008de:	f7 da                	neg    %edx
+  8008e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008e3:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008e6:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008ed:	e9 a8 00 00 00       	jmp    80099a <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008f9:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008fc:	89 04 24             	mov    %eax,(%esp)
+  8008ff:	e8 3a fb ff ff       	call   80043e <getuint>
+  800904:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800907:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  80090a:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800911:	e9 84 00 00 00       	jmp    80099a <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800916:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800919:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80091d:	8d 45 14             	lea    0x14(%ebp),%eax
+  800920:	89 04 24             	mov    %eax,(%esp)
+  800923:	e8 16 fb ff ff       	call   80043e <getuint>
+  800928:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80092b:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  80092e:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800935:	eb 63                	jmp    80099a <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800937:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80093a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80093e:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800945:	8b 45 08             	mov    0x8(%ebp),%eax
+  800948:	ff d0                	call   *%eax
+			putch('x', putdat);
+  80094a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80094d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800951:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800958:	8b 45 08             	mov    0x8(%ebp),%eax
+  80095b:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  80095d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800960:	8d 50 04             	lea    0x4(%eax),%edx
+  800963:	89 55 14             	mov    %edx,0x14(%ebp)
+  800966:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  800968:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80096b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800972:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  800979:	eb 1f                	jmp    80099a <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  80097b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80097e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800982:	8d 45 14             	lea    0x14(%ebp),%eax
+  800985:	89 04 24             	mov    %eax,(%esp)
+  800988:	e8 b1 fa ff ff       	call   80043e <getuint>
+  80098d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800990:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800993:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  80099a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  80099e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8009a1:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8009a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8009a8:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8009ac:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8009b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009b6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009ba:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009be:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009c5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009c8:	89 04 24             	mov    %eax,(%esp)
+  8009cb:	e8 90 f9 ff ff       	call   800360 <printnum>
+			break;
+  8009d0:	eb 3c                	jmp    800a0e <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009d2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009d9:	89 1c 24             	mov    %ebx,(%esp)
+  8009dc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009df:	ff d0                	call   *%eax
+			break;			
+  8009e1:	eb 2b                	jmp    800a0e <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009e6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009ea:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009f4:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009f6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009fa:	eb 04                	jmp    800a00 <vprintfmt+0x52c>
+  8009fc:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a00:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a03:	83 e8 01             	sub    $0x1,%eax
+  800a06:	0f b6 00             	movzbl (%eax),%eax
+  800a09:	3c 25                	cmp    $0x25,%al
+  800a0b:	75 ef                	jne    8009fc <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800a0d:	90                   	nop
+		}
+	}
+  800a0e:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800a0f:	e9 3f fc ff ff       	jmp    800653 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a14:	83 c4 40             	add    $0x40,%esp
+  800a17:	5b                   	pop    %ebx
+  800a18:	5e                   	pop    %esi
+  800a19:	5d                   	pop    %ebp
+  800a1a:	c3                   	ret    
+
+00800a1b <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a1b:	55                   	push   %ebp
+  800a1c:	89 e5                	mov    %esp,%ebp
+  800a1e:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a21:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a24:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a2a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a2e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a31:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a35:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a38:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a3c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a3f:	89 04 24             	mov    %eax,(%esp)
+  800a42:	e8 8d fa ff ff       	call   8004d4 <vprintfmt>
+	va_end(ap);
+}
+  800a47:	c9                   	leave  
+  800a48:	c3                   	ret    
+
+00800a49 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a49:	55                   	push   %ebp
+  800a4a:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a4c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4f:	8b 40 08             	mov    0x8(%eax),%eax
+  800a52:	8d 50 01             	lea    0x1(%eax),%edx
+  800a55:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a58:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a5e:	8b 10                	mov    (%eax),%edx
+  800a60:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a63:	8b 40 04             	mov    0x4(%eax),%eax
+  800a66:	39 c2                	cmp    %eax,%edx
+  800a68:	73 12                	jae    800a7c <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a6d:	8b 00                	mov    (%eax),%eax
+  800a6f:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a72:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a75:	89 0a                	mov    %ecx,(%edx)
+  800a77:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a7a:	88 10                	mov    %dl,(%eax)
+}
+  800a7c:	5d                   	pop    %ebp
+  800a7d:	c3                   	ret    
+
+00800a7e <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a7e:	55                   	push   %ebp
+  800a7f:	89 e5                	mov    %esp,%ebp
+  800a81:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a84:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a87:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a8d:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a90:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a93:	01 d0                	add    %edx,%eax
+  800a95:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a9f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800aa3:	74 06                	je     800aab <vsnprintf+0x2d>
+  800aa5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800aa9:	7f 07                	jg     800ab2 <vsnprintf+0x34>
+		return -E_INVAL;
+  800aab:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800ab0:	eb 2a                	jmp    800adc <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800ab2:	8b 45 14             	mov    0x14(%ebp),%eax
+  800ab5:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800ab9:	8b 45 10             	mov    0x10(%ebp),%eax
+  800abc:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ac0:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ac3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ac7:	c7 04 24 49 0a 80 00 	movl   $0x800a49,(%esp)
+  800ace:	e8 01 fa ff ff       	call   8004d4 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ad3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ad6:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800adc:	c9                   	leave  
+  800add:	c3                   	ret    
+
+00800ade <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800ade:	55                   	push   %ebp
+  800adf:	89 e5                	mov    %esp,%ebp
+  800ae1:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ae4:	8d 45 14             	lea    0x14(%ebp),%eax
+  800ae7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800aed:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800af1:	8b 45 10             	mov    0x10(%ebp),%eax
+  800af4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800af8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800afb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800aff:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b02:	89 04 24             	mov    %eax,(%esp)
+  800b05:	e8 74 ff ff ff       	call   800a7e <vsnprintf>
+  800b0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800b10:	c9                   	leave  
+  800b11:	c3                   	ret    
+
+00800b12 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b12:	55                   	push   %ebp
+  800b13:	89 e5                	mov    %esp,%ebp
+  800b15:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b18:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b1f:	eb 08                	jmp    800b29 <strlen+0x17>
+		n++;
+  800b21:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b25:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b29:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b2c:	0f b6 00             	movzbl (%eax),%eax
+  800b2f:	84 c0                	test   %al,%al
+  800b31:	75 ee                	jne    800b21 <strlen+0xf>
+		n++;
+	return n;
+  800b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b36:	c9                   	leave  
+  800b37:	c3                   	ret    
+
+00800b38 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b38:	55                   	push   %ebp
+  800b39:	89 e5                	mov    %esp,%ebp
+  800b3b:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b45:	eb 0c                	jmp    800b53 <strnlen+0x1b>
+		n++;
+  800b47:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b4b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b4f:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b53:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b57:	74 0a                	je     800b63 <strnlen+0x2b>
+  800b59:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5c:	0f b6 00             	movzbl (%eax),%eax
+  800b5f:	84 c0                	test   %al,%al
+  800b61:	75 e4                	jne    800b47 <strnlen+0xf>
+		n++;
+	return n;
+  800b63:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b66:	c9                   	leave  
+  800b67:	c3                   	ret    
+
+00800b68 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b68:	55                   	push   %ebp
+  800b69:	89 e5                	mov    %esp,%ebp
+  800b6b:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b6e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b71:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b74:	90                   	nop
+  800b75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b78:	8d 50 01             	lea    0x1(%eax),%edx
+  800b7b:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b7e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b81:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b84:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b87:	0f b6 12             	movzbl (%edx),%edx
+  800b8a:	88 10                	mov    %dl,(%eax)
+  800b8c:	0f b6 00             	movzbl (%eax),%eax
+  800b8f:	84 c0                	test   %al,%al
+  800b91:	75 e2                	jne    800b75 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b93:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b96:	c9                   	leave  
+  800b97:	c3                   	ret    
+
+00800b98 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b98:	55                   	push   %ebp
+  800b99:	89 e5                	mov    %esp,%ebp
+  800b9b:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b9e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba1:	89 04 24             	mov    %eax,(%esp)
+  800ba4:	e8 69 ff ff ff       	call   800b12 <strlen>
+  800ba9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800bac:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800baf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bb2:	01 c2                	add    %eax,%edx
+  800bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bb7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800bbb:	89 14 24             	mov    %edx,(%esp)
+  800bbe:	e8 a5 ff ff ff       	call   800b68 <strcpy>
+	return dst;
+  800bc3:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bc6:	c9                   	leave  
+  800bc7:	c3                   	ret    
+
+00800bc8 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bc8:	55                   	push   %ebp
+  800bc9:	89 e5                	mov    %esp,%ebp
+  800bcb:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bd4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bdb:	eb 23                	jmp    800c00 <strncpy+0x38>
+		*dst++ = *src;
+  800bdd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800be0:	8d 50 01             	lea    0x1(%eax),%edx
+  800be3:	89 55 08             	mov    %edx,0x8(%ebp)
+  800be6:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800be9:	0f b6 12             	movzbl (%edx),%edx
+  800bec:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800bee:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bf1:	0f b6 00             	movzbl (%eax),%eax
+  800bf4:	84 c0                	test   %al,%al
+  800bf6:	74 04                	je     800bfc <strncpy+0x34>
+			src++;
+  800bf8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800bfc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800c00:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c03:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800c06:	72 d5                	jb     800bdd <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800c08:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800c0b:	c9                   	leave  
+  800c0c:	c3                   	ret    
+
+00800c0d <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800c0d:	55                   	push   %ebp
+  800c0e:	89 e5                	mov    %esp,%ebp
+  800c10:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c13:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c16:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c19:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c1d:	74 33                	je     800c52 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c1f:	eb 17                	jmp    800c38 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c21:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c24:	8d 50 01             	lea    0x1(%eax),%edx
+  800c27:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c2a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c2d:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c30:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c33:	0f b6 12             	movzbl (%edx),%edx
+  800c36:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c38:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c3c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c40:	74 0a                	je     800c4c <strlcpy+0x3f>
+  800c42:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c45:	0f b6 00             	movzbl (%eax),%eax
+  800c48:	84 c0                	test   %al,%al
+  800c4a:	75 d5                	jne    800c21 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c4c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c4f:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c52:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c55:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c58:	29 c2                	sub    %eax,%edx
+  800c5a:	89 d0                	mov    %edx,%eax
+}
+  800c5c:	c9                   	leave  
+  800c5d:	c3                   	ret    
+
+00800c5e <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c5e:	55                   	push   %ebp
+  800c5f:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c61:	eb 08                	jmp    800c6b <strcmp+0xd>
+		p++, q++;
+  800c63:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c67:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c6b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c6e:	0f b6 00             	movzbl (%eax),%eax
+  800c71:	84 c0                	test   %al,%al
+  800c73:	74 10                	je     800c85 <strcmp+0x27>
+  800c75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c78:	0f b6 10             	movzbl (%eax),%edx
+  800c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c7e:	0f b6 00             	movzbl (%eax),%eax
+  800c81:	38 c2                	cmp    %al,%dl
+  800c83:	74 de                	je     800c63 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c85:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c88:	0f b6 00             	movzbl (%eax),%eax
+  800c8b:	0f b6 d0             	movzbl %al,%edx
+  800c8e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c91:	0f b6 00             	movzbl (%eax),%eax
+  800c94:	0f b6 c0             	movzbl %al,%eax
+  800c97:	29 c2                	sub    %eax,%edx
+  800c99:	89 d0                	mov    %edx,%eax
+}
+  800c9b:	5d                   	pop    %ebp
+  800c9c:	c3                   	ret    
+
+00800c9d <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c9d:	55                   	push   %ebp
+  800c9e:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800ca0:	eb 0c                	jmp    800cae <strncmp+0x11>
+		n--, p++, q++;
+  800ca2:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800ca6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800caa:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800cae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cb2:	74 1a                	je     800cce <strncmp+0x31>
+  800cb4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb7:	0f b6 00             	movzbl (%eax),%eax
+  800cba:	84 c0                	test   %al,%al
+  800cbc:	74 10                	je     800cce <strncmp+0x31>
+  800cbe:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc1:	0f b6 10             	movzbl (%eax),%edx
+  800cc4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cc7:	0f b6 00             	movzbl (%eax),%eax
+  800cca:	38 c2                	cmp    %al,%dl
+  800ccc:	74 d4                	je     800ca2 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800cce:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cd2:	75 07                	jne    800cdb <strncmp+0x3e>
+		return 0;
+  800cd4:	b8 00 00 00 00       	mov    $0x0,%eax
+  800cd9:	eb 16                	jmp    800cf1 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800cdb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cde:	0f b6 00             	movzbl (%eax),%eax
+  800ce1:	0f b6 d0             	movzbl %al,%edx
+  800ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce7:	0f b6 00             	movzbl (%eax),%eax
+  800cea:	0f b6 c0             	movzbl %al,%eax
+  800ced:	29 c2                	sub    %eax,%edx
+  800cef:	89 d0                	mov    %edx,%eax
+}
+  800cf1:	5d                   	pop    %ebp
+  800cf2:	c3                   	ret    
+
+00800cf3 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800cf3:	55                   	push   %ebp
+  800cf4:	89 e5                	mov    %esp,%ebp
+  800cf6:	83 ec 04             	sub    $0x4,%esp
+  800cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cfc:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cff:	eb 14                	jmp    800d15 <strchr+0x22>
+		if (*s == c)
+  800d01:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d04:	0f b6 00             	movzbl (%eax),%eax
+  800d07:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d0a:	75 05                	jne    800d11 <strchr+0x1e>
+			return (char *) s;
+  800d0c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d0f:	eb 13                	jmp    800d24 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d11:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d18:	0f b6 00             	movzbl (%eax),%eax
+  800d1b:	84 c0                	test   %al,%al
+  800d1d:	75 e2                	jne    800d01 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d1f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d24:	c9                   	leave  
+  800d25:	c3                   	ret    
+
+00800d26 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d26:	55                   	push   %ebp
+  800d27:	89 e5                	mov    %esp,%ebp
+  800d29:	83 ec 04             	sub    $0x4,%esp
+  800d2c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d2f:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d32:	eb 11                	jmp    800d45 <strfind+0x1f>
+		if (*s == c)
+  800d34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d37:	0f b6 00             	movzbl (%eax),%eax
+  800d3a:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d3d:	75 02                	jne    800d41 <strfind+0x1b>
+			break;
+  800d3f:	eb 0e                	jmp    800d4f <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d41:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d45:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d48:	0f b6 00             	movzbl (%eax),%eax
+  800d4b:	84 c0                	test   %al,%al
+  800d4d:	75 e5                	jne    800d34 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d4f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d52:	c9                   	leave  
+  800d53:	c3                   	ret    
+
+00800d54 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d54:	55                   	push   %ebp
+  800d55:	89 e5                	mov    %esp,%ebp
+  800d57:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d58:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d5c:	75 05                	jne    800d63 <memset+0xf>
+		return v;
+  800d5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d61:	eb 5c                	jmp    800dbf <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d63:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d66:	83 e0 03             	and    $0x3,%eax
+  800d69:	85 c0                	test   %eax,%eax
+  800d6b:	75 41                	jne    800dae <memset+0x5a>
+  800d6d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d70:	83 e0 03             	and    $0x3,%eax
+  800d73:	85 c0                	test   %eax,%eax
+  800d75:	75 37                	jne    800dae <memset+0x5a>
+		c &= 0xFF;
+  800d77:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d7e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d81:	c1 e0 18             	shl    $0x18,%eax
+  800d84:	89 c2                	mov    %eax,%edx
+  800d86:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d89:	c1 e0 10             	shl    $0x10,%eax
+  800d8c:	09 c2                	or     %eax,%edx
+  800d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d91:	c1 e0 08             	shl    $0x8,%eax
+  800d94:	09 d0                	or     %edx,%eax
+  800d96:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d99:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d9c:	c1 e8 02             	shr    $0x2,%eax
+  800d9f:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800da1:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da7:	89 d7                	mov    %edx,%edi
+  800da9:	fc                   	cld    
+  800daa:	f3 ab                	rep stos %eax,%es:(%edi)
+  800dac:	eb 0e                	jmp    800dbc <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800dae:	8b 55 08             	mov    0x8(%ebp),%edx
+  800db1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800db4:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800db7:	89 d7                	mov    %edx,%edi
+  800db9:	fc                   	cld    
+  800dba:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800dbc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800dbf:	5f                   	pop    %edi
+  800dc0:	5d                   	pop    %ebp
+  800dc1:	c3                   	ret    
+
+00800dc2 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800dc2:	55                   	push   %ebp
+  800dc3:	89 e5                	mov    %esp,%ebp
+  800dc5:	57                   	push   %edi
+  800dc6:	56                   	push   %esi
+  800dc7:	53                   	push   %ebx
+  800dc8:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dcb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dce:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dda:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800ddd:	73 6d                	jae    800e4c <memmove+0x8a>
+  800ddf:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800de5:	01 d0                	add    %edx,%eax
+  800de7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dea:	76 60                	jbe    800e4c <memmove+0x8a>
+		s += n;
+  800dec:	8b 45 10             	mov    0x10(%ebp),%eax
+  800def:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800df2:	8b 45 10             	mov    0x10(%ebp),%eax
+  800df5:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800df8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dfb:	83 e0 03             	and    $0x3,%eax
+  800dfe:	85 c0                	test   %eax,%eax
+  800e00:	75 2f                	jne    800e31 <memmove+0x6f>
+  800e02:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e05:	83 e0 03             	and    $0x3,%eax
+  800e08:	85 c0                	test   %eax,%eax
+  800e0a:	75 25                	jne    800e31 <memmove+0x6f>
+  800e0c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e0f:	83 e0 03             	and    $0x3,%eax
+  800e12:	85 c0                	test   %eax,%eax
+  800e14:	75 1b                	jne    800e31 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e16:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e19:	83 e8 04             	sub    $0x4,%eax
+  800e1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e1f:	83 ea 04             	sub    $0x4,%edx
+  800e22:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e25:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e28:	89 c7                	mov    %eax,%edi
+  800e2a:	89 d6                	mov    %edx,%esi
+  800e2c:	fd                   	std    
+  800e2d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e2f:	eb 18                	jmp    800e49 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e31:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e34:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e3a:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e3d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e40:	89 d7                	mov    %edx,%edi
+  800e42:	89 de                	mov    %ebx,%esi
+  800e44:	89 c1                	mov    %eax,%ecx
+  800e46:	fd                   	std    
+  800e47:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e49:	fc                   	cld    
+  800e4a:	eb 45                	jmp    800e91 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e4f:	83 e0 03             	and    $0x3,%eax
+  800e52:	85 c0                	test   %eax,%eax
+  800e54:	75 2b                	jne    800e81 <memmove+0xbf>
+  800e56:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e59:	83 e0 03             	and    $0x3,%eax
+  800e5c:	85 c0                	test   %eax,%eax
+  800e5e:	75 21                	jne    800e81 <memmove+0xbf>
+  800e60:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e63:	83 e0 03             	and    $0x3,%eax
+  800e66:	85 c0                	test   %eax,%eax
+  800e68:	75 17                	jne    800e81 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e6a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e6d:	c1 e8 02             	shr    $0x2,%eax
+  800e70:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e72:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e75:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e78:	89 c7                	mov    %eax,%edi
+  800e7a:	89 d6                	mov    %edx,%esi
+  800e7c:	fc                   	cld    
+  800e7d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e7f:	eb 10                	jmp    800e91 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e81:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e84:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e87:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e8a:	89 c7                	mov    %eax,%edi
+  800e8c:	89 d6                	mov    %edx,%esi
+  800e8e:	fc                   	cld    
+  800e8f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e91:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e94:	83 c4 10             	add    $0x10,%esp
+  800e97:	5b                   	pop    %ebx
+  800e98:	5e                   	pop    %esi
+  800e99:	5f                   	pop    %edi
+  800e9a:	5d                   	pop    %ebp
+  800e9b:	c3                   	ret    
+
+00800e9c <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e9c:	55                   	push   %ebp
+  800e9d:	89 e5                	mov    %esp,%ebp
+  800e9f:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800ea2:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ea5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ea9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800eac:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800eb0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eb3:	89 04 24             	mov    %eax,(%esp)
+  800eb6:	e8 07 ff ff ff       	call   800dc2 <memmove>
+}
+  800ebb:	c9                   	leave  
+  800ebc:	c3                   	ret    
+
+00800ebd <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800ebd:	55                   	push   %ebp
+  800ebe:	89 e5                	mov    %esp,%ebp
+  800ec0:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800ec3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ec6:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ecc:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ecf:	eb 30                	jmp    800f01 <memcmp+0x44>
+		if (*s1 != *s2)
+  800ed1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed4:	0f b6 10             	movzbl (%eax),%edx
+  800ed7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eda:	0f b6 00             	movzbl (%eax),%eax
+  800edd:	38 c2                	cmp    %al,%dl
+  800edf:	74 18                	je     800ef9 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ee1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ee4:	0f b6 00             	movzbl (%eax),%eax
+  800ee7:	0f b6 d0             	movzbl %al,%edx
+  800eea:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eed:	0f b6 00             	movzbl (%eax),%eax
+  800ef0:	0f b6 c0             	movzbl %al,%eax
+  800ef3:	29 c2                	sub    %eax,%edx
+  800ef5:	89 d0                	mov    %edx,%eax
+  800ef7:	eb 1a                	jmp    800f13 <memcmp+0x56>
+		s1++, s2++;
+  800ef9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800efd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800f01:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f04:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800f07:	89 55 10             	mov    %edx,0x10(%ebp)
+  800f0a:	85 c0                	test   %eax,%eax
+  800f0c:	75 c3                	jne    800ed1 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800f0e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f13:	c9                   	leave  
+  800f14:	c3                   	ret    
+
+00800f15 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f15:	55                   	push   %ebp
+  800f16:	89 e5                	mov    %esp,%ebp
+  800f18:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f1b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f1e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f21:	01 d0                	add    %edx,%eax
+  800f23:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f26:	eb 13                	jmp    800f3b <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f28:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f2b:	0f b6 10             	movzbl (%eax),%edx
+  800f2e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f31:	38 c2                	cmp    %al,%dl
+  800f33:	75 02                	jne    800f37 <memfind+0x22>
+			break;
+  800f35:	eb 0c                	jmp    800f43 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f37:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f3e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f41:	72 e5                	jb     800f28 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f43:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f46:	c9                   	leave  
+  800f47:	c3                   	ret    
+
+00800f48 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f48:	55                   	push   %ebp
+  800f49:	89 e5                	mov    %esp,%ebp
+  800f4b:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f4e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f55:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f5c:	eb 04                	jmp    800f62 <strtol+0x1a>
+		s++;
+  800f5e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f62:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f65:	0f b6 00             	movzbl (%eax),%eax
+  800f68:	3c 20                	cmp    $0x20,%al
+  800f6a:	74 f2                	je     800f5e <strtol+0x16>
+  800f6c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f6f:	0f b6 00             	movzbl (%eax),%eax
+  800f72:	3c 09                	cmp    $0x9,%al
+  800f74:	74 e8                	je     800f5e <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f76:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f79:	0f b6 00             	movzbl (%eax),%eax
+  800f7c:	3c 2b                	cmp    $0x2b,%al
+  800f7e:	75 06                	jne    800f86 <strtol+0x3e>
+		s++;
+  800f80:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f84:	eb 15                	jmp    800f9b <strtol+0x53>
+	else if (*s == '-')
+  800f86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f89:	0f b6 00             	movzbl (%eax),%eax
+  800f8c:	3c 2d                	cmp    $0x2d,%al
+  800f8e:	75 0b                	jne    800f9b <strtol+0x53>
+		s++, neg = 1;
+  800f90:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f94:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f9f:	74 06                	je     800fa7 <strtol+0x5f>
+  800fa1:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800fa5:	75 24                	jne    800fcb <strtol+0x83>
+  800fa7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800faa:	0f b6 00             	movzbl (%eax),%eax
+  800fad:	3c 30                	cmp    $0x30,%al
+  800faf:	75 1a                	jne    800fcb <strtol+0x83>
+  800fb1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fb4:	83 c0 01             	add    $0x1,%eax
+  800fb7:	0f b6 00             	movzbl (%eax),%eax
+  800fba:	3c 78                	cmp    $0x78,%al
+  800fbc:	75 0d                	jne    800fcb <strtol+0x83>
+		s += 2, base = 16;
+  800fbe:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fc2:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fc9:	eb 2a                	jmp    800ff5 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fcb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fcf:	75 17                	jne    800fe8 <strtol+0xa0>
+  800fd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fd4:	0f b6 00             	movzbl (%eax),%eax
+  800fd7:	3c 30                	cmp    $0x30,%al
+  800fd9:	75 0d                	jne    800fe8 <strtol+0xa0>
+		s++, base = 8;
+  800fdb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fdf:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fe6:	eb 0d                	jmp    800ff5 <strtol+0xad>
+	else if (base == 0)
+  800fe8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fec:	75 07                	jne    800ff5 <strtol+0xad>
+		base = 10;
+  800fee:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800ff5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff8:	0f b6 00             	movzbl (%eax),%eax
+  800ffb:	3c 2f                	cmp    $0x2f,%al
+  800ffd:	7e 1b                	jle    80101a <strtol+0xd2>
+  800fff:	8b 45 08             	mov    0x8(%ebp),%eax
+  801002:	0f b6 00             	movzbl (%eax),%eax
+  801005:	3c 39                	cmp    $0x39,%al
+  801007:	7f 11                	jg     80101a <strtol+0xd2>
+			dig = *s - '0';
+  801009:	8b 45 08             	mov    0x8(%ebp),%eax
+  80100c:	0f b6 00             	movzbl (%eax),%eax
+  80100f:	0f be c0             	movsbl %al,%eax
+  801012:	83 e8 30             	sub    $0x30,%eax
+  801015:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801018:	eb 48                	jmp    801062 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  80101a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101d:	0f b6 00             	movzbl (%eax),%eax
+  801020:	3c 60                	cmp    $0x60,%al
+  801022:	7e 1b                	jle    80103f <strtol+0xf7>
+  801024:	8b 45 08             	mov    0x8(%ebp),%eax
+  801027:	0f b6 00             	movzbl (%eax),%eax
+  80102a:	3c 7a                	cmp    $0x7a,%al
+  80102c:	7f 11                	jg     80103f <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  80102e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801031:	0f b6 00             	movzbl (%eax),%eax
+  801034:	0f be c0             	movsbl %al,%eax
+  801037:	83 e8 57             	sub    $0x57,%eax
+  80103a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80103d:	eb 23                	jmp    801062 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  80103f:	8b 45 08             	mov    0x8(%ebp),%eax
+  801042:	0f b6 00             	movzbl (%eax),%eax
+  801045:	3c 40                	cmp    $0x40,%al
+  801047:	7e 3d                	jle    801086 <strtol+0x13e>
+  801049:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104c:	0f b6 00             	movzbl (%eax),%eax
+  80104f:	3c 5a                	cmp    $0x5a,%al
+  801051:	7f 33                	jg     801086 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801053:	8b 45 08             	mov    0x8(%ebp),%eax
+  801056:	0f b6 00             	movzbl (%eax),%eax
+  801059:	0f be c0             	movsbl %al,%eax
+  80105c:	83 e8 37             	sub    $0x37,%eax
+  80105f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801062:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801065:	3b 45 10             	cmp    0x10(%ebp),%eax
+  801068:	7c 02                	jl     80106c <strtol+0x124>
+			break;
+  80106a:	eb 1a                	jmp    801086 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  80106c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  801070:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801073:	0f af 45 10          	imul   0x10(%ebp),%eax
+  801077:	89 c2                	mov    %eax,%edx
+  801079:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80107c:	01 d0                	add    %edx,%eax
+  80107e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  801081:	e9 6f ff ff ff       	jmp    800ff5 <strtol+0xad>
+
+	if (endptr)
+  801086:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80108a:	74 08                	je     801094 <strtol+0x14c>
+		*endptr = (char *) s;
+  80108c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80108f:	8b 55 08             	mov    0x8(%ebp),%edx
+  801092:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801094:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801098:	74 07                	je     8010a1 <strtol+0x159>
+  80109a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80109d:	f7 d8                	neg    %eax
+  80109f:	eb 03                	jmp    8010a4 <strtol+0x15c>
+  8010a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  8010a4:	c9                   	leave  
+  8010a5:	c3                   	ret    
+  8010a6:	66 90                	xchg   %ax,%ax
+  8010a8:	66 90                	xchg   %ax,%ax
+  8010aa:	66 90                	xchg   %ax,%ax
+  8010ac:	66 90                	xchg   %ax,%ax
+  8010ae:	66 90                	xchg   %ax,%ax
+
+008010b0 <__udivdi3>:
+  8010b0:	55                   	push   %ebp
+  8010b1:	57                   	push   %edi
+  8010b2:	56                   	push   %esi
+  8010b3:	83 ec 0c             	sub    $0xc,%esp
+  8010b6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ba:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010be:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010c2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010c6:	85 c0                	test   %eax,%eax
+  8010c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010cc:	89 ea                	mov    %ebp,%edx
+  8010ce:	89 0c 24             	mov    %ecx,(%esp)
+  8010d1:	75 2d                	jne    801100 <__udivdi3+0x50>
+  8010d3:	39 e9                	cmp    %ebp,%ecx
+  8010d5:	77 61                	ja     801138 <__udivdi3+0x88>
+  8010d7:	85 c9                	test   %ecx,%ecx
+  8010d9:	89 ce                	mov    %ecx,%esi
+  8010db:	75 0b                	jne    8010e8 <__udivdi3+0x38>
+  8010dd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010e2:	31 d2                	xor    %edx,%edx
+  8010e4:	f7 f1                	div    %ecx
+  8010e6:	89 c6                	mov    %eax,%esi
+  8010e8:	31 d2                	xor    %edx,%edx
+  8010ea:	89 e8                	mov    %ebp,%eax
+  8010ec:	f7 f6                	div    %esi
+  8010ee:	89 c5                	mov    %eax,%ebp
+  8010f0:	89 f8                	mov    %edi,%eax
+  8010f2:	f7 f6                	div    %esi
+  8010f4:	89 ea                	mov    %ebp,%edx
+  8010f6:	83 c4 0c             	add    $0xc,%esp
+  8010f9:	5e                   	pop    %esi
+  8010fa:	5f                   	pop    %edi
+  8010fb:	5d                   	pop    %ebp
+  8010fc:	c3                   	ret    
+  8010fd:	8d 76 00             	lea    0x0(%esi),%esi
+  801100:	39 e8                	cmp    %ebp,%eax
+  801102:	77 24                	ja     801128 <__udivdi3+0x78>
+  801104:	0f bd e8             	bsr    %eax,%ebp
+  801107:	83 f5 1f             	xor    $0x1f,%ebp
+  80110a:	75 3c                	jne    801148 <__udivdi3+0x98>
+  80110c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801110:	39 34 24             	cmp    %esi,(%esp)
+  801113:	0f 86 9f 00 00 00    	jbe    8011b8 <__udivdi3+0x108>
+  801119:	39 d0                	cmp    %edx,%eax
+  80111b:	0f 82 97 00 00 00    	jb     8011b8 <__udivdi3+0x108>
+  801121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801128:	31 d2                	xor    %edx,%edx
+  80112a:	31 c0                	xor    %eax,%eax
+  80112c:	83 c4 0c             	add    $0xc,%esp
+  80112f:	5e                   	pop    %esi
+  801130:	5f                   	pop    %edi
+  801131:	5d                   	pop    %ebp
+  801132:	c3                   	ret    
+  801133:	90                   	nop
+  801134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801138:	89 f8                	mov    %edi,%eax
+  80113a:	f7 f1                	div    %ecx
+  80113c:	31 d2                	xor    %edx,%edx
+  80113e:	83 c4 0c             	add    $0xc,%esp
+  801141:	5e                   	pop    %esi
+  801142:	5f                   	pop    %edi
+  801143:	5d                   	pop    %ebp
+  801144:	c3                   	ret    
+  801145:	8d 76 00             	lea    0x0(%esi),%esi
+  801148:	89 e9                	mov    %ebp,%ecx
+  80114a:	8b 3c 24             	mov    (%esp),%edi
+  80114d:	d3 e0                	shl    %cl,%eax
+  80114f:	89 c6                	mov    %eax,%esi
+  801151:	b8 20 00 00 00       	mov    $0x20,%eax
+  801156:	29 e8                	sub    %ebp,%eax
+  801158:	89 c1                	mov    %eax,%ecx
+  80115a:	d3 ef                	shr    %cl,%edi
+  80115c:	89 e9                	mov    %ebp,%ecx
+  80115e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801162:	8b 3c 24             	mov    (%esp),%edi
+  801165:	09 74 24 08          	or     %esi,0x8(%esp)
+  801169:	89 d6                	mov    %edx,%esi
+  80116b:	d3 e7                	shl    %cl,%edi
+  80116d:	89 c1                	mov    %eax,%ecx
+  80116f:	89 3c 24             	mov    %edi,(%esp)
+  801172:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801176:	d3 ee                	shr    %cl,%esi
+  801178:	89 e9                	mov    %ebp,%ecx
+  80117a:	d3 e2                	shl    %cl,%edx
+  80117c:	89 c1                	mov    %eax,%ecx
+  80117e:	d3 ef                	shr    %cl,%edi
+  801180:	09 d7                	or     %edx,%edi
+  801182:	89 f2                	mov    %esi,%edx
+  801184:	89 f8                	mov    %edi,%eax
+  801186:	f7 74 24 08          	divl   0x8(%esp)
+  80118a:	89 d6                	mov    %edx,%esi
+  80118c:	89 c7                	mov    %eax,%edi
+  80118e:	f7 24 24             	mull   (%esp)
+  801191:	39 d6                	cmp    %edx,%esi
+  801193:	89 14 24             	mov    %edx,(%esp)
+  801196:	72 30                	jb     8011c8 <__udivdi3+0x118>
+  801198:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80119c:	89 e9                	mov    %ebp,%ecx
+  80119e:	d3 e2                	shl    %cl,%edx
+  8011a0:	39 c2                	cmp    %eax,%edx
+  8011a2:	73 05                	jae    8011a9 <__udivdi3+0xf9>
+  8011a4:	3b 34 24             	cmp    (%esp),%esi
+  8011a7:	74 1f                	je     8011c8 <__udivdi3+0x118>
+  8011a9:	89 f8                	mov    %edi,%eax
+  8011ab:	31 d2                	xor    %edx,%edx
+  8011ad:	e9 7a ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011b8:	31 d2                	xor    %edx,%edx
+  8011ba:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011bf:	e9 68 ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011c8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011cb:	31 d2                	xor    %edx,%edx
+  8011cd:	83 c4 0c             	add    $0xc,%esp
+  8011d0:	5e                   	pop    %esi
+  8011d1:	5f                   	pop    %edi
+  8011d2:	5d                   	pop    %ebp
+  8011d3:	c3                   	ret    
+  8011d4:	66 90                	xchg   %ax,%ax
+  8011d6:	66 90                	xchg   %ax,%ax
+  8011d8:	66 90                	xchg   %ax,%ax
+  8011da:	66 90                	xchg   %ax,%ax
+  8011dc:	66 90                	xchg   %ax,%ax
+  8011de:	66 90                	xchg   %ax,%ax
+
+008011e0 <__umoddi3>:
+  8011e0:	55                   	push   %ebp
+  8011e1:	57                   	push   %edi
+  8011e2:	56                   	push   %esi
+  8011e3:	83 ec 14             	sub    $0x14,%esp
+  8011e6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011ee:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011f2:	89 c7                	mov    %eax,%edi
+  8011f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011f8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011fc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801200:	89 34 24             	mov    %esi,(%esp)
+  801203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801207:	85 c0                	test   %eax,%eax
+  801209:	89 c2                	mov    %eax,%edx
+  80120b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80120f:	75 17                	jne    801228 <__umoddi3+0x48>
+  801211:	39 fe                	cmp    %edi,%esi
+  801213:	76 4b                	jbe    801260 <__umoddi3+0x80>
+  801215:	89 c8                	mov    %ecx,%eax
+  801217:	89 fa                	mov    %edi,%edx
+  801219:	f7 f6                	div    %esi
+  80121b:	89 d0                	mov    %edx,%eax
+  80121d:	31 d2                	xor    %edx,%edx
+  80121f:	83 c4 14             	add    $0x14,%esp
+  801222:	5e                   	pop    %esi
+  801223:	5f                   	pop    %edi
+  801224:	5d                   	pop    %ebp
+  801225:	c3                   	ret    
+  801226:	66 90                	xchg   %ax,%ax
+  801228:	39 f8                	cmp    %edi,%eax
+  80122a:	77 54                	ja     801280 <__umoddi3+0xa0>
+  80122c:	0f bd e8             	bsr    %eax,%ebp
+  80122f:	83 f5 1f             	xor    $0x1f,%ebp
+  801232:	75 5c                	jne    801290 <__umoddi3+0xb0>
+  801234:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801238:	39 3c 24             	cmp    %edi,(%esp)
+  80123b:	0f 87 e7 00 00 00    	ja     801328 <__umoddi3+0x148>
+  801241:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801245:	29 f1                	sub    %esi,%ecx
+  801247:	19 c7                	sbb    %eax,%edi
+  801249:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80124d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801251:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801255:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801259:	83 c4 14             	add    $0x14,%esp
+  80125c:	5e                   	pop    %esi
+  80125d:	5f                   	pop    %edi
+  80125e:	5d                   	pop    %ebp
+  80125f:	c3                   	ret    
+  801260:	85 f6                	test   %esi,%esi
+  801262:	89 f5                	mov    %esi,%ebp
+  801264:	75 0b                	jne    801271 <__umoddi3+0x91>
+  801266:	b8 01 00 00 00       	mov    $0x1,%eax
+  80126b:	31 d2                	xor    %edx,%edx
+  80126d:	f7 f6                	div    %esi
+  80126f:	89 c5                	mov    %eax,%ebp
+  801271:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801275:	31 d2                	xor    %edx,%edx
+  801277:	f7 f5                	div    %ebp
+  801279:	89 c8                	mov    %ecx,%eax
+  80127b:	f7 f5                	div    %ebp
+  80127d:	eb 9c                	jmp    80121b <__umoddi3+0x3b>
+  80127f:	90                   	nop
+  801280:	89 c8                	mov    %ecx,%eax
+  801282:	89 fa                	mov    %edi,%edx
+  801284:	83 c4 14             	add    $0x14,%esp
+  801287:	5e                   	pop    %esi
+  801288:	5f                   	pop    %edi
+  801289:	5d                   	pop    %ebp
+  80128a:	c3                   	ret    
+  80128b:	90                   	nop
+  80128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801290:	8b 04 24             	mov    (%esp),%eax
+  801293:	be 20 00 00 00       	mov    $0x20,%esi
+  801298:	89 e9                	mov    %ebp,%ecx
+  80129a:	29 ee                	sub    %ebp,%esi
+  80129c:	d3 e2                	shl    %cl,%edx
+  80129e:	89 f1                	mov    %esi,%ecx
+  8012a0:	d3 e8                	shr    %cl,%eax
+  8012a2:	89 e9                	mov    %ebp,%ecx
+  8012a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012a8:	8b 04 24             	mov    (%esp),%eax
+  8012ab:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012af:	89 fa                	mov    %edi,%edx
+  8012b1:	d3 e0                	shl    %cl,%eax
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012b9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012bd:	d3 ea                	shr    %cl,%edx
+  8012bf:	89 e9                	mov    %ebp,%ecx
+  8012c1:	d3 e7                	shl    %cl,%edi
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	d3 e8                	shr    %cl,%eax
+  8012c7:	89 e9                	mov    %ebp,%ecx
+  8012c9:	09 f8                	or     %edi,%eax
+  8012cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012cf:	f7 74 24 04          	divl   0x4(%esp)
+  8012d3:	d3 e7                	shl    %cl,%edi
+  8012d5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012d9:	89 d7                	mov    %edx,%edi
+  8012db:	f7 64 24 08          	mull   0x8(%esp)
+  8012df:	39 d7                	cmp    %edx,%edi
+  8012e1:	89 c1                	mov    %eax,%ecx
+  8012e3:	89 14 24             	mov    %edx,(%esp)
+  8012e6:	72 2c                	jb     801314 <__umoddi3+0x134>
+  8012e8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012ec:	72 22                	jb     801310 <__umoddi3+0x130>
+  8012ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012f2:	29 c8                	sub    %ecx,%eax
+  8012f4:	19 d7                	sbb    %edx,%edi
+  8012f6:	89 e9                	mov    %ebp,%ecx
+  8012f8:	89 fa                	mov    %edi,%edx
+  8012fa:	d3 e8                	shr    %cl,%eax
+  8012fc:	89 f1                	mov    %esi,%ecx
+  8012fe:	d3 e2                	shl    %cl,%edx
+  801300:	89 e9                	mov    %ebp,%ecx
+  801302:	d3 ef                	shr    %cl,%edi
+  801304:	09 d0                	or     %edx,%eax
+  801306:	89 fa                	mov    %edi,%edx
+  801308:	83 c4 14             	add    $0x14,%esp
+  80130b:	5e                   	pop    %esi
+  80130c:	5f                   	pop    %edi
+  80130d:	5d                   	pop    %ebp
+  80130e:	c3                   	ret    
+  80130f:	90                   	nop
+  801310:	39 d7                	cmp    %edx,%edi
+  801312:	75 da                	jne    8012ee <__umoddi3+0x10e>
+  801314:	8b 14 24             	mov    (%esp),%edx
+  801317:	89 c1                	mov    %eax,%ecx
+  801319:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80131d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801321:	eb cb                	jmp    8012ee <__umoddi3+0x10e>
+  801323:	90                   	nop
+  801324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801328:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80132c:	0f 82 0f ff ff ff    	jb     801241 <__umoddi3+0x61>
+  801332:	e9 1a ff ff ff       	jmp    801251 <__umoddi3+0x71>
diff --git a/obj/user/buggyhello.o b/obj/user/buggyhello.o
new file mode 100644
index 0000000..941bc0d
Binary files /dev/null and b/obj/user/buggyhello.o differ
diff --git a/obj/user/buggyhello.sym b/obj/user/buggyhello.sym
new file mode 100644
index 0000000..f43f8a3
--- /dev/null
+++ b/obj/user/buggyhello.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040d0 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080004f T libmain
+0080009d T exit
+008000b1 t syscall
+00800112 T sys_cputs
+00800154 T sys_cgetc
+00800198 T sys_env_destroy
+008001db T sys_getenvid
+0080021f T _panic
+0080027a t putch
+008002d6 T vcprintf
+0080033a T cprintf
+00800360 t printnum
+0080043e t getuint
+0080048d t getint
+008004d4 T vprintfmt
+00800a1b T printfmt
+00800a49 t sprintputch
+00800a7e T vsnprintf
+00800ade T snprintf
+00800b12 T strlen
+00800b38 T strnlen
+00800b68 T strcpy
+00800b98 T strcat
+00800bc8 T strncpy
+00800c0d T strlcpy
+00800c5e T strcmp
+00800c9d T strncmp
+00800cf3 T strchr
+00800d26 T strfind
+00800d54 T memset
+00800dc2 T memmove
+00800e9c T memcpy
+00800ebd T memcmp
+00800f15 T memfind
+00800f48 T strtol
+008010b0 T __udivdi3
+008011e0 T __umoddi3
+00801404 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/buggyhello2 b/obj/user/buggyhello2
new file mode 100755
index 0000000..d576236
Binary files /dev/null and b/obj/user/buggyhello2 differ
diff --git a/obj/user/buggyhello2.asm b/obj/user/buggyhello2.asm
new file mode 100644
index 0000000..8bc564b
--- /dev/null
+++ b/obj/user/buggyhello2.asm
@@ -0,0 +1,2629 @@
+
+obj/user/buggyhello2:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 1f 00 00 00       	call   800050 <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+const char *hello = "hello, world\n";
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	sys_cputs(hello, 1024*1024);
+  800039:	a1 00 20 80 00       	mov    0x802000,%eax
+  80003e:	c7 44 24 04 00 00 10 	movl   $0x100000,0x4(%esp)
+  800045:	00 
+  800046:	89 04 24             	mov    %eax,(%esp)
+  800049:	e8 c5 00 00 00       	call   800113 <sys_cputs>
+}
+  80004e:	c9                   	leave  
+  80004f:	c3                   	ret    
+
+00800050 <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  800050:	55                   	push   %ebp
+  800051:	89 e5                	mov    %esp,%ebp
+  800053:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800056:	e8 81 01 00 00       	call   8001dc <sys_getenvid>
+  80005b:	25 ff 03 00 00       	and    $0x3ff,%eax
+  800060:	89 c2                	mov    %eax,%edx
+  800062:	89 d0                	mov    %edx,%eax
+  800064:	01 c0                	add    %eax,%eax
+  800066:	01 d0                	add    %edx,%eax
+  800068:	c1 e0 05             	shl    $0x5,%eax
+  80006b:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  800070:	a3 08 20 80 00       	mov    %eax,0x802008
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800075:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800079:	7e 0a                	jle    800085 <libmain+0x35>
+		binaryname = argv[0];
+  80007b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80007e:	8b 00                	mov    (%eax),%eax
+  800080:	a3 04 20 80 00       	mov    %eax,0x802004
+
+	// call user main routine
+	umain(argc, argv);
+  800085:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800088:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80008c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80008f:	89 04 24             	mov    %eax,(%esp)
+  800092:	e8 9c ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800097:	e8 02 00 00 00       	call   80009e <exit>
+}
+  80009c:	c9                   	leave  
+  80009d:	c3                   	ret    
+
+0080009e <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  80009e:	55                   	push   %ebp
+  80009f:	89 e5                	mov    %esp,%ebp
+  8000a1:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000a4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000ab:	e8 e9 00 00 00       	call   800199 <sys_env_destroy>
+}
+  8000b0:	c9                   	leave  
+  8000b1:	c3                   	ret    
+
+008000b2 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000b2:	55                   	push   %ebp
+  8000b3:	89 e5                	mov    %esp,%ebp
+  8000b5:	57                   	push   %edi
+  8000b6:	56                   	push   %esi
+  8000b7:	53                   	push   %ebx
+  8000b8:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000bb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000be:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000c1:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000c4:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000c7:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000ca:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000cd:	cd 30                	int    $0x30
+  8000cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000d2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000d6:	74 30                	je     800108 <syscall+0x56>
+  8000d8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000dc:	7e 2a                	jle    800108 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000e1:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000e8:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000ec:	c7 44 24 08 50 13 80 	movl   $0x801350,0x8(%esp)
+  8000f3:	00 
+  8000f4:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000fb:	00 
+  8000fc:	c7 04 24 6d 13 80 00 	movl   $0x80136d,(%esp)
+  800103:	e8 18 01 00 00       	call   800220 <_panic>
+
+	return ret;
+  800108:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  80010b:	83 c4 3c             	add    $0x3c,%esp
+  80010e:	5b                   	pop    %ebx
+  80010f:	5e                   	pop    %esi
+  800110:	5f                   	pop    %edi
+  800111:	5d                   	pop    %ebp
+  800112:	c3                   	ret    
+
+00800113 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800113:	55                   	push   %ebp
+  800114:	89 e5                	mov    %esp,%ebp
+  800116:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800119:	8b 45 08             	mov    0x8(%ebp),%eax
+  80011c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800123:	00 
+  800124:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80012b:	00 
+  80012c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800133:	00 
+  800134:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800137:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80013b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80013f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800146:	00 
+  800147:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80014e:	e8 5f ff ff ff       	call   8000b2 <syscall>
+}
+  800153:	c9                   	leave  
+  800154:	c3                   	ret    
+
+00800155 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800155:	55                   	push   %ebp
+  800156:	89 e5                	mov    %esp,%ebp
+  800158:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  80015b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800162:	00 
+  800163:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80016a:	00 
+  80016b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800172:	00 
+  800173:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  80017a:	00 
+  80017b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800182:	00 
+  800183:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80018a:	00 
+  80018b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800192:	e8 1b ff ff ff       	call   8000b2 <syscall>
+}
+  800197:	c9                   	leave  
+  800198:	c3                   	ret    
+
+00800199 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800199:	55                   	push   %ebp
+  80019a:	89 e5                	mov    %esp,%ebp
+  80019c:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  80019f:	8b 45 08             	mov    0x8(%ebp),%eax
+  8001a2:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001a9:	00 
+  8001aa:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001b1:	00 
+  8001b2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001b9:	00 
+  8001ba:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001c1:	00 
+  8001c2:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001c6:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001cd:	00 
+  8001ce:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001d5:	e8 d8 fe ff ff       	call   8000b2 <syscall>
+}
+  8001da:	c9                   	leave  
+  8001db:	c3                   	ret    
+
+008001dc <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001dc:	55                   	push   %ebp
+  8001dd:	89 e5                	mov    %esp,%ebp
+  8001df:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001e2:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001e9:	00 
+  8001ea:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001f1:	00 
+  8001f2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001f9:	00 
+  8001fa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800201:	00 
+  800202:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800209:	00 
+  80020a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800211:	00 
+  800212:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  800219:	e8 94 fe ff ff       	call   8000b2 <syscall>
+}
+  80021e:	c9                   	leave  
+  80021f:	c3                   	ret    
+
+00800220 <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  800220:	55                   	push   %ebp
+  800221:	89 e5                	mov    %esp,%ebp
+  800223:	53                   	push   %ebx
+  800224:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800227:	8d 45 14             	lea    0x14(%ebp),%eax
+  80022a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80022d:	8b 1d 04 20 80 00    	mov    0x802004,%ebx
+  800233:	e8 a4 ff ff ff       	call   8001dc <sys_getenvid>
+  800238:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80023b:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80023f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800242:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800246:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  80024a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80024e:	c7 04 24 7c 13 80 00 	movl   $0x80137c,(%esp)
+  800255:	e8 e1 00 00 00       	call   80033b <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  80025a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80025d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800261:	8b 45 10             	mov    0x10(%ebp),%eax
+  800264:	89 04 24             	mov    %eax,(%esp)
+  800267:	e8 6b 00 00 00       	call   8002d7 <vcprintf>
+	cprintf("\n");
+  80026c:	c7 04 24 9f 13 80 00 	movl   $0x80139f,(%esp)
+  800273:	e8 c3 00 00 00       	call   80033b <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  800278:	cc                   	int3   
+  800279:	eb fd                	jmp    800278 <_panic+0x58>
+
+0080027b <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  80027b:	55                   	push   %ebp
+  80027c:	89 e5                	mov    %esp,%ebp
+  80027e:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  800281:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800284:	8b 00                	mov    (%eax),%eax
+  800286:	8d 48 01             	lea    0x1(%eax),%ecx
+  800289:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80028c:	89 0a                	mov    %ecx,(%edx)
+  80028e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800291:	89 d1                	mov    %edx,%ecx
+  800293:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800296:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  80029a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80029d:	8b 00                	mov    (%eax),%eax
+  80029f:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8002a4:	75 20                	jne    8002c6 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8002a6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a9:	8b 00                	mov    (%eax),%eax
+  8002ab:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8002ae:	83 c2 08             	add    $0x8,%edx
+  8002b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002b5:	89 14 24             	mov    %edx,(%esp)
+  8002b8:	e8 56 fe ff ff       	call   800113 <sys_cputs>
+		b->idx = 0;
+  8002bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c9:	8b 40 04             	mov    0x4(%eax),%eax
+  8002cc:	8d 50 01             	lea    0x1(%eax),%edx
+  8002cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002d2:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002d5:	c9                   	leave  
+  8002d6:	c3                   	ret    
+
+008002d7 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002d7:	55                   	push   %ebp
+  8002d8:	89 e5                	mov    %esp,%ebp
+  8002da:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002e0:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002e7:	00 00 00 
+	b.cnt = 0;
+  8002ea:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002f1:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002f4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002fe:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800302:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800308:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80030c:	c7 04 24 7b 02 80 00 	movl   $0x80027b,(%esp)
+  800313:	e8 bd 01 00 00       	call   8004d5 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800318:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  80031e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800322:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800328:	83 c0 08             	add    $0x8,%eax
+  80032b:	89 04 24             	mov    %eax,(%esp)
+  80032e:	e8 e0 fd ff ff       	call   800113 <sys_cputs>
+
+	return b.cnt;
+  800333:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800339:	c9                   	leave  
+  80033a:	c3                   	ret    
+
+0080033b <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  80033b:	55                   	push   %ebp
+  80033c:	89 e5                	mov    %esp,%ebp
+  80033e:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  800341:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800344:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800347:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80034a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80034e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800351:	89 04 24             	mov    %eax,(%esp)
+  800354:	e8 7e ff ff ff       	call   8002d7 <vcprintf>
+  800359:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  80035c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80035f:	c9                   	leave  
+  800360:	c3                   	ret    
+
+00800361 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  800361:	55                   	push   %ebp
+  800362:	89 e5                	mov    %esp,%ebp
+  800364:	53                   	push   %ebx
+  800365:	83 ec 34             	sub    $0x34,%esp
+  800368:	8b 45 10             	mov    0x10(%ebp),%eax
+  80036b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80036e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800371:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800374:	8b 45 18             	mov    0x18(%ebp),%eax
+  800377:	ba 00 00 00 00       	mov    $0x0,%edx
+  80037c:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  80037f:	77 72                	ja     8003f3 <printnum+0x92>
+  800381:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800384:	72 05                	jb     80038b <printnum+0x2a>
+  800386:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  800389:	77 68                	ja     8003f3 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  80038b:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  80038e:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  800391:	8b 45 18             	mov    0x18(%ebp),%eax
+  800394:	ba 00 00 00 00       	mov    $0x0,%edx
+  800399:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80039d:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003a7:	89 04 24             	mov    %eax,(%esp)
+  8003aa:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8003ae:	e8 fd 0c 00 00       	call   8010b0 <__udivdi3>
+  8003b3:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003b6:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003ba:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003be:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003c1:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003c5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003c9:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003d0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003d7:	89 04 24             	mov    %eax,(%esp)
+  8003da:	e8 82 ff ff ff       	call   800361 <printnum>
+  8003df:	eb 1c                	jmp    8003fd <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003e8:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003eb:	89 04 24             	mov    %eax,(%esp)
+  8003ee:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003f1:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003f3:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003f7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003fb:	7f e4                	jg     8003e1 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003fd:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  800400:	bb 00 00 00 00       	mov    $0x0,%ebx
+  800405:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800408:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80040b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80040f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800413:	89 04 24             	mov    %eax,(%esp)
+  800416:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80041a:	e8 c1 0d 00 00       	call   8011e0 <__umoddi3>
+  80041f:	05 2c 14 80 00       	add    $0x80142c,%eax
+  800424:	0f b6 00             	movzbl (%eax),%eax
+  800427:	0f be c0             	movsbl %al,%eax
+  80042a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80042d:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800431:	89 04 24             	mov    %eax,(%esp)
+  800434:	8b 45 08             	mov    0x8(%ebp),%eax
+  800437:	ff d0                	call   *%eax
+}
+  800439:	83 c4 34             	add    $0x34,%esp
+  80043c:	5b                   	pop    %ebx
+  80043d:	5d                   	pop    %ebp
+  80043e:	c3                   	ret    
+
+0080043f <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  80043f:	55                   	push   %ebp
+  800440:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800442:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800446:	7e 14                	jle    80045c <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800448:	8b 45 08             	mov    0x8(%ebp),%eax
+  80044b:	8b 00                	mov    (%eax),%eax
+  80044d:	8d 48 08             	lea    0x8(%eax),%ecx
+  800450:	8b 55 08             	mov    0x8(%ebp),%edx
+  800453:	89 0a                	mov    %ecx,(%edx)
+  800455:	8b 50 04             	mov    0x4(%eax),%edx
+  800458:	8b 00                	mov    (%eax),%eax
+  80045a:	eb 30                	jmp    80048c <getuint+0x4d>
+	else if (lflag)
+  80045c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800460:	74 16                	je     800478 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  800462:	8b 45 08             	mov    0x8(%ebp),%eax
+  800465:	8b 00                	mov    (%eax),%eax
+  800467:	8d 48 04             	lea    0x4(%eax),%ecx
+  80046a:	8b 55 08             	mov    0x8(%ebp),%edx
+  80046d:	89 0a                	mov    %ecx,(%edx)
+  80046f:	8b 00                	mov    (%eax),%eax
+  800471:	ba 00 00 00 00       	mov    $0x0,%edx
+  800476:	eb 14                	jmp    80048c <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  800478:	8b 45 08             	mov    0x8(%ebp),%eax
+  80047b:	8b 00                	mov    (%eax),%eax
+  80047d:	8d 48 04             	lea    0x4(%eax),%ecx
+  800480:	8b 55 08             	mov    0x8(%ebp),%edx
+  800483:	89 0a                	mov    %ecx,(%edx)
+  800485:	8b 00                	mov    (%eax),%eax
+  800487:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  80048c:	5d                   	pop    %ebp
+  80048d:	c3                   	ret    
+
+0080048e <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  80048e:	55                   	push   %ebp
+  80048f:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800491:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800495:	7e 14                	jle    8004ab <getint+0x1d>
+		return va_arg(*ap, long long);
+  800497:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049a:	8b 00                	mov    (%eax),%eax
+  80049c:	8d 48 08             	lea    0x8(%eax),%ecx
+  80049f:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004a2:	89 0a                	mov    %ecx,(%edx)
+  8004a4:	8b 50 04             	mov    0x4(%eax),%edx
+  8004a7:	8b 00                	mov    (%eax),%eax
+  8004a9:	eb 28                	jmp    8004d3 <getint+0x45>
+	else if (lflag)
+  8004ab:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8004af:	74 12                	je     8004c3 <getint+0x35>
+		return va_arg(*ap, long);
+  8004b1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b4:	8b 00                	mov    (%eax),%eax
+  8004b6:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004b9:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004bc:	89 0a                	mov    %ecx,(%edx)
+  8004be:	8b 00                	mov    (%eax),%eax
+  8004c0:	99                   	cltd   
+  8004c1:	eb 10                	jmp    8004d3 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004c3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004c6:	8b 00                	mov    (%eax),%eax
+  8004c8:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004cb:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004ce:	89 0a                	mov    %ecx,(%edx)
+  8004d0:	8b 00                	mov    (%eax),%eax
+  8004d2:	99                   	cltd   
+}
+  8004d3:	5d                   	pop    %ebp
+  8004d4:	c3                   	ret    
+
+008004d5 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004d5:	55                   	push   %ebp
+  8004d6:	89 e5                	mov    %esp,%ebp
+  8004d8:	56                   	push   %esi
+  8004d9:	53                   	push   %ebx
+  8004da:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004dd:	e9 72 01 00 00       	jmp    800654 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004e2:	85 db                	test   %ebx,%ebx
+  8004e4:	75 05                	jne    8004eb <vprintfmt+0x16>
+				return;
+  8004e6:	e9 2a 05 00 00       	jmp    800a15 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004eb:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004ee:	0f 85 51 01 00 00    	jne    800645 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004f4:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004f7:	8d 50 01             	lea    0x1(%eax),%edx
+  8004fa:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004fd:	0f b6 00             	movzbl (%eax),%eax
+  800500:	0f b6 d8             	movzbl %al,%ebx
+  800503:	83 fb 5b             	cmp    $0x5b,%ebx
+  800506:	74 14                	je     80051c <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800508:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80050b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80050f:	89 1c 24             	mov    %ebx,(%esp)
+  800512:	8b 45 08             	mov    0x8(%ebp),%eax
+  800515:	ff d0                	call   *%eax
+				    continue;
+  800517:	e9 38 01 00 00       	jmp    800654 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  80051c:	8b 45 10             	mov    0x10(%ebp),%eax
+  80051f:	8d 50 01             	lea    0x1(%eax),%edx
+  800522:	89 55 10             	mov    %edx,0x10(%ebp)
+  800525:	0f b6 00             	movzbl (%eax),%eax
+  800528:	0f b6 c0             	movzbl %al,%eax
+  80052b:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				FG_COLOR = *(unsigned char *) fmt++;
+  800530:	8b 45 10             	mov    0x10(%ebp),%eax
+  800533:	8d 50 01             	lea    0x1(%eax),%edx
+  800536:	89 55 10             	mov    %edx,0x10(%ebp)
+  800539:	0f b6 00             	movzbl (%eax),%eax
+  80053c:	0f b6 c0             	movzbl %al,%eax
+  80053f:	a3 14 20 80 00       	mov    %eax,0x802014
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800544:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800549:	83 f8 2f             	cmp    $0x2f,%eax
+  80054c:	7e 19                	jle    800567 <vprintfmt+0x92>
+  80054e:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800553:	83 f8 39             	cmp    $0x39,%eax
+  800556:	7f 0f                	jg     800567 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800558:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  80055d:	83 e8 30             	sub    $0x30,%eax
+  800560:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  800565:	eb 50                	jmp    8005b7 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  800567:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  80056c:	83 f8 60             	cmp    $0x60,%eax
+  80056f:	7e 19                	jle    80058a <vprintfmt+0xb5>
+  800571:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800576:	83 f8 66             	cmp    $0x66,%eax
+  800579:	7f 0f                	jg     80058a <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  80057b:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800580:	83 e8 57             	sub    $0x57,%eax
+  800583:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  800588:	eb 2d                	jmp    8005b7 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  80058a:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  80058f:	83 f8 40             	cmp    $0x40,%eax
+  800592:	7e 19                	jle    8005ad <vprintfmt+0xd8>
+  800594:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800599:	83 f8 46             	cmp    $0x46,%eax
+  80059c:	7f 0f                	jg     8005ad <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  80059e:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8005a3:	83 e8 37             	sub    $0x37,%eax
+  8005a6:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  8005ab:	eb 0a                	jmp    8005b7 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8005ad:	c7 05 0c 20 80 00 00 	movl   $0x0,0x80200c
+  8005b4:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005b7:	a1 14 20 80 00       	mov    0x802014,%eax
+  8005bc:	83 f8 2f             	cmp    $0x2f,%eax
+  8005bf:	7e 19                	jle    8005da <vprintfmt+0x105>
+  8005c1:	a1 14 20 80 00       	mov    0x802014,%eax
+  8005c6:	83 f8 39             	cmp    $0x39,%eax
+  8005c9:	7f 0f                	jg     8005da <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005cb:	a1 14 20 80 00       	mov    0x802014,%eax
+  8005d0:	83 e8 30             	sub    $0x30,%eax
+  8005d3:	a3 14 20 80 00       	mov    %eax,0x802014
+  8005d8:	eb 50                	jmp    80062a <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005da:	a1 14 20 80 00       	mov    0x802014,%eax
+  8005df:	83 f8 60             	cmp    $0x60,%eax
+  8005e2:	7e 19                	jle    8005fd <vprintfmt+0x128>
+  8005e4:	a1 14 20 80 00       	mov    0x802014,%eax
+  8005e9:	83 f8 66             	cmp    $0x66,%eax
+  8005ec:	7f 0f                	jg     8005fd <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005ee:	a1 14 20 80 00       	mov    0x802014,%eax
+  8005f3:	83 e8 57             	sub    $0x57,%eax
+  8005f6:	a3 14 20 80 00       	mov    %eax,0x802014
+  8005fb:	eb 2d                	jmp    80062a <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005fd:	a1 14 20 80 00       	mov    0x802014,%eax
+  800602:	83 f8 40             	cmp    $0x40,%eax
+  800605:	7e 19                	jle    800620 <vprintfmt+0x14b>
+  800607:	a1 14 20 80 00       	mov    0x802014,%eax
+  80060c:	83 f8 46             	cmp    $0x46,%eax
+  80060f:	7f 0f                	jg     800620 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  800611:	a1 14 20 80 00       	mov    0x802014,%eax
+  800616:	83 e8 37             	sub    $0x37,%eax
+  800619:	a3 14 20 80 00       	mov    %eax,0x802014
+  80061e:	eb 0a                	jmp    80062a <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  800620:	c7 05 0c 20 80 00 07 	movl   $0x7,0x80200c
+  800627:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  80062a:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  80062f:	c1 e0 0c             	shl    $0xc,%eax
+  800632:	89 c2                	mov    %eax,%edx
+  800634:	a1 14 20 80 00       	mov    0x802014,%eax
+  800639:	c1 e0 08             	shl    $0x8,%eax
+  80063c:	09 d0                	or     %edx,%eax
+  80063e:	a3 10 20 80 00       	mov    %eax,0x802010
+				continue;
+  800643:	eb 0f                	jmp    800654 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800645:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800648:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80064c:	89 1c 24             	mov    %ebx,(%esp)
+  80064f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800652:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800654:	8b 45 10             	mov    0x10(%ebp),%eax
+  800657:	8d 50 01             	lea    0x1(%eax),%edx
+  80065a:	89 55 10             	mov    %edx,0x10(%ebp)
+  80065d:	0f b6 00             	movzbl (%eax),%eax
+  800660:	0f b6 d8             	movzbl %al,%ebx
+  800663:	83 fb 25             	cmp    $0x25,%ebx
+  800666:	0f 85 76 fe ff ff    	jne    8004e2 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  80066c:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  800670:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  800677:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  80067e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800685:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  80068c:	8b 45 10             	mov    0x10(%ebp),%eax
+  80068f:	8d 50 01             	lea    0x1(%eax),%edx
+  800692:	89 55 10             	mov    %edx,0x10(%ebp)
+  800695:	0f b6 00             	movzbl (%eax),%eax
+  800698:	0f b6 d8             	movzbl %al,%ebx
+  80069b:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  80069e:	83 f8 55             	cmp    $0x55,%eax
+  8006a1:	0f 87 3d 03 00 00    	ja     8009e4 <vprintfmt+0x50f>
+  8006a7:	8b 04 85 50 14 80 00 	mov    0x801450(,%eax,4),%eax
+  8006ae:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8006b0:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006b4:	eb d6                	jmp    80068c <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006b6:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006ba:	eb d0                	jmp    80068c <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006c3:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006c6:	89 d0                	mov    %edx,%eax
+  8006c8:	c1 e0 02             	shl    $0x2,%eax
+  8006cb:	01 d0                	add    %edx,%eax
+  8006cd:	01 c0                	add    %eax,%eax
+  8006cf:	01 d8                	add    %ebx,%eax
+  8006d1:	83 e8 30             	sub    $0x30,%eax
+  8006d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006d7:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006da:	0f b6 00             	movzbl (%eax),%eax
+  8006dd:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006e0:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006e3:	7e 0b                	jle    8006f0 <vprintfmt+0x21b>
+  8006e5:	83 fb 39             	cmp    $0x39,%ebx
+  8006e8:	7f 06                	jg     8006f0 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006ea:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006ee:	eb d3                	jmp    8006c3 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006f0:	eb 33                	jmp    800725 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006f2:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006f5:	8d 50 04             	lea    0x4(%eax),%edx
+  8006f8:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006fb:	8b 00                	mov    (%eax),%eax
+  8006fd:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  800700:	eb 23                	jmp    800725 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  800702:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800706:	79 0c                	jns    800714 <vprintfmt+0x23f>
+				width = 0;
+  800708:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  80070f:	e9 78 ff ff ff       	jmp    80068c <vprintfmt+0x1b7>
+  800714:	e9 73 ff ff ff       	jmp    80068c <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800719:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  800720:	e9 67 ff ff ff       	jmp    80068c <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800725:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800729:	79 12                	jns    80073d <vprintfmt+0x268>
+				width = precision, precision = -1;
+  80072b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80072e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800731:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800738:	e9 4f ff ff ff       	jmp    80068c <vprintfmt+0x1b7>
+  80073d:	e9 4a ff ff ff       	jmp    80068c <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800742:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800746:	e9 41 ff ff ff       	jmp    80068c <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  80074b:	8b 45 14             	mov    0x14(%ebp),%eax
+  80074e:	8d 50 04             	lea    0x4(%eax),%edx
+  800751:	89 55 14             	mov    %edx,0x14(%ebp)
+  800754:	8b 00                	mov    (%eax),%eax
+  800756:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800759:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80075d:	89 04 24             	mov    %eax,(%esp)
+  800760:	8b 45 08             	mov    0x8(%ebp),%eax
+  800763:	ff d0                	call   *%eax
+			break;
+  800765:	e9 a5 02 00 00       	jmp    800a0f <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  80076a:	8b 45 14             	mov    0x14(%ebp),%eax
+  80076d:	8d 50 04             	lea    0x4(%eax),%edx
+  800770:	89 55 14             	mov    %edx,0x14(%ebp)
+  800773:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800775:	85 db                	test   %ebx,%ebx
+  800777:	79 02                	jns    80077b <vprintfmt+0x2a6>
+				err = -err;
+  800779:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  80077b:	83 fb 06             	cmp    $0x6,%ebx
+  80077e:	7f 0b                	jg     80078b <vprintfmt+0x2b6>
+  800780:	8b 34 9d 10 14 80 00 	mov    0x801410(,%ebx,4),%esi
+  800787:	85 f6                	test   %esi,%esi
+  800789:	75 23                	jne    8007ae <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  80078b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80078f:	c7 44 24 08 3d 14 80 	movl   $0x80143d,0x8(%esp)
+  800796:	00 
+  800797:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80079a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80079e:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007a1:	89 04 24             	mov    %eax,(%esp)
+  8007a4:	e8 73 02 00 00       	call   800a1c <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8007a9:	e9 61 02 00 00       	jmp    800a0f <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8007ae:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007b2:	c7 44 24 08 46 14 80 	movl   $0x801446,0x8(%esp)
+  8007b9:	00 
+  8007ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007bd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007c1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007c4:	89 04 24             	mov    %eax,(%esp)
+  8007c7:	e8 50 02 00 00       	call   800a1c <printfmt>
+			break;
+  8007cc:	e9 3e 02 00 00       	jmp    800a0f <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007d1:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007d4:	8d 50 04             	lea    0x4(%eax),%edx
+  8007d7:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007da:	8b 30                	mov    (%eax),%esi
+  8007dc:	85 f6                	test   %esi,%esi
+  8007de:	75 05                	jne    8007e5 <vprintfmt+0x310>
+				p = "(null)";
+  8007e0:	be 49 14 80 00       	mov    $0x801449,%esi
+			if (width > 0 && padc != '-')
+  8007e5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007e9:	7e 37                	jle    800822 <vprintfmt+0x34d>
+  8007eb:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007ef:	74 31                	je     800822 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007f8:	89 34 24             	mov    %esi,(%esp)
+  8007fb:	e8 39 03 00 00       	call   800b39 <strnlen>
+  800800:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  800803:	eb 17                	jmp    80081c <vprintfmt+0x347>
+					putch(padc, putdat);
+  800805:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800809:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80080c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800810:	89 04 24             	mov    %eax,(%esp)
+  800813:	8b 45 08             	mov    0x8(%ebp),%eax
+  800816:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800818:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80081c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800820:	7f e3                	jg     800805 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800822:	eb 38                	jmp    80085c <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800824:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800828:	74 1f                	je     800849 <vprintfmt+0x374>
+  80082a:	83 fb 1f             	cmp    $0x1f,%ebx
+  80082d:	7e 05                	jle    800834 <vprintfmt+0x35f>
+  80082f:	83 fb 7e             	cmp    $0x7e,%ebx
+  800832:	7e 15                	jle    800849 <vprintfmt+0x374>
+					putch('?', putdat);
+  800834:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800837:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80083b:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800842:	8b 45 08             	mov    0x8(%ebp),%eax
+  800845:	ff d0                	call   *%eax
+  800847:	eb 0f                	jmp    800858 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800849:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80084c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800850:	89 1c 24             	mov    %ebx,(%esp)
+  800853:	8b 45 08             	mov    0x8(%ebp),%eax
+  800856:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800858:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80085c:	89 f0                	mov    %esi,%eax
+  80085e:	8d 70 01             	lea    0x1(%eax),%esi
+  800861:	0f b6 00             	movzbl (%eax),%eax
+  800864:	0f be d8             	movsbl %al,%ebx
+  800867:	85 db                	test   %ebx,%ebx
+  800869:	74 10                	je     80087b <vprintfmt+0x3a6>
+  80086b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80086f:	78 b3                	js     800824 <vprintfmt+0x34f>
+  800871:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800875:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800879:	79 a9                	jns    800824 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80087b:	eb 17                	jmp    800894 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  80087d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800880:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800884:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  80088b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80088e:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  800890:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800894:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800898:	7f e3                	jg     80087d <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  80089a:	e9 70 01 00 00       	jmp    800a0f <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  80089f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008a2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008a6:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008a9:	89 04 24             	mov    %eax,(%esp)
+  8008ac:	e8 dd fb ff ff       	call   80048e <getint>
+  8008b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008b4:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008bd:	85 d2                	test   %edx,%edx
+  8008bf:	79 26                	jns    8008e7 <vprintfmt+0x412>
+				putch('-', putdat);
+  8008c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008c4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008c8:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008cf:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008d2:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008da:	f7 d8                	neg    %eax
+  8008dc:	83 d2 00             	adc    $0x0,%edx
+  8008df:	f7 da                	neg    %edx
+  8008e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008e4:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008e7:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008ee:	e9 a8 00 00 00       	jmp    80099b <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008f6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008fa:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008fd:	89 04 24             	mov    %eax,(%esp)
+  800900:	e8 3a fb ff ff       	call   80043f <getuint>
+  800905:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800908:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  80090b:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800912:	e9 84 00 00 00       	jmp    80099b <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800917:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80091a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80091e:	8d 45 14             	lea    0x14(%ebp),%eax
+  800921:	89 04 24             	mov    %eax,(%esp)
+  800924:	e8 16 fb ff ff       	call   80043f <getuint>
+  800929:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80092c:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  80092f:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800936:	eb 63                	jmp    80099b <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800938:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80093b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80093f:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800946:	8b 45 08             	mov    0x8(%ebp),%eax
+  800949:	ff d0                	call   *%eax
+			putch('x', putdat);
+  80094b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80094e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800952:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800959:	8b 45 08             	mov    0x8(%ebp),%eax
+  80095c:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  80095e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800961:	8d 50 04             	lea    0x4(%eax),%edx
+  800964:	89 55 14             	mov    %edx,0x14(%ebp)
+  800967:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  800969:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80096c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800973:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  80097a:	eb 1f                	jmp    80099b <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  80097c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80097f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800983:	8d 45 14             	lea    0x14(%ebp),%eax
+  800986:	89 04 24             	mov    %eax,(%esp)
+  800989:	e8 b1 fa ff ff       	call   80043f <getuint>
+  80098e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800991:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800994:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  80099b:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  80099f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8009a2:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8009a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8009a9:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8009ad:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8009b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009b7:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009bb:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009bf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009c9:	89 04 24             	mov    %eax,(%esp)
+  8009cc:	e8 90 f9 ff ff       	call   800361 <printnum>
+			break;
+  8009d1:	eb 3c                	jmp    800a0f <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009da:	89 1c 24             	mov    %ebx,(%esp)
+  8009dd:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e0:	ff d0                	call   *%eax
+			break;			
+  8009e2:	eb 2b                	jmp    800a0f <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009e7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009eb:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009f2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009f5:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009f7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009fb:	eb 04                	jmp    800a01 <vprintfmt+0x52c>
+  8009fd:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a01:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a04:	83 e8 01             	sub    $0x1,%eax
+  800a07:	0f b6 00             	movzbl (%eax),%eax
+  800a0a:	3c 25                	cmp    $0x25,%al
+  800a0c:	75 ef                	jne    8009fd <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800a0e:	90                   	nop
+		}
+	}
+  800a0f:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800a10:	e9 3f fc ff ff       	jmp    800654 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a15:	83 c4 40             	add    $0x40,%esp
+  800a18:	5b                   	pop    %ebx
+  800a19:	5e                   	pop    %esi
+  800a1a:	5d                   	pop    %ebp
+  800a1b:	c3                   	ret    
+
+00800a1c <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a1c:	55                   	push   %ebp
+  800a1d:	89 e5                	mov    %esp,%ebp
+  800a1f:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a22:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a25:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a2f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a32:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a36:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a39:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a3d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a40:	89 04 24             	mov    %eax,(%esp)
+  800a43:	e8 8d fa ff ff       	call   8004d5 <vprintfmt>
+	va_end(ap);
+}
+  800a48:	c9                   	leave  
+  800a49:	c3                   	ret    
+
+00800a4a <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a4a:	55                   	push   %ebp
+  800a4b:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a50:	8b 40 08             	mov    0x8(%eax),%eax
+  800a53:	8d 50 01             	lea    0x1(%eax),%edx
+  800a56:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a59:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a5c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a5f:	8b 10                	mov    (%eax),%edx
+  800a61:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a64:	8b 40 04             	mov    0x4(%eax),%eax
+  800a67:	39 c2                	cmp    %eax,%edx
+  800a69:	73 12                	jae    800a7d <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a6e:	8b 00                	mov    (%eax),%eax
+  800a70:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a73:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a76:	89 0a                	mov    %ecx,(%edx)
+  800a78:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a7b:	88 10                	mov    %dl,(%eax)
+}
+  800a7d:	5d                   	pop    %ebp
+  800a7e:	c3                   	ret    
+
+00800a7f <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a7f:	55                   	push   %ebp
+  800a80:	89 e5                	mov    %esp,%ebp
+  800a82:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a85:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a88:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a8b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a8e:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a91:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a94:	01 d0                	add    %edx,%eax
+  800a96:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800aa0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800aa4:	74 06                	je     800aac <vsnprintf+0x2d>
+  800aa6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800aaa:	7f 07                	jg     800ab3 <vsnprintf+0x34>
+		return -E_INVAL;
+  800aac:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800ab1:	eb 2a                	jmp    800add <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800ab3:	8b 45 14             	mov    0x14(%ebp),%eax
+  800ab6:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800aba:	8b 45 10             	mov    0x10(%ebp),%eax
+  800abd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ac1:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ac4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ac8:	c7 04 24 4a 0a 80 00 	movl   $0x800a4a,(%esp)
+  800acf:	e8 01 fa ff ff       	call   8004d5 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ad4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ad7:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800ada:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800add:	c9                   	leave  
+  800ade:	c3                   	ret    
+
+00800adf <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800adf:	55                   	push   %ebp
+  800ae0:	89 e5                	mov    %esp,%ebp
+  800ae2:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ae5:	8d 45 14             	lea    0x14(%ebp),%eax
+  800ae8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800aee:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800af2:	8b 45 10             	mov    0x10(%ebp),%eax
+  800af5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800af9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800afc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800b00:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b03:	89 04 24             	mov    %eax,(%esp)
+  800b06:	e8 74 ff ff ff       	call   800a7f <vsnprintf>
+  800b0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800b0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800b11:	c9                   	leave  
+  800b12:	c3                   	ret    
+
+00800b13 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b13:	55                   	push   %ebp
+  800b14:	89 e5                	mov    %esp,%ebp
+  800b16:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b19:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b20:	eb 08                	jmp    800b2a <strlen+0x17>
+		n++;
+  800b22:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b26:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b2a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b2d:	0f b6 00             	movzbl (%eax),%eax
+  800b30:	84 c0                	test   %al,%al
+  800b32:	75 ee                	jne    800b22 <strlen+0xf>
+		n++;
+	return n;
+  800b34:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b37:	c9                   	leave  
+  800b38:	c3                   	ret    
+
+00800b39 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b39:	55                   	push   %ebp
+  800b3a:	89 e5                	mov    %esp,%ebp
+  800b3c:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b46:	eb 0c                	jmp    800b54 <strnlen+0x1b>
+		n++;
+  800b48:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b4c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b50:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b54:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b58:	74 0a                	je     800b64 <strnlen+0x2b>
+  800b5a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5d:	0f b6 00             	movzbl (%eax),%eax
+  800b60:	84 c0                	test   %al,%al
+  800b62:	75 e4                	jne    800b48 <strnlen+0xf>
+		n++;
+	return n;
+  800b64:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b67:	c9                   	leave  
+  800b68:	c3                   	ret    
+
+00800b69 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b69:	55                   	push   %ebp
+  800b6a:	89 e5                	mov    %esp,%ebp
+  800b6c:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b6f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b72:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b75:	90                   	nop
+  800b76:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b79:	8d 50 01             	lea    0x1(%eax),%edx
+  800b7c:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b7f:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b82:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b85:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b88:	0f b6 12             	movzbl (%edx),%edx
+  800b8b:	88 10                	mov    %dl,(%eax)
+  800b8d:	0f b6 00             	movzbl (%eax),%eax
+  800b90:	84 c0                	test   %al,%al
+  800b92:	75 e2                	jne    800b76 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b94:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b97:	c9                   	leave  
+  800b98:	c3                   	ret    
+
+00800b99 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b99:	55                   	push   %ebp
+  800b9a:	89 e5                	mov    %esp,%ebp
+  800b9c:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b9f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba2:	89 04 24             	mov    %eax,(%esp)
+  800ba5:	e8 69 ff ff ff       	call   800b13 <strlen>
+  800baa:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800bad:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800bb0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bb3:	01 c2                	add    %eax,%edx
+  800bb5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bb8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800bbc:	89 14 24             	mov    %edx,(%esp)
+  800bbf:	e8 a5 ff ff ff       	call   800b69 <strcpy>
+	return dst;
+  800bc4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bc7:	c9                   	leave  
+  800bc8:	c3                   	ret    
+
+00800bc9 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bc9:	55                   	push   %ebp
+  800bca:	89 e5                	mov    %esp,%ebp
+  800bcc:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bcf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd2:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bd5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bdc:	eb 23                	jmp    800c01 <strncpy+0x38>
+		*dst++ = *src;
+  800bde:	8b 45 08             	mov    0x8(%ebp),%eax
+  800be1:	8d 50 01             	lea    0x1(%eax),%edx
+  800be4:	89 55 08             	mov    %edx,0x8(%ebp)
+  800be7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800bea:	0f b6 12             	movzbl (%edx),%edx
+  800bed:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800bef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bf2:	0f b6 00             	movzbl (%eax),%eax
+  800bf5:	84 c0                	test   %al,%al
+  800bf7:	74 04                	je     800bfd <strncpy+0x34>
+			src++;
+  800bf9:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800bfd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800c01:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c04:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800c07:	72 d5                	jb     800bde <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800c09:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800c0c:	c9                   	leave  
+  800c0d:	c3                   	ret    
+
+00800c0e <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800c0e:	55                   	push   %ebp
+  800c0f:	89 e5                	mov    %esp,%ebp
+  800c11:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c14:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c17:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c1a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c1e:	74 33                	je     800c53 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c20:	eb 17                	jmp    800c39 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c22:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c25:	8d 50 01             	lea    0x1(%eax),%edx
+  800c28:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c2b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c2e:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c31:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c34:	0f b6 12             	movzbl (%edx),%edx
+  800c37:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c39:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c3d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c41:	74 0a                	je     800c4d <strlcpy+0x3f>
+  800c43:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c46:	0f b6 00             	movzbl (%eax),%eax
+  800c49:	84 c0                	test   %al,%al
+  800c4b:	75 d5                	jne    800c22 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c50:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c53:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c56:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c59:	29 c2                	sub    %eax,%edx
+  800c5b:	89 d0                	mov    %edx,%eax
+}
+  800c5d:	c9                   	leave  
+  800c5e:	c3                   	ret    
+
+00800c5f <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c5f:	55                   	push   %ebp
+  800c60:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c62:	eb 08                	jmp    800c6c <strcmp+0xd>
+		p++, q++;
+  800c64:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c68:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c6c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c6f:	0f b6 00             	movzbl (%eax),%eax
+  800c72:	84 c0                	test   %al,%al
+  800c74:	74 10                	je     800c86 <strcmp+0x27>
+  800c76:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c79:	0f b6 10             	movzbl (%eax),%edx
+  800c7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c7f:	0f b6 00             	movzbl (%eax),%eax
+  800c82:	38 c2                	cmp    %al,%dl
+  800c84:	74 de                	je     800c64 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c89:	0f b6 00             	movzbl (%eax),%eax
+  800c8c:	0f b6 d0             	movzbl %al,%edx
+  800c8f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c92:	0f b6 00             	movzbl (%eax),%eax
+  800c95:	0f b6 c0             	movzbl %al,%eax
+  800c98:	29 c2                	sub    %eax,%edx
+  800c9a:	89 d0                	mov    %edx,%eax
+}
+  800c9c:	5d                   	pop    %ebp
+  800c9d:	c3                   	ret    
+
+00800c9e <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c9e:	55                   	push   %ebp
+  800c9f:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800ca1:	eb 0c                	jmp    800caf <strncmp+0x11>
+		n--, p++, q++;
+  800ca3:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800ca7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800cab:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800caf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cb3:	74 1a                	je     800ccf <strncmp+0x31>
+  800cb5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb8:	0f b6 00             	movzbl (%eax),%eax
+  800cbb:	84 c0                	test   %al,%al
+  800cbd:	74 10                	je     800ccf <strncmp+0x31>
+  800cbf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc2:	0f b6 10             	movzbl (%eax),%edx
+  800cc5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cc8:	0f b6 00             	movzbl (%eax),%eax
+  800ccb:	38 c2                	cmp    %al,%dl
+  800ccd:	74 d4                	je     800ca3 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800ccf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cd3:	75 07                	jne    800cdc <strncmp+0x3e>
+		return 0;
+  800cd5:	b8 00 00 00 00       	mov    $0x0,%eax
+  800cda:	eb 16                	jmp    800cf2 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800cdc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cdf:	0f b6 00             	movzbl (%eax),%eax
+  800ce2:	0f b6 d0             	movzbl %al,%edx
+  800ce5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce8:	0f b6 00             	movzbl (%eax),%eax
+  800ceb:	0f b6 c0             	movzbl %al,%eax
+  800cee:	29 c2                	sub    %eax,%edx
+  800cf0:	89 d0                	mov    %edx,%eax
+}
+  800cf2:	5d                   	pop    %ebp
+  800cf3:	c3                   	ret    
+
+00800cf4 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800cf4:	55                   	push   %ebp
+  800cf5:	89 e5                	mov    %esp,%ebp
+  800cf7:	83 ec 04             	sub    $0x4,%esp
+  800cfa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cfd:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d00:	eb 14                	jmp    800d16 <strchr+0x22>
+		if (*s == c)
+  800d02:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d05:	0f b6 00             	movzbl (%eax),%eax
+  800d08:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d0b:	75 05                	jne    800d12 <strchr+0x1e>
+			return (char *) s;
+  800d0d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d10:	eb 13                	jmp    800d25 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d12:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d16:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d19:	0f b6 00             	movzbl (%eax),%eax
+  800d1c:	84 c0                	test   %al,%al
+  800d1e:	75 e2                	jne    800d02 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d20:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d25:	c9                   	leave  
+  800d26:	c3                   	ret    
+
+00800d27 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d27:	55                   	push   %ebp
+  800d28:	89 e5                	mov    %esp,%ebp
+  800d2a:	83 ec 04             	sub    $0x4,%esp
+  800d2d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d30:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d33:	eb 11                	jmp    800d46 <strfind+0x1f>
+		if (*s == c)
+  800d35:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d38:	0f b6 00             	movzbl (%eax),%eax
+  800d3b:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d3e:	75 02                	jne    800d42 <strfind+0x1b>
+			break;
+  800d40:	eb 0e                	jmp    800d50 <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d42:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d46:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d49:	0f b6 00             	movzbl (%eax),%eax
+  800d4c:	84 c0                	test   %al,%al
+  800d4e:	75 e5                	jne    800d35 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d50:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d53:	c9                   	leave  
+  800d54:	c3                   	ret    
+
+00800d55 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d55:	55                   	push   %ebp
+  800d56:	89 e5                	mov    %esp,%ebp
+  800d58:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d59:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d5d:	75 05                	jne    800d64 <memset+0xf>
+		return v;
+  800d5f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d62:	eb 5c                	jmp    800dc0 <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d64:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d67:	83 e0 03             	and    $0x3,%eax
+  800d6a:	85 c0                	test   %eax,%eax
+  800d6c:	75 41                	jne    800daf <memset+0x5a>
+  800d6e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d71:	83 e0 03             	and    $0x3,%eax
+  800d74:	85 c0                	test   %eax,%eax
+  800d76:	75 37                	jne    800daf <memset+0x5a>
+		c &= 0xFF;
+  800d78:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d7f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d82:	c1 e0 18             	shl    $0x18,%eax
+  800d85:	89 c2                	mov    %eax,%edx
+  800d87:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d8a:	c1 e0 10             	shl    $0x10,%eax
+  800d8d:	09 c2                	or     %eax,%edx
+  800d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d92:	c1 e0 08             	shl    $0x8,%eax
+  800d95:	09 d0                	or     %edx,%eax
+  800d97:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d9a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d9d:	c1 e8 02             	shr    $0x2,%eax
+  800da0:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800da2:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da8:	89 d7                	mov    %edx,%edi
+  800daa:	fc                   	cld    
+  800dab:	f3 ab                	rep stos %eax,%es:(%edi)
+  800dad:	eb 0e                	jmp    800dbd <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800daf:	8b 55 08             	mov    0x8(%ebp),%edx
+  800db2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800db5:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800db8:	89 d7                	mov    %edx,%edi
+  800dba:	fc                   	cld    
+  800dbb:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800dbd:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800dc0:	5f                   	pop    %edi
+  800dc1:	5d                   	pop    %ebp
+  800dc2:	c3                   	ret    
+
+00800dc3 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800dc3:	55                   	push   %ebp
+  800dc4:	89 e5                	mov    %esp,%ebp
+  800dc6:	57                   	push   %edi
+  800dc7:	56                   	push   %esi
+  800dc8:	53                   	push   %ebx
+  800dc9:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dd2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800ddb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dde:	73 6d                	jae    800e4d <memmove+0x8a>
+  800de0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de3:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800de6:	01 d0                	add    %edx,%eax
+  800de8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800deb:	76 60                	jbe    800e4d <memmove+0x8a>
+		s += n;
+  800ded:	8b 45 10             	mov    0x10(%ebp),%eax
+  800df0:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800df3:	8b 45 10             	mov    0x10(%ebp),%eax
+  800df6:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800df9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dfc:	83 e0 03             	and    $0x3,%eax
+  800dff:	85 c0                	test   %eax,%eax
+  800e01:	75 2f                	jne    800e32 <memmove+0x6f>
+  800e03:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e06:	83 e0 03             	and    $0x3,%eax
+  800e09:	85 c0                	test   %eax,%eax
+  800e0b:	75 25                	jne    800e32 <memmove+0x6f>
+  800e0d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e10:	83 e0 03             	and    $0x3,%eax
+  800e13:	85 c0                	test   %eax,%eax
+  800e15:	75 1b                	jne    800e32 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e17:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e1a:	83 e8 04             	sub    $0x4,%eax
+  800e1d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e20:	83 ea 04             	sub    $0x4,%edx
+  800e23:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e26:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e29:	89 c7                	mov    %eax,%edi
+  800e2b:	89 d6                	mov    %edx,%esi
+  800e2d:	fd                   	std    
+  800e2e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e30:	eb 18                	jmp    800e4a <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e32:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e35:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e3b:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e3e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e41:	89 d7                	mov    %edx,%edi
+  800e43:	89 de                	mov    %ebx,%esi
+  800e45:	89 c1                	mov    %eax,%ecx
+  800e47:	fd                   	std    
+  800e48:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e4a:	fc                   	cld    
+  800e4b:	eb 45                	jmp    800e92 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e50:	83 e0 03             	and    $0x3,%eax
+  800e53:	85 c0                	test   %eax,%eax
+  800e55:	75 2b                	jne    800e82 <memmove+0xbf>
+  800e57:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e5a:	83 e0 03             	and    $0x3,%eax
+  800e5d:	85 c0                	test   %eax,%eax
+  800e5f:	75 21                	jne    800e82 <memmove+0xbf>
+  800e61:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e64:	83 e0 03             	and    $0x3,%eax
+  800e67:	85 c0                	test   %eax,%eax
+  800e69:	75 17                	jne    800e82 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e6e:	c1 e8 02             	shr    $0x2,%eax
+  800e71:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e73:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e76:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e79:	89 c7                	mov    %eax,%edi
+  800e7b:	89 d6                	mov    %edx,%esi
+  800e7d:	fc                   	cld    
+  800e7e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e80:	eb 10                	jmp    800e92 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e82:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e85:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e88:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e8b:	89 c7                	mov    %eax,%edi
+  800e8d:	89 d6                	mov    %edx,%esi
+  800e8f:	fc                   	cld    
+  800e90:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e92:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e95:	83 c4 10             	add    $0x10,%esp
+  800e98:	5b                   	pop    %ebx
+  800e99:	5e                   	pop    %esi
+  800e9a:	5f                   	pop    %edi
+  800e9b:	5d                   	pop    %ebp
+  800e9c:	c3                   	ret    
+
+00800e9d <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e9d:	55                   	push   %ebp
+  800e9e:	89 e5                	mov    %esp,%ebp
+  800ea0:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800ea3:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ea6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800eaa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ead:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800eb1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eb4:	89 04 24             	mov    %eax,(%esp)
+  800eb7:	e8 07 ff ff ff       	call   800dc3 <memmove>
+}
+  800ebc:	c9                   	leave  
+  800ebd:	c3                   	ret    
+
+00800ebe <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800ebe:	55                   	push   %ebp
+  800ebf:	89 e5                	mov    %esp,%ebp
+  800ec1:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800ec4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ec7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800eca:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ecd:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ed0:	eb 30                	jmp    800f02 <memcmp+0x44>
+		if (*s1 != *s2)
+  800ed2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed5:	0f b6 10             	movzbl (%eax),%edx
+  800ed8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800edb:	0f b6 00             	movzbl (%eax),%eax
+  800ede:	38 c2                	cmp    %al,%dl
+  800ee0:	74 18                	je     800efa <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ee2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ee5:	0f b6 00             	movzbl (%eax),%eax
+  800ee8:	0f b6 d0             	movzbl %al,%edx
+  800eeb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eee:	0f b6 00             	movzbl (%eax),%eax
+  800ef1:	0f b6 c0             	movzbl %al,%eax
+  800ef4:	29 c2                	sub    %eax,%edx
+  800ef6:	89 d0                	mov    %edx,%eax
+  800ef8:	eb 1a                	jmp    800f14 <memcmp+0x56>
+		s1++, s2++;
+  800efa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800efe:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800f02:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f05:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800f08:	89 55 10             	mov    %edx,0x10(%ebp)
+  800f0b:	85 c0                	test   %eax,%eax
+  800f0d:	75 c3                	jne    800ed2 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800f0f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f14:	c9                   	leave  
+  800f15:	c3                   	ret    
+
+00800f16 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f16:	55                   	push   %ebp
+  800f17:	89 e5                	mov    %esp,%ebp
+  800f19:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f1c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f1f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f22:	01 d0                	add    %edx,%eax
+  800f24:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f27:	eb 13                	jmp    800f3c <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f29:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f2c:	0f b6 10             	movzbl (%eax),%edx
+  800f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f32:	38 c2                	cmp    %al,%dl
+  800f34:	75 02                	jne    800f38 <memfind+0x22>
+			break;
+  800f36:	eb 0c                	jmp    800f44 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f38:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f3c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f3f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f42:	72 e5                	jb     800f29 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f44:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f47:	c9                   	leave  
+  800f48:	c3                   	ret    
+
+00800f49 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f49:	55                   	push   %ebp
+  800f4a:	89 e5                	mov    %esp,%ebp
+  800f4c:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f4f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f56:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f5d:	eb 04                	jmp    800f63 <strtol+0x1a>
+		s++;
+  800f5f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f63:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f66:	0f b6 00             	movzbl (%eax),%eax
+  800f69:	3c 20                	cmp    $0x20,%al
+  800f6b:	74 f2                	je     800f5f <strtol+0x16>
+  800f6d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f70:	0f b6 00             	movzbl (%eax),%eax
+  800f73:	3c 09                	cmp    $0x9,%al
+  800f75:	74 e8                	je     800f5f <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f77:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f7a:	0f b6 00             	movzbl (%eax),%eax
+  800f7d:	3c 2b                	cmp    $0x2b,%al
+  800f7f:	75 06                	jne    800f87 <strtol+0x3e>
+		s++;
+  800f81:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f85:	eb 15                	jmp    800f9c <strtol+0x53>
+	else if (*s == '-')
+  800f87:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f8a:	0f b6 00             	movzbl (%eax),%eax
+  800f8d:	3c 2d                	cmp    $0x2d,%al
+  800f8f:	75 0b                	jne    800f9c <strtol+0x53>
+		s++, neg = 1;
+  800f91:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f95:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f9c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fa0:	74 06                	je     800fa8 <strtol+0x5f>
+  800fa2:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800fa6:	75 24                	jne    800fcc <strtol+0x83>
+  800fa8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fab:	0f b6 00             	movzbl (%eax),%eax
+  800fae:	3c 30                	cmp    $0x30,%al
+  800fb0:	75 1a                	jne    800fcc <strtol+0x83>
+  800fb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fb5:	83 c0 01             	add    $0x1,%eax
+  800fb8:	0f b6 00             	movzbl (%eax),%eax
+  800fbb:	3c 78                	cmp    $0x78,%al
+  800fbd:	75 0d                	jne    800fcc <strtol+0x83>
+		s += 2, base = 16;
+  800fbf:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fc3:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fca:	eb 2a                	jmp    800ff6 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fcc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fd0:	75 17                	jne    800fe9 <strtol+0xa0>
+  800fd2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fd5:	0f b6 00             	movzbl (%eax),%eax
+  800fd8:	3c 30                	cmp    $0x30,%al
+  800fda:	75 0d                	jne    800fe9 <strtol+0xa0>
+		s++, base = 8;
+  800fdc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fe0:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fe7:	eb 0d                	jmp    800ff6 <strtol+0xad>
+	else if (base == 0)
+  800fe9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fed:	75 07                	jne    800ff6 <strtol+0xad>
+		base = 10;
+  800fef:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800ff6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff9:	0f b6 00             	movzbl (%eax),%eax
+  800ffc:	3c 2f                	cmp    $0x2f,%al
+  800ffe:	7e 1b                	jle    80101b <strtol+0xd2>
+  801000:	8b 45 08             	mov    0x8(%ebp),%eax
+  801003:	0f b6 00             	movzbl (%eax),%eax
+  801006:	3c 39                	cmp    $0x39,%al
+  801008:	7f 11                	jg     80101b <strtol+0xd2>
+			dig = *s - '0';
+  80100a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80100d:	0f b6 00             	movzbl (%eax),%eax
+  801010:	0f be c0             	movsbl %al,%eax
+  801013:	83 e8 30             	sub    $0x30,%eax
+  801016:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801019:	eb 48                	jmp    801063 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  80101b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101e:	0f b6 00             	movzbl (%eax),%eax
+  801021:	3c 60                	cmp    $0x60,%al
+  801023:	7e 1b                	jle    801040 <strtol+0xf7>
+  801025:	8b 45 08             	mov    0x8(%ebp),%eax
+  801028:	0f b6 00             	movzbl (%eax),%eax
+  80102b:	3c 7a                	cmp    $0x7a,%al
+  80102d:	7f 11                	jg     801040 <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  80102f:	8b 45 08             	mov    0x8(%ebp),%eax
+  801032:	0f b6 00             	movzbl (%eax),%eax
+  801035:	0f be c0             	movsbl %al,%eax
+  801038:	83 e8 57             	sub    $0x57,%eax
+  80103b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80103e:	eb 23                	jmp    801063 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  801040:	8b 45 08             	mov    0x8(%ebp),%eax
+  801043:	0f b6 00             	movzbl (%eax),%eax
+  801046:	3c 40                	cmp    $0x40,%al
+  801048:	7e 3d                	jle    801087 <strtol+0x13e>
+  80104a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104d:	0f b6 00             	movzbl (%eax),%eax
+  801050:	3c 5a                	cmp    $0x5a,%al
+  801052:	7f 33                	jg     801087 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801054:	8b 45 08             	mov    0x8(%ebp),%eax
+  801057:	0f b6 00             	movzbl (%eax),%eax
+  80105a:	0f be c0             	movsbl %al,%eax
+  80105d:	83 e8 37             	sub    $0x37,%eax
+  801060:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801063:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801066:	3b 45 10             	cmp    0x10(%ebp),%eax
+  801069:	7c 02                	jl     80106d <strtol+0x124>
+			break;
+  80106b:	eb 1a                	jmp    801087 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  80106d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  801071:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801074:	0f af 45 10          	imul   0x10(%ebp),%eax
+  801078:	89 c2                	mov    %eax,%edx
+  80107a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80107d:	01 d0                	add    %edx,%eax
+  80107f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  801082:	e9 6f ff ff ff       	jmp    800ff6 <strtol+0xad>
+
+	if (endptr)
+  801087:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80108b:	74 08                	je     801095 <strtol+0x14c>
+		*endptr = (char *) s;
+  80108d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  801090:	8b 55 08             	mov    0x8(%ebp),%edx
+  801093:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801095:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801099:	74 07                	je     8010a2 <strtol+0x159>
+  80109b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80109e:	f7 d8                	neg    %eax
+  8010a0:	eb 03                	jmp    8010a5 <strtol+0x15c>
+  8010a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  8010a5:	c9                   	leave  
+  8010a6:	c3                   	ret    
+  8010a7:	66 90                	xchg   %ax,%ax
+  8010a9:	66 90                	xchg   %ax,%ax
+  8010ab:	66 90                	xchg   %ax,%ax
+  8010ad:	66 90                	xchg   %ax,%ax
+  8010af:	90                   	nop
+
+008010b0 <__udivdi3>:
+  8010b0:	55                   	push   %ebp
+  8010b1:	57                   	push   %edi
+  8010b2:	56                   	push   %esi
+  8010b3:	83 ec 0c             	sub    $0xc,%esp
+  8010b6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ba:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010be:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010c2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010c6:	85 c0                	test   %eax,%eax
+  8010c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010cc:	89 ea                	mov    %ebp,%edx
+  8010ce:	89 0c 24             	mov    %ecx,(%esp)
+  8010d1:	75 2d                	jne    801100 <__udivdi3+0x50>
+  8010d3:	39 e9                	cmp    %ebp,%ecx
+  8010d5:	77 61                	ja     801138 <__udivdi3+0x88>
+  8010d7:	85 c9                	test   %ecx,%ecx
+  8010d9:	89 ce                	mov    %ecx,%esi
+  8010db:	75 0b                	jne    8010e8 <__udivdi3+0x38>
+  8010dd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010e2:	31 d2                	xor    %edx,%edx
+  8010e4:	f7 f1                	div    %ecx
+  8010e6:	89 c6                	mov    %eax,%esi
+  8010e8:	31 d2                	xor    %edx,%edx
+  8010ea:	89 e8                	mov    %ebp,%eax
+  8010ec:	f7 f6                	div    %esi
+  8010ee:	89 c5                	mov    %eax,%ebp
+  8010f0:	89 f8                	mov    %edi,%eax
+  8010f2:	f7 f6                	div    %esi
+  8010f4:	89 ea                	mov    %ebp,%edx
+  8010f6:	83 c4 0c             	add    $0xc,%esp
+  8010f9:	5e                   	pop    %esi
+  8010fa:	5f                   	pop    %edi
+  8010fb:	5d                   	pop    %ebp
+  8010fc:	c3                   	ret    
+  8010fd:	8d 76 00             	lea    0x0(%esi),%esi
+  801100:	39 e8                	cmp    %ebp,%eax
+  801102:	77 24                	ja     801128 <__udivdi3+0x78>
+  801104:	0f bd e8             	bsr    %eax,%ebp
+  801107:	83 f5 1f             	xor    $0x1f,%ebp
+  80110a:	75 3c                	jne    801148 <__udivdi3+0x98>
+  80110c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801110:	39 34 24             	cmp    %esi,(%esp)
+  801113:	0f 86 9f 00 00 00    	jbe    8011b8 <__udivdi3+0x108>
+  801119:	39 d0                	cmp    %edx,%eax
+  80111b:	0f 82 97 00 00 00    	jb     8011b8 <__udivdi3+0x108>
+  801121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801128:	31 d2                	xor    %edx,%edx
+  80112a:	31 c0                	xor    %eax,%eax
+  80112c:	83 c4 0c             	add    $0xc,%esp
+  80112f:	5e                   	pop    %esi
+  801130:	5f                   	pop    %edi
+  801131:	5d                   	pop    %ebp
+  801132:	c3                   	ret    
+  801133:	90                   	nop
+  801134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801138:	89 f8                	mov    %edi,%eax
+  80113a:	f7 f1                	div    %ecx
+  80113c:	31 d2                	xor    %edx,%edx
+  80113e:	83 c4 0c             	add    $0xc,%esp
+  801141:	5e                   	pop    %esi
+  801142:	5f                   	pop    %edi
+  801143:	5d                   	pop    %ebp
+  801144:	c3                   	ret    
+  801145:	8d 76 00             	lea    0x0(%esi),%esi
+  801148:	89 e9                	mov    %ebp,%ecx
+  80114a:	8b 3c 24             	mov    (%esp),%edi
+  80114d:	d3 e0                	shl    %cl,%eax
+  80114f:	89 c6                	mov    %eax,%esi
+  801151:	b8 20 00 00 00       	mov    $0x20,%eax
+  801156:	29 e8                	sub    %ebp,%eax
+  801158:	89 c1                	mov    %eax,%ecx
+  80115a:	d3 ef                	shr    %cl,%edi
+  80115c:	89 e9                	mov    %ebp,%ecx
+  80115e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801162:	8b 3c 24             	mov    (%esp),%edi
+  801165:	09 74 24 08          	or     %esi,0x8(%esp)
+  801169:	89 d6                	mov    %edx,%esi
+  80116b:	d3 e7                	shl    %cl,%edi
+  80116d:	89 c1                	mov    %eax,%ecx
+  80116f:	89 3c 24             	mov    %edi,(%esp)
+  801172:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801176:	d3 ee                	shr    %cl,%esi
+  801178:	89 e9                	mov    %ebp,%ecx
+  80117a:	d3 e2                	shl    %cl,%edx
+  80117c:	89 c1                	mov    %eax,%ecx
+  80117e:	d3 ef                	shr    %cl,%edi
+  801180:	09 d7                	or     %edx,%edi
+  801182:	89 f2                	mov    %esi,%edx
+  801184:	89 f8                	mov    %edi,%eax
+  801186:	f7 74 24 08          	divl   0x8(%esp)
+  80118a:	89 d6                	mov    %edx,%esi
+  80118c:	89 c7                	mov    %eax,%edi
+  80118e:	f7 24 24             	mull   (%esp)
+  801191:	39 d6                	cmp    %edx,%esi
+  801193:	89 14 24             	mov    %edx,(%esp)
+  801196:	72 30                	jb     8011c8 <__udivdi3+0x118>
+  801198:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80119c:	89 e9                	mov    %ebp,%ecx
+  80119e:	d3 e2                	shl    %cl,%edx
+  8011a0:	39 c2                	cmp    %eax,%edx
+  8011a2:	73 05                	jae    8011a9 <__udivdi3+0xf9>
+  8011a4:	3b 34 24             	cmp    (%esp),%esi
+  8011a7:	74 1f                	je     8011c8 <__udivdi3+0x118>
+  8011a9:	89 f8                	mov    %edi,%eax
+  8011ab:	31 d2                	xor    %edx,%edx
+  8011ad:	e9 7a ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011b8:	31 d2                	xor    %edx,%edx
+  8011ba:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011bf:	e9 68 ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011c8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011cb:	31 d2                	xor    %edx,%edx
+  8011cd:	83 c4 0c             	add    $0xc,%esp
+  8011d0:	5e                   	pop    %esi
+  8011d1:	5f                   	pop    %edi
+  8011d2:	5d                   	pop    %ebp
+  8011d3:	c3                   	ret    
+  8011d4:	66 90                	xchg   %ax,%ax
+  8011d6:	66 90                	xchg   %ax,%ax
+  8011d8:	66 90                	xchg   %ax,%ax
+  8011da:	66 90                	xchg   %ax,%ax
+  8011dc:	66 90                	xchg   %ax,%ax
+  8011de:	66 90                	xchg   %ax,%ax
+
+008011e0 <__umoddi3>:
+  8011e0:	55                   	push   %ebp
+  8011e1:	57                   	push   %edi
+  8011e2:	56                   	push   %esi
+  8011e3:	83 ec 14             	sub    $0x14,%esp
+  8011e6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011ee:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011f2:	89 c7                	mov    %eax,%edi
+  8011f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011f8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011fc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801200:	89 34 24             	mov    %esi,(%esp)
+  801203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801207:	85 c0                	test   %eax,%eax
+  801209:	89 c2                	mov    %eax,%edx
+  80120b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80120f:	75 17                	jne    801228 <__umoddi3+0x48>
+  801211:	39 fe                	cmp    %edi,%esi
+  801213:	76 4b                	jbe    801260 <__umoddi3+0x80>
+  801215:	89 c8                	mov    %ecx,%eax
+  801217:	89 fa                	mov    %edi,%edx
+  801219:	f7 f6                	div    %esi
+  80121b:	89 d0                	mov    %edx,%eax
+  80121d:	31 d2                	xor    %edx,%edx
+  80121f:	83 c4 14             	add    $0x14,%esp
+  801222:	5e                   	pop    %esi
+  801223:	5f                   	pop    %edi
+  801224:	5d                   	pop    %ebp
+  801225:	c3                   	ret    
+  801226:	66 90                	xchg   %ax,%ax
+  801228:	39 f8                	cmp    %edi,%eax
+  80122a:	77 54                	ja     801280 <__umoddi3+0xa0>
+  80122c:	0f bd e8             	bsr    %eax,%ebp
+  80122f:	83 f5 1f             	xor    $0x1f,%ebp
+  801232:	75 5c                	jne    801290 <__umoddi3+0xb0>
+  801234:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801238:	39 3c 24             	cmp    %edi,(%esp)
+  80123b:	0f 87 e7 00 00 00    	ja     801328 <__umoddi3+0x148>
+  801241:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801245:	29 f1                	sub    %esi,%ecx
+  801247:	19 c7                	sbb    %eax,%edi
+  801249:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80124d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801251:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801255:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801259:	83 c4 14             	add    $0x14,%esp
+  80125c:	5e                   	pop    %esi
+  80125d:	5f                   	pop    %edi
+  80125e:	5d                   	pop    %ebp
+  80125f:	c3                   	ret    
+  801260:	85 f6                	test   %esi,%esi
+  801262:	89 f5                	mov    %esi,%ebp
+  801264:	75 0b                	jne    801271 <__umoddi3+0x91>
+  801266:	b8 01 00 00 00       	mov    $0x1,%eax
+  80126b:	31 d2                	xor    %edx,%edx
+  80126d:	f7 f6                	div    %esi
+  80126f:	89 c5                	mov    %eax,%ebp
+  801271:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801275:	31 d2                	xor    %edx,%edx
+  801277:	f7 f5                	div    %ebp
+  801279:	89 c8                	mov    %ecx,%eax
+  80127b:	f7 f5                	div    %ebp
+  80127d:	eb 9c                	jmp    80121b <__umoddi3+0x3b>
+  80127f:	90                   	nop
+  801280:	89 c8                	mov    %ecx,%eax
+  801282:	89 fa                	mov    %edi,%edx
+  801284:	83 c4 14             	add    $0x14,%esp
+  801287:	5e                   	pop    %esi
+  801288:	5f                   	pop    %edi
+  801289:	5d                   	pop    %ebp
+  80128a:	c3                   	ret    
+  80128b:	90                   	nop
+  80128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801290:	8b 04 24             	mov    (%esp),%eax
+  801293:	be 20 00 00 00       	mov    $0x20,%esi
+  801298:	89 e9                	mov    %ebp,%ecx
+  80129a:	29 ee                	sub    %ebp,%esi
+  80129c:	d3 e2                	shl    %cl,%edx
+  80129e:	89 f1                	mov    %esi,%ecx
+  8012a0:	d3 e8                	shr    %cl,%eax
+  8012a2:	89 e9                	mov    %ebp,%ecx
+  8012a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012a8:	8b 04 24             	mov    (%esp),%eax
+  8012ab:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012af:	89 fa                	mov    %edi,%edx
+  8012b1:	d3 e0                	shl    %cl,%eax
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012b9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012bd:	d3 ea                	shr    %cl,%edx
+  8012bf:	89 e9                	mov    %ebp,%ecx
+  8012c1:	d3 e7                	shl    %cl,%edi
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	d3 e8                	shr    %cl,%eax
+  8012c7:	89 e9                	mov    %ebp,%ecx
+  8012c9:	09 f8                	or     %edi,%eax
+  8012cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012cf:	f7 74 24 04          	divl   0x4(%esp)
+  8012d3:	d3 e7                	shl    %cl,%edi
+  8012d5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012d9:	89 d7                	mov    %edx,%edi
+  8012db:	f7 64 24 08          	mull   0x8(%esp)
+  8012df:	39 d7                	cmp    %edx,%edi
+  8012e1:	89 c1                	mov    %eax,%ecx
+  8012e3:	89 14 24             	mov    %edx,(%esp)
+  8012e6:	72 2c                	jb     801314 <__umoddi3+0x134>
+  8012e8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012ec:	72 22                	jb     801310 <__umoddi3+0x130>
+  8012ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012f2:	29 c8                	sub    %ecx,%eax
+  8012f4:	19 d7                	sbb    %edx,%edi
+  8012f6:	89 e9                	mov    %ebp,%ecx
+  8012f8:	89 fa                	mov    %edi,%edx
+  8012fa:	d3 e8                	shr    %cl,%eax
+  8012fc:	89 f1                	mov    %esi,%ecx
+  8012fe:	d3 e2                	shl    %cl,%edx
+  801300:	89 e9                	mov    %ebp,%ecx
+  801302:	d3 ef                	shr    %cl,%edi
+  801304:	09 d0                	or     %edx,%eax
+  801306:	89 fa                	mov    %edi,%edx
+  801308:	83 c4 14             	add    $0x14,%esp
+  80130b:	5e                   	pop    %esi
+  80130c:	5f                   	pop    %edi
+  80130d:	5d                   	pop    %ebp
+  80130e:	c3                   	ret    
+  80130f:	90                   	nop
+  801310:	39 d7                	cmp    %edx,%edi
+  801312:	75 da                	jne    8012ee <__umoddi3+0x10e>
+  801314:	8b 14 24             	mov    (%esp),%edx
+  801317:	89 c1                	mov    %eax,%ecx
+  801319:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80131d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801321:	eb cb                	jmp    8012ee <__umoddi3+0x10e>
+  801323:	90                   	nop
+  801324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801328:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80132c:	0f 82 0f ff ff ff    	jb     801241 <__umoddi3+0x61>
+  801332:	e9 1a ff ff ff       	jmp    801251 <__umoddi3+0x71>
diff --git a/obj/user/buggyhello2.o b/obj/user/buggyhello2.o
new file mode 100644
index 0000000..66ad983
Binary files /dev/null and b/obj/user/buggyhello2.o differ
diff --git a/obj/user/buggyhello2.sym b/obj/user/buggyhello2.sym
new file mode 100644
index 0000000..ab1d5d8
--- /dev/null
+++ b/obj/user/buggyhello2.sym
@@ -0,0 +1,55 @@
+00200010 R __STAB_BEGIN__
+00202a1c R __STAB_END__
+00202a1d R __STABSTR_BEGIN__
+002040f2 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+00800050 T libmain
+0080009e T exit
+008000b2 t syscall
+00800113 T sys_cputs
+00800155 T sys_cgetc
+00800199 T sys_env_destroy
+008001dc T sys_getenvid
+00800220 T _panic
+0080027b t putch
+008002d7 T vcprintf
+0080033b T cprintf
+00800361 t printnum
+0080043f t getuint
+0080048e t getint
+008004d5 T vprintfmt
+00800a1c T printfmt
+00800a4a t sprintputch
+00800a7f T vsnprintf
+00800adf T snprintf
+00800b13 T strlen
+00800b39 T strnlen
+00800b69 T strcpy
+00800b99 T strcat
+00800bc9 T strncpy
+00800c0e T strlcpy
+00800c5f T strcmp
+00800c9e T strncmp
+00800cf4 T strchr
+00800d27 T strfind
+00800d55 T memset
+00800dc3 T memmove
+00800e9d T memcpy
+00800ebe T memcmp
+00800f16 T memfind
+00800f49 T strtol
+008010b0 T __udivdi3
+008011e0 T __umoddi3
+00801410 r error_string
+00802000 D hello
+00802004 D binaryname
+00802008 B thisenv
+0080200c B BG_COLOR
+00802010 B COLOR
+00802014 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/divzero b/obj/user/divzero
new file mode 100755
index 0000000..ba4d3dd
Binary files /dev/null and b/obj/user/divzero differ
diff --git a/obj/user/divzero.asm b/obj/user/divzero.asm
new file mode 100644
index 0000000..d5594bb
--- /dev/null
+++ b/obj/user/divzero.asm
@@ -0,0 +1,2632 @@
+
+obj/user/divzero:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 32 00 00 00       	call   800063 <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+int zero;
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	zero = 0;
+  800039:	c7 05 04 20 80 00 00 	movl   $0x0,0x802004
+  800040:	00 00 00 
+	cprintf("1/0 is %08x!\n", 1/zero);
+  800043:	8b 0d 04 20 80 00    	mov    0x802004,%ecx
+  800049:	b8 01 00 00 00       	mov    $0x1,%eax
+  80004e:	99                   	cltd   
+  80004f:	f7 f9                	idiv   %ecx
+  800051:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800055:	c7 04 24 48 13 80 00 	movl   $0x801348,(%esp)
+  80005c:	e8 24 01 00 00       	call   800185 <cprintf>
+}
+  800061:	c9                   	leave  
+  800062:	c3                   	ret    
+
+00800063 <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  800063:	55                   	push   %ebp
+  800064:	89 e5                	mov    %esp,%ebp
+  800066:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800069:	e8 ad 0f 00 00       	call   80101b <sys_getenvid>
+  80006e:	25 ff 03 00 00       	and    $0x3ff,%eax
+  800073:	89 c2                	mov    %eax,%edx
+  800075:	89 d0                	mov    %edx,%eax
+  800077:	01 c0                	add    %eax,%eax
+  800079:	01 d0                	add    %edx,%eax
+  80007b:	c1 e0 05             	shl    $0x5,%eax
+  80007e:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  800083:	a3 08 20 80 00       	mov    %eax,0x802008
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800088:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  80008c:	7e 0a                	jle    800098 <libmain+0x35>
+		binaryname = argv[0];
+  80008e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800091:	8b 00                	mov    (%eax),%eax
+  800093:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800098:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80009b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80009f:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000a2:	89 04 24             	mov    %eax,(%esp)
+  8000a5:	e8 89 ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  8000aa:	e8 02 00 00 00       	call   8000b1 <exit>
+}
+  8000af:	c9                   	leave  
+  8000b0:	c3                   	ret    
+
+008000b1 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  8000b1:	55                   	push   %ebp
+  8000b2:	89 e5                	mov    %esp,%ebp
+  8000b4:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000b7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000be:	e8 15 0f 00 00       	call   800fd8 <sys_env_destroy>
+}
+  8000c3:	c9                   	leave  
+  8000c4:	c3                   	ret    
+
+008000c5 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  8000c5:	55                   	push   %ebp
+  8000c6:	89 e5                	mov    %esp,%ebp
+  8000c8:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  8000cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000ce:	8b 00                	mov    (%eax),%eax
+  8000d0:	8d 48 01             	lea    0x1(%eax),%ecx
+  8000d3:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000d6:	89 0a                	mov    %ecx,(%edx)
+  8000d8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8000db:	89 d1                	mov    %edx,%ecx
+  8000dd:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000e0:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  8000e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000e7:	8b 00                	mov    (%eax),%eax
+  8000e9:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8000ee:	75 20                	jne    800110 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8000f0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000f3:	8b 00                	mov    (%eax),%eax
+  8000f5:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000f8:	83 c2 08             	add    $0x8,%edx
+  8000fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8000ff:	89 14 24             	mov    %edx,(%esp)
+  800102:	e8 4b 0e 00 00       	call   800f52 <sys_cputs>
+		b->idx = 0;
+  800107:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80010a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  800110:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800113:	8b 40 04             	mov    0x4(%eax),%eax
+  800116:	8d 50 01             	lea    0x1(%eax),%edx
+  800119:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80011c:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  80011f:	c9                   	leave  
+  800120:	c3                   	ret    
+
+00800121 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  800121:	55                   	push   %ebp
+  800122:	89 e5                	mov    %esp,%ebp
+  800124:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  80012a:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  800131:	00 00 00 
+	b.cnt = 0;
+  800134:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  80013b:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  80013e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800141:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800145:	8b 45 08             	mov    0x8(%ebp),%eax
+  800148:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80014c:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800152:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800156:	c7 04 24 c5 00 80 00 	movl   $0x8000c5,(%esp)
+  80015d:	e8 bd 01 00 00       	call   80031f <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800162:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800168:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80016c:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800172:	83 c0 08             	add    $0x8,%eax
+  800175:	89 04 24             	mov    %eax,(%esp)
+  800178:	e8 d5 0d 00 00       	call   800f52 <sys_cputs>
+
+	return b.cnt;
+  80017d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800183:	c9                   	leave  
+  800184:	c3                   	ret    
+
+00800185 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800185:	55                   	push   %ebp
+  800186:	89 e5                	mov    %esp,%ebp
+  800188:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  80018b:	8d 45 0c             	lea    0xc(%ebp),%eax
+  80018e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800191:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800194:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800198:	8b 45 08             	mov    0x8(%ebp),%eax
+  80019b:	89 04 24             	mov    %eax,(%esp)
+  80019e:	e8 7e ff ff ff       	call   800121 <vcprintf>
+  8001a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  8001a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8001a9:	c9                   	leave  
+  8001aa:	c3                   	ret    
+
+008001ab <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  8001ab:	55                   	push   %ebp
+  8001ac:	89 e5                	mov    %esp,%ebp
+  8001ae:	53                   	push   %ebx
+  8001af:	83 ec 34             	sub    $0x34,%esp
+  8001b2:	8b 45 10             	mov    0x10(%ebp),%eax
+  8001b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8001b8:	8b 45 14             	mov    0x14(%ebp),%eax
+  8001bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  8001be:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001c1:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001c6:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001c9:	77 72                	ja     80023d <printnum+0x92>
+  8001cb:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001ce:	72 05                	jb     8001d5 <printnum+0x2a>
+  8001d0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  8001d3:	77 68                	ja     80023d <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  8001d5:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8001d8:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  8001db:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001de:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001e3:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001e7:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8001eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8001ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8001f1:	89 04 24             	mov    %eax,(%esp)
+  8001f4:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8001f8:	e8 c3 0e 00 00       	call   8010c0 <__udivdi3>
+  8001fd:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  800200:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  800204:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  800208:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  80020b:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  80020f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800213:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800217:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80021a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80021e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800221:	89 04 24             	mov    %eax,(%esp)
+  800224:	e8 82 ff ff ff       	call   8001ab <printnum>
+  800229:	eb 1c                	jmp    800247 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  80022b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80022e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800232:	8b 45 20             	mov    0x20(%ebp),%eax
+  800235:	89 04 24             	mov    %eax,(%esp)
+  800238:	8b 45 08             	mov    0x8(%ebp),%eax
+  80023b:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  80023d:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  800241:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  800245:	7f e4                	jg     80022b <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  800247:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  80024a:	bb 00 00 00 00       	mov    $0x0,%ebx
+  80024f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800252:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800255:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  800259:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80025d:	89 04 24             	mov    %eax,(%esp)
+  800260:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800264:	e8 87 0f 00 00       	call   8011f0 <__umoddi3>
+  800269:	05 e8 13 80 00       	add    $0x8013e8,%eax
+  80026e:	0f b6 00             	movzbl (%eax),%eax
+  800271:	0f be c0             	movsbl %al,%eax
+  800274:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800277:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80027b:	89 04 24             	mov    %eax,(%esp)
+  80027e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800281:	ff d0                	call   *%eax
+}
+  800283:	83 c4 34             	add    $0x34,%esp
+  800286:	5b                   	pop    %ebx
+  800287:	5d                   	pop    %ebp
+  800288:	c3                   	ret    
+
+00800289 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800289:	55                   	push   %ebp
+  80028a:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80028c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800290:	7e 14                	jle    8002a6 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800292:	8b 45 08             	mov    0x8(%ebp),%eax
+  800295:	8b 00                	mov    (%eax),%eax
+  800297:	8d 48 08             	lea    0x8(%eax),%ecx
+  80029a:	8b 55 08             	mov    0x8(%ebp),%edx
+  80029d:	89 0a                	mov    %ecx,(%edx)
+  80029f:	8b 50 04             	mov    0x4(%eax),%edx
+  8002a2:	8b 00                	mov    (%eax),%eax
+  8002a4:	eb 30                	jmp    8002d6 <getuint+0x4d>
+	else if (lflag)
+  8002a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8002aa:	74 16                	je     8002c2 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  8002ac:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002af:	8b 00                	mov    (%eax),%eax
+  8002b1:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002b4:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002b7:	89 0a                	mov    %ecx,(%edx)
+  8002b9:	8b 00                	mov    (%eax),%eax
+  8002bb:	ba 00 00 00 00       	mov    $0x0,%edx
+  8002c0:	eb 14                	jmp    8002d6 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  8002c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002c5:	8b 00                	mov    (%eax),%eax
+  8002c7:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002ca:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002cd:	89 0a                	mov    %ecx,(%edx)
+  8002cf:	8b 00                	mov    (%eax),%eax
+  8002d1:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  8002d6:	5d                   	pop    %ebp
+  8002d7:	c3                   	ret    
+
+008002d8 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  8002d8:	55                   	push   %ebp
+  8002d9:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  8002db:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  8002df:	7e 14                	jle    8002f5 <getint+0x1d>
+		return va_arg(*ap, long long);
+  8002e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002e4:	8b 00                	mov    (%eax),%eax
+  8002e6:	8d 48 08             	lea    0x8(%eax),%ecx
+  8002e9:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002ec:	89 0a                	mov    %ecx,(%edx)
+  8002ee:	8b 50 04             	mov    0x4(%eax),%edx
+  8002f1:	8b 00                	mov    (%eax),%eax
+  8002f3:	eb 28                	jmp    80031d <getint+0x45>
+	else if (lflag)
+  8002f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8002f9:	74 12                	je     80030d <getint+0x35>
+		return va_arg(*ap, long);
+  8002fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002fe:	8b 00                	mov    (%eax),%eax
+  800300:	8d 48 04             	lea    0x4(%eax),%ecx
+  800303:	8b 55 08             	mov    0x8(%ebp),%edx
+  800306:	89 0a                	mov    %ecx,(%edx)
+  800308:	8b 00                	mov    (%eax),%eax
+  80030a:	99                   	cltd   
+  80030b:	eb 10                	jmp    80031d <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  80030d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800310:	8b 00                	mov    (%eax),%eax
+  800312:	8d 48 04             	lea    0x4(%eax),%ecx
+  800315:	8b 55 08             	mov    0x8(%ebp),%edx
+  800318:	89 0a                	mov    %ecx,(%edx)
+  80031a:	8b 00                	mov    (%eax),%eax
+  80031c:	99                   	cltd   
+}
+  80031d:	5d                   	pop    %ebp
+  80031e:	c3                   	ret    
+
+0080031f <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  80031f:	55                   	push   %ebp
+  800320:	89 e5                	mov    %esp,%ebp
+  800322:	56                   	push   %esi
+  800323:	53                   	push   %ebx
+  800324:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800327:	e9 72 01 00 00       	jmp    80049e <vprintfmt+0x17f>
+			if (ch == '\0')
+  80032c:	85 db                	test   %ebx,%ebx
+  80032e:	75 05                	jne    800335 <vprintfmt+0x16>
+				return;
+  800330:	e9 2a 05 00 00       	jmp    80085f <vprintfmt+0x540>
+			else if(ch == '\033'){
+  800335:	83 fb 1b             	cmp    $0x1b,%ebx
+  800338:	0f 85 51 01 00 00    	jne    80048f <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  80033e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800341:	8d 50 01             	lea    0x1(%eax),%edx
+  800344:	89 55 10             	mov    %edx,0x10(%ebp)
+  800347:	0f b6 00             	movzbl (%eax),%eax
+  80034a:	0f b6 d8             	movzbl %al,%ebx
+  80034d:	83 fb 5b             	cmp    $0x5b,%ebx
+  800350:	74 14                	je     800366 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800352:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800355:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800359:	89 1c 24             	mov    %ebx,(%esp)
+  80035c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80035f:	ff d0                	call   *%eax
+				    continue;
+  800361:	e9 38 01 00 00       	jmp    80049e <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800366:	8b 45 10             	mov    0x10(%ebp),%eax
+  800369:	8d 50 01             	lea    0x1(%eax),%edx
+  80036c:	89 55 10             	mov    %edx,0x10(%ebp)
+  80036f:	0f b6 00             	movzbl (%eax),%eax
+  800372:	0f b6 c0             	movzbl %al,%eax
+  800375:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				FG_COLOR = *(unsigned char *) fmt++;
+  80037a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80037d:	8d 50 01             	lea    0x1(%eax),%edx
+  800380:	89 55 10             	mov    %edx,0x10(%ebp)
+  800383:	0f b6 00             	movzbl (%eax),%eax
+  800386:	0f b6 c0             	movzbl %al,%eax
+  800389:	a3 14 20 80 00       	mov    %eax,0x802014
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  80038e:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800393:	83 f8 2f             	cmp    $0x2f,%eax
+  800396:	7e 19                	jle    8003b1 <vprintfmt+0x92>
+  800398:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  80039d:	83 f8 39             	cmp    $0x39,%eax
+  8003a0:	7f 0f                	jg     8003b1 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  8003a2:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003a7:	83 e8 30             	sub    $0x30,%eax
+  8003aa:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  8003af:	eb 50                	jmp    800401 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  8003b1:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003b6:	83 f8 60             	cmp    $0x60,%eax
+  8003b9:	7e 19                	jle    8003d4 <vprintfmt+0xb5>
+  8003bb:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003c0:	83 f8 66             	cmp    $0x66,%eax
+  8003c3:	7f 0f                	jg     8003d4 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  8003c5:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003ca:	83 e8 57             	sub    $0x57,%eax
+  8003cd:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  8003d2:	eb 2d                	jmp    800401 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  8003d4:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003d9:	83 f8 40             	cmp    $0x40,%eax
+  8003dc:	7e 19                	jle    8003f7 <vprintfmt+0xd8>
+  8003de:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003e3:	83 f8 46             	cmp    $0x46,%eax
+  8003e6:	7f 0f                	jg     8003f7 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  8003e8:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  8003ed:	83 e8 37             	sub    $0x37,%eax
+  8003f0:	a3 0c 20 80 00       	mov    %eax,0x80200c
+  8003f5:	eb 0a                	jmp    800401 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8003f7:	c7 05 0c 20 80 00 00 	movl   $0x0,0x80200c
+  8003fe:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  800401:	a1 14 20 80 00       	mov    0x802014,%eax
+  800406:	83 f8 2f             	cmp    $0x2f,%eax
+  800409:	7e 19                	jle    800424 <vprintfmt+0x105>
+  80040b:	a1 14 20 80 00       	mov    0x802014,%eax
+  800410:	83 f8 39             	cmp    $0x39,%eax
+  800413:	7f 0f                	jg     800424 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  800415:	a1 14 20 80 00       	mov    0x802014,%eax
+  80041a:	83 e8 30             	sub    $0x30,%eax
+  80041d:	a3 14 20 80 00       	mov    %eax,0x802014
+  800422:	eb 50                	jmp    800474 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  800424:	a1 14 20 80 00       	mov    0x802014,%eax
+  800429:	83 f8 60             	cmp    $0x60,%eax
+  80042c:	7e 19                	jle    800447 <vprintfmt+0x128>
+  80042e:	a1 14 20 80 00       	mov    0x802014,%eax
+  800433:	83 f8 66             	cmp    $0x66,%eax
+  800436:	7f 0f                	jg     800447 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  800438:	a1 14 20 80 00       	mov    0x802014,%eax
+  80043d:	83 e8 57             	sub    $0x57,%eax
+  800440:	a3 14 20 80 00       	mov    %eax,0x802014
+  800445:	eb 2d                	jmp    800474 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  800447:	a1 14 20 80 00       	mov    0x802014,%eax
+  80044c:	83 f8 40             	cmp    $0x40,%eax
+  80044f:	7e 19                	jle    80046a <vprintfmt+0x14b>
+  800451:	a1 14 20 80 00       	mov    0x802014,%eax
+  800456:	83 f8 46             	cmp    $0x46,%eax
+  800459:	7f 0f                	jg     80046a <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  80045b:	a1 14 20 80 00       	mov    0x802014,%eax
+  800460:	83 e8 37             	sub    $0x37,%eax
+  800463:	a3 14 20 80 00       	mov    %eax,0x802014
+  800468:	eb 0a                	jmp    800474 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80046a:	c7 05 0c 20 80 00 07 	movl   $0x7,0x80200c
+  800471:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800474:	a1 0c 20 80 00       	mov    0x80200c,%eax
+  800479:	c1 e0 0c             	shl    $0xc,%eax
+  80047c:	89 c2                	mov    %eax,%edx
+  80047e:	a1 14 20 80 00       	mov    0x802014,%eax
+  800483:	c1 e0 08             	shl    $0x8,%eax
+  800486:	09 d0                	or     %edx,%eax
+  800488:	a3 10 20 80 00       	mov    %eax,0x802010
+				continue;
+  80048d:	eb 0f                	jmp    80049e <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  80048f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800492:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800496:	89 1c 24             	mov    %ebx,(%esp)
+  800499:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049c:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80049e:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004a1:	8d 50 01             	lea    0x1(%eax),%edx
+  8004a4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004a7:	0f b6 00             	movzbl (%eax),%eax
+  8004aa:	0f b6 d8             	movzbl %al,%ebx
+  8004ad:	83 fb 25             	cmp    $0x25,%ebx
+  8004b0:	0f 85 76 fe ff ff    	jne    80032c <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  8004b6:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  8004ba:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  8004c1:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  8004c8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  8004cf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  8004d6:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004d9:	8d 50 01             	lea    0x1(%eax),%edx
+  8004dc:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004df:	0f b6 00             	movzbl (%eax),%eax
+  8004e2:	0f b6 d8             	movzbl %al,%ebx
+  8004e5:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  8004e8:	83 f8 55             	cmp    $0x55,%eax
+  8004eb:	0f 87 3d 03 00 00    	ja     80082e <vprintfmt+0x50f>
+  8004f1:	8b 04 85 0c 14 80 00 	mov    0x80140c(,%eax,4),%eax
+  8004f8:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8004fa:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8004fe:	eb d6                	jmp    8004d6 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  800500:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  800504:	eb d0                	jmp    8004d6 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800506:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  80050d:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  800510:	89 d0                	mov    %edx,%eax
+  800512:	c1 e0 02             	shl    $0x2,%eax
+  800515:	01 d0                	add    %edx,%eax
+  800517:	01 c0                	add    %eax,%eax
+  800519:	01 d8                	add    %ebx,%eax
+  80051b:	83 e8 30             	sub    $0x30,%eax
+  80051e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  800521:	8b 45 10             	mov    0x10(%ebp),%eax
+  800524:	0f b6 00             	movzbl (%eax),%eax
+  800527:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  80052a:	83 fb 2f             	cmp    $0x2f,%ebx
+  80052d:	7e 0b                	jle    80053a <vprintfmt+0x21b>
+  80052f:	83 fb 39             	cmp    $0x39,%ebx
+  800532:	7f 06                	jg     80053a <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800534:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  800538:	eb d3                	jmp    80050d <vprintfmt+0x1ee>
+			goto process_precision;
+  80053a:	eb 33                	jmp    80056f <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  80053c:	8b 45 14             	mov    0x14(%ebp),%eax
+  80053f:	8d 50 04             	lea    0x4(%eax),%edx
+  800542:	89 55 14             	mov    %edx,0x14(%ebp)
+  800545:	8b 00                	mov    (%eax),%eax
+  800547:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  80054a:	eb 23                	jmp    80056f <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  80054c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800550:	79 0c                	jns    80055e <vprintfmt+0x23f>
+				width = 0;
+  800552:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  800559:	e9 78 ff ff ff       	jmp    8004d6 <vprintfmt+0x1b7>
+  80055e:	e9 73 ff ff ff       	jmp    8004d6 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800563:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80056a:	e9 67 ff ff ff       	jmp    8004d6 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  80056f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800573:	79 12                	jns    800587 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800575:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800578:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80057b:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800582:	e9 4f ff ff ff       	jmp    8004d6 <vprintfmt+0x1b7>
+  800587:	e9 4a ff ff ff       	jmp    8004d6 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  80058c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800590:	e9 41 ff ff ff       	jmp    8004d6 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800595:	8b 45 14             	mov    0x14(%ebp),%eax
+  800598:	8d 50 04             	lea    0x4(%eax),%edx
+  80059b:	89 55 14             	mov    %edx,0x14(%ebp)
+  80059e:	8b 00                	mov    (%eax),%eax
+  8005a0:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8005a3:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8005a7:	89 04 24             	mov    %eax,(%esp)
+  8005aa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005ad:	ff d0                	call   *%eax
+			break;
+  8005af:	e9 a5 02 00 00       	jmp    800859 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  8005b4:	8b 45 14             	mov    0x14(%ebp),%eax
+  8005b7:	8d 50 04             	lea    0x4(%eax),%edx
+  8005ba:	89 55 14             	mov    %edx,0x14(%ebp)
+  8005bd:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  8005bf:	85 db                	test   %ebx,%ebx
+  8005c1:	79 02                	jns    8005c5 <vprintfmt+0x2a6>
+				err = -err;
+  8005c3:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  8005c5:	83 fb 06             	cmp    $0x6,%ebx
+  8005c8:	7f 0b                	jg     8005d5 <vprintfmt+0x2b6>
+  8005ca:	8b 34 9d cc 13 80 00 	mov    0x8013cc(,%ebx,4),%esi
+  8005d1:	85 f6                	test   %esi,%esi
+  8005d3:	75 23                	jne    8005f8 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  8005d5:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  8005d9:	c7 44 24 08 f9 13 80 	movl   $0x8013f9,0x8(%esp)
+  8005e0:	00 
+  8005e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005e8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005eb:	89 04 24             	mov    %eax,(%esp)
+  8005ee:	e8 73 02 00 00       	call   800866 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8005f3:	e9 61 02 00 00       	jmp    800859 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8005f8:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8005fc:	c7 44 24 08 02 14 80 	movl   $0x801402,0x8(%esp)
+  800603:	00 
+  800604:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800607:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80060b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060e:	89 04 24             	mov    %eax,(%esp)
+  800611:	e8 50 02 00 00       	call   800866 <printfmt>
+			break;
+  800616:	e9 3e 02 00 00       	jmp    800859 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  80061b:	8b 45 14             	mov    0x14(%ebp),%eax
+  80061e:	8d 50 04             	lea    0x4(%eax),%edx
+  800621:	89 55 14             	mov    %edx,0x14(%ebp)
+  800624:	8b 30                	mov    (%eax),%esi
+  800626:	85 f6                	test   %esi,%esi
+  800628:	75 05                	jne    80062f <vprintfmt+0x310>
+				p = "(null)";
+  80062a:	be 05 14 80 00       	mov    $0x801405,%esi
+			if (width > 0 && padc != '-')
+  80062f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800633:	7e 37                	jle    80066c <vprintfmt+0x34d>
+  800635:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800639:	74 31                	je     80066c <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80063b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80063e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800642:	89 34 24             	mov    %esi,(%esp)
+  800645:	e8 39 03 00 00       	call   800983 <strnlen>
+  80064a:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  80064d:	eb 17                	jmp    800666 <vprintfmt+0x347>
+					putch(padc, putdat);
+  80064f:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800653:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800656:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80065a:	89 04 24             	mov    %eax,(%esp)
+  80065d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800660:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800662:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800666:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80066a:	7f e3                	jg     80064f <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80066c:	eb 38                	jmp    8006a6 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  80066e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800672:	74 1f                	je     800693 <vprintfmt+0x374>
+  800674:	83 fb 1f             	cmp    $0x1f,%ebx
+  800677:	7e 05                	jle    80067e <vprintfmt+0x35f>
+  800679:	83 fb 7e             	cmp    $0x7e,%ebx
+  80067c:	7e 15                	jle    800693 <vprintfmt+0x374>
+					putch('?', putdat);
+  80067e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800681:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800685:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  80068c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80068f:	ff d0                	call   *%eax
+  800691:	eb 0f                	jmp    8006a2 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800693:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800696:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80069a:	89 1c 24             	mov    %ebx,(%esp)
+  80069d:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006a0:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  8006a2:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8006a6:	89 f0                	mov    %esi,%eax
+  8006a8:	8d 70 01             	lea    0x1(%eax),%esi
+  8006ab:	0f b6 00             	movzbl (%eax),%eax
+  8006ae:	0f be d8             	movsbl %al,%ebx
+  8006b1:	85 db                	test   %ebx,%ebx
+  8006b3:	74 10                	je     8006c5 <vprintfmt+0x3a6>
+  8006b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006b9:	78 b3                	js     80066e <vprintfmt+0x34f>
+  8006bb:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  8006bf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006c3:	79 a9                	jns    80066e <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006c5:	eb 17                	jmp    8006de <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  8006c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006ca:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006ce:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  8006d5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006d8:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006da:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8006de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006e2:	7f e3                	jg     8006c7 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  8006e4:	e9 70 01 00 00       	jmp    800859 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  8006e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8006ec:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006f0:	8d 45 14             	lea    0x14(%ebp),%eax
+  8006f3:	89 04 24             	mov    %eax,(%esp)
+  8006f6:	e8 dd fb ff ff       	call   8002d8 <getint>
+  8006fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006fe:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  800701:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800704:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800707:	85 d2                	test   %edx,%edx
+  800709:	79 26                	jns    800731 <vprintfmt+0x412>
+				putch('-', putdat);
+  80070b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80070e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800712:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  800719:	8b 45 08             	mov    0x8(%ebp),%eax
+  80071c:	ff d0                	call   *%eax
+				num = -(long long) num;
+  80071e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800721:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800724:	f7 d8                	neg    %eax
+  800726:	83 d2 00             	adc    $0x0,%edx
+  800729:	f7 da                	neg    %edx
+  80072b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80072e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  800731:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800738:	e9 a8 00 00 00       	jmp    8007e5 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  80073d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800740:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800744:	8d 45 14             	lea    0x14(%ebp),%eax
+  800747:	89 04 24             	mov    %eax,(%esp)
+  80074a:	e8 3a fb ff ff       	call   800289 <getuint>
+  80074f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800752:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  800755:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  80075c:	e9 84 00 00 00       	jmp    8007e5 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800761:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800764:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800768:	8d 45 14             	lea    0x14(%ebp),%eax
+  80076b:	89 04 24             	mov    %eax,(%esp)
+  80076e:	e8 16 fb ff ff       	call   800289 <getuint>
+  800773:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800776:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800779:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800780:	eb 63                	jmp    8007e5 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800782:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800785:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800789:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800790:	8b 45 08             	mov    0x8(%ebp),%eax
+  800793:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800795:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800798:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80079c:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  8007a3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007a6:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  8007a8:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007ab:	8d 50 04             	lea    0x4(%eax),%edx
+  8007ae:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007b1:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  8007b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  8007bd:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  8007c4:	eb 1f                	jmp    8007e5 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  8007c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8007c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007cd:	8d 45 14             	lea    0x14(%ebp),%eax
+  8007d0:	89 04 24             	mov    %eax,(%esp)
+  8007d3:	e8 b1 fa ff ff       	call   800289 <getuint>
+  8007d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007db:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  8007de:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  8007e5:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  8007e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8007ec:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8007f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8007f3:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8007f7:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8007fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800801:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800805:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800809:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80080c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800810:	8b 45 08             	mov    0x8(%ebp),%eax
+  800813:	89 04 24             	mov    %eax,(%esp)
+  800816:	e8 90 f9 ff ff       	call   8001ab <printnum>
+			break;
+  80081b:	eb 3c                	jmp    800859 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  80081d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800820:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800824:	89 1c 24             	mov    %ebx,(%esp)
+  800827:	8b 45 08             	mov    0x8(%ebp),%eax
+  80082a:	ff d0                	call   *%eax
+			break;			
+  80082c:	eb 2b                	jmp    800859 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  80082e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800831:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800835:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  80083c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80083f:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  800841:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800845:	eb 04                	jmp    80084b <vprintfmt+0x52c>
+  800847:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80084b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80084e:	83 e8 01             	sub    $0x1,%eax
+  800851:	0f b6 00             	movzbl (%eax),%eax
+  800854:	3c 25                	cmp    $0x25,%al
+  800856:	75 ef                	jne    800847 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800858:	90                   	nop
+		}
+	}
+  800859:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80085a:	e9 3f fc ff ff       	jmp    80049e <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  80085f:	83 c4 40             	add    $0x40,%esp
+  800862:	5b                   	pop    %ebx
+  800863:	5e                   	pop    %esi
+  800864:	5d                   	pop    %ebp
+  800865:	c3                   	ret    
+
+00800866 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800866:	55                   	push   %ebp
+  800867:	89 e5                	mov    %esp,%ebp
+  800869:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  80086c:	8d 45 14             	lea    0x14(%ebp),%eax
+  80086f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800872:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800875:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800879:	8b 45 10             	mov    0x10(%ebp),%eax
+  80087c:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800880:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800883:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800887:	8b 45 08             	mov    0x8(%ebp),%eax
+  80088a:	89 04 24             	mov    %eax,(%esp)
+  80088d:	e8 8d fa ff ff       	call   80031f <vprintfmt>
+	va_end(ap);
+}
+  800892:	c9                   	leave  
+  800893:	c3                   	ret    
+
+00800894 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800894:	55                   	push   %ebp
+  800895:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800897:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80089a:	8b 40 08             	mov    0x8(%eax),%eax
+  80089d:	8d 50 01             	lea    0x1(%eax),%edx
+  8008a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008a3:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  8008a6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008a9:	8b 10                	mov    (%eax),%edx
+  8008ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008ae:	8b 40 04             	mov    0x4(%eax),%eax
+  8008b1:	39 c2                	cmp    %eax,%edx
+  8008b3:	73 12                	jae    8008c7 <sprintputch+0x33>
+		*b->buf++ = ch;
+  8008b5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008b8:	8b 00                	mov    (%eax),%eax
+  8008ba:	8d 48 01             	lea    0x1(%eax),%ecx
+  8008bd:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8008c0:	89 0a                	mov    %ecx,(%edx)
+  8008c2:	8b 55 08             	mov    0x8(%ebp),%edx
+  8008c5:	88 10                	mov    %dl,(%eax)
+}
+  8008c7:	5d                   	pop    %ebp
+  8008c8:	c3                   	ret    
+
+008008c9 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  8008c9:	55                   	push   %ebp
+  8008ca:	89 e5                	mov    %esp,%ebp
+  8008cc:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  8008cf:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8008d5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008d8:	8d 50 ff             	lea    -0x1(%eax),%edx
+  8008db:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008de:	01 d0                	add    %edx,%eax
+  8008e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  8008ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  8008ee:	74 06                	je     8008f6 <vsnprintf+0x2d>
+  8008f0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8008f4:	7f 07                	jg     8008fd <vsnprintf+0x34>
+		return -E_INVAL;
+  8008f6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  8008fb:	eb 2a                	jmp    800927 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  8008fd:	8b 45 14             	mov    0x14(%ebp),%eax
+  800900:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800904:	8b 45 10             	mov    0x10(%ebp),%eax
+  800907:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80090b:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  80090e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800912:	c7 04 24 94 08 80 00 	movl   $0x800894,(%esp)
+  800919:	e8 01 fa ff ff       	call   80031f <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  80091e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800921:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800924:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800927:	c9                   	leave  
+  800928:	c3                   	ret    
+
+00800929 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800929:	55                   	push   %ebp
+  80092a:	89 e5                	mov    %esp,%ebp
+  80092c:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  80092f:	8d 45 14             	lea    0x14(%ebp),%eax
+  800932:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800935:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800938:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  80093c:	8b 45 10             	mov    0x10(%ebp),%eax
+  80093f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800943:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800946:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80094a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094d:	89 04 24             	mov    %eax,(%esp)
+  800950:	e8 74 ff ff ff       	call   8008c9 <vsnprintf>
+  800955:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800958:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80095b:	c9                   	leave  
+  80095c:	c3                   	ret    
+
+0080095d <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  80095d:	55                   	push   %ebp
+  80095e:	89 e5                	mov    %esp,%ebp
+  800960:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800963:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  80096a:	eb 08                	jmp    800974 <strlen+0x17>
+		n++;
+  80096c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800970:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800974:	8b 45 08             	mov    0x8(%ebp),%eax
+  800977:	0f b6 00             	movzbl (%eax),%eax
+  80097a:	84 c0                	test   %al,%al
+  80097c:	75 ee                	jne    80096c <strlen+0xf>
+		n++;
+	return n;
+  80097e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800981:	c9                   	leave  
+  800982:	c3                   	ret    
+
+00800983 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800983:	55                   	push   %ebp
+  800984:	89 e5                	mov    %esp,%ebp
+  800986:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800989:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800990:	eb 0c                	jmp    80099e <strnlen+0x1b>
+		n++;
+  800992:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800996:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80099a:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  80099e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8009a2:	74 0a                	je     8009ae <strnlen+0x2b>
+  8009a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009a7:	0f b6 00             	movzbl (%eax),%eax
+  8009aa:	84 c0                	test   %al,%al
+  8009ac:	75 e4                	jne    800992 <strnlen+0xf>
+		n++;
+	return n;
+  8009ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009b1:	c9                   	leave  
+  8009b2:	c3                   	ret    
+
+008009b3 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  8009b3:	55                   	push   %ebp
+  8009b4:	89 e5                	mov    %esp,%ebp
+  8009b6:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  8009b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  8009bf:	90                   	nop
+  8009c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009c3:	8d 50 01             	lea    0x1(%eax),%edx
+  8009c6:	89 55 08             	mov    %edx,0x8(%ebp)
+  8009c9:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8009cc:	8d 4a 01             	lea    0x1(%edx),%ecx
+  8009cf:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  8009d2:	0f b6 12             	movzbl (%edx),%edx
+  8009d5:	88 10                	mov    %dl,(%eax)
+  8009d7:	0f b6 00             	movzbl (%eax),%eax
+  8009da:	84 c0                	test   %al,%al
+  8009dc:	75 e2                	jne    8009c0 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  8009de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009e1:	c9                   	leave  
+  8009e2:	c3                   	ret    
+
+008009e3 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  8009e3:	55                   	push   %ebp
+  8009e4:	89 e5                	mov    %esp,%ebp
+  8009e6:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  8009e9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ec:	89 04 24             	mov    %eax,(%esp)
+  8009ef:	e8 69 ff ff ff       	call   80095d <strlen>
+  8009f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  8009f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  8009fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009fd:	01 c2                	add    %eax,%edx
+  8009ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a02:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a06:	89 14 24             	mov    %edx,(%esp)
+  800a09:	e8 a5 ff ff ff       	call   8009b3 <strcpy>
+	return dst;
+  800a0e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800a11:	c9                   	leave  
+  800a12:	c3                   	ret    
+
+00800a13 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800a13:	55                   	push   %ebp
+  800a14:	89 e5                	mov    %esp,%ebp
+  800a16:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800a19:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a1c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800a1f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800a26:	eb 23                	jmp    800a4b <strncpy+0x38>
+		*dst++ = *src;
+  800a28:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a2b:	8d 50 01             	lea    0x1(%eax),%edx
+  800a2e:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a31:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a34:	0f b6 12             	movzbl (%edx),%edx
+  800a37:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800a39:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a3c:	0f b6 00             	movzbl (%eax),%eax
+  800a3f:	84 c0                	test   %al,%al
+  800a41:	74 04                	je     800a47 <strncpy+0x34>
+			src++;
+  800a43:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800a47:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800a4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a4e:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800a51:	72 d5                	jb     800a28 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800a53:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800a56:	c9                   	leave  
+  800a57:	c3                   	ret    
+
+00800a58 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800a58:	55                   	push   %ebp
+  800a59:	89 e5                	mov    %esp,%ebp
+  800a5b:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800a5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a61:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800a64:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a68:	74 33                	je     800a9d <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800a6a:	eb 17                	jmp    800a83 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800a6c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a6f:	8d 50 01             	lea    0x1(%eax),%edx
+  800a72:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a75:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a78:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800a7b:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800a7e:	0f b6 12             	movzbl (%edx),%edx
+  800a81:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800a83:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a87:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a8b:	74 0a                	je     800a97 <strlcpy+0x3f>
+  800a8d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a90:	0f b6 00             	movzbl (%eax),%eax
+  800a93:	84 c0                	test   %al,%al
+  800a95:	75 d5                	jne    800a6c <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800a97:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a9a:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800a9d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800aa0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800aa3:	29 c2                	sub    %eax,%edx
+  800aa5:	89 d0                	mov    %edx,%eax
+}
+  800aa7:	c9                   	leave  
+  800aa8:	c3                   	ret    
+
+00800aa9 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800aa9:	55                   	push   %ebp
+  800aaa:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800aac:	eb 08                	jmp    800ab6 <strcmp+0xd>
+		p++, q++;
+  800aae:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ab2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800ab6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ab9:	0f b6 00             	movzbl (%eax),%eax
+  800abc:	84 c0                	test   %al,%al
+  800abe:	74 10                	je     800ad0 <strcmp+0x27>
+  800ac0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ac3:	0f b6 10             	movzbl (%eax),%edx
+  800ac6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ac9:	0f b6 00             	movzbl (%eax),%eax
+  800acc:	38 c2                	cmp    %al,%dl
+  800ace:	74 de                	je     800aae <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800ad0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ad3:	0f b6 00             	movzbl (%eax),%eax
+  800ad6:	0f b6 d0             	movzbl %al,%edx
+  800ad9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800adc:	0f b6 00             	movzbl (%eax),%eax
+  800adf:	0f b6 c0             	movzbl %al,%eax
+  800ae2:	29 c2                	sub    %eax,%edx
+  800ae4:	89 d0                	mov    %edx,%eax
+}
+  800ae6:	5d                   	pop    %ebp
+  800ae7:	c3                   	ret    
+
+00800ae8 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800ae8:	55                   	push   %ebp
+  800ae9:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800aeb:	eb 0c                	jmp    800af9 <strncmp+0x11>
+		n--, p++, q++;
+  800aed:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800af1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800af5:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800af9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800afd:	74 1a                	je     800b19 <strncmp+0x31>
+  800aff:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b02:	0f b6 00             	movzbl (%eax),%eax
+  800b05:	84 c0                	test   %al,%al
+  800b07:	74 10                	je     800b19 <strncmp+0x31>
+  800b09:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b0c:	0f b6 10             	movzbl (%eax),%edx
+  800b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b12:	0f b6 00             	movzbl (%eax),%eax
+  800b15:	38 c2                	cmp    %al,%dl
+  800b17:	74 d4                	je     800aed <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800b19:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b1d:	75 07                	jne    800b26 <strncmp+0x3e>
+		return 0;
+  800b1f:	b8 00 00 00 00       	mov    $0x0,%eax
+  800b24:	eb 16                	jmp    800b3c <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800b26:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b29:	0f b6 00             	movzbl (%eax),%eax
+  800b2c:	0f b6 d0             	movzbl %al,%edx
+  800b2f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b32:	0f b6 00             	movzbl (%eax),%eax
+  800b35:	0f b6 c0             	movzbl %al,%eax
+  800b38:	29 c2                	sub    %eax,%edx
+  800b3a:	89 d0                	mov    %edx,%eax
+}
+  800b3c:	5d                   	pop    %ebp
+  800b3d:	c3                   	ret    
+
+00800b3e <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800b3e:	55                   	push   %ebp
+  800b3f:	89 e5                	mov    %esp,%ebp
+  800b41:	83 ec 04             	sub    $0x4,%esp
+  800b44:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b47:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b4a:	eb 14                	jmp    800b60 <strchr+0x22>
+		if (*s == c)
+  800b4c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b4f:	0f b6 00             	movzbl (%eax),%eax
+  800b52:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b55:	75 05                	jne    800b5c <strchr+0x1e>
+			return (char *) s;
+  800b57:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5a:	eb 13                	jmp    800b6f <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800b5c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b60:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b63:	0f b6 00             	movzbl (%eax),%eax
+  800b66:	84 c0                	test   %al,%al
+  800b68:	75 e2                	jne    800b4c <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800b6a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800b6f:	c9                   	leave  
+  800b70:	c3                   	ret    
+
+00800b71 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800b71:	55                   	push   %ebp
+  800b72:	89 e5                	mov    %esp,%ebp
+  800b74:	83 ec 04             	sub    $0x4,%esp
+  800b77:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b7a:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b7d:	eb 11                	jmp    800b90 <strfind+0x1f>
+		if (*s == c)
+  800b7f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b82:	0f b6 00             	movzbl (%eax),%eax
+  800b85:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b88:	75 02                	jne    800b8c <strfind+0x1b>
+			break;
+  800b8a:	eb 0e                	jmp    800b9a <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800b8c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b90:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b93:	0f b6 00             	movzbl (%eax),%eax
+  800b96:	84 c0                	test   %al,%al
+  800b98:	75 e5                	jne    800b7f <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800b9a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800b9d:	c9                   	leave  
+  800b9e:	c3                   	ret    
+
+00800b9f <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800b9f:	55                   	push   %ebp
+  800ba0:	89 e5                	mov    %esp,%ebp
+  800ba2:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800ba3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800ba7:	75 05                	jne    800bae <memset+0xf>
+		return v;
+  800ba9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bac:	eb 5c                	jmp    800c0a <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800bae:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bb1:	83 e0 03             	and    $0x3,%eax
+  800bb4:	85 c0                	test   %eax,%eax
+  800bb6:	75 41                	jne    800bf9 <memset+0x5a>
+  800bb8:	8b 45 10             	mov    0x10(%ebp),%eax
+  800bbb:	83 e0 03             	and    $0x3,%eax
+  800bbe:	85 c0                	test   %eax,%eax
+  800bc0:	75 37                	jne    800bf9 <memset+0x5a>
+		c &= 0xFF;
+  800bc2:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800bc9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bcc:	c1 e0 18             	shl    $0x18,%eax
+  800bcf:	89 c2                	mov    %eax,%edx
+  800bd1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bd4:	c1 e0 10             	shl    $0x10,%eax
+  800bd7:	09 c2                	or     %eax,%edx
+  800bd9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bdc:	c1 e0 08             	shl    $0x8,%eax
+  800bdf:	09 d0                	or     %edx,%eax
+  800be1:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800be4:	8b 45 10             	mov    0x10(%ebp),%eax
+  800be7:	c1 e8 02             	shr    $0x2,%eax
+  800bea:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800bec:	8b 55 08             	mov    0x8(%ebp),%edx
+  800bef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bf2:	89 d7                	mov    %edx,%edi
+  800bf4:	fc                   	cld    
+  800bf5:	f3 ab                	rep stos %eax,%es:(%edi)
+  800bf7:	eb 0e                	jmp    800c07 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800bf9:	8b 55 08             	mov    0x8(%ebp),%edx
+  800bfc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bff:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800c02:	89 d7                	mov    %edx,%edi
+  800c04:	fc                   	cld    
+  800c05:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800c07:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800c0a:	5f                   	pop    %edi
+  800c0b:	5d                   	pop    %ebp
+  800c0c:	c3                   	ret    
+
+00800c0d <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800c0d:	55                   	push   %ebp
+  800c0e:	89 e5                	mov    %esp,%ebp
+  800c10:	57                   	push   %edi
+  800c11:	56                   	push   %esi
+  800c12:	53                   	push   %ebx
+  800c13:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800c16:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c19:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800c1c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800c22:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c25:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c28:	73 6d                	jae    800c97 <memmove+0x8a>
+  800c2a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c2d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c30:	01 d0                	add    %edx,%eax
+  800c32:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c35:	76 60                	jbe    800c97 <memmove+0x8a>
+		s += n;
+  800c37:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c3a:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800c3d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c40:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c46:	83 e0 03             	and    $0x3,%eax
+  800c49:	85 c0                	test   %eax,%eax
+  800c4b:	75 2f                	jne    800c7c <memmove+0x6f>
+  800c4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c50:	83 e0 03             	and    $0x3,%eax
+  800c53:	85 c0                	test   %eax,%eax
+  800c55:	75 25                	jne    800c7c <memmove+0x6f>
+  800c57:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c5a:	83 e0 03             	and    $0x3,%eax
+  800c5d:	85 c0                	test   %eax,%eax
+  800c5f:	75 1b                	jne    800c7c <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800c61:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c64:	83 e8 04             	sub    $0x4,%eax
+  800c67:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c6a:	83 ea 04             	sub    $0x4,%edx
+  800c6d:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800c70:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800c73:	89 c7                	mov    %eax,%edi
+  800c75:	89 d6                	mov    %edx,%esi
+  800c77:	fd                   	std    
+  800c78:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800c7a:	eb 18                	jmp    800c94 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800c7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c7f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800c82:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c85:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800c88:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c8b:	89 d7                	mov    %edx,%edi
+  800c8d:	89 de                	mov    %ebx,%esi
+  800c8f:	89 c1                	mov    %eax,%ecx
+  800c91:	fd                   	std    
+  800c92:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800c94:	fc                   	cld    
+  800c95:	eb 45                	jmp    800cdc <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c97:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c9a:	83 e0 03             	and    $0x3,%eax
+  800c9d:	85 c0                	test   %eax,%eax
+  800c9f:	75 2b                	jne    800ccc <memmove+0xbf>
+  800ca1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ca4:	83 e0 03             	and    $0x3,%eax
+  800ca7:	85 c0                	test   %eax,%eax
+  800ca9:	75 21                	jne    800ccc <memmove+0xbf>
+  800cab:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cae:	83 e0 03             	and    $0x3,%eax
+  800cb1:	85 c0                	test   %eax,%eax
+  800cb3:	75 17                	jne    800ccc <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800cb5:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cb8:	c1 e8 02             	shr    $0x2,%eax
+  800cbb:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800cbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800cc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cc3:	89 c7                	mov    %eax,%edi
+  800cc5:	89 d6                	mov    %edx,%esi
+  800cc7:	fc                   	cld    
+  800cc8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800cca:	eb 10                	jmp    800cdc <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800ccc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ccf:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cd2:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800cd5:	89 c7                	mov    %eax,%edi
+  800cd7:	89 d6                	mov    %edx,%esi
+  800cd9:	fc                   	cld    
+  800cda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800cdc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800cdf:	83 c4 10             	add    $0x10,%esp
+  800ce2:	5b                   	pop    %ebx
+  800ce3:	5e                   	pop    %esi
+  800ce4:	5f                   	pop    %edi
+  800ce5:	5d                   	pop    %ebp
+  800ce6:	c3                   	ret    
+
+00800ce7 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800ce7:	55                   	push   %ebp
+  800ce8:	89 e5                	mov    %esp,%ebp
+  800cea:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800ced:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cf0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800cf4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cf7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800cfb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cfe:	89 04 24             	mov    %eax,(%esp)
+  800d01:	e8 07 ff ff ff       	call   800c0d <memmove>
+}
+  800d06:	c9                   	leave  
+  800d07:	c3                   	ret    
+
+00800d08 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800d08:	55                   	push   %ebp
+  800d09:	89 e5                	mov    %esp,%ebp
+  800d0b:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800d0e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d11:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800d14:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d17:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800d1a:	eb 30                	jmp    800d4c <memcmp+0x44>
+		if (*s1 != *s2)
+  800d1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d1f:	0f b6 10             	movzbl (%eax),%edx
+  800d22:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d25:	0f b6 00             	movzbl (%eax),%eax
+  800d28:	38 c2                	cmp    %al,%dl
+  800d2a:	74 18                	je     800d44 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800d2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d2f:	0f b6 00             	movzbl (%eax),%eax
+  800d32:	0f b6 d0             	movzbl %al,%edx
+  800d35:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d38:	0f b6 00             	movzbl (%eax),%eax
+  800d3b:	0f b6 c0             	movzbl %al,%eax
+  800d3e:	29 c2                	sub    %eax,%edx
+  800d40:	89 d0                	mov    %edx,%eax
+  800d42:	eb 1a                	jmp    800d5e <memcmp+0x56>
+		s1++, s2++;
+  800d44:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800d48:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800d4c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d4f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800d52:	89 55 10             	mov    %edx,0x10(%ebp)
+  800d55:	85 c0                	test   %eax,%eax
+  800d57:	75 c3                	jne    800d1c <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800d59:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d5e:	c9                   	leave  
+  800d5f:	c3                   	ret    
+
+00800d60 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800d60:	55                   	push   %ebp
+  800d61:	89 e5                	mov    %esp,%ebp
+  800d63:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800d66:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d69:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d6c:	01 d0                	add    %edx,%eax
+  800d6e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800d71:	eb 13                	jmp    800d86 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800d73:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d76:	0f b6 10             	movzbl (%eax),%edx
+  800d79:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7c:	38 c2                	cmp    %al,%dl
+  800d7e:	75 02                	jne    800d82 <memfind+0x22>
+			break;
+  800d80:	eb 0c                	jmp    800d8e <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800d82:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d89:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800d8c:	72 e5                	jb     800d73 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800d8e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d91:	c9                   	leave  
+  800d92:	c3                   	ret    
+
+00800d93 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800d93:	55                   	push   %ebp
+  800d94:	89 e5                	mov    %esp,%ebp
+  800d96:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800d99:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800da0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800da7:	eb 04                	jmp    800dad <strtol+0x1a>
+		s++;
+  800da9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800dad:	8b 45 08             	mov    0x8(%ebp),%eax
+  800db0:	0f b6 00             	movzbl (%eax),%eax
+  800db3:	3c 20                	cmp    $0x20,%al
+  800db5:	74 f2                	je     800da9 <strtol+0x16>
+  800db7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dba:	0f b6 00             	movzbl (%eax),%eax
+  800dbd:	3c 09                	cmp    $0x9,%al
+  800dbf:	74 e8                	je     800da9 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800dc1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc4:	0f b6 00             	movzbl (%eax),%eax
+  800dc7:	3c 2b                	cmp    $0x2b,%al
+  800dc9:	75 06                	jne    800dd1 <strtol+0x3e>
+		s++;
+  800dcb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800dcf:	eb 15                	jmp    800de6 <strtol+0x53>
+	else if (*s == '-')
+  800dd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dd4:	0f b6 00             	movzbl (%eax),%eax
+  800dd7:	3c 2d                	cmp    $0x2d,%al
+  800dd9:	75 0b                	jne    800de6 <strtol+0x53>
+		s++, neg = 1;
+  800ddb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ddf:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800de6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800dea:	74 06                	je     800df2 <strtol+0x5f>
+  800dec:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800df0:	75 24                	jne    800e16 <strtol+0x83>
+  800df2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800df5:	0f b6 00             	movzbl (%eax),%eax
+  800df8:	3c 30                	cmp    $0x30,%al
+  800dfa:	75 1a                	jne    800e16 <strtol+0x83>
+  800dfc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dff:	83 c0 01             	add    $0x1,%eax
+  800e02:	0f b6 00             	movzbl (%eax),%eax
+  800e05:	3c 78                	cmp    $0x78,%al
+  800e07:	75 0d                	jne    800e16 <strtol+0x83>
+		s += 2, base = 16;
+  800e09:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800e0d:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800e14:	eb 2a                	jmp    800e40 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800e16:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e1a:	75 17                	jne    800e33 <strtol+0xa0>
+  800e1c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e1f:	0f b6 00             	movzbl (%eax),%eax
+  800e22:	3c 30                	cmp    $0x30,%al
+  800e24:	75 0d                	jne    800e33 <strtol+0xa0>
+		s++, base = 8;
+  800e26:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800e2a:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800e31:	eb 0d                	jmp    800e40 <strtol+0xad>
+	else if (base == 0)
+  800e33:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e37:	75 07                	jne    800e40 <strtol+0xad>
+		base = 10;
+  800e39:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800e40:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e43:	0f b6 00             	movzbl (%eax),%eax
+  800e46:	3c 2f                	cmp    $0x2f,%al
+  800e48:	7e 1b                	jle    800e65 <strtol+0xd2>
+  800e4a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e4d:	0f b6 00             	movzbl (%eax),%eax
+  800e50:	3c 39                	cmp    $0x39,%al
+  800e52:	7f 11                	jg     800e65 <strtol+0xd2>
+			dig = *s - '0';
+  800e54:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e57:	0f b6 00             	movzbl (%eax),%eax
+  800e5a:	0f be c0             	movsbl %al,%eax
+  800e5d:	83 e8 30             	sub    $0x30,%eax
+  800e60:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e63:	eb 48                	jmp    800ead <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  800e65:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e68:	0f b6 00             	movzbl (%eax),%eax
+  800e6b:	3c 60                	cmp    $0x60,%al
+  800e6d:	7e 1b                	jle    800e8a <strtol+0xf7>
+  800e6f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e72:	0f b6 00             	movzbl (%eax),%eax
+  800e75:	3c 7a                	cmp    $0x7a,%al
+  800e77:	7f 11                	jg     800e8a <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  800e79:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e7c:	0f b6 00             	movzbl (%eax),%eax
+  800e7f:	0f be c0             	movsbl %al,%eax
+  800e82:	83 e8 57             	sub    $0x57,%eax
+  800e85:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e88:	eb 23                	jmp    800ead <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  800e8a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e8d:	0f b6 00             	movzbl (%eax),%eax
+  800e90:	3c 40                	cmp    $0x40,%al
+  800e92:	7e 3d                	jle    800ed1 <strtol+0x13e>
+  800e94:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e97:	0f b6 00             	movzbl (%eax),%eax
+  800e9a:	3c 5a                	cmp    $0x5a,%al
+  800e9c:	7f 33                	jg     800ed1 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  800e9e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ea1:	0f b6 00             	movzbl (%eax),%eax
+  800ea4:	0f be c0             	movsbl %al,%eax
+  800ea7:	83 e8 37             	sub    $0x37,%eax
+  800eaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  800ead:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800eb0:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800eb3:	7c 02                	jl     800eb7 <strtol+0x124>
+			break;
+  800eb5:	eb 1a                	jmp    800ed1 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  800eb7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ebb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ebe:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800ec2:	89 c2                	mov    %eax,%edx
+  800ec4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800ec7:	01 d0                	add    %edx,%eax
+  800ec9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  800ecc:	e9 6f ff ff ff       	jmp    800e40 <strtol+0xad>
+
+	if (endptr)
+  800ed1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800ed5:	74 08                	je     800edf <strtol+0x14c>
+		*endptr = (char *) s;
+  800ed7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800eda:	8b 55 08             	mov    0x8(%ebp),%edx
+  800edd:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  800edf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800ee3:	74 07                	je     800eec <strtol+0x159>
+  800ee5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ee8:	f7 d8                	neg    %eax
+  800eea:	eb 03                	jmp    800eef <strtol+0x15c>
+  800eec:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800eef:	c9                   	leave  
+  800ef0:	c3                   	ret    
+
+00800ef1 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  800ef1:	55                   	push   %ebp
+  800ef2:	89 e5                	mov    %esp,%ebp
+  800ef4:	57                   	push   %edi
+  800ef5:	56                   	push   %esi
+  800ef6:	53                   	push   %ebx
+  800ef7:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  800efa:	8b 45 08             	mov    0x8(%ebp),%eax
+  800efd:	8b 55 10             	mov    0x10(%ebp),%edx
+  800f00:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  800f03:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  800f06:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  800f09:	8b 75 20             	mov    0x20(%ebp),%esi
+  800f0c:	cd 30                	int    $0x30
+  800f0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  800f11:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800f15:	74 30                	je     800f47 <syscall+0x56>
+  800f17:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800f1b:	7e 2a                	jle    800f47 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  800f1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800f20:	89 44 24 10          	mov    %eax,0x10(%esp)
+  800f24:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f27:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800f2b:	c7 44 24 08 64 15 80 	movl   $0x801564,0x8(%esp)
+  800f32:	00 
+  800f33:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  800f3a:	00 
+  800f3b:	c7 04 24 81 15 80 00 	movl   $0x801581,(%esp)
+  800f42:	e8 18 01 00 00       	call   80105f <_panic>
+
+	return ret;
+  800f47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  800f4a:	83 c4 3c             	add    $0x3c,%esp
+  800f4d:	5b                   	pop    %ebx
+  800f4e:	5e                   	pop    %esi
+  800f4f:	5f                   	pop    %edi
+  800f50:	5d                   	pop    %ebp
+  800f51:	c3                   	ret    
+
+00800f52 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800f52:	55                   	push   %ebp
+  800f53:	89 e5                	mov    %esp,%ebp
+  800f55:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800f58:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f5b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f62:	00 
+  800f63:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800f6a:	00 
+  800f6b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800f72:	00 
+  800f73:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800f76:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800f7a:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800f7e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800f85:	00 
+  800f86:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800f8d:	e8 5f ff ff ff       	call   800ef1 <syscall>
+}
+  800f92:	c9                   	leave  
+  800f93:	c3                   	ret    
+
+00800f94 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800f94:	55                   	push   %ebp
+  800f95:	89 e5                	mov    %esp,%ebp
+  800f97:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800f9a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800fa1:	00 
+  800fa2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800fa9:	00 
+  800faa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800fb1:	00 
+  800fb2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800fb9:	00 
+  800fba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800fc1:	00 
+  800fc2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800fc9:	00 
+  800fca:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800fd1:	e8 1b ff ff ff       	call   800ef1 <syscall>
+}
+  800fd6:	c9                   	leave  
+  800fd7:	c3                   	ret    
+
+00800fd8 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800fd8:	55                   	push   %ebp
+  800fd9:	89 e5                	mov    %esp,%ebp
+  800fdb:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800fde:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fe1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800fe8:	00 
+  800fe9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800ff0:	00 
+  800ff1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800ff8:	00 
+  800ff9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  801000:	00 
+  801001:	89 44 24 08          	mov    %eax,0x8(%esp)
+  801005:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  80100c:	00 
+  80100d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  801014:	e8 d8 fe ff ff       	call   800ef1 <syscall>
+}
+  801019:	c9                   	leave  
+  80101a:	c3                   	ret    
+
+0080101b <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  80101b:	55                   	push   %ebp
+  80101c:	89 e5                	mov    %esp,%ebp
+  80101e:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  801021:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  801028:	00 
+  801029:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  801030:	00 
+  801031:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  801038:	00 
+  801039:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  801040:	00 
+  801041:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  801048:	00 
+  801049:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  801050:	00 
+  801051:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  801058:	e8 94 fe ff ff       	call   800ef1 <syscall>
+}
+  80105d:	c9                   	leave  
+  80105e:	c3                   	ret    
+
+0080105f <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80105f:	55                   	push   %ebp
+  801060:	89 e5                	mov    %esp,%ebp
+  801062:	53                   	push   %ebx
+  801063:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  801066:	8d 45 14             	lea    0x14(%ebp),%eax
+  801069:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80106c:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  801072:	e8 a4 ff ff ff       	call   80101b <sys_getenvid>
+  801077:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80107a:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80107e:	8b 55 08             	mov    0x8(%ebp),%edx
+  801081:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  801085:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  801089:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80108d:	c7 04 24 90 15 80 00 	movl   $0x801590,(%esp)
+  801094:	e8 ec f0 ff ff       	call   800185 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  801099:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80109c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8010a0:	8b 45 10             	mov    0x10(%ebp),%eax
+  8010a3:	89 04 24             	mov    %eax,(%esp)
+  8010a6:	e8 76 f0 ff ff       	call   800121 <vcprintf>
+	cprintf("\n");
+  8010ab:	c7 04 24 b3 15 80 00 	movl   $0x8015b3,(%esp)
+  8010b2:	e8 ce f0 ff ff       	call   800185 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  8010b7:	cc                   	int3   
+  8010b8:	eb fd                	jmp    8010b7 <_panic+0x58>
+  8010ba:	66 90                	xchg   %ax,%ax
+  8010bc:	66 90                	xchg   %ax,%ax
+  8010be:	66 90                	xchg   %ax,%ax
+
+008010c0 <__udivdi3>:
+  8010c0:	55                   	push   %ebp
+  8010c1:	57                   	push   %edi
+  8010c2:	56                   	push   %esi
+  8010c3:	83 ec 0c             	sub    $0xc,%esp
+  8010c6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ca:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010ce:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010d2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010d6:	85 c0                	test   %eax,%eax
+  8010d8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010dc:	89 ea                	mov    %ebp,%edx
+  8010de:	89 0c 24             	mov    %ecx,(%esp)
+  8010e1:	75 2d                	jne    801110 <__udivdi3+0x50>
+  8010e3:	39 e9                	cmp    %ebp,%ecx
+  8010e5:	77 61                	ja     801148 <__udivdi3+0x88>
+  8010e7:	85 c9                	test   %ecx,%ecx
+  8010e9:	89 ce                	mov    %ecx,%esi
+  8010eb:	75 0b                	jne    8010f8 <__udivdi3+0x38>
+  8010ed:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010f2:	31 d2                	xor    %edx,%edx
+  8010f4:	f7 f1                	div    %ecx
+  8010f6:	89 c6                	mov    %eax,%esi
+  8010f8:	31 d2                	xor    %edx,%edx
+  8010fa:	89 e8                	mov    %ebp,%eax
+  8010fc:	f7 f6                	div    %esi
+  8010fe:	89 c5                	mov    %eax,%ebp
+  801100:	89 f8                	mov    %edi,%eax
+  801102:	f7 f6                	div    %esi
+  801104:	89 ea                	mov    %ebp,%edx
+  801106:	83 c4 0c             	add    $0xc,%esp
+  801109:	5e                   	pop    %esi
+  80110a:	5f                   	pop    %edi
+  80110b:	5d                   	pop    %ebp
+  80110c:	c3                   	ret    
+  80110d:	8d 76 00             	lea    0x0(%esi),%esi
+  801110:	39 e8                	cmp    %ebp,%eax
+  801112:	77 24                	ja     801138 <__udivdi3+0x78>
+  801114:	0f bd e8             	bsr    %eax,%ebp
+  801117:	83 f5 1f             	xor    $0x1f,%ebp
+  80111a:	75 3c                	jne    801158 <__udivdi3+0x98>
+  80111c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801120:	39 34 24             	cmp    %esi,(%esp)
+  801123:	0f 86 9f 00 00 00    	jbe    8011c8 <__udivdi3+0x108>
+  801129:	39 d0                	cmp    %edx,%eax
+  80112b:	0f 82 97 00 00 00    	jb     8011c8 <__udivdi3+0x108>
+  801131:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801138:	31 d2                	xor    %edx,%edx
+  80113a:	31 c0                	xor    %eax,%eax
+  80113c:	83 c4 0c             	add    $0xc,%esp
+  80113f:	5e                   	pop    %esi
+  801140:	5f                   	pop    %edi
+  801141:	5d                   	pop    %ebp
+  801142:	c3                   	ret    
+  801143:	90                   	nop
+  801144:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801148:	89 f8                	mov    %edi,%eax
+  80114a:	f7 f1                	div    %ecx
+  80114c:	31 d2                	xor    %edx,%edx
+  80114e:	83 c4 0c             	add    $0xc,%esp
+  801151:	5e                   	pop    %esi
+  801152:	5f                   	pop    %edi
+  801153:	5d                   	pop    %ebp
+  801154:	c3                   	ret    
+  801155:	8d 76 00             	lea    0x0(%esi),%esi
+  801158:	89 e9                	mov    %ebp,%ecx
+  80115a:	8b 3c 24             	mov    (%esp),%edi
+  80115d:	d3 e0                	shl    %cl,%eax
+  80115f:	89 c6                	mov    %eax,%esi
+  801161:	b8 20 00 00 00       	mov    $0x20,%eax
+  801166:	29 e8                	sub    %ebp,%eax
+  801168:	89 c1                	mov    %eax,%ecx
+  80116a:	d3 ef                	shr    %cl,%edi
+  80116c:	89 e9                	mov    %ebp,%ecx
+  80116e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801172:	8b 3c 24             	mov    (%esp),%edi
+  801175:	09 74 24 08          	or     %esi,0x8(%esp)
+  801179:	89 d6                	mov    %edx,%esi
+  80117b:	d3 e7                	shl    %cl,%edi
+  80117d:	89 c1                	mov    %eax,%ecx
+  80117f:	89 3c 24             	mov    %edi,(%esp)
+  801182:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801186:	d3 ee                	shr    %cl,%esi
+  801188:	89 e9                	mov    %ebp,%ecx
+  80118a:	d3 e2                	shl    %cl,%edx
+  80118c:	89 c1                	mov    %eax,%ecx
+  80118e:	d3 ef                	shr    %cl,%edi
+  801190:	09 d7                	or     %edx,%edi
+  801192:	89 f2                	mov    %esi,%edx
+  801194:	89 f8                	mov    %edi,%eax
+  801196:	f7 74 24 08          	divl   0x8(%esp)
+  80119a:	89 d6                	mov    %edx,%esi
+  80119c:	89 c7                	mov    %eax,%edi
+  80119e:	f7 24 24             	mull   (%esp)
+  8011a1:	39 d6                	cmp    %edx,%esi
+  8011a3:	89 14 24             	mov    %edx,(%esp)
+  8011a6:	72 30                	jb     8011d8 <__udivdi3+0x118>
+  8011a8:	8b 54 24 04          	mov    0x4(%esp),%edx
+  8011ac:	89 e9                	mov    %ebp,%ecx
+  8011ae:	d3 e2                	shl    %cl,%edx
+  8011b0:	39 c2                	cmp    %eax,%edx
+  8011b2:	73 05                	jae    8011b9 <__udivdi3+0xf9>
+  8011b4:	3b 34 24             	cmp    (%esp),%esi
+  8011b7:	74 1f                	je     8011d8 <__udivdi3+0x118>
+  8011b9:	89 f8                	mov    %edi,%eax
+  8011bb:	31 d2                	xor    %edx,%edx
+  8011bd:	e9 7a ff ff ff       	jmp    80113c <__udivdi3+0x7c>
+  8011c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011c8:	31 d2                	xor    %edx,%edx
+  8011ca:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011cf:	e9 68 ff ff ff       	jmp    80113c <__udivdi3+0x7c>
+  8011d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011d8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011db:	31 d2                	xor    %edx,%edx
+  8011dd:	83 c4 0c             	add    $0xc,%esp
+  8011e0:	5e                   	pop    %esi
+  8011e1:	5f                   	pop    %edi
+  8011e2:	5d                   	pop    %ebp
+  8011e3:	c3                   	ret    
+  8011e4:	66 90                	xchg   %ax,%ax
+  8011e6:	66 90                	xchg   %ax,%ax
+  8011e8:	66 90                	xchg   %ax,%ax
+  8011ea:	66 90                	xchg   %ax,%ax
+  8011ec:	66 90                	xchg   %ax,%ax
+  8011ee:	66 90                	xchg   %ax,%ax
+
+008011f0 <__umoddi3>:
+  8011f0:	55                   	push   %ebp
+  8011f1:	57                   	push   %edi
+  8011f2:	56                   	push   %esi
+  8011f3:	83 ec 14             	sub    $0x14,%esp
+  8011f6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011fa:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011fe:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  801202:	89 c7                	mov    %eax,%edi
+  801204:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801208:	8b 44 24 30          	mov    0x30(%esp),%eax
+  80120c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801210:	89 34 24             	mov    %esi,(%esp)
+  801213:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801217:	85 c0                	test   %eax,%eax
+  801219:	89 c2                	mov    %eax,%edx
+  80121b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80121f:	75 17                	jne    801238 <__umoddi3+0x48>
+  801221:	39 fe                	cmp    %edi,%esi
+  801223:	76 4b                	jbe    801270 <__umoddi3+0x80>
+  801225:	89 c8                	mov    %ecx,%eax
+  801227:	89 fa                	mov    %edi,%edx
+  801229:	f7 f6                	div    %esi
+  80122b:	89 d0                	mov    %edx,%eax
+  80122d:	31 d2                	xor    %edx,%edx
+  80122f:	83 c4 14             	add    $0x14,%esp
+  801232:	5e                   	pop    %esi
+  801233:	5f                   	pop    %edi
+  801234:	5d                   	pop    %ebp
+  801235:	c3                   	ret    
+  801236:	66 90                	xchg   %ax,%ax
+  801238:	39 f8                	cmp    %edi,%eax
+  80123a:	77 54                	ja     801290 <__umoddi3+0xa0>
+  80123c:	0f bd e8             	bsr    %eax,%ebp
+  80123f:	83 f5 1f             	xor    $0x1f,%ebp
+  801242:	75 5c                	jne    8012a0 <__umoddi3+0xb0>
+  801244:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801248:	39 3c 24             	cmp    %edi,(%esp)
+  80124b:	0f 87 e7 00 00 00    	ja     801338 <__umoddi3+0x148>
+  801251:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801255:	29 f1                	sub    %esi,%ecx
+  801257:	19 c7                	sbb    %eax,%edi
+  801259:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80125d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801261:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801265:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801269:	83 c4 14             	add    $0x14,%esp
+  80126c:	5e                   	pop    %esi
+  80126d:	5f                   	pop    %edi
+  80126e:	5d                   	pop    %ebp
+  80126f:	c3                   	ret    
+  801270:	85 f6                	test   %esi,%esi
+  801272:	89 f5                	mov    %esi,%ebp
+  801274:	75 0b                	jne    801281 <__umoddi3+0x91>
+  801276:	b8 01 00 00 00       	mov    $0x1,%eax
+  80127b:	31 d2                	xor    %edx,%edx
+  80127d:	f7 f6                	div    %esi
+  80127f:	89 c5                	mov    %eax,%ebp
+  801281:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801285:	31 d2                	xor    %edx,%edx
+  801287:	f7 f5                	div    %ebp
+  801289:	89 c8                	mov    %ecx,%eax
+  80128b:	f7 f5                	div    %ebp
+  80128d:	eb 9c                	jmp    80122b <__umoddi3+0x3b>
+  80128f:	90                   	nop
+  801290:	89 c8                	mov    %ecx,%eax
+  801292:	89 fa                	mov    %edi,%edx
+  801294:	83 c4 14             	add    $0x14,%esp
+  801297:	5e                   	pop    %esi
+  801298:	5f                   	pop    %edi
+  801299:	5d                   	pop    %ebp
+  80129a:	c3                   	ret    
+  80129b:	90                   	nop
+  80129c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8012a0:	8b 04 24             	mov    (%esp),%eax
+  8012a3:	be 20 00 00 00       	mov    $0x20,%esi
+  8012a8:	89 e9                	mov    %ebp,%ecx
+  8012aa:	29 ee                	sub    %ebp,%esi
+  8012ac:	d3 e2                	shl    %cl,%edx
+  8012ae:	89 f1                	mov    %esi,%ecx
+  8012b0:	d3 e8                	shr    %cl,%eax
+  8012b2:	89 e9                	mov    %ebp,%ecx
+  8012b4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012b8:	8b 04 24             	mov    (%esp),%eax
+  8012bb:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012bf:	89 fa                	mov    %edi,%edx
+  8012c1:	d3 e0                	shl    %cl,%eax
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012c9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012cd:	d3 ea                	shr    %cl,%edx
+  8012cf:	89 e9                	mov    %ebp,%ecx
+  8012d1:	d3 e7                	shl    %cl,%edi
+  8012d3:	89 f1                	mov    %esi,%ecx
+  8012d5:	d3 e8                	shr    %cl,%eax
+  8012d7:	89 e9                	mov    %ebp,%ecx
+  8012d9:	09 f8                	or     %edi,%eax
+  8012db:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012df:	f7 74 24 04          	divl   0x4(%esp)
+  8012e3:	d3 e7                	shl    %cl,%edi
+  8012e5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012e9:	89 d7                	mov    %edx,%edi
+  8012eb:	f7 64 24 08          	mull   0x8(%esp)
+  8012ef:	39 d7                	cmp    %edx,%edi
+  8012f1:	89 c1                	mov    %eax,%ecx
+  8012f3:	89 14 24             	mov    %edx,(%esp)
+  8012f6:	72 2c                	jb     801324 <__umoddi3+0x134>
+  8012f8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012fc:	72 22                	jb     801320 <__umoddi3+0x130>
+  8012fe:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  801302:	29 c8                	sub    %ecx,%eax
+  801304:	19 d7                	sbb    %edx,%edi
+  801306:	89 e9                	mov    %ebp,%ecx
+  801308:	89 fa                	mov    %edi,%edx
+  80130a:	d3 e8                	shr    %cl,%eax
+  80130c:	89 f1                	mov    %esi,%ecx
+  80130e:	d3 e2                	shl    %cl,%edx
+  801310:	89 e9                	mov    %ebp,%ecx
+  801312:	d3 ef                	shr    %cl,%edi
+  801314:	09 d0                	or     %edx,%eax
+  801316:	89 fa                	mov    %edi,%edx
+  801318:	83 c4 14             	add    $0x14,%esp
+  80131b:	5e                   	pop    %esi
+  80131c:	5f                   	pop    %edi
+  80131d:	5d                   	pop    %ebp
+  80131e:	c3                   	ret    
+  80131f:	90                   	nop
+  801320:	39 d7                	cmp    %edx,%edi
+  801322:	75 da                	jne    8012fe <__umoddi3+0x10e>
+  801324:	8b 14 24             	mov    (%esp),%edx
+  801327:	89 c1                	mov    %eax,%ecx
+  801329:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80132d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801331:	eb cb                	jmp    8012fe <__umoddi3+0x10e>
+  801333:	90                   	nop
+  801334:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801338:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80133c:	0f 82 0f ff ff ff    	jb     801251 <__umoddi3+0x61>
+  801342:	e9 1a ff ff ff       	jmp    801261 <__umoddi3+0x71>
diff --git a/obj/user/divzero.o b/obj/user/divzero.o
new file mode 100644
index 0000000..fe95190
Binary files /dev/null and b/obj/user/divzero.o differ
diff --git a/obj/user/divzero.sym b/obj/user/divzero.sym
new file mode 100644
index 0000000..7a72846
--- /dev/null
+++ b/obj/user/divzero.sym
@@ -0,0 +1,55 @@
+00200010 R __STAB_BEGIN__
+00202a28 R __STAB_END__
+00202a29 R __STABSTR_BEGIN__
+002040f1 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+00800063 T libmain
+008000b1 T exit
+008000c5 t putch
+00800121 T vcprintf
+00800185 T cprintf
+008001ab t printnum
+00800289 t getuint
+008002d8 t getint
+0080031f T vprintfmt
+00800866 T printfmt
+00800894 t sprintputch
+008008c9 T vsnprintf
+00800929 T snprintf
+0080095d T strlen
+00800983 T strnlen
+008009b3 T strcpy
+008009e3 T strcat
+00800a13 T strncpy
+00800a58 T strlcpy
+00800aa9 T strcmp
+00800ae8 T strncmp
+00800b3e T strchr
+00800b71 T strfind
+00800b9f T memset
+00800c0d T memmove
+00800ce7 T memcpy
+00800d08 T memcmp
+00800d60 T memfind
+00800d93 T strtol
+00800ef1 t syscall
+00800f52 T sys_cputs
+00800f94 T sys_cgetc
+00800fd8 T sys_env_destroy
+0080101b T sys_getenvid
+0080105f T _panic
+008010c0 T __udivdi3
+008011f0 T __umoddi3
+008013cc r error_string
+00802000 D binaryname
+00802004 B zero
+00802008 B thisenv
+0080200c B BG_COLOR
+00802010 B COLOR
+00802014 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/evilhello b/obj/user/evilhello
new file mode 100755
index 0000000..77c4c30
Binary files /dev/null and b/obj/user/evilhello differ
diff --git a/obj/user/evilhello.asm b/obj/user/evilhello.asm
new file mode 100644
index 0000000..ffccbac
--- /dev/null
+++ b/obj/user/evilhello.asm
@@ -0,0 +1,2629 @@
+
+obj/user/evilhello:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 1e 00 00 00       	call   80004f <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	// try to print the kernel entry point as a string!  mua ha ha!
+	sys_cputs((char*)0xf010000c, 100);
+  800039:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+  800040:	00 
+  800041:	c7 04 24 0c 00 10 f0 	movl   $0xf010000c,(%esp)
+  800048:	e8 c5 00 00 00       	call   800112 <sys_cputs>
+}
+  80004d:	c9                   	leave  
+  80004e:	c3                   	ret    
+
+0080004f <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80004f:	55                   	push   %ebp
+  800050:	89 e5                	mov    %esp,%ebp
+  800052:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800055:	e8 81 01 00 00       	call   8001db <sys_getenvid>
+  80005a:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80005f:	89 c2                	mov    %eax,%edx
+  800061:	89 d0                	mov    %edx,%eax
+  800063:	01 c0                	add    %eax,%eax
+  800065:	01 d0                	add    %edx,%eax
+  800067:	c1 e0 05             	shl    $0x5,%eax
+  80006a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80006f:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800074:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800078:	7e 0a                	jle    800084 <libmain+0x35>
+		binaryname = argv[0];
+  80007a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80007d:	8b 00                	mov    (%eax),%eax
+  80007f:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800084:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800087:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80008b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80008e:	89 04 24             	mov    %eax,(%esp)
+  800091:	e8 9d ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800096:	e8 02 00 00 00       	call   80009d <exit>
+}
+  80009b:	c9                   	leave  
+  80009c:	c3                   	ret    
+
+0080009d <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  80009d:	55                   	push   %ebp
+  80009e:	89 e5                	mov    %esp,%ebp
+  8000a0:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000aa:	e8 e9 00 00 00       	call   800198 <sys_env_destroy>
+}
+  8000af:	c9                   	leave  
+  8000b0:	c3                   	ret    
+
+008000b1 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000b1:	55                   	push   %ebp
+  8000b2:	89 e5                	mov    %esp,%ebp
+  8000b4:	57                   	push   %edi
+  8000b5:	56                   	push   %esi
+  8000b6:	53                   	push   %ebx
+  8000b7:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000ba:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000bd:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000c0:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000c3:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000c6:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000c9:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000cc:	cd 30                	int    $0x30
+  8000ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000d5:	74 30                	je     800107 <syscall+0x56>
+  8000d7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000db:	7e 2a                	jle    800107 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000e0:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000e4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000eb:	c7 44 24 08 42 13 80 	movl   $0x801342,0x8(%esp)
+  8000f2:	00 
+  8000f3:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000fa:	00 
+  8000fb:	c7 04 24 5f 13 80 00 	movl   $0x80135f,(%esp)
+  800102:	e8 18 01 00 00       	call   80021f <_panic>
+
+	return ret;
+  800107:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  80010a:	83 c4 3c             	add    $0x3c,%esp
+  80010d:	5b                   	pop    %ebx
+  80010e:	5e                   	pop    %esi
+  80010f:	5f                   	pop    %edi
+  800110:	5d                   	pop    %ebp
+  800111:	c3                   	ret    
+
+00800112 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800112:	55                   	push   %ebp
+  800113:	89 e5                	mov    %esp,%ebp
+  800115:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800118:	8b 45 08             	mov    0x8(%ebp),%eax
+  80011b:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800122:	00 
+  800123:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80012a:	00 
+  80012b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800132:	00 
+  800133:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800136:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80013a:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80013e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800145:	00 
+  800146:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80014d:	e8 5f ff ff ff       	call   8000b1 <syscall>
+}
+  800152:	c9                   	leave  
+  800153:	c3                   	ret    
+
+00800154 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800154:	55                   	push   %ebp
+  800155:	89 e5                	mov    %esp,%ebp
+  800157:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  80015a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800161:	00 
+  800162:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800169:	00 
+  80016a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800171:	00 
+  800172:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800179:	00 
+  80017a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800181:	00 
+  800182:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800189:	00 
+  80018a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800191:	e8 1b ff ff ff       	call   8000b1 <syscall>
+}
+  800196:	c9                   	leave  
+  800197:	c3                   	ret    
+
+00800198 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800198:	55                   	push   %ebp
+  800199:	89 e5                	mov    %esp,%ebp
+  80019b:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  80019e:	8b 45 08             	mov    0x8(%ebp),%eax
+  8001a1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001a8:	00 
+  8001a9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001b0:	00 
+  8001b1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001b8:	00 
+  8001b9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001c0:	00 
+  8001c1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001c5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001cc:	00 
+  8001cd:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001d4:	e8 d8 fe ff ff       	call   8000b1 <syscall>
+}
+  8001d9:	c9                   	leave  
+  8001da:	c3                   	ret    
+
+008001db <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001db:	55                   	push   %ebp
+  8001dc:	89 e5                	mov    %esp,%ebp
+  8001de:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001e1:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001e8:	00 
+  8001e9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001f0:	00 
+  8001f1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001f8:	00 
+  8001f9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800200:	00 
+  800201:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800208:	00 
+  800209:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800210:	00 
+  800211:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  800218:	e8 94 fe ff ff       	call   8000b1 <syscall>
+}
+  80021d:	c9                   	leave  
+  80021e:	c3                   	ret    
+
+0080021f <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80021f:	55                   	push   %ebp
+  800220:	89 e5                	mov    %esp,%ebp
+  800222:	53                   	push   %ebx
+  800223:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800226:	8d 45 14             	lea    0x14(%ebp),%eax
+  800229:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80022c:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  800232:	e8 a4 ff ff ff       	call   8001db <sys_getenvid>
+  800237:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80023a:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80023e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800241:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800245:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  800249:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80024d:	c7 04 24 70 13 80 00 	movl   $0x801370,(%esp)
+  800254:	e8 e1 00 00 00       	call   80033a <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  800259:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80025c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800260:	8b 45 10             	mov    0x10(%ebp),%eax
+  800263:	89 04 24             	mov    %eax,(%esp)
+  800266:	e8 6b 00 00 00       	call   8002d6 <vcprintf>
+	cprintf("\n");
+  80026b:	c7 04 24 93 13 80 00 	movl   $0x801393,(%esp)
+  800272:	e8 c3 00 00 00       	call   80033a <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  800277:	cc                   	int3   
+  800278:	eb fd                	jmp    800277 <_panic+0x58>
+
+0080027a <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  80027a:	55                   	push   %ebp
+  80027b:	89 e5                	mov    %esp,%ebp
+  80027d:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  800280:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800283:	8b 00                	mov    (%eax),%eax
+  800285:	8d 48 01             	lea    0x1(%eax),%ecx
+  800288:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80028b:	89 0a                	mov    %ecx,(%edx)
+  80028d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800290:	89 d1                	mov    %edx,%ecx
+  800292:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800295:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  800299:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80029c:	8b 00                	mov    (%eax),%eax
+  80029e:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8002a3:	75 20                	jne    8002c5 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8002a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002a8:	8b 00                	mov    (%eax),%eax
+  8002aa:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8002ad:	83 c2 08             	add    $0x8,%edx
+  8002b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002b4:	89 14 24             	mov    %edx,(%esp)
+  8002b7:	e8 56 fe ff ff       	call   800112 <sys_cputs>
+		b->idx = 0;
+  8002bc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002c5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c8:	8b 40 04             	mov    0x4(%eax),%eax
+  8002cb:	8d 50 01             	lea    0x1(%eax),%edx
+  8002ce:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002d1:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002d4:	c9                   	leave  
+  8002d5:	c3                   	ret    
+
+008002d6 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002d6:	55                   	push   %ebp
+  8002d7:	89 e5                	mov    %esp,%ebp
+  8002d9:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002df:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002e6:	00 00 00 
+	b.cnt = 0;
+  8002e9:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002f0:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002fd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800301:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800307:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80030b:	c7 04 24 7a 02 80 00 	movl   $0x80027a,(%esp)
+  800312:	e8 bd 01 00 00       	call   8004d4 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800317:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  80031d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800321:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800327:	83 c0 08             	add    $0x8,%eax
+  80032a:	89 04 24             	mov    %eax,(%esp)
+  80032d:	e8 e0 fd ff ff       	call   800112 <sys_cputs>
+
+	return b.cnt;
+  800332:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800338:	c9                   	leave  
+  800339:	c3                   	ret    
+
+0080033a <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  80033a:	55                   	push   %ebp
+  80033b:	89 e5                	mov    %esp,%ebp
+  80033d:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  800340:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800343:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800346:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800349:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80034d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800350:	89 04 24             	mov    %eax,(%esp)
+  800353:	e8 7e ff ff ff       	call   8002d6 <vcprintf>
+  800358:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  80035b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80035e:	c9                   	leave  
+  80035f:	c3                   	ret    
+
+00800360 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  800360:	55                   	push   %ebp
+  800361:	89 e5                	mov    %esp,%ebp
+  800363:	53                   	push   %ebx
+  800364:	83 ec 34             	sub    $0x34,%esp
+  800367:	8b 45 10             	mov    0x10(%ebp),%eax
+  80036a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80036d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800370:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800373:	8b 45 18             	mov    0x18(%ebp),%eax
+  800376:	ba 00 00 00 00       	mov    $0x0,%edx
+  80037b:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  80037e:	77 72                	ja     8003f2 <printnum+0x92>
+  800380:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800383:	72 05                	jb     80038a <printnum+0x2a>
+  800385:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  800388:	77 68                	ja     8003f2 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  80038a:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  80038d:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  800390:	8b 45 18             	mov    0x18(%ebp),%eax
+  800393:	ba 00 00 00 00       	mov    $0x0,%edx
+  800398:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80039c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003a6:	89 04 24             	mov    %eax,(%esp)
+  8003a9:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8003ad:	e8 fe 0c 00 00       	call   8010b0 <__udivdi3>
+  8003b2:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003b5:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003b9:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003bd:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003c0:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003c4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003c8:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003d3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003d6:	89 04 24             	mov    %eax,(%esp)
+  8003d9:	e8 82 ff ff ff       	call   800360 <printnum>
+  8003de:	eb 1c                	jmp    8003fc <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003e3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003e7:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003ea:	89 04 24             	mov    %eax,(%esp)
+  8003ed:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003f0:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003f2:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003f6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003fa:	7f e4                	jg     8003e0 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003fc:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003ff:	bb 00 00 00 00       	mov    $0x0,%ebx
+  800404:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800407:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80040a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80040e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800412:	89 04 24             	mov    %eax,(%esp)
+  800415:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800419:	e8 c2 0d 00 00       	call   8011e0 <__umoddi3>
+  80041e:	05 20 14 80 00       	add    $0x801420,%eax
+  800423:	0f b6 00             	movzbl (%eax),%eax
+  800426:	0f be c0             	movsbl %al,%eax
+  800429:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80042c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800430:	89 04 24             	mov    %eax,(%esp)
+  800433:	8b 45 08             	mov    0x8(%ebp),%eax
+  800436:	ff d0                	call   *%eax
+}
+  800438:	83 c4 34             	add    $0x34,%esp
+  80043b:	5b                   	pop    %ebx
+  80043c:	5d                   	pop    %ebp
+  80043d:	c3                   	ret    
+
+0080043e <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  80043e:	55                   	push   %ebp
+  80043f:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800441:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800445:	7e 14                	jle    80045b <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800447:	8b 45 08             	mov    0x8(%ebp),%eax
+  80044a:	8b 00                	mov    (%eax),%eax
+  80044c:	8d 48 08             	lea    0x8(%eax),%ecx
+  80044f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800452:	89 0a                	mov    %ecx,(%edx)
+  800454:	8b 50 04             	mov    0x4(%eax),%edx
+  800457:	8b 00                	mov    (%eax),%eax
+  800459:	eb 30                	jmp    80048b <getuint+0x4d>
+	else if (lflag)
+  80045b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80045f:	74 16                	je     800477 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  800461:	8b 45 08             	mov    0x8(%ebp),%eax
+  800464:	8b 00                	mov    (%eax),%eax
+  800466:	8d 48 04             	lea    0x4(%eax),%ecx
+  800469:	8b 55 08             	mov    0x8(%ebp),%edx
+  80046c:	89 0a                	mov    %ecx,(%edx)
+  80046e:	8b 00                	mov    (%eax),%eax
+  800470:	ba 00 00 00 00       	mov    $0x0,%edx
+  800475:	eb 14                	jmp    80048b <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  800477:	8b 45 08             	mov    0x8(%ebp),%eax
+  80047a:	8b 00                	mov    (%eax),%eax
+  80047c:	8d 48 04             	lea    0x4(%eax),%ecx
+  80047f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800482:	89 0a                	mov    %ecx,(%edx)
+  800484:	8b 00                	mov    (%eax),%eax
+  800486:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  80048b:	5d                   	pop    %ebp
+  80048c:	c3                   	ret    
+
+0080048d <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  80048d:	55                   	push   %ebp
+  80048e:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800490:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800494:	7e 14                	jle    8004aa <getint+0x1d>
+		return va_arg(*ap, long long);
+  800496:	8b 45 08             	mov    0x8(%ebp),%eax
+  800499:	8b 00                	mov    (%eax),%eax
+  80049b:	8d 48 08             	lea    0x8(%eax),%ecx
+  80049e:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004a1:	89 0a                	mov    %ecx,(%edx)
+  8004a3:	8b 50 04             	mov    0x4(%eax),%edx
+  8004a6:	8b 00                	mov    (%eax),%eax
+  8004a8:	eb 28                	jmp    8004d2 <getint+0x45>
+	else if (lflag)
+  8004aa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8004ae:	74 12                	je     8004c2 <getint+0x35>
+		return va_arg(*ap, long);
+  8004b0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b3:	8b 00                	mov    (%eax),%eax
+  8004b5:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004b8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004bb:	89 0a                	mov    %ecx,(%edx)
+  8004bd:	8b 00                	mov    (%eax),%eax
+  8004bf:	99                   	cltd   
+  8004c0:	eb 10                	jmp    8004d2 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004c5:	8b 00                	mov    (%eax),%eax
+  8004c7:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004ca:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004cd:	89 0a                	mov    %ecx,(%edx)
+  8004cf:	8b 00                	mov    (%eax),%eax
+  8004d1:	99                   	cltd   
+}
+  8004d2:	5d                   	pop    %ebp
+  8004d3:	c3                   	ret    
+
+008004d4 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004d4:	55                   	push   %ebp
+  8004d5:	89 e5                	mov    %esp,%ebp
+  8004d7:	56                   	push   %esi
+  8004d8:	53                   	push   %ebx
+  8004d9:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004dc:	e9 72 01 00 00       	jmp    800653 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004e1:	85 db                	test   %ebx,%ebx
+  8004e3:	75 05                	jne    8004ea <vprintfmt+0x16>
+				return;
+  8004e5:	e9 2a 05 00 00       	jmp    800a14 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004ea:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004ed:	0f 85 51 01 00 00    	jne    800644 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004f3:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004f6:	8d 50 01             	lea    0x1(%eax),%edx
+  8004f9:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004fc:	0f b6 00             	movzbl (%eax),%eax
+  8004ff:	0f b6 d8             	movzbl %al,%ebx
+  800502:	83 fb 5b             	cmp    $0x5b,%ebx
+  800505:	74 14                	je     80051b <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800507:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80050a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80050e:	89 1c 24             	mov    %ebx,(%esp)
+  800511:	8b 45 08             	mov    0x8(%ebp),%eax
+  800514:	ff d0                	call   *%eax
+				    continue;
+  800516:	e9 38 01 00 00       	jmp    800653 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  80051b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80051e:	8d 50 01             	lea    0x1(%eax),%edx
+  800521:	89 55 10             	mov    %edx,0x10(%ebp)
+  800524:	0f b6 00             	movzbl (%eax),%eax
+  800527:	0f b6 c0             	movzbl %al,%eax
+  80052a:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  80052f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800532:	8d 50 01             	lea    0x1(%eax),%edx
+  800535:	89 55 10             	mov    %edx,0x10(%ebp)
+  800538:	0f b6 00             	movzbl (%eax),%eax
+  80053b:	0f b6 c0             	movzbl %al,%eax
+  80053e:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800543:	a1 08 20 80 00       	mov    0x802008,%eax
+  800548:	83 f8 2f             	cmp    $0x2f,%eax
+  80054b:	7e 19                	jle    800566 <vprintfmt+0x92>
+  80054d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800552:	83 f8 39             	cmp    $0x39,%eax
+  800555:	7f 0f                	jg     800566 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800557:	a1 08 20 80 00       	mov    0x802008,%eax
+  80055c:	83 e8 30             	sub    $0x30,%eax
+  80055f:	a3 08 20 80 00       	mov    %eax,0x802008
+  800564:	eb 50                	jmp    8005b6 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  800566:	a1 08 20 80 00       	mov    0x802008,%eax
+  80056b:	83 f8 60             	cmp    $0x60,%eax
+  80056e:	7e 19                	jle    800589 <vprintfmt+0xb5>
+  800570:	a1 08 20 80 00       	mov    0x802008,%eax
+  800575:	83 f8 66             	cmp    $0x66,%eax
+  800578:	7f 0f                	jg     800589 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  80057a:	a1 08 20 80 00       	mov    0x802008,%eax
+  80057f:	83 e8 57             	sub    $0x57,%eax
+  800582:	a3 08 20 80 00       	mov    %eax,0x802008
+  800587:	eb 2d                	jmp    8005b6 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  800589:	a1 08 20 80 00       	mov    0x802008,%eax
+  80058e:	83 f8 40             	cmp    $0x40,%eax
+  800591:	7e 19                	jle    8005ac <vprintfmt+0xd8>
+  800593:	a1 08 20 80 00       	mov    0x802008,%eax
+  800598:	83 f8 46             	cmp    $0x46,%eax
+  80059b:	7f 0f                	jg     8005ac <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  80059d:	a1 08 20 80 00       	mov    0x802008,%eax
+  8005a2:	83 e8 37             	sub    $0x37,%eax
+  8005a5:	a3 08 20 80 00       	mov    %eax,0x802008
+  8005aa:	eb 0a                	jmp    8005b6 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8005ac:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8005b3:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005b6:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005bb:	83 f8 2f             	cmp    $0x2f,%eax
+  8005be:	7e 19                	jle    8005d9 <vprintfmt+0x105>
+  8005c0:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005c5:	83 f8 39             	cmp    $0x39,%eax
+  8005c8:	7f 0f                	jg     8005d9 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005ca:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005cf:	83 e8 30             	sub    $0x30,%eax
+  8005d2:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005d7:	eb 50                	jmp    800629 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005d9:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005de:	83 f8 60             	cmp    $0x60,%eax
+  8005e1:	7e 19                	jle    8005fc <vprintfmt+0x128>
+  8005e3:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005e8:	83 f8 66             	cmp    $0x66,%eax
+  8005eb:	7f 0f                	jg     8005fc <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005ed:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f2:	83 e8 57             	sub    $0x57,%eax
+  8005f5:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005fa:	eb 2d                	jmp    800629 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005fc:	a1 10 20 80 00       	mov    0x802010,%eax
+  800601:	83 f8 40             	cmp    $0x40,%eax
+  800604:	7e 19                	jle    80061f <vprintfmt+0x14b>
+  800606:	a1 10 20 80 00       	mov    0x802010,%eax
+  80060b:	83 f8 46             	cmp    $0x46,%eax
+  80060e:	7f 0f                	jg     80061f <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  800610:	a1 10 20 80 00       	mov    0x802010,%eax
+  800615:	83 e8 37             	sub    $0x37,%eax
+  800618:	a3 10 20 80 00       	mov    %eax,0x802010
+  80061d:	eb 0a                	jmp    800629 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80061f:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800626:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800629:	a1 08 20 80 00       	mov    0x802008,%eax
+  80062e:	c1 e0 0c             	shl    $0xc,%eax
+  800631:	89 c2                	mov    %eax,%edx
+  800633:	a1 10 20 80 00       	mov    0x802010,%eax
+  800638:	c1 e0 08             	shl    $0x8,%eax
+  80063b:	09 d0                	or     %edx,%eax
+  80063d:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800642:	eb 0f                	jmp    800653 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800644:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800647:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80064b:	89 1c 24             	mov    %ebx,(%esp)
+  80064e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800651:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800653:	8b 45 10             	mov    0x10(%ebp),%eax
+  800656:	8d 50 01             	lea    0x1(%eax),%edx
+  800659:	89 55 10             	mov    %edx,0x10(%ebp)
+  80065c:	0f b6 00             	movzbl (%eax),%eax
+  80065f:	0f b6 d8             	movzbl %al,%ebx
+  800662:	83 fb 25             	cmp    $0x25,%ebx
+  800665:	0f 85 76 fe ff ff    	jne    8004e1 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  80066b:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  80066f:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  800676:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  80067d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800684:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  80068b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80068e:	8d 50 01             	lea    0x1(%eax),%edx
+  800691:	89 55 10             	mov    %edx,0x10(%ebp)
+  800694:	0f b6 00             	movzbl (%eax),%eax
+  800697:	0f b6 d8             	movzbl %al,%ebx
+  80069a:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  80069d:	83 f8 55             	cmp    $0x55,%eax
+  8006a0:	0f 87 3d 03 00 00    	ja     8009e3 <vprintfmt+0x50f>
+  8006a6:	8b 04 85 44 14 80 00 	mov    0x801444(,%eax,4),%eax
+  8006ad:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8006af:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006b3:	eb d6                	jmp    80068b <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006b5:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006b9:	eb d0                	jmp    80068b <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006c5:	89 d0                	mov    %edx,%eax
+  8006c7:	c1 e0 02             	shl    $0x2,%eax
+  8006ca:	01 d0                	add    %edx,%eax
+  8006cc:	01 c0                	add    %eax,%eax
+  8006ce:	01 d8                	add    %ebx,%eax
+  8006d0:	83 e8 30             	sub    $0x30,%eax
+  8006d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006d6:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006d9:	0f b6 00             	movzbl (%eax),%eax
+  8006dc:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006df:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006e2:	7e 0b                	jle    8006ef <vprintfmt+0x21b>
+  8006e4:	83 fb 39             	cmp    $0x39,%ebx
+  8006e7:	7f 06                	jg     8006ef <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006e9:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006ed:	eb d3                	jmp    8006c2 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006ef:	eb 33                	jmp    800724 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006f1:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006f4:	8d 50 04             	lea    0x4(%eax),%edx
+  8006f7:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006fa:	8b 00                	mov    (%eax),%eax
+  8006fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006ff:	eb 23                	jmp    800724 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  800701:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800705:	79 0c                	jns    800713 <vprintfmt+0x23f>
+				width = 0;
+  800707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  80070e:	e9 78 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+  800713:	e9 73 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800718:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80071f:	e9 67 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800724:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800728:	79 12                	jns    80073c <vprintfmt+0x268>
+				width = precision, precision = -1;
+  80072a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80072d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800730:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800737:	e9 4f ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+  80073c:	e9 4a ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800741:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800745:	e9 41 ff ff ff       	jmp    80068b <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  80074a:	8b 45 14             	mov    0x14(%ebp),%eax
+  80074d:	8d 50 04             	lea    0x4(%eax),%edx
+  800750:	89 55 14             	mov    %edx,0x14(%ebp)
+  800753:	8b 00                	mov    (%eax),%eax
+  800755:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800758:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80075c:	89 04 24             	mov    %eax,(%esp)
+  80075f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800762:	ff d0                	call   *%eax
+			break;
+  800764:	e9 a5 02 00 00       	jmp    800a0e <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  800769:	8b 45 14             	mov    0x14(%ebp),%eax
+  80076c:	8d 50 04             	lea    0x4(%eax),%edx
+  80076f:	89 55 14             	mov    %edx,0x14(%ebp)
+  800772:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800774:	85 db                	test   %ebx,%ebx
+  800776:	79 02                	jns    80077a <vprintfmt+0x2a6>
+				err = -err;
+  800778:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  80077a:	83 fb 06             	cmp    $0x6,%ebx
+  80077d:	7f 0b                	jg     80078a <vprintfmt+0x2b6>
+  80077f:	8b 34 9d 04 14 80 00 	mov    0x801404(,%ebx,4),%esi
+  800786:	85 f6                	test   %esi,%esi
+  800788:	75 23                	jne    8007ad <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  80078a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80078e:	c7 44 24 08 31 14 80 	movl   $0x801431,0x8(%esp)
+  800795:	00 
+  800796:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800799:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80079d:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007a0:	89 04 24             	mov    %eax,(%esp)
+  8007a3:	e8 73 02 00 00       	call   800a1b <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8007a8:	e9 61 02 00 00       	jmp    800a0e <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8007ad:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007b1:	c7 44 24 08 3a 14 80 	movl   $0x80143a,0x8(%esp)
+  8007b8:	00 
+  8007b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007c3:	89 04 24             	mov    %eax,(%esp)
+  8007c6:	e8 50 02 00 00       	call   800a1b <printfmt>
+			break;
+  8007cb:	e9 3e 02 00 00       	jmp    800a0e <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007d0:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007d3:	8d 50 04             	lea    0x4(%eax),%edx
+  8007d6:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007d9:	8b 30                	mov    (%eax),%esi
+  8007db:	85 f6                	test   %esi,%esi
+  8007dd:	75 05                	jne    8007e4 <vprintfmt+0x310>
+				p = "(null)";
+  8007df:	be 3d 14 80 00       	mov    $0x80143d,%esi
+			if (width > 0 && padc != '-')
+  8007e4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007e8:	7e 37                	jle    800821 <vprintfmt+0x34d>
+  8007ea:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007ee:	74 31                	je     800821 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007f7:	89 34 24             	mov    %esi,(%esp)
+  8007fa:	e8 39 03 00 00       	call   800b38 <strnlen>
+  8007ff:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  800802:	eb 17                	jmp    80081b <vprintfmt+0x347>
+					putch(padc, putdat);
+  800804:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800808:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80080b:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80080f:	89 04 24             	mov    %eax,(%esp)
+  800812:	8b 45 08             	mov    0x8(%ebp),%eax
+  800815:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800817:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80081b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80081f:	7f e3                	jg     800804 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800821:	eb 38                	jmp    80085b <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800823:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800827:	74 1f                	je     800848 <vprintfmt+0x374>
+  800829:	83 fb 1f             	cmp    $0x1f,%ebx
+  80082c:	7e 05                	jle    800833 <vprintfmt+0x35f>
+  80082e:	83 fb 7e             	cmp    $0x7e,%ebx
+  800831:	7e 15                	jle    800848 <vprintfmt+0x374>
+					putch('?', putdat);
+  800833:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800836:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80083a:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800841:	8b 45 08             	mov    0x8(%ebp),%eax
+  800844:	ff d0                	call   *%eax
+  800846:	eb 0f                	jmp    800857 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800848:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80084b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80084f:	89 1c 24             	mov    %ebx,(%esp)
+  800852:	8b 45 08             	mov    0x8(%ebp),%eax
+  800855:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800857:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80085b:	89 f0                	mov    %esi,%eax
+  80085d:	8d 70 01             	lea    0x1(%eax),%esi
+  800860:	0f b6 00             	movzbl (%eax),%eax
+  800863:	0f be d8             	movsbl %al,%ebx
+  800866:	85 db                	test   %ebx,%ebx
+  800868:	74 10                	je     80087a <vprintfmt+0x3a6>
+  80086a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80086e:	78 b3                	js     800823 <vprintfmt+0x34f>
+  800870:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800874:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800878:	79 a9                	jns    800823 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80087a:	eb 17                	jmp    800893 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  80087c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80087f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800883:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  80088a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80088d:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80088f:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800893:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800897:	7f e3                	jg     80087c <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  800899:	e9 70 01 00 00       	jmp    800a0e <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  80089e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008a1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008a5:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008a8:	89 04 24             	mov    %eax,(%esp)
+  8008ab:	e8 dd fb ff ff       	call   80048d <getint>
+  8008b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008bc:	85 d2                	test   %edx,%edx
+  8008be:	79 26                	jns    8008e6 <vprintfmt+0x412>
+				putch('-', putdat);
+  8008c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008c3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008c7:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008d1:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008d9:	f7 d8                	neg    %eax
+  8008db:	83 d2 00             	adc    $0x0,%edx
+  8008de:	f7 da                	neg    %edx
+  8008e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008e3:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008e6:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008ed:	e9 a8 00 00 00       	jmp    80099a <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008f9:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008fc:	89 04 24             	mov    %eax,(%esp)
+  8008ff:	e8 3a fb ff ff       	call   80043e <getuint>
+  800904:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800907:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  80090a:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800911:	e9 84 00 00 00       	jmp    80099a <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800916:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800919:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80091d:	8d 45 14             	lea    0x14(%ebp),%eax
+  800920:	89 04 24             	mov    %eax,(%esp)
+  800923:	e8 16 fb ff ff       	call   80043e <getuint>
+  800928:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80092b:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  80092e:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800935:	eb 63                	jmp    80099a <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800937:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80093a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80093e:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800945:	8b 45 08             	mov    0x8(%ebp),%eax
+  800948:	ff d0                	call   *%eax
+			putch('x', putdat);
+  80094a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80094d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800951:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800958:	8b 45 08             	mov    0x8(%ebp),%eax
+  80095b:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  80095d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800960:	8d 50 04             	lea    0x4(%eax),%edx
+  800963:	89 55 14             	mov    %edx,0x14(%ebp)
+  800966:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  800968:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80096b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800972:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  800979:	eb 1f                	jmp    80099a <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  80097b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80097e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800982:	8d 45 14             	lea    0x14(%ebp),%eax
+  800985:	89 04 24             	mov    %eax,(%esp)
+  800988:	e8 b1 fa ff ff       	call   80043e <getuint>
+  80098d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800990:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800993:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  80099a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  80099e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8009a1:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8009a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8009a8:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8009ac:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8009b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009b6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009ba:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009be:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009c5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009c8:	89 04 24             	mov    %eax,(%esp)
+  8009cb:	e8 90 f9 ff ff       	call   800360 <printnum>
+			break;
+  8009d0:	eb 3c                	jmp    800a0e <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009d2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009d9:	89 1c 24             	mov    %ebx,(%esp)
+  8009dc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009df:	ff d0                	call   *%eax
+			break;			
+  8009e1:	eb 2b                	jmp    800a0e <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009e6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009ea:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009f4:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009f6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009fa:	eb 04                	jmp    800a00 <vprintfmt+0x52c>
+  8009fc:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a00:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a03:	83 e8 01             	sub    $0x1,%eax
+  800a06:	0f b6 00             	movzbl (%eax),%eax
+  800a09:	3c 25                	cmp    $0x25,%al
+  800a0b:	75 ef                	jne    8009fc <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800a0d:	90                   	nop
+		}
+	}
+  800a0e:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800a0f:	e9 3f fc ff ff       	jmp    800653 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a14:	83 c4 40             	add    $0x40,%esp
+  800a17:	5b                   	pop    %ebx
+  800a18:	5e                   	pop    %esi
+  800a19:	5d                   	pop    %ebp
+  800a1a:	c3                   	ret    
+
+00800a1b <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a1b:	55                   	push   %ebp
+  800a1c:	89 e5                	mov    %esp,%ebp
+  800a1e:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a21:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a24:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a2a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a2e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a31:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a35:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a38:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a3c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a3f:	89 04 24             	mov    %eax,(%esp)
+  800a42:	e8 8d fa ff ff       	call   8004d4 <vprintfmt>
+	va_end(ap);
+}
+  800a47:	c9                   	leave  
+  800a48:	c3                   	ret    
+
+00800a49 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a49:	55                   	push   %ebp
+  800a4a:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a4c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4f:	8b 40 08             	mov    0x8(%eax),%eax
+  800a52:	8d 50 01             	lea    0x1(%eax),%edx
+  800a55:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a58:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a5e:	8b 10                	mov    (%eax),%edx
+  800a60:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a63:	8b 40 04             	mov    0x4(%eax),%eax
+  800a66:	39 c2                	cmp    %eax,%edx
+  800a68:	73 12                	jae    800a7c <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a6d:	8b 00                	mov    (%eax),%eax
+  800a6f:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a72:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a75:	89 0a                	mov    %ecx,(%edx)
+  800a77:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a7a:	88 10                	mov    %dl,(%eax)
+}
+  800a7c:	5d                   	pop    %ebp
+  800a7d:	c3                   	ret    
+
+00800a7e <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a7e:	55                   	push   %ebp
+  800a7f:	89 e5                	mov    %esp,%ebp
+  800a81:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a84:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a87:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a8d:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a90:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a93:	01 d0                	add    %edx,%eax
+  800a95:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a9f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800aa3:	74 06                	je     800aab <vsnprintf+0x2d>
+  800aa5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800aa9:	7f 07                	jg     800ab2 <vsnprintf+0x34>
+		return -E_INVAL;
+  800aab:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800ab0:	eb 2a                	jmp    800adc <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800ab2:	8b 45 14             	mov    0x14(%ebp),%eax
+  800ab5:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800ab9:	8b 45 10             	mov    0x10(%ebp),%eax
+  800abc:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ac0:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ac3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ac7:	c7 04 24 49 0a 80 00 	movl   $0x800a49,(%esp)
+  800ace:	e8 01 fa ff ff       	call   8004d4 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ad3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ad6:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800adc:	c9                   	leave  
+  800add:	c3                   	ret    
+
+00800ade <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800ade:	55                   	push   %ebp
+  800adf:	89 e5                	mov    %esp,%ebp
+  800ae1:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ae4:	8d 45 14             	lea    0x14(%ebp),%eax
+  800ae7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800aed:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800af1:	8b 45 10             	mov    0x10(%ebp),%eax
+  800af4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800af8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800afb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800aff:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b02:	89 04 24             	mov    %eax,(%esp)
+  800b05:	e8 74 ff ff ff       	call   800a7e <vsnprintf>
+  800b0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800b10:	c9                   	leave  
+  800b11:	c3                   	ret    
+
+00800b12 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b12:	55                   	push   %ebp
+  800b13:	89 e5                	mov    %esp,%ebp
+  800b15:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b18:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b1f:	eb 08                	jmp    800b29 <strlen+0x17>
+		n++;
+  800b21:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b25:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b29:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b2c:	0f b6 00             	movzbl (%eax),%eax
+  800b2f:	84 c0                	test   %al,%al
+  800b31:	75 ee                	jne    800b21 <strlen+0xf>
+		n++;
+	return n;
+  800b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b36:	c9                   	leave  
+  800b37:	c3                   	ret    
+
+00800b38 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b38:	55                   	push   %ebp
+  800b39:	89 e5                	mov    %esp,%ebp
+  800b3b:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b45:	eb 0c                	jmp    800b53 <strnlen+0x1b>
+		n++;
+  800b47:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b4b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b4f:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b53:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b57:	74 0a                	je     800b63 <strnlen+0x2b>
+  800b59:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5c:	0f b6 00             	movzbl (%eax),%eax
+  800b5f:	84 c0                	test   %al,%al
+  800b61:	75 e4                	jne    800b47 <strnlen+0xf>
+		n++;
+	return n;
+  800b63:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b66:	c9                   	leave  
+  800b67:	c3                   	ret    
+
+00800b68 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b68:	55                   	push   %ebp
+  800b69:	89 e5                	mov    %esp,%ebp
+  800b6b:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b6e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b71:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b74:	90                   	nop
+  800b75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b78:	8d 50 01             	lea    0x1(%eax),%edx
+  800b7b:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b7e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b81:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b84:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b87:	0f b6 12             	movzbl (%edx),%edx
+  800b8a:	88 10                	mov    %dl,(%eax)
+  800b8c:	0f b6 00             	movzbl (%eax),%eax
+  800b8f:	84 c0                	test   %al,%al
+  800b91:	75 e2                	jne    800b75 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b93:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b96:	c9                   	leave  
+  800b97:	c3                   	ret    
+
+00800b98 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b98:	55                   	push   %ebp
+  800b99:	89 e5                	mov    %esp,%ebp
+  800b9b:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b9e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba1:	89 04 24             	mov    %eax,(%esp)
+  800ba4:	e8 69 ff ff ff       	call   800b12 <strlen>
+  800ba9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800bac:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800baf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bb2:	01 c2                	add    %eax,%edx
+  800bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bb7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800bbb:	89 14 24             	mov    %edx,(%esp)
+  800bbe:	e8 a5 ff ff ff       	call   800b68 <strcpy>
+	return dst;
+  800bc3:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bc6:	c9                   	leave  
+  800bc7:	c3                   	ret    
+
+00800bc8 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bc8:	55                   	push   %ebp
+  800bc9:	89 e5                	mov    %esp,%ebp
+  800bcb:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bce:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd1:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bd4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bdb:	eb 23                	jmp    800c00 <strncpy+0x38>
+		*dst++ = *src;
+  800bdd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800be0:	8d 50 01             	lea    0x1(%eax),%edx
+  800be3:	89 55 08             	mov    %edx,0x8(%ebp)
+  800be6:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800be9:	0f b6 12             	movzbl (%edx),%edx
+  800bec:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800bee:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bf1:	0f b6 00             	movzbl (%eax),%eax
+  800bf4:	84 c0                	test   %al,%al
+  800bf6:	74 04                	je     800bfc <strncpy+0x34>
+			src++;
+  800bf8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800bfc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800c00:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c03:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800c06:	72 d5                	jb     800bdd <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800c08:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800c0b:	c9                   	leave  
+  800c0c:	c3                   	ret    
+
+00800c0d <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800c0d:	55                   	push   %ebp
+  800c0e:	89 e5                	mov    %esp,%ebp
+  800c10:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c13:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c16:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c19:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c1d:	74 33                	je     800c52 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c1f:	eb 17                	jmp    800c38 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c21:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c24:	8d 50 01             	lea    0x1(%eax),%edx
+  800c27:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c2a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c2d:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c30:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c33:	0f b6 12             	movzbl (%edx),%edx
+  800c36:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c38:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c3c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c40:	74 0a                	je     800c4c <strlcpy+0x3f>
+  800c42:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c45:	0f b6 00             	movzbl (%eax),%eax
+  800c48:	84 c0                	test   %al,%al
+  800c4a:	75 d5                	jne    800c21 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c4c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c4f:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c52:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c55:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c58:	29 c2                	sub    %eax,%edx
+  800c5a:	89 d0                	mov    %edx,%eax
+}
+  800c5c:	c9                   	leave  
+  800c5d:	c3                   	ret    
+
+00800c5e <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c5e:	55                   	push   %ebp
+  800c5f:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c61:	eb 08                	jmp    800c6b <strcmp+0xd>
+		p++, q++;
+  800c63:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c67:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c6b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c6e:	0f b6 00             	movzbl (%eax),%eax
+  800c71:	84 c0                	test   %al,%al
+  800c73:	74 10                	je     800c85 <strcmp+0x27>
+  800c75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c78:	0f b6 10             	movzbl (%eax),%edx
+  800c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c7e:	0f b6 00             	movzbl (%eax),%eax
+  800c81:	38 c2                	cmp    %al,%dl
+  800c83:	74 de                	je     800c63 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c85:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c88:	0f b6 00             	movzbl (%eax),%eax
+  800c8b:	0f b6 d0             	movzbl %al,%edx
+  800c8e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c91:	0f b6 00             	movzbl (%eax),%eax
+  800c94:	0f b6 c0             	movzbl %al,%eax
+  800c97:	29 c2                	sub    %eax,%edx
+  800c99:	89 d0                	mov    %edx,%eax
+}
+  800c9b:	5d                   	pop    %ebp
+  800c9c:	c3                   	ret    
+
+00800c9d <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c9d:	55                   	push   %ebp
+  800c9e:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800ca0:	eb 0c                	jmp    800cae <strncmp+0x11>
+		n--, p++, q++;
+  800ca2:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800ca6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800caa:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800cae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cb2:	74 1a                	je     800cce <strncmp+0x31>
+  800cb4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb7:	0f b6 00             	movzbl (%eax),%eax
+  800cba:	84 c0                	test   %al,%al
+  800cbc:	74 10                	je     800cce <strncmp+0x31>
+  800cbe:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc1:	0f b6 10             	movzbl (%eax),%edx
+  800cc4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cc7:	0f b6 00             	movzbl (%eax),%eax
+  800cca:	38 c2                	cmp    %al,%dl
+  800ccc:	74 d4                	je     800ca2 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800cce:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cd2:	75 07                	jne    800cdb <strncmp+0x3e>
+		return 0;
+  800cd4:	b8 00 00 00 00       	mov    $0x0,%eax
+  800cd9:	eb 16                	jmp    800cf1 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800cdb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cde:	0f b6 00             	movzbl (%eax),%eax
+  800ce1:	0f b6 d0             	movzbl %al,%edx
+  800ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce7:	0f b6 00             	movzbl (%eax),%eax
+  800cea:	0f b6 c0             	movzbl %al,%eax
+  800ced:	29 c2                	sub    %eax,%edx
+  800cef:	89 d0                	mov    %edx,%eax
+}
+  800cf1:	5d                   	pop    %ebp
+  800cf2:	c3                   	ret    
+
+00800cf3 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800cf3:	55                   	push   %ebp
+  800cf4:	89 e5                	mov    %esp,%ebp
+  800cf6:	83 ec 04             	sub    $0x4,%esp
+  800cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cfc:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cff:	eb 14                	jmp    800d15 <strchr+0x22>
+		if (*s == c)
+  800d01:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d04:	0f b6 00             	movzbl (%eax),%eax
+  800d07:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d0a:	75 05                	jne    800d11 <strchr+0x1e>
+			return (char *) s;
+  800d0c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d0f:	eb 13                	jmp    800d24 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d11:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d18:	0f b6 00             	movzbl (%eax),%eax
+  800d1b:	84 c0                	test   %al,%al
+  800d1d:	75 e2                	jne    800d01 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d1f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d24:	c9                   	leave  
+  800d25:	c3                   	ret    
+
+00800d26 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d26:	55                   	push   %ebp
+  800d27:	89 e5                	mov    %esp,%ebp
+  800d29:	83 ec 04             	sub    $0x4,%esp
+  800d2c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d2f:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d32:	eb 11                	jmp    800d45 <strfind+0x1f>
+		if (*s == c)
+  800d34:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d37:	0f b6 00             	movzbl (%eax),%eax
+  800d3a:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d3d:	75 02                	jne    800d41 <strfind+0x1b>
+			break;
+  800d3f:	eb 0e                	jmp    800d4f <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d41:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d45:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d48:	0f b6 00             	movzbl (%eax),%eax
+  800d4b:	84 c0                	test   %al,%al
+  800d4d:	75 e5                	jne    800d34 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d4f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d52:	c9                   	leave  
+  800d53:	c3                   	ret    
+
+00800d54 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d54:	55                   	push   %ebp
+  800d55:	89 e5                	mov    %esp,%ebp
+  800d57:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d58:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d5c:	75 05                	jne    800d63 <memset+0xf>
+		return v;
+  800d5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d61:	eb 5c                	jmp    800dbf <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d63:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d66:	83 e0 03             	and    $0x3,%eax
+  800d69:	85 c0                	test   %eax,%eax
+  800d6b:	75 41                	jne    800dae <memset+0x5a>
+  800d6d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d70:	83 e0 03             	and    $0x3,%eax
+  800d73:	85 c0                	test   %eax,%eax
+  800d75:	75 37                	jne    800dae <memset+0x5a>
+		c &= 0xFF;
+  800d77:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d7e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d81:	c1 e0 18             	shl    $0x18,%eax
+  800d84:	89 c2                	mov    %eax,%edx
+  800d86:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d89:	c1 e0 10             	shl    $0x10,%eax
+  800d8c:	09 c2                	or     %eax,%edx
+  800d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d91:	c1 e0 08             	shl    $0x8,%eax
+  800d94:	09 d0                	or     %edx,%eax
+  800d96:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d99:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d9c:	c1 e8 02             	shr    $0x2,%eax
+  800d9f:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800da1:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da7:	89 d7                	mov    %edx,%edi
+  800da9:	fc                   	cld    
+  800daa:	f3 ab                	rep stos %eax,%es:(%edi)
+  800dac:	eb 0e                	jmp    800dbc <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800dae:	8b 55 08             	mov    0x8(%ebp),%edx
+  800db1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800db4:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800db7:	89 d7                	mov    %edx,%edi
+  800db9:	fc                   	cld    
+  800dba:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800dbc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800dbf:	5f                   	pop    %edi
+  800dc0:	5d                   	pop    %ebp
+  800dc1:	c3                   	ret    
+
+00800dc2 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800dc2:	55                   	push   %ebp
+  800dc3:	89 e5                	mov    %esp,%ebp
+  800dc5:	57                   	push   %edi
+  800dc6:	56                   	push   %esi
+  800dc7:	53                   	push   %ebx
+  800dc8:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dcb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dce:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dda:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800ddd:	73 6d                	jae    800e4c <memmove+0x8a>
+  800ddf:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800de5:	01 d0                	add    %edx,%eax
+  800de7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dea:	76 60                	jbe    800e4c <memmove+0x8a>
+		s += n;
+  800dec:	8b 45 10             	mov    0x10(%ebp),%eax
+  800def:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800df2:	8b 45 10             	mov    0x10(%ebp),%eax
+  800df5:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800df8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dfb:	83 e0 03             	and    $0x3,%eax
+  800dfe:	85 c0                	test   %eax,%eax
+  800e00:	75 2f                	jne    800e31 <memmove+0x6f>
+  800e02:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e05:	83 e0 03             	and    $0x3,%eax
+  800e08:	85 c0                	test   %eax,%eax
+  800e0a:	75 25                	jne    800e31 <memmove+0x6f>
+  800e0c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e0f:	83 e0 03             	and    $0x3,%eax
+  800e12:	85 c0                	test   %eax,%eax
+  800e14:	75 1b                	jne    800e31 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e16:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e19:	83 e8 04             	sub    $0x4,%eax
+  800e1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e1f:	83 ea 04             	sub    $0x4,%edx
+  800e22:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e25:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e28:	89 c7                	mov    %eax,%edi
+  800e2a:	89 d6                	mov    %edx,%esi
+  800e2c:	fd                   	std    
+  800e2d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e2f:	eb 18                	jmp    800e49 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e31:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e34:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e3a:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e3d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e40:	89 d7                	mov    %edx,%edi
+  800e42:	89 de                	mov    %ebx,%esi
+  800e44:	89 c1                	mov    %eax,%ecx
+  800e46:	fd                   	std    
+  800e47:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e49:	fc                   	cld    
+  800e4a:	eb 45                	jmp    800e91 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e4f:	83 e0 03             	and    $0x3,%eax
+  800e52:	85 c0                	test   %eax,%eax
+  800e54:	75 2b                	jne    800e81 <memmove+0xbf>
+  800e56:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e59:	83 e0 03             	and    $0x3,%eax
+  800e5c:	85 c0                	test   %eax,%eax
+  800e5e:	75 21                	jne    800e81 <memmove+0xbf>
+  800e60:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e63:	83 e0 03             	and    $0x3,%eax
+  800e66:	85 c0                	test   %eax,%eax
+  800e68:	75 17                	jne    800e81 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e6a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e6d:	c1 e8 02             	shr    $0x2,%eax
+  800e70:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e72:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e75:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e78:	89 c7                	mov    %eax,%edi
+  800e7a:	89 d6                	mov    %edx,%esi
+  800e7c:	fc                   	cld    
+  800e7d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e7f:	eb 10                	jmp    800e91 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e81:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e84:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e87:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e8a:	89 c7                	mov    %eax,%edi
+  800e8c:	89 d6                	mov    %edx,%esi
+  800e8e:	fc                   	cld    
+  800e8f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e91:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e94:	83 c4 10             	add    $0x10,%esp
+  800e97:	5b                   	pop    %ebx
+  800e98:	5e                   	pop    %esi
+  800e99:	5f                   	pop    %edi
+  800e9a:	5d                   	pop    %ebp
+  800e9b:	c3                   	ret    
+
+00800e9c <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e9c:	55                   	push   %ebp
+  800e9d:	89 e5                	mov    %esp,%ebp
+  800e9f:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800ea2:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ea5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ea9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800eac:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800eb0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eb3:	89 04 24             	mov    %eax,(%esp)
+  800eb6:	e8 07 ff ff ff       	call   800dc2 <memmove>
+}
+  800ebb:	c9                   	leave  
+  800ebc:	c3                   	ret    
+
+00800ebd <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800ebd:	55                   	push   %ebp
+  800ebe:	89 e5                	mov    %esp,%ebp
+  800ec0:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800ec3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ec6:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ecc:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ecf:	eb 30                	jmp    800f01 <memcmp+0x44>
+		if (*s1 != *s2)
+  800ed1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed4:	0f b6 10             	movzbl (%eax),%edx
+  800ed7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eda:	0f b6 00             	movzbl (%eax),%eax
+  800edd:	38 c2                	cmp    %al,%dl
+  800edf:	74 18                	je     800ef9 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ee1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ee4:	0f b6 00             	movzbl (%eax),%eax
+  800ee7:	0f b6 d0             	movzbl %al,%edx
+  800eea:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eed:	0f b6 00             	movzbl (%eax),%eax
+  800ef0:	0f b6 c0             	movzbl %al,%eax
+  800ef3:	29 c2                	sub    %eax,%edx
+  800ef5:	89 d0                	mov    %edx,%eax
+  800ef7:	eb 1a                	jmp    800f13 <memcmp+0x56>
+		s1++, s2++;
+  800ef9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800efd:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800f01:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f04:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800f07:	89 55 10             	mov    %edx,0x10(%ebp)
+  800f0a:	85 c0                	test   %eax,%eax
+  800f0c:	75 c3                	jne    800ed1 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800f0e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f13:	c9                   	leave  
+  800f14:	c3                   	ret    
+
+00800f15 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f15:	55                   	push   %ebp
+  800f16:	89 e5                	mov    %esp,%ebp
+  800f18:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f1b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f1e:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f21:	01 d0                	add    %edx,%eax
+  800f23:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f26:	eb 13                	jmp    800f3b <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f28:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f2b:	0f b6 10             	movzbl (%eax),%edx
+  800f2e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f31:	38 c2                	cmp    %al,%dl
+  800f33:	75 02                	jne    800f37 <memfind+0x22>
+			break;
+  800f35:	eb 0c                	jmp    800f43 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f37:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f3e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f41:	72 e5                	jb     800f28 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f43:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f46:	c9                   	leave  
+  800f47:	c3                   	ret    
+
+00800f48 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f48:	55                   	push   %ebp
+  800f49:	89 e5                	mov    %esp,%ebp
+  800f4b:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f4e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f55:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f5c:	eb 04                	jmp    800f62 <strtol+0x1a>
+		s++;
+  800f5e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f62:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f65:	0f b6 00             	movzbl (%eax),%eax
+  800f68:	3c 20                	cmp    $0x20,%al
+  800f6a:	74 f2                	je     800f5e <strtol+0x16>
+  800f6c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f6f:	0f b6 00             	movzbl (%eax),%eax
+  800f72:	3c 09                	cmp    $0x9,%al
+  800f74:	74 e8                	je     800f5e <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f76:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f79:	0f b6 00             	movzbl (%eax),%eax
+  800f7c:	3c 2b                	cmp    $0x2b,%al
+  800f7e:	75 06                	jne    800f86 <strtol+0x3e>
+		s++;
+  800f80:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f84:	eb 15                	jmp    800f9b <strtol+0x53>
+	else if (*s == '-')
+  800f86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f89:	0f b6 00             	movzbl (%eax),%eax
+  800f8c:	3c 2d                	cmp    $0x2d,%al
+  800f8e:	75 0b                	jne    800f9b <strtol+0x53>
+		s++, neg = 1;
+  800f90:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f94:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f9f:	74 06                	je     800fa7 <strtol+0x5f>
+  800fa1:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800fa5:	75 24                	jne    800fcb <strtol+0x83>
+  800fa7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800faa:	0f b6 00             	movzbl (%eax),%eax
+  800fad:	3c 30                	cmp    $0x30,%al
+  800faf:	75 1a                	jne    800fcb <strtol+0x83>
+  800fb1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fb4:	83 c0 01             	add    $0x1,%eax
+  800fb7:	0f b6 00             	movzbl (%eax),%eax
+  800fba:	3c 78                	cmp    $0x78,%al
+  800fbc:	75 0d                	jne    800fcb <strtol+0x83>
+		s += 2, base = 16;
+  800fbe:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fc2:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fc9:	eb 2a                	jmp    800ff5 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fcb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fcf:	75 17                	jne    800fe8 <strtol+0xa0>
+  800fd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fd4:	0f b6 00             	movzbl (%eax),%eax
+  800fd7:	3c 30                	cmp    $0x30,%al
+  800fd9:	75 0d                	jne    800fe8 <strtol+0xa0>
+		s++, base = 8;
+  800fdb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fdf:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fe6:	eb 0d                	jmp    800ff5 <strtol+0xad>
+	else if (base == 0)
+  800fe8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fec:	75 07                	jne    800ff5 <strtol+0xad>
+		base = 10;
+  800fee:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800ff5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff8:	0f b6 00             	movzbl (%eax),%eax
+  800ffb:	3c 2f                	cmp    $0x2f,%al
+  800ffd:	7e 1b                	jle    80101a <strtol+0xd2>
+  800fff:	8b 45 08             	mov    0x8(%ebp),%eax
+  801002:	0f b6 00             	movzbl (%eax),%eax
+  801005:	3c 39                	cmp    $0x39,%al
+  801007:	7f 11                	jg     80101a <strtol+0xd2>
+			dig = *s - '0';
+  801009:	8b 45 08             	mov    0x8(%ebp),%eax
+  80100c:	0f b6 00             	movzbl (%eax),%eax
+  80100f:	0f be c0             	movsbl %al,%eax
+  801012:	83 e8 30             	sub    $0x30,%eax
+  801015:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801018:	eb 48                	jmp    801062 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  80101a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101d:	0f b6 00             	movzbl (%eax),%eax
+  801020:	3c 60                	cmp    $0x60,%al
+  801022:	7e 1b                	jle    80103f <strtol+0xf7>
+  801024:	8b 45 08             	mov    0x8(%ebp),%eax
+  801027:	0f b6 00             	movzbl (%eax),%eax
+  80102a:	3c 7a                	cmp    $0x7a,%al
+  80102c:	7f 11                	jg     80103f <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  80102e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801031:	0f b6 00             	movzbl (%eax),%eax
+  801034:	0f be c0             	movsbl %al,%eax
+  801037:	83 e8 57             	sub    $0x57,%eax
+  80103a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80103d:	eb 23                	jmp    801062 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  80103f:	8b 45 08             	mov    0x8(%ebp),%eax
+  801042:	0f b6 00             	movzbl (%eax),%eax
+  801045:	3c 40                	cmp    $0x40,%al
+  801047:	7e 3d                	jle    801086 <strtol+0x13e>
+  801049:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104c:	0f b6 00             	movzbl (%eax),%eax
+  80104f:	3c 5a                	cmp    $0x5a,%al
+  801051:	7f 33                	jg     801086 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801053:	8b 45 08             	mov    0x8(%ebp),%eax
+  801056:	0f b6 00             	movzbl (%eax),%eax
+  801059:	0f be c0             	movsbl %al,%eax
+  80105c:	83 e8 37             	sub    $0x37,%eax
+  80105f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801062:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801065:	3b 45 10             	cmp    0x10(%ebp),%eax
+  801068:	7c 02                	jl     80106c <strtol+0x124>
+			break;
+  80106a:	eb 1a                	jmp    801086 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  80106c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  801070:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801073:	0f af 45 10          	imul   0x10(%ebp),%eax
+  801077:	89 c2                	mov    %eax,%edx
+  801079:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80107c:	01 d0                	add    %edx,%eax
+  80107e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  801081:	e9 6f ff ff ff       	jmp    800ff5 <strtol+0xad>
+
+	if (endptr)
+  801086:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80108a:	74 08                	je     801094 <strtol+0x14c>
+		*endptr = (char *) s;
+  80108c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80108f:	8b 55 08             	mov    0x8(%ebp),%edx
+  801092:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801094:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801098:	74 07                	je     8010a1 <strtol+0x159>
+  80109a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80109d:	f7 d8                	neg    %eax
+  80109f:	eb 03                	jmp    8010a4 <strtol+0x15c>
+  8010a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  8010a4:	c9                   	leave  
+  8010a5:	c3                   	ret    
+  8010a6:	66 90                	xchg   %ax,%ax
+  8010a8:	66 90                	xchg   %ax,%ax
+  8010aa:	66 90                	xchg   %ax,%ax
+  8010ac:	66 90                	xchg   %ax,%ax
+  8010ae:	66 90                	xchg   %ax,%ax
+
+008010b0 <__udivdi3>:
+  8010b0:	55                   	push   %ebp
+  8010b1:	57                   	push   %edi
+  8010b2:	56                   	push   %esi
+  8010b3:	83 ec 0c             	sub    $0xc,%esp
+  8010b6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ba:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010be:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010c2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010c6:	85 c0                	test   %eax,%eax
+  8010c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010cc:	89 ea                	mov    %ebp,%edx
+  8010ce:	89 0c 24             	mov    %ecx,(%esp)
+  8010d1:	75 2d                	jne    801100 <__udivdi3+0x50>
+  8010d3:	39 e9                	cmp    %ebp,%ecx
+  8010d5:	77 61                	ja     801138 <__udivdi3+0x88>
+  8010d7:	85 c9                	test   %ecx,%ecx
+  8010d9:	89 ce                	mov    %ecx,%esi
+  8010db:	75 0b                	jne    8010e8 <__udivdi3+0x38>
+  8010dd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010e2:	31 d2                	xor    %edx,%edx
+  8010e4:	f7 f1                	div    %ecx
+  8010e6:	89 c6                	mov    %eax,%esi
+  8010e8:	31 d2                	xor    %edx,%edx
+  8010ea:	89 e8                	mov    %ebp,%eax
+  8010ec:	f7 f6                	div    %esi
+  8010ee:	89 c5                	mov    %eax,%ebp
+  8010f0:	89 f8                	mov    %edi,%eax
+  8010f2:	f7 f6                	div    %esi
+  8010f4:	89 ea                	mov    %ebp,%edx
+  8010f6:	83 c4 0c             	add    $0xc,%esp
+  8010f9:	5e                   	pop    %esi
+  8010fa:	5f                   	pop    %edi
+  8010fb:	5d                   	pop    %ebp
+  8010fc:	c3                   	ret    
+  8010fd:	8d 76 00             	lea    0x0(%esi),%esi
+  801100:	39 e8                	cmp    %ebp,%eax
+  801102:	77 24                	ja     801128 <__udivdi3+0x78>
+  801104:	0f bd e8             	bsr    %eax,%ebp
+  801107:	83 f5 1f             	xor    $0x1f,%ebp
+  80110a:	75 3c                	jne    801148 <__udivdi3+0x98>
+  80110c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801110:	39 34 24             	cmp    %esi,(%esp)
+  801113:	0f 86 9f 00 00 00    	jbe    8011b8 <__udivdi3+0x108>
+  801119:	39 d0                	cmp    %edx,%eax
+  80111b:	0f 82 97 00 00 00    	jb     8011b8 <__udivdi3+0x108>
+  801121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801128:	31 d2                	xor    %edx,%edx
+  80112a:	31 c0                	xor    %eax,%eax
+  80112c:	83 c4 0c             	add    $0xc,%esp
+  80112f:	5e                   	pop    %esi
+  801130:	5f                   	pop    %edi
+  801131:	5d                   	pop    %ebp
+  801132:	c3                   	ret    
+  801133:	90                   	nop
+  801134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801138:	89 f8                	mov    %edi,%eax
+  80113a:	f7 f1                	div    %ecx
+  80113c:	31 d2                	xor    %edx,%edx
+  80113e:	83 c4 0c             	add    $0xc,%esp
+  801141:	5e                   	pop    %esi
+  801142:	5f                   	pop    %edi
+  801143:	5d                   	pop    %ebp
+  801144:	c3                   	ret    
+  801145:	8d 76 00             	lea    0x0(%esi),%esi
+  801148:	89 e9                	mov    %ebp,%ecx
+  80114a:	8b 3c 24             	mov    (%esp),%edi
+  80114d:	d3 e0                	shl    %cl,%eax
+  80114f:	89 c6                	mov    %eax,%esi
+  801151:	b8 20 00 00 00       	mov    $0x20,%eax
+  801156:	29 e8                	sub    %ebp,%eax
+  801158:	89 c1                	mov    %eax,%ecx
+  80115a:	d3 ef                	shr    %cl,%edi
+  80115c:	89 e9                	mov    %ebp,%ecx
+  80115e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801162:	8b 3c 24             	mov    (%esp),%edi
+  801165:	09 74 24 08          	or     %esi,0x8(%esp)
+  801169:	89 d6                	mov    %edx,%esi
+  80116b:	d3 e7                	shl    %cl,%edi
+  80116d:	89 c1                	mov    %eax,%ecx
+  80116f:	89 3c 24             	mov    %edi,(%esp)
+  801172:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801176:	d3 ee                	shr    %cl,%esi
+  801178:	89 e9                	mov    %ebp,%ecx
+  80117a:	d3 e2                	shl    %cl,%edx
+  80117c:	89 c1                	mov    %eax,%ecx
+  80117e:	d3 ef                	shr    %cl,%edi
+  801180:	09 d7                	or     %edx,%edi
+  801182:	89 f2                	mov    %esi,%edx
+  801184:	89 f8                	mov    %edi,%eax
+  801186:	f7 74 24 08          	divl   0x8(%esp)
+  80118a:	89 d6                	mov    %edx,%esi
+  80118c:	89 c7                	mov    %eax,%edi
+  80118e:	f7 24 24             	mull   (%esp)
+  801191:	39 d6                	cmp    %edx,%esi
+  801193:	89 14 24             	mov    %edx,(%esp)
+  801196:	72 30                	jb     8011c8 <__udivdi3+0x118>
+  801198:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80119c:	89 e9                	mov    %ebp,%ecx
+  80119e:	d3 e2                	shl    %cl,%edx
+  8011a0:	39 c2                	cmp    %eax,%edx
+  8011a2:	73 05                	jae    8011a9 <__udivdi3+0xf9>
+  8011a4:	3b 34 24             	cmp    (%esp),%esi
+  8011a7:	74 1f                	je     8011c8 <__udivdi3+0x118>
+  8011a9:	89 f8                	mov    %edi,%eax
+  8011ab:	31 d2                	xor    %edx,%edx
+  8011ad:	e9 7a ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011b8:	31 d2                	xor    %edx,%edx
+  8011ba:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011bf:	e9 68 ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011c8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011cb:	31 d2                	xor    %edx,%edx
+  8011cd:	83 c4 0c             	add    $0xc,%esp
+  8011d0:	5e                   	pop    %esi
+  8011d1:	5f                   	pop    %edi
+  8011d2:	5d                   	pop    %ebp
+  8011d3:	c3                   	ret    
+  8011d4:	66 90                	xchg   %ax,%ax
+  8011d6:	66 90                	xchg   %ax,%ax
+  8011d8:	66 90                	xchg   %ax,%ax
+  8011da:	66 90                	xchg   %ax,%ax
+  8011dc:	66 90                	xchg   %ax,%ax
+  8011de:	66 90                	xchg   %ax,%ax
+
+008011e0 <__umoddi3>:
+  8011e0:	55                   	push   %ebp
+  8011e1:	57                   	push   %edi
+  8011e2:	56                   	push   %esi
+  8011e3:	83 ec 14             	sub    $0x14,%esp
+  8011e6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011ee:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011f2:	89 c7                	mov    %eax,%edi
+  8011f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011f8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011fc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801200:	89 34 24             	mov    %esi,(%esp)
+  801203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801207:	85 c0                	test   %eax,%eax
+  801209:	89 c2                	mov    %eax,%edx
+  80120b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80120f:	75 17                	jne    801228 <__umoddi3+0x48>
+  801211:	39 fe                	cmp    %edi,%esi
+  801213:	76 4b                	jbe    801260 <__umoddi3+0x80>
+  801215:	89 c8                	mov    %ecx,%eax
+  801217:	89 fa                	mov    %edi,%edx
+  801219:	f7 f6                	div    %esi
+  80121b:	89 d0                	mov    %edx,%eax
+  80121d:	31 d2                	xor    %edx,%edx
+  80121f:	83 c4 14             	add    $0x14,%esp
+  801222:	5e                   	pop    %esi
+  801223:	5f                   	pop    %edi
+  801224:	5d                   	pop    %ebp
+  801225:	c3                   	ret    
+  801226:	66 90                	xchg   %ax,%ax
+  801228:	39 f8                	cmp    %edi,%eax
+  80122a:	77 54                	ja     801280 <__umoddi3+0xa0>
+  80122c:	0f bd e8             	bsr    %eax,%ebp
+  80122f:	83 f5 1f             	xor    $0x1f,%ebp
+  801232:	75 5c                	jne    801290 <__umoddi3+0xb0>
+  801234:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801238:	39 3c 24             	cmp    %edi,(%esp)
+  80123b:	0f 87 e7 00 00 00    	ja     801328 <__umoddi3+0x148>
+  801241:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801245:	29 f1                	sub    %esi,%ecx
+  801247:	19 c7                	sbb    %eax,%edi
+  801249:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80124d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801251:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801255:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801259:	83 c4 14             	add    $0x14,%esp
+  80125c:	5e                   	pop    %esi
+  80125d:	5f                   	pop    %edi
+  80125e:	5d                   	pop    %ebp
+  80125f:	c3                   	ret    
+  801260:	85 f6                	test   %esi,%esi
+  801262:	89 f5                	mov    %esi,%ebp
+  801264:	75 0b                	jne    801271 <__umoddi3+0x91>
+  801266:	b8 01 00 00 00       	mov    $0x1,%eax
+  80126b:	31 d2                	xor    %edx,%edx
+  80126d:	f7 f6                	div    %esi
+  80126f:	89 c5                	mov    %eax,%ebp
+  801271:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801275:	31 d2                	xor    %edx,%edx
+  801277:	f7 f5                	div    %ebp
+  801279:	89 c8                	mov    %ecx,%eax
+  80127b:	f7 f5                	div    %ebp
+  80127d:	eb 9c                	jmp    80121b <__umoddi3+0x3b>
+  80127f:	90                   	nop
+  801280:	89 c8                	mov    %ecx,%eax
+  801282:	89 fa                	mov    %edi,%edx
+  801284:	83 c4 14             	add    $0x14,%esp
+  801287:	5e                   	pop    %esi
+  801288:	5f                   	pop    %edi
+  801289:	5d                   	pop    %ebp
+  80128a:	c3                   	ret    
+  80128b:	90                   	nop
+  80128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801290:	8b 04 24             	mov    (%esp),%eax
+  801293:	be 20 00 00 00       	mov    $0x20,%esi
+  801298:	89 e9                	mov    %ebp,%ecx
+  80129a:	29 ee                	sub    %ebp,%esi
+  80129c:	d3 e2                	shl    %cl,%edx
+  80129e:	89 f1                	mov    %esi,%ecx
+  8012a0:	d3 e8                	shr    %cl,%eax
+  8012a2:	89 e9                	mov    %ebp,%ecx
+  8012a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012a8:	8b 04 24             	mov    (%esp),%eax
+  8012ab:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012af:	89 fa                	mov    %edi,%edx
+  8012b1:	d3 e0                	shl    %cl,%eax
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012b9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012bd:	d3 ea                	shr    %cl,%edx
+  8012bf:	89 e9                	mov    %ebp,%ecx
+  8012c1:	d3 e7                	shl    %cl,%edi
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	d3 e8                	shr    %cl,%eax
+  8012c7:	89 e9                	mov    %ebp,%ecx
+  8012c9:	09 f8                	or     %edi,%eax
+  8012cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012cf:	f7 74 24 04          	divl   0x4(%esp)
+  8012d3:	d3 e7                	shl    %cl,%edi
+  8012d5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012d9:	89 d7                	mov    %edx,%edi
+  8012db:	f7 64 24 08          	mull   0x8(%esp)
+  8012df:	39 d7                	cmp    %edx,%edi
+  8012e1:	89 c1                	mov    %eax,%ecx
+  8012e3:	89 14 24             	mov    %edx,(%esp)
+  8012e6:	72 2c                	jb     801314 <__umoddi3+0x134>
+  8012e8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012ec:	72 22                	jb     801310 <__umoddi3+0x130>
+  8012ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012f2:	29 c8                	sub    %ecx,%eax
+  8012f4:	19 d7                	sbb    %edx,%edi
+  8012f6:	89 e9                	mov    %ebp,%ecx
+  8012f8:	89 fa                	mov    %edi,%edx
+  8012fa:	d3 e8                	shr    %cl,%eax
+  8012fc:	89 f1                	mov    %esi,%ecx
+  8012fe:	d3 e2                	shl    %cl,%edx
+  801300:	89 e9                	mov    %ebp,%ecx
+  801302:	d3 ef                	shr    %cl,%edi
+  801304:	09 d0                	or     %edx,%eax
+  801306:	89 fa                	mov    %edi,%edx
+  801308:	83 c4 14             	add    $0x14,%esp
+  80130b:	5e                   	pop    %esi
+  80130c:	5f                   	pop    %edi
+  80130d:	5d                   	pop    %ebp
+  80130e:	c3                   	ret    
+  80130f:	90                   	nop
+  801310:	39 d7                	cmp    %edx,%edi
+  801312:	75 da                	jne    8012ee <__umoddi3+0x10e>
+  801314:	8b 14 24             	mov    (%esp),%edx
+  801317:	89 c1                	mov    %eax,%ecx
+  801319:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80131d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801321:	eb cb                	jmp    8012ee <__umoddi3+0x10e>
+  801323:	90                   	nop
+  801324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801328:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80132c:	0f 82 0f ff ff ff    	jb     801241 <__umoddi3+0x61>
+  801332:	e9 1a ff ff ff       	jmp    801251 <__umoddi3+0x71>
diff --git a/obj/user/evilhello.o b/obj/user/evilhello.o
new file mode 100644
index 0000000..4726a80
Binary files /dev/null and b/obj/user/evilhello.o differ
diff --git a/obj/user/evilhello.sym b/obj/user/evilhello.sym
new file mode 100644
index 0000000..7c3dce1
--- /dev/null
+++ b/obj/user/evilhello.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040cf R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080004f T libmain
+0080009d T exit
+008000b1 t syscall
+00800112 T sys_cputs
+00800154 T sys_cgetc
+00800198 T sys_env_destroy
+008001db T sys_getenvid
+0080021f T _panic
+0080027a t putch
+008002d6 T vcprintf
+0080033a T cprintf
+00800360 t printnum
+0080043e t getuint
+0080048d t getint
+008004d4 T vprintfmt
+00800a1b T printfmt
+00800a49 t sprintputch
+00800a7e T vsnprintf
+00800ade T snprintf
+00800b12 T strlen
+00800b38 T strnlen
+00800b68 T strcpy
+00800b98 T strcat
+00800bc8 T strncpy
+00800c0d T strlcpy
+00800c5e T strcmp
+00800c9d T strncmp
+00800cf3 T strchr
+00800d26 T strfind
+00800d54 T memset
+00800dc2 T memmove
+00800e9c T memcpy
+00800ebd T memcmp
+00800f15 T memfind
+00800f48 T strtol
+008010b0 T __udivdi3
+008011e0 T __umoddi3
+00801404 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/faultread b/obj/user/faultread
new file mode 100755
index 0000000..a0e3f25
Binary files /dev/null and b/obj/user/faultread differ
diff --git a/obj/user/faultread.asm b/obj/user/faultread.asm
new file mode 100644
index 0000000..063e3d8
--- /dev/null
+++ b/obj/user/faultread.asm
@@ -0,0 +1,2628 @@
+
+obj/user/faultread:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 21 00 00 00       	call   800052 <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	cprintf("I read %08x from location 0!\n", *(unsigned*)0);
+  800039:	b8 00 00 00 00       	mov    $0x0,%eax
+  80003e:	8b 00                	mov    (%eax),%eax
+  800040:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800044:	c7 04 24 38 13 80 00 	movl   $0x801338,(%esp)
+  80004b:	e8 24 01 00 00       	call   800174 <cprintf>
+}
+  800050:	c9                   	leave  
+  800051:	c3                   	ret    
+
+00800052 <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  800052:	55                   	push   %ebp
+  800053:	89 e5                	mov    %esp,%ebp
+  800055:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800058:	e8 ad 0f 00 00       	call   80100a <sys_getenvid>
+  80005d:	25 ff 03 00 00       	and    $0x3ff,%eax
+  800062:	89 c2                	mov    %eax,%edx
+  800064:	89 d0                	mov    %edx,%eax
+  800066:	01 c0                	add    %eax,%eax
+  800068:	01 d0                	add    %edx,%eax
+  80006a:	c1 e0 05             	shl    $0x5,%eax
+  80006d:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  800072:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800077:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  80007b:	7e 0a                	jle    800087 <libmain+0x35>
+		binaryname = argv[0];
+  80007d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800080:	8b 00                	mov    (%eax),%eax
+  800082:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800087:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80008a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80008e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800091:	89 04 24             	mov    %eax,(%esp)
+  800094:	e8 9a ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800099:	e8 02 00 00 00       	call   8000a0 <exit>
+}
+  80009e:	c9                   	leave  
+  80009f:	c3                   	ret    
+
+008000a0 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  8000a0:	55                   	push   %ebp
+  8000a1:	89 e5                	mov    %esp,%ebp
+  8000a3:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000a6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000ad:	e8 15 0f 00 00       	call   800fc7 <sys_env_destroy>
+}
+  8000b2:	c9                   	leave  
+  8000b3:	c3                   	ret    
+
+008000b4 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  8000b4:	55                   	push   %ebp
+  8000b5:	89 e5                	mov    %esp,%ebp
+  8000b7:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  8000ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000bd:	8b 00                	mov    (%eax),%eax
+  8000bf:	8d 48 01             	lea    0x1(%eax),%ecx
+  8000c2:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000c5:	89 0a                	mov    %ecx,(%edx)
+  8000c7:	8b 55 08             	mov    0x8(%ebp),%edx
+  8000ca:	89 d1                	mov    %edx,%ecx
+  8000cc:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000cf:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  8000d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000d6:	8b 00                	mov    (%eax),%eax
+  8000d8:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8000dd:	75 20                	jne    8000ff <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8000df:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000e2:	8b 00                	mov    (%eax),%eax
+  8000e4:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000e7:	83 c2 08             	add    $0x8,%edx
+  8000ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8000ee:	89 14 24             	mov    %edx,(%esp)
+  8000f1:	e8 4b 0e 00 00       	call   800f41 <sys_cputs>
+		b->idx = 0;
+  8000f6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000f9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8000ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800102:	8b 40 04             	mov    0x4(%eax),%eax
+  800105:	8d 50 01             	lea    0x1(%eax),%edx
+  800108:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80010b:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  80010e:	c9                   	leave  
+  80010f:	c3                   	ret    
+
+00800110 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  800110:	55                   	push   %ebp
+  800111:	89 e5                	mov    %esp,%ebp
+  800113:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  800119:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  800120:	00 00 00 
+	b.cnt = 0;
+  800123:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  80012a:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  80012d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800130:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800134:	8b 45 08             	mov    0x8(%ebp),%eax
+  800137:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80013b:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800141:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800145:	c7 04 24 b4 00 80 00 	movl   $0x8000b4,(%esp)
+  80014c:	e8 bd 01 00 00       	call   80030e <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800151:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800157:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80015b:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800161:	83 c0 08             	add    $0x8,%eax
+  800164:	89 04 24             	mov    %eax,(%esp)
+  800167:	e8 d5 0d 00 00       	call   800f41 <sys_cputs>
+
+	return b.cnt;
+  80016c:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800172:	c9                   	leave  
+  800173:	c3                   	ret    
+
+00800174 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800174:	55                   	push   %ebp
+  800175:	89 e5                	mov    %esp,%ebp
+  800177:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  80017a:	8d 45 0c             	lea    0xc(%ebp),%eax
+  80017d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800180:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800183:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800187:	8b 45 08             	mov    0x8(%ebp),%eax
+  80018a:	89 04 24             	mov    %eax,(%esp)
+  80018d:	e8 7e ff ff ff       	call   800110 <vcprintf>
+  800192:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  800195:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800198:	c9                   	leave  
+  800199:	c3                   	ret    
+
+0080019a <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  80019a:	55                   	push   %ebp
+  80019b:	89 e5                	mov    %esp,%ebp
+  80019d:	53                   	push   %ebx
+  80019e:	83 ec 34             	sub    $0x34,%esp
+  8001a1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8001a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8001a7:	8b 45 14             	mov    0x14(%ebp),%eax
+  8001aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  8001ad:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001b0:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001b5:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001b8:	77 72                	ja     80022c <printnum+0x92>
+  8001ba:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001bd:	72 05                	jb     8001c4 <printnum+0x2a>
+  8001bf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  8001c2:	77 68                	ja     80022c <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  8001c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8001c7:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  8001ca:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001cd:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001d2:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001d6:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8001da:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8001dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8001e0:	89 04 24             	mov    %eax,(%esp)
+  8001e3:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8001e7:	e8 c4 0e 00 00       	call   8010b0 <__udivdi3>
+  8001ec:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8001ef:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8001f3:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8001f7:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8001fa:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8001fe:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800202:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800206:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800209:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80020d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800210:	89 04 24             	mov    %eax,(%esp)
+  800213:	e8 82 ff ff ff       	call   80019a <printnum>
+  800218:	eb 1c                	jmp    800236 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  80021a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80021d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800221:	8b 45 20             	mov    0x20(%ebp),%eax
+  800224:	89 04 24             	mov    %eax,(%esp)
+  800227:	8b 45 08             	mov    0x8(%ebp),%eax
+  80022a:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  80022c:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  800230:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  800234:	7f e4                	jg     80021a <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  800236:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  800239:	bb 00 00 00 00       	mov    $0x0,%ebx
+  80023e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800241:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800244:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  800248:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80024c:	89 04 24             	mov    %eax,(%esp)
+  80024f:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800253:	e8 88 0f 00 00       	call   8011e0 <__umoddi3>
+  800258:	05 e8 13 80 00       	add    $0x8013e8,%eax
+  80025d:	0f b6 00             	movzbl (%eax),%eax
+  800260:	0f be c0             	movsbl %al,%eax
+  800263:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800266:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80026a:	89 04 24             	mov    %eax,(%esp)
+  80026d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800270:	ff d0                	call   *%eax
+}
+  800272:	83 c4 34             	add    $0x34,%esp
+  800275:	5b                   	pop    %ebx
+  800276:	5d                   	pop    %ebp
+  800277:	c3                   	ret    
+
+00800278 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800278:	55                   	push   %ebp
+  800279:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80027b:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80027f:	7e 14                	jle    800295 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800281:	8b 45 08             	mov    0x8(%ebp),%eax
+  800284:	8b 00                	mov    (%eax),%eax
+  800286:	8d 48 08             	lea    0x8(%eax),%ecx
+  800289:	8b 55 08             	mov    0x8(%ebp),%edx
+  80028c:	89 0a                	mov    %ecx,(%edx)
+  80028e:	8b 50 04             	mov    0x4(%eax),%edx
+  800291:	8b 00                	mov    (%eax),%eax
+  800293:	eb 30                	jmp    8002c5 <getuint+0x4d>
+	else if (lflag)
+  800295:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800299:	74 16                	je     8002b1 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  80029b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80029e:	8b 00                	mov    (%eax),%eax
+  8002a0:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002a3:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002a6:	89 0a                	mov    %ecx,(%edx)
+  8002a8:	8b 00                	mov    (%eax),%eax
+  8002aa:	ba 00 00 00 00       	mov    $0x0,%edx
+  8002af:	eb 14                	jmp    8002c5 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  8002b1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002b4:	8b 00                	mov    (%eax),%eax
+  8002b6:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002b9:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002bc:	89 0a                	mov    %ecx,(%edx)
+  8002be:	8b 00                	mov    (%eax),%eax
+  8002c0:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  8002c5:	5d                   	pop    %ebp
+  8002c6:	c3                   	ret    
+
+008002c7 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  8002c7:	55                   	push   %ebp
+  8002c8:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  8002ca:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  8002ce:	7e 14                	jle    8002e4 <getint+0x1d>
+		return va_arg(*ap, long long);
+  8002d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002d3:	8b 00                	mov    (%eax),%eax
+  8002d5:	8d 48 08             	lea    0x8(%eax),%ecx
+  8002d8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002db:	89 0a                	mov    %ecx,(%edx)
+  8002dd:	8b 50 04             	mov    0x4(%eax),%edx
+  8002e0:	8b 00                	mov    (%eax),%eax
+  8002e2:	eb 28                	jmp    80030c <getint+0x45>
+	else if (lflag)
+  8002e4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8002e8:	74 12                	je     8002fc <getint+0x35>
+		return va_arg(*ap, long);
+  8002ea:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002ed:	8b 00                	mov    (%eax),%eax
+  8002ef:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002f2:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002f5:	89 0a                	mov    %ecx,(%edx)
+  8002f7:	8b 00                	mov    (%eax),%eax
+  8002f9:	99                   	cltd   
+  8002fa:	eb 10                	jmp    80030c <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8002fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002ff:	8b 00                	mov    (%eax),%eax
+  800301:	8d 48 04             	lea    0x4(%eax),%ecx
+  800304:	8b 55 08             	mov    0x8(%ebp),%edx
+  800307:	89 0a                	mov    %ecx,(%edx)
+  800309:	8b 00                	mov    (%eax),%eax
+  80030b:	99                   	cltd   
+}
+  80030c:	5d                   	pop    %ebp
+  80030d:	c3                   	ret    
+
+0080030e <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  80030e:	55                   	push   %ebp
+  80030f:	89 e5                	mov    %esp,%ebp
+  800311:	56                   	push   %esi
+  800312:	53                   	push   %ebx
+  800313:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800316:	e9 72 01 00 00       	jmp    80048d <vprintfmt+0x17f>
+			if (ch == '\0')
+  80031b:	85 db                	test   %ebx,%ebx
+  80031d:	75 05                	jne    800324 <vprintfmt+0x16>
+				return;
+  80031f:	e9 2a 05 00 00       	jmp    80084e <vprintfmt+0x540>
+			else if(ch == '\033'){
+  800324:	83 fb 1b             	cmp    $0x1b,%ebx
+  800327:	0f 85 51 01 00 00    	jne    80047e <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  80032d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800330:	8d 50 01             	lea    0x1(%eax),%edx
+  800333:	89 55 10             	mov    %edx,0x10(%ebp)
+  800336:	0f b6 00             	movzbl (%eax),%eax
+  800339:	0f b6 d8             	movzbl %al,%ebx
+  80033c:	83 fb 5b             	cmp    $0x5b,%ebx
+  80033f:	74 14                	je     800355 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800341:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800348:	89 1c 24             	mov    %ebx,(%esp)
+  80034b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80034e:	ff d0                	call   *%eax
+				    continue;
+  800350:	e9 38 01 00 00       	jmp    80048d <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800355:	8b 45 10             	mov    0x10(%ebp),%eax
+  800358:	8d 50 01             	lea    0x1(%eax),%edx
+  80035b:	89 55 10             	mov    %edx,0x10(%ebp)
+  80035e:	0f b6 00             	movzbl (%eax),%eax
+  800361:	0f b6 c0             	movzbl %al,%eax
+  800364:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  800369:	8b 45 10             	mov    0x10(%ebp),%eax
+  80036c:	8d 50 01             	lea    0x1(%eax),%edx
+  80036f:	89 55 10             	mov    %edx,0x10(%ebp)
+  800372:	0f b6 00             	movzbl (%eax),%eax
+  800375:	0f b6 c0             	movzbl %al,%eax
+  800378:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  80037d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800382:	83 f8 2f             	cmp    $0x2f,%eax
+  800385:	7e 19                	jle    8003a0 <vprintfmt+0x92>
+  800387:	a1 08 20 80 00       	mov    0x802008,%eax
+  80038c:	83 f8 39             	cmp    $0x39,%eax
+  80038f:	7f 0f                	jg     8003a0 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800391:	a1 08 20 80 00       	mov    0x802008,%eax
+  800396:	83 e8 30             	sub    $0x30,%eax
+  800399:	a3 08 20 80 00       	mov    %eax,0x802008
+  80039e:	eb 50                	jmp    8003f0 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  8003a0:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003a5:	83 f8 60             	cmp    $0x60,%eax
+  8003a8:	7e 19                	jle    8003c3 <vprintfmt+0xb5>
+  8003aa:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003af:	83 f8 66             	cmp    $0x66,%eax
+  8003b2:	7f 0f                	jg     8003c3 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  8003b4:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003b9:	83 e8 57             	sub    $0x57,%eax
+  8003bc:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003c1:	eb 2d                	jmp    8003f0 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  8003c3:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003c8:	83 f8 40             	cmp    $0x40,%eax
+  8003cb:	7e 19                	jle    8003e6 <vprintfmt+0xd8>
+  8003cd:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003d2:	83 f8 46             	cmp    $0x46,%eax
+  8003d5:	7f 0f                	jg     8003e6 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  8003d7:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003dc:	83 e8 37             	sub    $0x37,%eax
+  8003df:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003e4:	eb 0a                	jmp    8003f0 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8003e6:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8003ed:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8003f0:	a1 10 20 80 00       	mov    0x802010,%eax
+  8003f5:	83 f8 2f             	cmp    $0x2f,%eax
+  8003f8:	7e 19                	jle    800413 <vprintfmt+0x105>
+  8003fa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8003ff:	83 f8 39             	cmp    $0x39,%eax
+  800402:	7f 0f                	jg     800413 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  800404:	a1 10 20 80 00       	mov    0x802010,%eax
+  800409:	83 e8 30             	sub    $0x30,%eax
+  80040c:	a3 10 20 80 00       	mov    %eax,0x802010
+  800411:	eb 50                	jmp    800463 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  800413:	a1 10 20 80 00       	mov    0x802010,%eax
+  800418:	83 f8 60             	cmp    $0x60,%eax
+  80041b:	7e 19                	jle    800436 <vprintfmt+0x128>
+  80041d:	a1 10 20 80 00       	mov    0x802010,%eax
+  800422:	83 f8 66             	cmp    $0x66,%eax
+  800425:	7f 0f                	jg     800436 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  800427:	a1 10 20 80 00       	mov    0x802010,%eax
+  80042c:	83 e8 57             	sub    $0x57,%eax
+  80042f:	a3 10 20 80 00       	mov    %eax,0x802010
+  800434:	eb 2d                	jmp    800463 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  800436:	a1 10 20 80 00       	mov    0x802010,%eax
+  80043b:	83 f8 40             	cmp    $0x40,%eax
+  80043e:	7e 19                	jle    800459 <vprintfmt+0x14b>
+  800440:	a1 10 20 80 00       	mov    0x802010,%eax
+  800445:	83 f8 46             	cmp    $0x46,%eax
+  800448:	7f 0f                	jg     800459 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  80044a:	a1 10 20 80 00       	mov    0x802010,%eax
+  80044f:	83 e8 37             	sub    $0x37,%eax
+  800452:	a3 10 20 80 00       	mov    %eax,0x802010
+  800457:	eb 0a                	jmp    800463 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  800459:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800460:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800463:	a1 08 20 80 00       	mov    0x802008,%eax
+  800468:	c1 e0 0c             	shl    $0xc,%eax
+  80046b:	89 c2                	mov    %eax,%edx
+  80046d:	a1 10 20 80 00       	mov    0x802010,%eax
+  800472:	c1 e0 08             	shl    $0x8,%eax
+  800475:	09 d0                	or     %edx,%eax
+  800477:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  80047c:	eb 0f                	jmp    80048d <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  80047e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800481:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800485:	89 1c 24             	mov    %ebx,(%esp)
+  800488:	8b 45 08             	mov    0x8(%ebp),%eax
+  80048b:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80048d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800490:	8d 50 01             	lea    0x1(%eax),%edx
+  800493:	89 55 10             	mov    %edx,0x10(%ebp)
+  800496:	0f b6 00             	movzbl (%eax),%eax
+  800499:	0f b6 d8             	movzbl %al,%ebx
+  80049c:	83 fb 25             	cmp    $0x25,%ebx
+  80049f:	0f 85 76 fe ff ff    	jne    80031b <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  8004a5:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  8004a9:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  8004b0:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  8004b7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  8004be:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  8004c5:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004c8:	8d 50 01             	lea    0x1(%eax),%edx
+  8004cb:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004ce:	0f b6 00             	movzbl (%eax),%eax
+  8004d1:	0f b6 d8             	movzbl %al,%ebx
+  8004d4:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  8004d7:	83 f8 55             	cmp    $0x55,%eax
+  8004da:	0f 87 3d 03 00 00    	ja     80081d <vprintfmt+0x50f>
+  8004e0:	8b 04 85 0c 14 80 00 	mov    0x80140c(,%eax,4),%eax
+  8004e7:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8004e9:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8004ed:	eb d6                	jmp    8004c5 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8004ef:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8004f3:	eb d0                	jmp    8004c5 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8004f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8004fc:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8004ff:	89 d0                	mov    %edx,%eax
+  800501:	c1 e0 02             	shl    $0x2,%eax
+  800504:	01 d0                	add    %edx,%eax
+  800506:	01 c0                	add    %eax,%eax
+  800508:	01 d8                	add    %ebx,%eax
+  80050a:	83 e8 30             	sub    $0x30,%eax
+  80050d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  800510:	8b 45 10             	mov    0x10(%ebp),%eax
+  800513:	0f b6 00             	movzbl (%eax),%eax
+  800516:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  800519:	83 fb 2f             	cmp    $0x2f,%ebx
+  80051c:	7e 0b                	jle    800529 <vprintfmt+0x21b>
+  80051e:	83 fb 39             	cmp    $0x39,%ebx
+  800521:	7f 06                	jg     800529 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800523:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  800527:	eb d3                	jmp    8004fc <vprintfmt+0x1ee>
+			goto process_precision;
+  800529:	eb 33                	jmp    80055e <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  80052b:	8b 45 14             	mov    0x14(%ebp),%eax
+  80052e:	8d 50 04             	lea    0x4(%eax),%edx
+  800531:	89 55 14             	mov    %edx,0x14(%ebp)
+  800534:	8b 00                	mov    (%eax),%eax
+  800536:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  800539:	eb 23                	jmp    80055e <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  80053b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80053f:	79 0c                	jns    80054d <vprintfmt+0x23f>
+				width = 0;
+  800541:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  800548:	e9 78 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+  80054d:	e9 73 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800552:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  800559:	e9 67 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  80055e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800562:	79 12                	jns    800576 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800564:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800567:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80056a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800571:	e9 4f ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+  800576:	e9 4a ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  80057b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  80057f:	e9 41 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800584:	8b 45 14             	mov    0x14(%ebp),%eax
+  800587:	8d 50 04             	lea    0x4(%eax),%edx
+  80058a:	89 55 14             	mov    %edx,0x14(%ebp)
+  80058d:	8b 00                	mov    (%eax),%eax
+  80058f:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800592:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800596:	89 04 24             	mov    %eax,(%esp)
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	ff d0                	call   *%eax
+			break;
+  80059e:	e9 a5 02 00 00       	jmp    800848 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  8005a3:	8b 45 14             	mov    0x14(%ebp),%eax
+  8005a6:	8d 50 04             	lea    0x4(%eax),%edx
+  8005a9:	89 55 14             	mov    %edx,0x14(%ebp)
+  8005ac:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  8005ae:	85 db                	test   %ebx,%ebx
+  8005b0:	79 02                	jns    8005b4 <vprintfmt+0x2a6>
+				err = -err;
+  8005b2:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  8005b4:	83 fb 06             	cmp    $0x6,%ebx
+  8005b7:	7f 0b                	jg     8005c4 <vprintfmt+0x2b6>
+  8005b9:	8b 34 9d cc 13 80 00 	mov    0x8013cc(,%ebx,4),%esi
+  8005c0:	85 f6                	test   %esi,%esi
+  8005c2:	75 23                	jne    8005e7 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  8005c4:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  8005c8:	c7 44 24 08 f9 13 80 	movl   $0x8013f9,0x8(%esp)
+  8005cf:	00 
+  8005d0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005d3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005d7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005da:	89 04 24             	mov    %eax,(%esp)
+  8005dd:	e8 73 02 00 00       	call   800855 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8005e2:	e9 61 02 00 00       	jmp    800848 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8005e7:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8005eb:	c7 44 24 08 02 14 80 	movl   $0x801402,0x8(%esp)
+  8005f2:	00 
+  8005f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005f6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fd:	89 04 24             	mov    %eax,(%esp)
+  800600:	e8 50 02 00 00       	call   800855 <printfmt>
+			break;
+  800605:	e9 3e 02 00 00       	jmp    800848 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  80060a:	8b 45 14             	mov    0x14(%ebp),%eax
+  80060d:	8d 50 04             	lea    0x4(%eax),%edx
+  800610:	89 55 14             	mov    %edx,0x14(%ebp)
+  800613:	8b 30                	mov    (%eax),%esi
+  800615:	85 f6                	test   %esi,%esi
+  800617:	75 05                	jne    80061e <vprintfmt+0x310>
+				p = "(null)";
+  800619:	be 05 14 80 00       	mov    $0x801405,%esi
+			if (width > 0 && padc != '-')
+  80061e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800622:	7e 37                	jle    80065b <vprintfmt+0x34d>
+  800624:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800628:	74 31                	je     80065b <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80062a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80062d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800631:	89 34 24             	mov    %esi,(%esp)
+  800634:	e8 39 03 00 00       	call   800972 <strnlen>
+  800639:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  80063c:	eb 17                	jmp    800655 <vprintfmt+0x347>
+					putch(padc, putdat);
+  80063e:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800642:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800645:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800649:	89 04 24             	mov    %eax,(%esp)
+  80064c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80064f:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800651:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800655:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800659:	7f e3                	jg     80063e <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80065b:	eb 38                	jmp    800695 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  80065d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800661:	74 1f                	je     800682 <vprintfmt+0x374>
+  800663:	83 fb 1f             	cmp    $0x1f,%ebx
+  800666:	7e 05                	jle    80066d <vprintfmt+0x35f>
+  800668:	83 fb 7e             	cmp    $0x7e,%ebx
+  80066b:	7e 15                	jle    800682 <vprintfmt+0x374>
+					putch('?', putdat);
+  80066d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800670:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800674:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  80067b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80067e:	ff d0                	call   *%eax
+  800680:	eb 0f                	jmp    800691 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800682:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800685:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800689:	89 1c 24             	mov    %ebx,(%esp)
+  80068c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80068f:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800691:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800695:	89 f0                	mov    %esi,%eax
+  800697:	8d 70 01             	lea    0x1(%eax),%esi
+  80069a:	0f b6 00             	movzbl (%eax),%eax
+  80069d:	0f be d8             	movsbl %al,%ebx
+  8006a0:	85 db                	test   %ebx,%ebx
+  8006a2:	74 10                	je     8006b4 <vprintfmt+0x3a6>
+  8006a4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006a8:	78 b3                	js     80065d <vprintfmt+0x34f>
+  8006aa:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  8006ae:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006b2:	79 a9                	jns    80065d <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006b4:	eb 17                	jmp    8006cd <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  8006b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006b9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006bd:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  8006c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006c7:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006c9:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8006cd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006d1:	7f e3                	jg     8006b6 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  8006d3:	e9 70 01 00 00       	jmp    800848 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  8006d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8006db:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006df:	8d 45 14             	lea    0x14(%ebp),%eax
+  8006e2:	89 04 24             	mov    %eax,(%esp)
+  8006e5:	e8 dd fb ff ff       	call   8002c7 <getint>
+  8006ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006ed:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8006f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8006f6:	85 d2                	test   %edx,%edx
+  8006f8:	79 26                	jns    800720 <vprintfmt+0x412>
+				putch('-', putdat);
+  8006fa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006fd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800701:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  800708:	8b 45 08             	mov    0x8(%ebp),%eax
+  80070b:	ff d0                	call   *%eax
+				num = -(long long) num;
+  80070d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800710:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800713:	f7 d8                	neg    %eax
+  800715:	83 d2 00             	adc    $0x0,%edx
+  800718:	f7 da                	neg    %edx
+  80071a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80071d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  800720:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800727:	e9 a8 00 00 00       	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  80072c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80072f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800733:	8d 45 14             	lea    0x14(%ebp),%eax
+  800736:	89 04 24             	mov    %eax,(%esp)
+  800739:	e8 3a fb ff ff       	call   800278 <getuint>
+  80073e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800741:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  800744:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  80074b:	e9 84 00 00 00       	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800750:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800753:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800757:	8d 45 14             	lea    0x14(%ebp),%eax
+  80075a:	89 04 24             	mov    %eax,(%esp)
+  80075d:	e8 16 fb ff ff       	call   800278 <getuint>
+  800762:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800765:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800768:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  80076f:	eb 63                	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800771:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800774:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800778:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  80077f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800782:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800784:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800787:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80078b:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800792:	8b 45 08             	mov    0x8(%ebp),%eax
+  800795:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  800797:	8b 45 14             	mov    0x14(%ebp),%eax
+  80079a:	8d 50 04             	lea    0x4(%eax),%edx
+  80079d:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007a0:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  8007a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  8007ac:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  8007b3:	eb 1f                	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  8007b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8007b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007bc:	8d 45 14             	lea    0x14(%ebp),%eax
+  8007bf:	89 04 24             	mov    %eax,(%esp)
+  8007c2:	e8 b1 fa ff ff       	call   800278 <getuint>
+  8007c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  8007cd:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  8007d4:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  8007d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8007db:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8007df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8007e2:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8007e6:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8007ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8007f0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8007f4:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8007f8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007ff:	8b 45 08             	mov    0x8(%ebp),%eax
+  800802:	89 04 24             	mov    %eax,(%esp)
+  800805:	e8 90 f9 ff ff       	call   80019a <printnum>
+			break;
+  80080a:	eb 3c                	jmp    800848 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  80080c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80080f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800813:	89 1c 24             	mov    %ebx,(%esp)
+  800816:	8b 45 08             	mov    0x8(%ebp),%eax
+  800819:	ff d0                	call   *%eax
+			break;			
+  80081b:	eb 2b                	jmp    800848 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  80081d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800820:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800824:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  80082b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80082e:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  800830:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800834:	eb 04                	jmp    80083a <vprintfmt+0x52c>
+  800836:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80083a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80083d:	83 e8 01             	sub    $0x1,%eax
+  800840:	0f b6 00             	movzbl (%eax),%eax
+  800843:	3c 25                	cmp    $0x25,%al
+  800845:	75 ef                	jne    800836 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800847:	90                   	nop
+		}
+	}
+  800848:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800849:	e9 3f fc ff ff       	jmp    80048d <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  80084e:	83 c4 40             	add    $0x40,%esp
+  800851:	5b                   	pop    %ebx
+  800852:	5e                   	pop    %esi
+  800853:	5d                   	pop    %ebp
+  800854:	c3                   	ret    
+
+00800855 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800855:	55                   	push   %ebp
+  800856:	89 e5                	mov    %esp,%ebp
+  800858:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  80085b:	8d 45 14             	lea    0x14(%ebp),%eax
+  80085e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800861:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800864:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800868:	8b 45 10             	mov    0x10(%ebp),%eax
+  80086b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80086f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800872:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800876:	8b 45 08             	mov    0x8(%ebp),%eax
+  800879:	89 04 24             	mov    %eax,(%esp)
+  80087c:	e8 8d fa ff ff       	call   80030e <vprintfmt>
+	va_end(ap);
+}
+  800881:	c9                   	leave  
+  800882:	c3                   	ret    
+
+00800883 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800883:	55                   	push   %ebp
+  800884:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800886:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800889:	8b 40 08             	mov    0x8(%eax),%eax
+  80088c:	8d 50 01             	lea    0x1(%eax),%edx
+  80088f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800892:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800895:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800898:	8b 10                	mov    (%eax),%edx
+  80089a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80089d:	8b 40 04             	mov    0x4(%eax),%eax
+  8008a0:	39 c2                	cmp    %eax,%edx
+  8008a2:	73 12                	jae    8008b6 <sprintputch+0x33>
+		*b->buf++ = ch;
+  8008a4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008a7:	8b 00                	mov    (%eax),%eax
+  8008a9:	8d 48 01             	lea    0x1(%eax),%ecx
+  8008ac:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8008af:	89 0a                	mov    %ecx,(%edx)
+  8008b1:	8b 55 08             	mov    0x8(%ebp),%edx
+  8008b4:	88 10                	mov    %dl,(%eax)
+}
+  8008b6:	5d                   	pop    %ebp
+  8008b7:	c3                   	ret    
+
+008008b8 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  8008b8:	55                   	push   %ebp
+  8008b9:	89 e5                	mov    %esp,%ebp
+  8008bb:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  8008be:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8008c4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008c7:	8d 50 ff             	lea    -0x1(%eax),%edx
+  8008ca:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008cd:	01 d0                	add    %edx,%eax
+  8008cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  8008d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  8008dd:	74 06                	je     8008e5 <vsnprintf+0x2d>
+  8008df:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8008e3:	7f 07                	jg     8008ec <vsnprintf+0x34>
+		return -E_INVAL;
+  8008e5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  8008ea:	eb 2a                	jmp    800916 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  8008ec:	8b 45 14             	mov    0x14(%ebp),%eax
+  8008ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8008f3:	8b 45 10             	mov    0x10(%ebp),%eax
+  8008f6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8008fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  8008fd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800901:	c7 04 24 83 08 80 00 	movl   $0x800883,(%esp)
+  800908:	e8 01 fa ff ff       	call   80030e <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  80090d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800910:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800913:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800916:	c9                   	leave  
+  800917:	c3                   	ret    
+
+00800918 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800918:	55                   	push   %ebp
+  800919:	89 e5                	mov    %esp,%ebp
+  80091b:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  80091e:	8d 45 14             	lea    0x14(%ebp),%eax
+  800921:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800924:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800927:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  80092b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80092e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800932:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800935:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800939:	8b 45 08             	mov    0x8(%ebp),%eax
+  80093c:	89 04 24             	mov    %eax,(%esp)
+  80093f:	e8 74 ff ff ff       	call   8008b8 <vsnprintf>
+  800944:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800947:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80094a:	c9                   	leave  
+  80094b:	c3                   	ret    
+
+0080094c <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  80094c:	55                   	push   %ebp
+  80094d:	89 e5                	mov    %esp,%ebp
+  80094f:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800952:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800959:	eb 08                	jmp    800963 <strlen+0x17>
+		n++;
+  80095b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  80095f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800963:	8b 45 08             	mov    0x8(%ebp),%eax
+  800966:	0f b6 00             	movzbl (%eax),%eax
+  800969:	84 c0                	test   %al,%al
+  80096b:	75 ee                	jne    80095b <strlen+0xf>
+		n++;
+	return n;
+  80096d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800970:	c9                   	leave  
+  800971:	c3                   	ret    
+
+00800972 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800972:	55                   	push   %ebp
+  800973:	89 e5                	mov    %esp,%ebp
+  800975:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800978:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  80097f:	eb 0c                	jmp    80098d <strnlen+0x1b>
+		n++;
+  800981:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800985:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800989:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  80098d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800991:	74 0a                	je     80099d <strnlen+0x2b>
+  800993:	8b 45 08             	mov    0x8(%ebp),%eax
+  800996:	0f b6 00             	movzbl (%eax),%eax
+  800999:	84 c0                	test   %al,%al
+  80099b:	75 e4                	jne    800981 <strnlen+0xf>
+		n++;
+	return n;
+  80099d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009a0:	c9                   	leave  
+  8009a1:	c3                   	ret    
+
+008009a2 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  8009a2:	55                   	push   %ebp
+  8009a3:	89 e5                	mov    %esp,%ebp
+  8009a5:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  8009a8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  8009ae:	90                   	nop
+  8009af:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009b2:	8d 50 01             	lea    0x1(%eax),%edx
+  8009b5:	89 55 08             	mov    %edx,0x8(%ebp)
+  8009b8:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8009bb:	8d 4a 01             	lea    0x1(%edx),%ecx
+  8009be:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  8009c1:	0f b6 12             	movzbl (%edx),%edx
+  8009c4:	88 10                	mov    %dl,(%eax)
+  8009c6:	0f b6 00             	movzbl (%eax),%eax
+  8009c9:	84 c0                	test   %al,%al
+  8009cb:	75 e2                	jne    8009af <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  8009cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009d0:	c9                   	leave  
+  8009d1:	c3                   	ret    
+
+008009d2 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  8009d2:	55                   	push   %ebp
+  8009d3:	89 e5                	mov    %esp,%ebp
+  8009d5:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  8009d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009db:	89 04 24             	mov    %eax,(%esp)
+  8009de:	e8 69 ff ff ff       	call   80094c <strlen>
+  8009e3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  8009e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  8009e9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ec:	01 c2                	add    %eax,%edx
+  8009ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009f5:	89 14 24             	mov    %edx,(%esp)
+  8009f8:	e8 a5 ff ff ff       	call   8009a2 <strcpy>
+	return dst;
+  8009fd:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800a00:	c9                   	leave  
+  800a01:	c3                   	ret    
+
+00800a02 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800a02:	55                   	push   %ebp
+  800a03:	89 e5                	mov    %esp,%ebp
+  800a05:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800a08:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a0b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800a0e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800a15:	eb 23                	jmp    800a3a <strncpy+0x38>
+		*dst++ = *src;
+  800a17:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a1a:	8d 50 01             	lea    0x1(%eax),%edx
+  800a1d:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a20:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a23:	0f b6 12             	movzbl (%edx),%edx
+  800a26:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800a28:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a2b:	0f b6 00             	movzbl (%eax),%eax
+  800a2e:	84 c0                	test   %al,%al
+  800a30:	74 04                	je     800a36 <strncpy+0x34>
+			src++;
+  800a32:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800a36:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800a3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a3d:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800a40:	72 d5                	jb     800a17 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800a42:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800a45:	c9                   	leave  
+  800a46:	c3                   	ret    
+
+00800a47 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800a47:	55                   	push   %ebp
+  800a48:	89 e5                	mov    %esp,%ebp
+  800a4a:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800a4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a50:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800a53:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a57:	74 33                	je     800a8c <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800a59:	eb 17                	jmp    800a72 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800a5b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a5e:	8d 50 01             	lea    0x1(%eax),%edx
+  800a61:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a64:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a67:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800a6a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800a6d:	0f b6 12             	movzbl (%edx),%edx
+  800a70:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800a72:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a76:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a7a:	74 0a                	je     800a86 <strlcpy+0x3f>
+  800a7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a7f:	0f b6 00             	movzbl (%eax),%eax
+  800a82:	84 c0                	test   %al,%al
+  800a84:	75 d5                	jne    800a5b <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800a86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a89:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800a8c:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a92:	29 c2                	sub    %eax,%edx
+  800a94:	89 d0                	mov    %edx,%eax
+}
+  800a96:	c9                   	leave  
+  800a97:	c3                   	ret    
+
+00800a98 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800a98:	55                   	push   %ebp
+  800a99:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800a9b:	eb 08                	jmp    800aa5 <strcmp+0xd>
+		p++, q++;
+  800a9d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800aa1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800aa5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aa8:	0f b6 00             	movzbl (%eax),%eax
+  800aab:	84 c0                	test   %al,%al
+  800aad:	74 10                	je     800abf <strcmp+0x27>
+  800aaf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ab2:	0f b6 10             	movzbl (%eax),%edx
+  800ab5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ab8:	0f b6 00             	movzbl (%eax),%eax
+  800abb:	38 c2                	cmp    %al,%dl
+  800abd:	74 de                	je     800a9d <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800abf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ac2:	0f b6 00             	movzbl (%eax),%eax
+  800ac5:	0f b6 d0             	movzbl %al,%edx
+  800ac8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800acb:	0f b6 00             	movzbl (%eax),%eax
+  800ace:	0f b6 c0             	movzbl %al,%eax
+  800ad1:	29 c2                	sub    %eax,%edx
+  800ad3:	89 d0                	mov    %edx,%eax
+}
+  800ad5:	5d                   	pop    %ebp
+  800ad6:	c3                   	ret    
+
+00800ad7 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800ad7:	55                   	push   %ebp
+  800ad8:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800ada:	eb 0c                	jmp    800ae8 <strncmp+0x11>
+		n--, p++, q++;
+  800adc:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800ae0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ae4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800ae8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800aec:	74 1a                	je     800b08 <strncmp+0x31>
+  800aee:	8b 45 08             	mov    0x8(%ebp),%eax
+  800af1:	0f b6 00             	movzbl (%eax),%eax
+  800af4:	84 c0                	test   %al,%al
+  800af6:	74 10                	je     800b08 <strncmp+0x31>
+  800af8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800afb:	0f b6 10             	movzbl (%eax),%edx
+  800afe:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b01:	0f b6 00             	movzbl (%eax),%eax
+  800b04:	38 c2                	cmp    %al,%dl
+  800b06:	74 d4                	je     800adc <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800b08:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b0c:	75 07                	jne    800b15 <strncmp+0x3e>
+		return 0;
+  800b0e:	b8 00 00 00 00       	mov    $0x0,%eax
+  800b13:	eb 16                	jmp    800b2b <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800b15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b18:	0f b6 00             	movzbl (%eax),%eax
+  800b1b:	0f b6 d0             	movzbl %al,%edx
+  800b1e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b21:	0f b6 00             	movzbl (%eax),%eax
+  800b24:	0f b6 c0             	movzbl %al,%eax
+  800b27:	29 c2                	sub    %eax,%edx
+  800b29:	89 d0                	mov    %edx,%eax
+}
+  800b2b:	5d                   	pop    %ebp
+  800b2c:	c3                   	ret    
+
+00800b2d <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800b2d:	55                   	push   %ebp
+  800b2e:	89 e5                	mov    %esp,%ebp
+  800b30:	83 ec 04             	sub    $0x4,%esp
+  800b33:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b36:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b39:	eb 14                	jmp    800b4f <strchr+0x22>
+		if (*s == c)
+  800b3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b3e:	0f b6 00             	movzbl (%eax),%eax
+  800b41:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b44:	75 05                	jne    800b4b <strchr+0x1e>
+			return (char *) s;
+  800b46:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b49:	eb 13                	jmp    800b5e <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800b4b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b4f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b52:	0f b6 00             	movzbl (%eax),%eax
+  800b55:	84 c0                	test   %al,%al
+  800b57:	75 e2                	jne    800b3b <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800b59:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800b5e:	c9                   	leave  
+  800b5f:	c3                   	ret    
+
+00800b60 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800b60:	55                   	push   %ebp
+  800b61:	89 e5                	mov    %esp,%ebp
+  800b63:	83 ec 04             	sub    $0x4,%esp
+  800b66:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b69:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b6c:	eb 11                	jmp    800b7f <strfind+0x1f>
+		if (*s == c)
+  800b6e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b71:	0f b6 00             	movzbl (%eax),%eax
+  800b74:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b77:	75 02                	jne    800b7b <strfind+0x1b>
+			break;
+  800b79:	eb 0e                	jmp    800b89 <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800b7b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b7f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b82:	0f b6 00             	movzbl (%eax),%eax
+  800b85:	84 c0                	test   %al,%al
+  800b87:	75 e5                	jne    800b6e <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800b89:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800b8c:	c9                   	leave  
+  800b8d:	c3                   	ret    
+
+00800b8e <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800b8e:	55                   	push   %ebp
+  800b8f:	89 e5                	mov    %esp,%ebp
+  800b91:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800b92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b96:	75 05                	jne    800b9d <memset+0xf>
+		return v;
+  800b98:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b9b:	eb 5c                	jmp    800bf9 <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800b9d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba0:	83 e0 03             	and    $0x3,%eax
+  800ba3:	85 c0                	test   %eax,%eax
+  800ba5:	75 41                	jne    800be8 <memset+0x5a>
+  800ba7:	8b 45 10             	mov    0x10(%ebp),%eax
+  800baa:	83 e0 03             	and    $0x3,%eax
+  800bad:	85 c0                	test   %eax,%eax
+  800baf:	75 37                	jne    800be8 <memset+0x5a>
+		c &= 0xFF;
+  800bb1:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800bb8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bbb:	c1 e0 18             	shl    $0x18,%eax
+  800bbe:	89 c2                	mov    %eax,%edx
+  800bc0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bc3:	c1 e0 10             	shl    $0x10,%eax
+  800bc6:	09 c2                	or     %eax,%edx
+  800bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bcb:	c1 e0 08             	shl    $0x8,%eax
+  800bce:	09 d0                	or     %edx,%eax
+  800bd0:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800bd3:	8b 45 10             	mov    0x10(%ebp),%eax
+  800bd6:	c1 e8 02             	shr    $0x2,%eax
+  800bd9:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800bdb:	8b 55 08             	mov    0x8(%ebp),%edx
+  800bde:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800be1:	89 d7                	mov    %edx,%edi
+  800be3:	fc                   	cld    
+  800be4:	f3 ab                	rep stos %eax,%es:(%edi)
+  800be6:	eb 0e                	jmp    800bf6 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800be8:	8b 55 08             	mov    0x8(%ebp),%edx
+  800beb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bee:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800bf1:	89 d7                	mov    %edx,%edi
+  800bf3:	fc                   	cld    
+  800bf4:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800bf6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bf9:	5f                   	pop    %edi
+  800bfa:	5d                   	pop    %ebp
+  800bfb:	c3                   	ret    
+
+00800bfc <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800bfc:	55                   	push   %ebp
+  800bfd:	89 e5                	mov    %esp,%ebp
+  800bff:	57                   	push   %edi
+  800c00:	56                   	push   %esi
+  800c01:	53                   	push   %ebx
+  800c02:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800c05:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c08:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800c0b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c0e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800c11:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c14:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c17:	73 6d                	jae    800c86 <memmove+0x8a>
+  800c19:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c1f:	01 d0                	add    %edx,%eax
+  800c21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c24:	76 60                	jbe    800c86 <memmove+0x8a>
+		s += n;
+  800c26:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c29:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800c2c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c2f:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	83 e0 03             	and    $0x3,%eax
+  800c38:	85 c0                	test   %eax,%eax
+  800c3a:	75 2f                	jne    800c6b <memmove+0x6f>
+  800c3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c3f:	83 e0 03             	and    $0x3,%eax
+  800c42:	85 c0                	test   %eax,%eax
+  800c44:	75 25                	jne    800c6b <memmove+0x6f>
+  800c46:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c49:	83 e0 03             	and    $0x3,%eax
+  800c4c:	85 c0                	test   %eax,%eax
+  800c4e:	75 1b                	jne    800c6b <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800c50:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c53:	83 e8 04             	sub    $0x4,%eax
+  800c56:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c59:	83 ea 04             	sub    $0x4,%edx
+  800c5c:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800c5f:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800c62:	89 c7                	mov    %eax,%edi
+  800c64:	89 d6                	mov    %edx,%esi
+  800c66:	fd                   	std    
+  800c67:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800c69:	eb 18                	jmp    800c83 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800c6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c6e:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800c71:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c74:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800c77:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c7a:	89 d7                	mov    %edx,%edi
+  800c7c:	89 de                	mov    %ebx,%esi
+  800c7e:	89 c1                	mov    %eax,%ecx
+  800c80:	fd                   	std    
+  800c81:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800c83:	fc                   	cld    
+  800c84:	eb 45                	jmp    800ccb <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c89:	83 e0 03             	and    $0x3,%eax
+  800c8c:	85 c0                	test   %eax,%eax
+  800c8e:	75 2b                	jne    800cbb <memmove+0xbf>
+  800c90:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c93:	83 e0 03             	and    $0x3,%eax
+  800c96:	85 c0                	test   %eax,%eax
+  800c98:	75 21                	jne    800cbb <memmove+0xbf>
+  800c9a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c9d:	83 e0 03             	and    $0x3,%eax
+  800ca0:	85 c0                	test   %eax,%eax
+  800ca2:	75 17                	jne    800cbb <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800ca4:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ca7:	c1 e8 02             	shr    $0x2,%eax
+  800caa:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800cac:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800caf:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cb2:	89 c7                	mov    %eax,%edi
+  800cb4:	89 d6                	mov    %edx,%esi
+  800cb6:	fc                   	cld    
+  800cb7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800cb9:	eb 10                	jmp    800ccb <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800cbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800cbe:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cc1:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800cc4:	89 c7                	mov    %eax,%edi
+  800cc6:	89 d6                	mov    %edx,%esi
+  800cc8:	fc                   	cld    
+  800cc9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800ccb:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800cce:	83 c4 10             	add    $0x10,%esp
+  800cd1:	5b                   	pop    %ebx
+  800cd2:	5e                   	pop    %esi
+  800cd3:	5f                   	pop    %edi
+  800cd4:	5d                   	pop    %ebp
+  800cd5:	c3                   	ret    
+
+00800cd6 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800cd6:	55                   	push   %ebp
+  800cd7:	89 e5                	mov    %esp,%ebp
+  800cd9:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800cdc:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cdf:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ce3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800cea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ced:	89 04 24             	mov    %eax,(%esp)
+  800cf0:	e8 07 ff ff ff       	call   800bfc <memmove>
+}
+  800cf5:	c9                   	leave  
+  800cf6:	c3                   	ret    
+
+00800cf7 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800cf7:	55                   	push   %ebp
+  800cf8:	89 e5                	mov    %esp,%ebp
+  800cfa:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800cfd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d00:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800d03:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d06:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800d09:	eb 30                	jmp    800d3b <memcmp+0x44>
+		if (*s1 != *s2)
+  800d0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d0e:	0f b6 10             	movzbl (%eax),%edx
+  800d11:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d14:	0f b6 00             	movzbl (%eax),%eax
+  800d17:	38 c2                	cmp    %al,%dl
+  800d19:	74 18                	je     800d33 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800d1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d1e:	0f b6 00             	movzbl (%eax),%eax
+  800d21:	0f b6 d0             	movzbl %al,%edx
+  800d24:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d27:	0f b6 00             	movzbl (%eax),%eax
+  800d2a:	0f b6 c0             	movzbl %al,%eax
+  800d2d:	29 c2                	sub    %eax,%edx
+  800d2f:	89 d0                	mov    %edx,%eax
+  800d31:	eb 1a                	jmp    800d4d <memcmp+0x56>
+		s1++, s2++;
+  800d33:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800d37:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800d3b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d3e:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800d41:	89 55 10             	mov    %edx,0x10(%ebp)
+  800d44:	85 c0                	test   %eax,%eax
+  800d46:	75 c3                	jne    800d0b <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800d48:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d4d:	c9                   	leave  
+  800d4e:	c3                   	ret    
+
+00800d4f <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800d4f:	55                   	push   %ebp
+  800d50:	89 e5                	mov    %esp,%ebp
+  800d52:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800d55:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d58:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d5b:	01 d0                	add    %edx,%eax
+  800d5d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800d60:	eb 13                	jmp    800d75 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800d62:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d65:	0f b6 10             	movzbl (%eax),%edx
+  800d68:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d6b:	38 c2                	cmp    %al,%dl
+  800d6d:	75 02                	jne    800d71 <memfind+0x22>
+			break;
+  800d6f:	eb 0c                	jmp    800d7d <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800d71:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d78:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800d7b:	72 e5                	jb     800d62 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800d7d:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d80:	c9                   	leave  
+  800d81:	c3                   	ret    
+
+00800d82 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800d82:	55                   	push   %ebp
+  800d83:	89 e5                	mov    %esp,%ebp
+  800d85:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800d88:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800d8f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800d96:	eb 04                	jmp    800d9c <strtol+0x1a>
+		s++;
+  800d98:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800d9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d9f:	0f b6 00             	movzbl (%eax),%eax
+  800da2:	3c 20                	cmp    $0x20,%al
+  800da4:	74 f2                	je     800d98 <strtol+0x16>
+  800da6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800da9:	0f b6 00             	movzbl (%eax),%eax
+  800dac:	3c 09                	cmp    $0x9,%al
+  800dae:	74 e8                	je     800d98 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800db0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800db3:	0f b6 00             	movzbl (%eax),%eax
+  800db6:	3c 2b                	cmp    $0x2b,%al
+  800db8:	75 06                	jne    800dc0 <strtol+0x3e>
+		s++;
+  800dba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800dbe:	eb 15                	jmp    800dd5 <strtol+0x53>
+	else if (*s == '-')
+  800dc0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc3:	0f b6 00             	movzbl (%eax),%eax
+  800dc6:	3c 2d                	cmp    $0x2d,%al
+  800dc8:	75 0b                	jne    800dd5 <strtol+0x53>
+		s++, neg = 1;
+  800dca:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800dce:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800dd5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800dd9:	74 06                	je     800de1 <strtol+0x5f>
+  800ddb:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800ddf:	75 24                	jne    800e05 <strtol+0x83>
+  800de1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de4:	0f b6 00             	movzbl (%eax),%eax
+  800de7:	3c 30                	cmp    $0x30,%al
+  800de9:	75 1a                	jne    800e05 <strtol+0x83>
+  800deb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dee:	83 c0 01             	add    $0x1,%eax
+  800df1:	0f b6 00             	movzbl (%eax),%eax
+  800df4:	3c 78                	cmp    $0x78,%al
+  800df6:	75 0d                	jne    800e05 <strtol+0x83>
+		s += 2, base = 16;
+  800df8:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800dfc:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800e03:	eb 2a                	jmp    800e2f <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800e05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e09:	75 17                	jne    800e22 <strtol+0xa0>
+  800e0b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e0e:	0f b6 00             	movzbl (%eax),%eax
+  800e11:	3c 30                	cmp    $0x30,%al
+  800e13:	75 0d                	jne    800e22 <strtol+0xa0>
+		s++, base = 8;
+  800e15:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800e19:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800e20:	eb 0d                	jmp    800e2f <strtol+0xad>
+	else if (base == 0)
+  800e22:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e26:	75 07                	jne    800e2f <strtol+0xad>
+		base = 10;
+  800e28:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800e2f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e32:	0f b6 00             	movzbl (%eax),%eax
+  800e35:	3c 2f                	cmp    $0x2f,%al
+  800e37:	7e 1b                	jle    800e54 <strtol+0xd2>
+  800e39:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e3c:	0f b6 00             	movzbl (%eax),%eax
+  800e3f:	3c 39                	cmp    $0x39,%al
+  800e41:	7f 11                	jg     800e54 <strtol+0xd2>
+			dig = *s - '0';
+  800e43:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e46:	0f b6 00             	movzbl (%eax),%eax
+  800e49:	0f be c0             	movsbl %al,%eax
+  800e4c:	83 e8 30             	sub    $0x30,%eax
+  800e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e52:	eb 48                	jmp    800e9c <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  800e54:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e57:	0f b6 00             	movzbl (%eax),%eax
+  800e5a:	3c 60                	cmp    $0x60,%al
+  800e5c:	7e 1b                	jle    800e79 <strtol+0xf7>
+  800e5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e61:	0f b6 00             	movzbl (%eax),%eax
+  800e64:	3c 7a                	cmp    $0x7a,%al
+  800e66:	7f 11                	jg     800e79 <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  800e68:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e6b:	0f b6 00             	movzbl (%eax),%eax
+  800e6e:	0f be c0             	movsbl %al,%eax
+  800e71:	83 e8 57             	sub    $0x57,%eax
+  800e74:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e77:	eb 23                	jmp    800e9c <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  800e79:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e7c:	0f b6 00             	movzbl (%eax),%eax
+  800e7f:	3c 40                	cmp    $0x40,%al
+  800e81:	7e 3d                	jle    800ec0 <strtol+0x13e>
+  800e83:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e86:	0f b6 00             	movzbl (%eax),%eax
+  800e89:	3c 5a                	cmp    $0x5a,%al
+  800e8b:	7f 33                	jg     800ec0 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  800e8d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e90:	0f b6 00             	movzbl (%eax),%eax
+  800e93:	0f be c0             	movsbl %al,%eax
+  800e96:	83 e8 37             	sub    $0x37,%eax
+  800e99:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  800e9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800e9f:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800ea2:	7c 02                	jl     800ea6 <strtol+0x124>
+			break;
+  800ea4:	eb 1a                	jmp    800ec0 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  800ea6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800eaa:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ead:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800eb1:	89 c2                	mov    %eax,%edx
+  800eb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800eb6:	01 d0                	add    %edx,%eax
+  800eb8:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  800ebb:	e9 6f ff ff ff       	jmp    800e2f <strtol+0xad>
+
+	if (endptr)
+  800ec0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800ec4:	74 08                	je     800ece <strtol+0x14c>
+		*endptr = (char *) s;
+  800ec6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ec9:	8b 55 08             	mov    0x8(%ebp),%edx
+  800ecc:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  800ece:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800ed2:	74 07                	je     800edb <strtol+0x159>
+  800ed4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ed7:	f7 d8                	neg    %eax
+  800ed9:	eb 03                	jmp    800ede <strtol+0x15c>
+  800edb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800ede:	c9                   	leave  
+  800edf:	c3                   	ret    
+
+00800ee0 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  800ee0:	55                   	push   %ebp
+  800ee1:	89 e5                	mov    %esp,%ebp
+  800ee3:	57                   	push   %edi
+  800ee4:	56                   	push   %esi
+  800ee5:	53                   	push   %ebx
+  800ee6:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  800ee9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eec:	8b 55 10             	mov    0x10(%ebp),%edx
+  800eef:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  800ef2:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  800ef5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  800ef8:	8b 75 20             	mov    0x20(%ebp),%esi
+  800efb:	cd 30                	int    $0x30
+  800efd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  800f00:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800f04:	74 30                	je     800f36 <syscall+0x56>
+  800f06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800f0a:	7e 2a                	jle    800f36 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  800f0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800f0f:	89 44 24 10          	mov    %eax,0x10(%esp)
+  800f13:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f16:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800f1a:	c7 44 24 08 64 15 80 	movl   $0x801564,0x8(%esp)
+  800f21:	00 
+  800f22:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  800f29:	00 
+  800f2a:	c7 04 24 81 15 80 00 	movl   $0x801581,(%esp)
+  800f31:	e8 18 01 00 00       	call   80104e <_panic>
+
+	return ret;
+  800f36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  800f39:	83 c4 3c             	add    $0x3c,%esp
+  800f3c:	5b                   	pop    %ebx
+  800f3d:	5e                   	pop    %esi
+  800f3e:	5f                   	pop    %edi
+  800f3f:	5d                   	pop    %ebp
+  800f40:	c3                   	ret    
+
+00800f41 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800f41:	55                   	push   %ebp
+  800f42:	89 e5                	mov    %esp,%ebp
+  800f44:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800f47:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f4a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f51:	00 
+  800f52:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800f59:	00 
+  800f5a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800f61:	00 
+  800f62:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800f65:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800f69:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800f6d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800f74:	00 
+  800f75:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800f7c:	e8 5f ff ff ff       	call   800ee0 <syscall>
+}
+  800f81:	c9                   	leave  
+  800f82:	c3                   	ret    
+
+00800f83 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800f83:	55                   	push   %ebp
+  800f84:	89 e5                	mov    %esp,%ebp
+  800f86:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800f89:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f90:	00 
+  800f91:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800f98:	00 
+  800f99:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800fa0:	00 
+  800fa1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800fa8:	00 
+  800fa9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800fb0:	00 
+  800fb1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800fb8:	00 
+  800fb9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800fc0:	e8 1b ff ff ff       	call   800ee0 <syscall>
+}
+  800fc5:	c9                   	leave  
+  800fc6:	c3                   	ret    
+
+00800fc7 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800fc7:	55                   	push   %ebp
+  800fc8:	89 e5                	mov    %esp,%ebp
+  800fca:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800fcd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fd0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800fd7:	00 
+  800fd8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800fdf:	00 
+  800fe0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800fe7:	00 
+  800fe8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800fef:	00 
+  800ff0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ff4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  800ffb:	00 
+  800ffc:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  801003:	e8 d8 fe ff ff       	call   800ee0 <syscall>
+}
+  801008:	c9                   	leave  
+  801009:	c3                   	ret    
+
+0080100a <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  80100a:	55                   	push   %ebp
+  80100b:	89 e5                	mov    %esp,%ebp
+  80100d:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  801010:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  801017:	00 
+  801018:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80101f:	00 
+  801020:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  801027:	00 
+  801028:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  80102f:	00 
+  801030:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  801037:	00 
+  801038:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80103f:	00 
+  801040:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  801047:	e8 94 fe ff ff       	call   800ee0 <syscall>
+}
+  80104c:	c9                   	leave  
+  80104d:	c3                   	ret    
+
+0080104e <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80104e:	55                   	push   %ebp
+  80104f:	89 e5                	mov    %esp,%ebp
+  801051:	53                   	push   %ebx
+  801052:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  801055:	8d 45 14             	lea    0x14(%ebp),%eax
+  801058:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80105b:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  801061:	e8 a4 ff ff ff       	call   80100a <sys_getenvid>
+  801066:	8b 55 0c             	mov    0xc(%ebp),%edx
+  801069:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80106d:	8b 55 08             	mov    0x8(%ebp),%edx
+  801070:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  801074:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  801078:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80107c:	c7 04 24 90 15 80 00 	movl   $0x801590,(%esp)
+  801083:	e8 ec f0 ff ff       	call   800174 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  801088:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80108b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80108f:	8b 45 10             	mov    0x10(%ebp),%eax
+  801092:	89 04 24             	mov    %eax,(%esp)
+  801095:	e8 76 f0 ff ff       	call   800110 <vcprintf>
+	cprintf("\n");
+  80109a:	c7 04 24 b3 15 80 00 	movl   $0x8015b3,(%esp)
+  8010a1:	e8 ce f0 ff ff       	call   800174 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  8010a6:	cc                   	int3   
+  8010a7:	eb fd                	jmp    8010a6 <_panic+0x58>
+  8010a9:	66 90                	xchg   %ax,%ax
+  8010ab:	66 90                	xchg   %ax,%ax
+  8010ad:	66 90                	xchg   %ax,%ax
+  8010af:	90                   	nop
+
+008010b0 <__udivdi3>:
+  8010b0:	55                   	push   %ebp
+  8010b1:	57                   	push   %edi
+  8010b2:	56                   	push   %esi
+  8010b3:	83 ec 0c             	sub    $0xc,%esp
+  8010b6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ba:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010be:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010c2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010c6:	85 c0                	test   %eax,%eax
+  8010c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010cc:	89 ea                	mov    %ebp,%edx
+  8010ce:	89 0c 24             	mov    %ecx,(%esp)
+  8010d1:	75 2d                	jne    801100 <__udivdi3+0x50>
+  8010d3:	39 e9                	cmp    %ebp,%ecx
+  8010d5:	77 61                	ja     801138 <__udivdi3+0x88>
+  8010d7:	85 c9                	test   %ecx,%ecx
+  8010d9:	89 ce                	mov    %ecx,%esi
+  8010db:	75 0b                	jne    8010e8 <__udivdi3+0x38>
+  8010dd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010e2:	31 d2                	xor    %edx,%edx
+  8010e4:	f7 f1                	div    %ecx
+  8010e6:	89 c6                	mov    %eax,%esi
+  8010e8:	31 d2                	xor    %edx,%edx
+  8010ea:	89 e8                	mov    %ebp,%eax
+  8010ec:	f7 f6                	div    %esi
+  8010ee:	89 c5                	mov    %eax,%ebp
+  8010f0:	89 f8                	mov    %edi,%eax
+  8010f2:	f7 f6                	div    %esi
+  8010f4:	89 ea                	mov    %ebp,%edx
+  8010f6:	83 c4 0c             	add    $0xc,%esp
+  8010f9:	5e                   	pop    %esi
+  8010fa:	5f                   	pop    %edi
+  8010fb:	5d                   	pop    %ebp
+  8010fc:	c3                   	ret    
+  8010fd:	8d 76 00             	lea    0x0(%esi),%esi
+  801100:	39 e8                	cmp    %ebp,%eax
+  801102:	77 24                	ja     801128 <__udivdi3+0x78>
+  801104:	0f bd e8             	bsr    %eax,%ebp
+  801107:	83 f5 1f             	xor    $0x1f,%ebp
+  80110a:	75 3c                	jne    801148 <__udivdi3+0x98>
+  80110c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801110:	39 34 24             	cmp    %esi,(%esp)
+  801113:	0f 86 9f 00 00 00    	jbe    8011b8 <__udivdi3+0x108>
+  801119:	39 d0                	cmp    %edx,%eax
+  80111b:	0f 82 97 00 00 00    	jb     8011b8 <__udivdi3+0x108>
+  801121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801128:	31 d2                	xor    %edx,%edx
+  80112a:	31 c0                	xor    %eax,%eax
+  80112c:	83 c4 0c             	add    $0xc,%esp
+  80112f:	5e                   	pop    %esi
+  801130:	5f                   	pop    %edi
+  801131:	5d                   	pop    %ebp
+  801132:	c3                   	ret    
+  801133:	90                   	nop
+  801134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801138:	89 f8                	mov    %edi,%eax
+  80113a:	f7 f1                	div    %ecx
+  80113c:	31 d2                	xor    %edx,%edx
+  80113e:	83 c4 0c             	add    $0xc,%esp
+  801141:	5e                   	pop    %esi
+  801142:	5f                   	pop    %edi
+  801143:	5d                   	pop    %ebp
+  801144:	c3                   	ret    
+  801145:	8d 76 00             	lea    0x0(%esi),%esi
+  801148:	89 e9                	mov    %ebp,%ecx
+  80114a:	8b 3c 24             	mov    (%esp),%edi
+  80114d:	d3 e0                	shl    %cl,%eax
+  80114f:	89 c6                	mov    %eax,%esi
+  801151:	b8 20 00 00 00       	mov    $0x20,%eax
+  801156:	29 e8                	sub    %ebp,%eax
+  801158:	89 c1                	mov    %eax,%ecx
+  80115a:	d3 ef                	shr    %cl,%edi
+  80115c:	89 e9                	mov    %ebp,%ecx
+  80115e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801162:	8b 3c 24             	mov    (%esp),%edi
+  801165:	09 74 24 08          	or     %esi,0x8(%esp)
+  801169:	89 d6                	mov    %edx,%esi
+  80116b:	d3 e7                	shl    %cl,%edi
+  80116d:	89 c1                	mov    %eax,%ecx
+  80116f:	89 3c 24             	mov    %edi,(%esp)
+  801172:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801176:	d3 ee                	shr    %cl,%esi
+  801178:	89 e9                	mov    %ebp,%ecx
+  80117a:	d3 e2                	shl    %cl,%edx
+  80117c:	89 c1                	mov    %eax,%ecx
+  80117e:	d3 ef                	shr    %cl,%edi
+  801180:	09 d7                	or     %edx,%edi
+  801182:	89 f2                	mov    %esi,%edx
+  801184:	89 f8                	mov    %edi,%eax
+  801186:	f7 74 24 08          	divl   0x8(%esp)
+  80118a:	89 d6                	mov    %edx,%esi
+  80118c:	89 c7                	mov    %eax,%edi
+  80118e:	f7 24 24             	mull   (%esp)
+  801191:	39 d6                	cmp    %edx,%esi
+  801193:	89 14 24             	mov    %edx,(%esp)
+  801196:	72 30                	jb     8011c8 <__udivdi3+0x118>
+  801198:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80119c:	89 e9                	mov    %ebp,%ecx
+  80119e:	d3 e2                	shl    %cl,%edx
+  8011a0:	39 c2                	cmp    %eax,%edx
+  8011a2:	73 05                	jae    8011a9 <__udivdi3+0xf9>
+  8011a4:	3b 34 24             	cmp    (%esp),%esi
+  8011a7:	74 1f                	je     8011c8 <__udivdi3+0x118>
+  8011a9:	89 f8                	mov    %edi,%eax
+  8011ab:	31 d2                	xor    %edx,%edx
+  8011ad:	e9 7a ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011b8:	31 d2                	xor    %edx,%edx
+  8011ba:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011bf:	e9 68 ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011c8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011cb:	31 d2                	xor    %edx,%edx
+  8011cd:	83 c4 0c             	add    $0xc,%esp
+  8011d0:	5e                   	pop    %esi
+  8011d1:	5f                   	pop    %edi
+  8011d2:	5d                   	pop    %ebp
+  8011d3:	c3                   	ret    
+  8011d4:	66 90                	xchg   %ax,%ax
+  8011d6:	66 90                	xchg   %ax,%ax
+  8011d8:	66 90                	xchg   %ax,%ax
+  8011da:	66 90                	xchg   %ax,%ax
+  8011dc:	66 90                	xchg   %ax,%ax
+  8011de:	66 90                	xchg   %ax,%ax
+
+008011e0 <__umoddi3>:
+  8011e0:	55                   	push   %ebp
+  8011e1:	57                   	push   %edi
+  8011e2:	56                   	push   %esi
+  8011e3:	83 ec 14             	sub    $0x14,%esp
+  8011e6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011ee:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011f2:	89 c7                	mov    %eax,%edi
+  8011f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011f8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011fc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801200:	89 34 24             	mov    %esi,(%esp)
+  801203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801207:	85 c0                	test   %eax,%eax
+  801209:	89 c2                	mov    %eax,%edx
+  80120b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80120f:	75 17                	jne    801228 <__umoddi3+0x48>
+  801211:	39 fe                	cmp    %edi,%esi
+  801213:	76 4b                	jbe    801260 <__umoddi3+0x80>
+  801215:	89 c8                	mov    %ecx,%eax
+  801217:	89 fa                	mov    %edi,%edx
+  801219:	f7 f6                	div    %esi
+  80121b:	89 d0                	mov    %edx,%eax
+  80121d:	31 d2                	xor    %edx,%edx
+  80121f:	83 c4 14             	add    $0x14,%esp
+  801222:	5e                   	pop    %esi
+  801223:	5f                   	pop    %edi
+  801224:	5d                   	pop    %ebp
+  801225:	c3                   	ret    
+  801226:	66 90                	xchg   %ax,%ax
+  801228:	39 f8                	cmp    %edi,%eax
+  80122a:	77 54                	ja     801280 <__umoddi3+0xa0>
+  80122c:	0f bd e8             	bsr    %eax,%ebp
+  80122f:	83 f5 1f             	xor    $0x1f,%ebp
+  801232:	75 5c                	jne    801290 <__umoddi3+0xb0>
+  801234:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801238:	39 3c 24             	cmp    %edi,(%esp)
+  80123b:	0f 87 e7 00 00 00    	ja     801328 <__umoddi3+0x148>
+  801241:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801245:	29 f1                	sub    %esi,%ecx
+  801247:	19 c7                	sbb    %eax,%edi
+  801249:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80124d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801251:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801255:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801259:	83 c4 14             	add    $0x14,%esp
+  80125c:	5e                   	pop    %esi
+  80125d:	5f                   	pop    %edi
+  80125e:	5d                   	pop    %ebp
+  80125f:	c3                   	ret    
+  801260:	85 f6                	test   %esi,%esi
+  801262:	89 f5                	mov    %esi,%ebp
+  801264:	75 0b                	jne    801271 <__umoddi3+0x91>
+  801266:	b8 01 00 00 00       	mov    $0x1,%eax
+  80126b:	31 d2                	xor    %edx,%edx
+  80126d:	f7 f6                	div    %esi
+  80126f:	89 c5                	mov    %eax,%ebp
+  801271:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801275:	31 d2                	xor    %edx,%edx
+  801277:	f7 f5                	div    %ebp
+  801279:	89 c8                	mov    %ecx,%eax
+  80127b:	f7 f5                	div    %ebp
+  80127d:	eb 9c                	jmp    80121b <__umoddi3+0x3b>
+  80127f:	90                   	nop
+  801280:	89 c8                	mov    %ecx,%eax
+  801282:	89 fa                	mov    %edi,%edx
+  801284:	83 c4 14             	add    $0x14,%esp
+  801287:	5e                   	pop    %esi
+  801288:	5f                   	pop    %edi
+  801289:	5d                   	pop    %ebp
+  80128a:	c3                   	ret    
+  80128b:	90                   	nop
+  80128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801290:	8b 04 24             	mov    (%esp),%eax
+  801293:	be 20 00 00 00       	mov    $0x20,%esi
+  801298:	89 e9                	mov    %ebp,%ecx
+  80129a:	29 ee                	sub    %ebp,%esi
+  80129c:	d3 e2                	shl    %cl,%edx
+  80129e:	89 f1                	mov    %esi,%ecx
+  8012a0:	d3 e8                	shr    %cl,%eax
+  8012a2:	89 e9                	mov    %ebp,%ecx
+  8012a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012a8:	8b 04 24             	mov    (%esp),%eax
+  8012ab:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012af:	89 fa                	mov    %edi,%edx
+  8012b1:	d3 e0                	shl    %cl,%eax
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012b9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012bd:	d3 ea                	shr    %cl,%edx
+  8012bf:	89 e9                	mov    %ebp,%ecx
+  8012c1:	d3 e7                	shl    %cl,%edi
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	d3 e8                	shr    %cl,%eax
+  8012c7:	89 e9                	mov    %ebp,%ecx
+  8012c9:	09 f8                	or     %edi,%eax
+  8012cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012cf:	f7 74 24 04          	divl   0x4(%esp)
+  8012d3:	d3 e7                	shl    %cl,%edi
+  8012d5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012d9:	89 d7                	mov    %edx,%edi
+  8012db:	f7 64 24 08          	mull   0x8(%esp)
+  8012df:	39 d7                	cmp    %edx,%edi
+  8012e1:	89 c1                	mov    %eax,%ecx
+  8012e3:	89 14 24             	mov    %edx,(%esp)
+  8012e6:	72 2c                	jb     801314 <__umoddi3+0x134>
+  8012e8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012ec:	72 22                	jb     801310 <__umoddi3+0x130>
+  8012ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012f2:	29 c8                	sub    %ecx,%eax
+  8012f4:	19 d7                	sbb    %edx,%edi
+  8012f6:	89 e9                	mov    %ebp,%ecx
+  8012f8:	89 fa                	mov    %edi,%edx
+  8012fa:	d3 e8                	shr    %cl,%eax
+  8012fc:	89 f1                	mov    %esi,%ecx
+  8012fe:	d3 e2                	shl    %cl,%edx
+  801300:	89 e9                	mov    %ebp,%ecx
+  801302:	d3 ef                	shr    %cl,%edi
+  801304:	09 d0                	or     %edx,%eax
+  801306:	89 fa                	mov    %edi,%edx
+  801308:	83 c4 14             	add    $0x14,%esp
+  80130b:	5e                   	pop    %esi
+  80130c:	5f                   	pop    %edi
+  80130d:	5d                   	pop    %ebp
+  80130e:	c3                   	ret    
+  80130f:	90                   	nop
+  801310:	39 d7                	cmp    %edx,%edi
+  801312:	75 da                	jne    8012ee <__umoddi3+0x10e>
+  801314:	8b 14 24             	mov    (%esp),%edx
+  801317:	89 c1                	mov    %eax,%ecx
+  801319:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80131d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801321:	eb cb                	jmp    8012ee <__umoddi3+0x10e>
+  801323:	90                   	nop
+  801324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801328:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80132c:	0f 82 0f ff ff ff    	jb     801241 <__umoddi3+0x61>
+  801332:	e9 1a ff ff ff       	jmp    801251 <__umoddi3+0x71>
diff --git a/obj/user/faultread.o b/obj/user/faultread.o
new file mode 100644
index 0000000..1f01480
Binary files /dev/null and b/obj/user/faultread.o differ
diff --git a/obj/user/faultread.sym b/obj/user/faultread.sym
new file mode 100644
index 0000000..03051c3
--- /dev/null
+++ b/obj/user/faultread.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040cf R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+00800052 T libmain
+008000a0 T exit
+008000b4 t putch
+00800110 T vcprintf
+00800174 T cprintf
+0080019a t printnum
+00800278 t getuint
+008002c7 t getint
+0080030e T vprintfmt
+00800855 T printfmt
+00800883 t sprintputch
+008008b8 T vsnprintf
+00800918 T snprintf
+0080094c T strlen
+00800972 T strnlen
+008009a2 T strcpy
+008009d2 T strcat
+00800a02 T strncpy
+00800a47 T strlcpy
+00800a98 T strcmp
+00800ad7 T strncmp
+00800b2d T strchr
+00800b60 T strfind
+00800b8e T memset
+00800bfc T memmove
+00800cd6 T memcpy
+00800cf7 T memcmp
+00800d4f T memfind
+00800d82 T strtol
+00800ee0 t syscall
+00800f41 T sys_cputs
+00800f83 T sys_cgetc
+00800fc7 T sys_env_destroy
+0080100a T sys_getenvid
+0080104e T _panic
+008010b0 T __udivdi3
+008011e0 T __umoddi3
+008013cc r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/faultreadkernel b/obj/user/faultreadkernel
new file mode 100755
index 0000000..f90629b
Binary files /dev/null and b/obj/user/faultreadkernel differ
diff --git a/obj/user/faultreadkernel.asm b/obj/user/faultreadkernel.asm
new file mode 100644
index 0000000..b6b18e5
--- /dev/null
+++ b/obj/user/faultreadkernel.asm
@@ -0,0 +1,2628 @@
+
+obj/user/faultreadkernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 21 00 00 00       	call   800052 <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	cprintf("I read %08x from location 0xf0100000!\n", *(unsigned*)0xf0100000);
+  800039:	b8 00 00 10 f0       	mov    $0xf0100000,%eax
+  80003e:	8b 00                	mov    (%eax),%eax
+  800040:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800044:	c7 04 24 38 13 80 00 	movl   $0x801338,(%esp)
+  80004b:	e8 24 01 00 00       	call   800174 <cprintf>
+}
+  800050:	c9                   	leave  
+  800051:	c3                   	ret    
+
+00800052 <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  800052:	55                   	push   %ebp
+  800053:	89 e5                	mov    %esp,%ebp
+  800055:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800058:	e8 ad 0f 00 00       	call   80100a <sys_getenvid>
+  80005d:	25 ff 03 00 00       	and    $0x3ff,%eax
+  800062:	89 c2                	mov    %eax,%edx
+  800064:	89 d0                	mov    %edx,%eax
+  800066:	01 c0                	add    %eax,%eax
+  800068:	01 d0                	add    %edx,%eax
+  80006a:	c1 e0 05             	shl    $0x5,%eax
+  80006d:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  800072:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800077:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  80007b:	7e 0a                	jle    800087 <libmain+0x35>
+		binaryname = argv[0];
+  80007d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800080:	8b 00                	mov    (%eax),%eax
+  800082:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800087:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80008a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80008e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800091:	89 04 24             	mov    %eax,(%esp)
+  800094:	e8 9a ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800099:	e8 02 00 00 00       	call   8000a0 <exit>
+}
+  80009e:	c9                   	leave  
+  80009f:	c3                   	ret    
+
+008000a0 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  8000a0:	55                   	push   %ebp
+  8000a1:	89 e5                	mov    %esp,%ebp
+  8000a3:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000a6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000ad:	e8 15 0f 00 00       	call   800fc7 <sys_env_destroy>
+}
+  8000b2:	c9                   	leave  
+  8000b3:	c3                   	ret    
+
+008000b4 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  8000b4:	55                   	push   %ebp
+  8000b5:	89 e5                	mov    %esp,%ebp
+  8000b7:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  8000ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000bd:	8b 00                	mov    (%eax),%eax
+  8000bf:	8d 48 01             	lea    0x1(%eax),%ecx
+  8000c2:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000c5:	89 0a                	mov    %ecx,(%edx)
+  8000c7:	8b 55 08             	mov    0x8(%ebp),%edx
+  8000ca:	89 d1                	mov    %edx,%ecx
+  8000cc:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000cf:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  8000d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000d6:	8b 00                	mov    (%eax),%eax
+  8000d8:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8000dd:	75 20                	jne    8000ff <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8000df:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000e2:	8b 00                	mov    (%eax),%eax
+  8000e4:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000e7:	83 c2 08             	add    $0x8,%edx
+  8000ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8000ee:	89 14 24             	mov    %edx,(%esp)
+  8000f1:	e8 4b 0e 00 00       	call   800f41 <sys_cputs>
+		b->idx = 0;
+  8000f6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000f9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8000ff:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800102:	8b 40 04             	mov    0x4(%eax),%eax
+  800105:	8d 50 01             	lea    0x1(%eax),%edx
+  800108:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80010b:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  80010e:	c9                   	leave  
+  80010f:	c3                   	ret    
+
+00800110 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  800110:	55                   	push   %ebp
+  800111:	89 e5                	mov    %esp,%ebp
+  800113:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  800119:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  800120:	00 00 00 
+	b.cnt = 0;
+  800123:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  80012a:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  80012d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800130:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800134:	8b 45 08             	mov    0x8(%ebp),%eax
+  800137:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80013b:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800141:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800145:	c7 04 24 b4 00 80 00 	movl   $0x8000b4,(%esp)
+  80014c:	e8 bd 01 00 00       	call   80030e <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800151:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800157:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80015b:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800161:	83 c0 08             	add    $0x8,%eax
+  800164:	89 04 24             	mov    %eax,(%esp)
+  800167:	e8 d5 0d 00 00       	call   800f41 <sys_cputs>
+
+	return b.cnt;
+  80016c:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800172:	c9                   	leave  
+  800173:	c3                   	ret    
+
+00800174 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800174:	55                   	push   %ebp
+  800175:	89 e5                	mov    %esp,%ebp
+  800177:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  80017a:	8d 45 0c             	lea    0xc(%ebp),%eax
+  80017d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800180:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800183:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800187:	8b 45 08             	mov    0x8(%ebp),%eax
+  80018a:	89 04 24             	mov    %eax,(%esp)
+  80018d:	e8 7e ff ff ff       	call   800110 <vcprintf>
+  800192:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  800195:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800198:	c9                   	leave  
+  800199:	c3                   	ret    
+
+0080019a <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  80019a:	55                   	push   %ebp
+  80019b:	89 e5                	mov    %esp,%ebp
+  80019d:	53                   	push   %ebx
+  80019e:	83 ec 34             	sub    $0x34,%esp
+  8001a1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8001a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8001a7:	8b 45 14             	mov    0x14(%ebp),%eax
+  8001aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  8001ad:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001b0:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001b5:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001b8:	77 72                	ja     80022c <printnum+0x92>
+  8001ba:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001bd:	72 05                	jb     8001c4 <printnum+0x2a>
+  8001bf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  8001c2:	77 68                	ja     80022c <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  8001c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8001c7:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  8001ca:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001cd:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001d2:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001d6:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8001da:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8001dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8001e0:	89 04 24             	mov    %eax,(%esp)
+  8001e3:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8001e7:	e8 c4 0e 00 00       	call   8010b0 <__udivdi3>
+  8001ec:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8001ef:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8001f3:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8001f7:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8001fa:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8001fe:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800202:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800206:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800209:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80020d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800210:	89 04 24             	mov    %eax,(%esp)
+  800213:	e8 82 ff ff ff       	call   80019a <printnum>
+  800218:	eb 1c                	jmp    800236 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  80021a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80021d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800221:	8b 45 20             	mov    0x20(%ebp),%eax
+  800224:	89 04 24             	mov    %eax,(%esp)
+  800227:	8b 45 08             	mov    0x8(%ebp),%eax
+  80022a:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  80022c:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  800230:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  800234:	7f e4                	jg     80021a <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  800236:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  800239:	bb 00 00 00 00       	mov    $0x0,%ebx
+  80023e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800241:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800244:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  800248:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  80024c:	89 04 24             	mov    %eax,(%esp)
+  80024f:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800253:	e8 88 0f 00 00       	call   8011e0 <__umoddi3>
+  800258:	05 f4 13 80 00       	add    $0x8013f4,%eax
+  80025d:	0f b6 00             	movzbl (%eax),%eax
+  800260:	0f be c0             	movsbl %al,%eax
+  800263:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800266:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80026a:	89 04 24             	mov    %eax,(%esp)
+  80026d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800270:	ff d0                	call   *%eax
+}
+  800272:	83 c4 34             	add    $0x34,%esp
+  800275:	5b                   	pop    %ebx
+  800276:	5d                   	pop    %ebp
+  800277:	c3                   	ret    
+
+00800278 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800278:	55                   	push   %ebp
+  800279:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80027b:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80027f:	7e 14                	jle    800295 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800281:	8b 45 08             	mov    0x8(%ebp),%eax
+  800284:	8b 00                	mov    (%eax),%eax
+  800286:	8d 48 08             	lea    0x8(%eax),%ecx
+  800289:	8b 55 08             	mov    0x8(%ebp),%edx
+  80028c:	89 0a                	mov    %ecx,(%edx)
+  80028e:	8b 50 04             	mov    0x4(%eax),%edx
+  800291:	8b 00                	mov    (%eax),%eax
+  800293:	eb 30                	jmp    8002c5 <getuint+0x4d>
+	else if (lflag)
+  800295:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800299:	74 16                	je     8002b1 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  80029b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80029e:	8b 00                	mov    (%eax),%eax
+  8002a0:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002a3:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002a6:	89 0a                	mov    %ecx,(%edx)
+  8002a8:	8b 00                	mov    (%eax),%eax
+  8002aa:	ba 00 00 00 00       	mov    $0x0,%edx
+  8002af:	eb 14                	jmp    8002c5 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  8002b1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002b4:	8b 00                	mov    (%eax),%eax
+  8002b6:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002b9:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002bc:	89 0a                	mov    %ecx,(%edx)
+  8002be:	8b 00                	mov    (%eax),%eax
+  8002c0:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  8002c5:	5d                   	pop    %ebp
+  8002c6:	c3                   	ret    
+
+008002c7 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  8002c7:	55                   	push   %ebp
+  8002c8:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  8002ca:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  8002ce:	7e 14                	jle    8002e4 <getint+0x1d>
+		return va_arg(*ap, long long);
+  8002d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002d3:	8b 00                	mov    (%eax),%eax
+  8002d5:	8d 48 08             	lea    0x8(%eax),%ecx
+  8002d8:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002db:	89 0a                	mov    %ecx,(%edx)
+  8002dd:	8b 50 04             	mov    0x4(%eax),%edx
+  8002e0:	8b 00                	mov    (%eax),%eax
+  8002e2:	eb 28                	jmp    80030c <getint+0x45>
+	else if (lflag)
+  8002e4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8002e8:	74 12                	je     8002fc <getint+0x35>
+		return va_arg(*ap, long);
+  8002ea:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002ed:	8b 00                	mov    (%eax),%eax
+  8002ef:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002f2:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002f5:	89 0a                	mov    %ecx,(%edx)
+  8002f7:	8b 00                	mov    (%eax),%eax
+  8002f9:	99                   	cltd   
+  8002fa:	eb 10                	jmp    80030c <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8002fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002ff:	8b 00                	mov    (%eax),%eax
+  800301:	8d 48 04             	lea    0x4(%eax),%ecx
+  800304:	8b 55 08             	mov    0x8(%ebp),%edx
+  800307:	89 0a                	mov    %ecx,(%edx)
+  800309:	8b 00                	mov    (%eax),%eax
+  80030b:	99                   	cltd   
+}
+  80030c:	5d                   	pop    %ebp
+  80030d:	c3                   	ret    
+
+0080030e <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  80030e:	55                   	push   %ebp
+  80030f:	89 e5                	mov    %esp,%ebp
+  800311:	56                   	push   %esi
+  800312:	53                   	push   %ebx
+  800313:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800316:	e9 72 01 00 00       	jmp    80048d <vprintfmt+0x17f>
+			if (ch == '\0')
+  80031b:	85 db                	test   %ebx,%ebx
+  80031d:	75 05                	jne    800324 <vprintfmt+0x16>
+				return;
+  80031f:	e9 2a 05 00 00       	jmp    80084e <vprintfmt+0x540>
+			else if(ch == '\033'){
+  800324:	83 fb 1b             	cmp    $0x1b,%ebx
+  800327:	0f 85 51 01 00 00    	jne    80047e <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  80032d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800330:	8d 50 01             	lea    0x1(%eax),%edx
+  800333:	89 55 10             	mov    %edx,0x10(%ebp)
+  800336:	0f b6 00             	movzbl (%eax),%eax
+  800339:	0f b6 d8             	movzbl %al,%ebx
+  80033c:	83 fb 5b             	cmp    $0x5b,%ebx
+  80033f:	74 14                	je     800355 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800341:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800348:	89 1c 24             	mov    %ebx,(%esp)
+  80034b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80034e:	ff d0                	call   *%eax
+				    continue;
+  800350:	e9 38 01 00 00       	jmp    80048d <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800355:	8b 45 10             	mov    0x10(%ebp),%eax
+  800358:	8d 50 01             	lea    0x1(%eax),%edx
+  80035b:	89 55 10             	mov    %edx,0x10(%ebp)
+  80035e:	0f b6 00             	movzbl (%eax),%eax
+  800361:	0f b6 c0             	movzbl %al,%eax
+  800364:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  800369:	8b 45 10             	mov    0x10(%ebp),%eax
+  80036c:	8d 50 01             	lea    0x1(%eax),%edx
+  80036f:	89 55 10             	mov    %edx,0x10(%ebp)
+  800372:	0f b6 00             	movzbl (%eax),%eax
+  800375:	0f b6 c0             	movzbl %al,%eax
+  800378:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  80037d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800382:	83 f8 2f             	cmp    $0x2f,%eax
+  800385:	7e 19                	jle    8003a0 <vprintfmt+0x92>
+  800387:	a1 08 20 80 00       	mov    0x802008,%eax
+  80038c:	83 f8 39             	cmp    $0x39,%eax
+  80038f:	7f 0f                	jg     8003a0 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800391:	a1 08 20 80 00       	mov    0x802008,%eax
+  800396:	83 e8 30             	sub    $0x30,%eax
+  800399:	a3 08 20 80 00       	mov    %eax,0x802008
+  80039e:	eb 50                	jmp    8003f0 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  8003a0:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003a5:	83 f8 60             	cmp    $0x60,%eax
+  8003a8:	7e 19                	jle    8003c3 <vprintfmt+0xb5>
+  8003aa:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003af:	83 f8 66             	cmp    $0x66,%eax
+  8003b2:	7f 0f                	jg     8003c3 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  8003b4:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003b9:	83 e8 57             	sub    $0x57,%eax
+  8003bc:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003c1:	eb 2d                	jmp    8003f0 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  8003c3:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003c8:	83 f8 40             	cmp    $0x40,%eax
+  8003cb:	7e 19                	jle    8003e6 <vprintfmt+0xd8>
+  8003cd:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003d2:	83 f8 46             	cmp    $0x46,%eax
+  8003d5:	7f 0f                	jg     8003e6 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  8003d7:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003dc:	83 e8 37             	sub    $0x37,%eax
+  8003df:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003e4:	eb 0a                	jmp    8003f0 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8003e6:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8003ed:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8003f0:	a1 10 20 80 00       	mov    0x802010,%eax
+  8003f5:	83 f8 2f             	cmp    $0x2f,%eax
+  8003f8:	7e 19                	jle    800413 <vprintfmt+0x105>
+  8003fa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8003ff:	83 f8 39             	cmp    $0x39,%eax
+  800402:	7f 0f                	jg     800413 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  800404:	a1 10 20 80 00       	mov    0x802010,%eax
+  800409:	83 e8 30             	sub    $0x30,%eax
+  80040c:	a3 10 20 80 00       	mov    %eax,0x802010
+  800411:	eb 50                	jmp    800463 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  800413:	a1 10 20 80 00       	mov    0x802010,%eax
+  800418:	83 f8 60             	cmp    $0x60,%eax
+  80041b:	7e 19                	jle    800436 <vprintfmt+0x128>
+  80041d:	a1 10 20 80 00       	mov    0x802010,%eax
+  800422:	83 f8 66             	cmp    $0x66,%eax
+  800425:	7f 0f                	jg     800436 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  800427:	a1 10 20 80 00       	mov    0x802010,%eax
+  80042c:	83 e8 57             	sub    $0x57,%eax
+  80042f:	a3 10 20 80 00       	mov    %eax,0x802010
+  800434:	eb 2d                	jmp    800463 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  800436:	a1 10 20 80 00       	mov    0x802010,%eax
+  80043b:	83 f8 40             	cmp    $0x40,%eax
+  80043e:	7e 19                	jle    800459 <vprintfmt+0x14b>
+  800440:	a1 10 20 80 00       	mov    0x802010,%eax
+  800445:	83 f8 46             	cmp    $0x46,%eax
+  800448:	7f 0f                	jg     800459 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  80044a:	a1 10 20 80 00       	mov    0x802010,%eax
+  80044f:	83 e8 37             	sub    $0x37,%eax
+  800452:	a3 10 20 80 00       	mov    %eax,0x802010
+  800457:	eb 0a                	jmp    800463 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  800459:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800460:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800463:	a1 08 20 80 00       	mov    0x802008,%eax
+  800468:	c1 e0 0c             	shl    $0xc,%eax
+  80046b:	89 c2                	mov    %eax,%edx
+  80046d:	a1 10 20 80 00       	mov    0x802010,%eax
+  800472:	c1 e0 08             	shl    $0x8,%eax
+  800475:	09 d0                	or     %edx,%eax
+  800477:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  80047c:	eb 0f                	jmp    80048d <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  80047e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800481:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800485:	89 1c 24             	mov    %ebx,(%esp)
+  800488:	8b 45 08             	mov    0x8(%ebp),%eax
+  80048b:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80048d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800490:	8d 50 01             	lea    0x1(%eax),%edx
+  800493:	89 55 10             	mov    %edx,0x10(%ebp)
+  800496:	0f b6 00             	movzbl (%eax),%eax
+  800499:	0f b6 d8             	movzbl %al,%ebx
+  80049c:	83 fb 25             	cmp    $0x25,%ebx
+  80049f:	0f 85 76 fe ff ff    	jne    80031b <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  8004a5:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  8004a9:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  8004b0:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  8004b7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  8004be:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  8004c5:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004c8:	8d 50 01             	lea    0x1(%eax),%edx
+  8004cb:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004ce:	0f b6 00             	movzbl (%eax),%eax
+  8004d1:	0f b6 d8             	movzbl %al,%ebx
+  8004d4:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  8004d7:	83 f8 55             	cmp    $0x55,%eax
+  8004da:	0f 87 3d 03 00 00    	ja     80081d <vprintfmt+0x50f>
+  8004e0:	8b 04 85 18 14 80 00 	mov    0x801418(,%eax,4),%eax
+  8004e7:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8004e9:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8004ed:	eb d6                	jmp    8004c5 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8004ef:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8004f3:	eb d0                	jmp    8004c5 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8004f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8004fc:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8004ff:	89 d0                	mov    %edx,%eax
+  800501:	c1 e0 02             	shl    $0x2,%eax
+  800504:	01 d0                	add    %edx,%eax
+  800506:	01 c0                	add    %eax,%eax
+  800508:	01 d8                	add    %ebx,%eax
+  80050a:	83 e8 30             	sub    $0x30,%eax
+  80050d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  800510:	8b 45 10             	mov    0x10(%ebp),%eax
+  800513:	0f b6 00             	movzbl (%eax),%eax
+  800516:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  800519:	83 fb 2f             	cmp    $0x2f,%ebx
+  80051c:	7e 0b                	jle    800529 <vprintfmt+0x21b>
+  80051e:	83 fb 39             	cmp    $0x39,%ebx
+  800521:	7f 06                	jg     800529 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800523:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  800527:	eb d3                	jmp    8004fc <vprintfmt+0x1ee>
+			goto process_precision;
+  800529:	eb 33                	jmp    80055e <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  80052b:	8b 45 14             	mov    0x14(%ebp),%eax
+  80052e:	8d 50 04             	lea    0x4(%eax),%edx
+  800531:	89 55 14             	mov    %edx,0x14(%ebp)
+  800534:	8b 00                	mov    (%eax),%eax
+  800536:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  800539:	eb 23                	jmp    80055e <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  80053b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80053f:	79 0c                	jns    80054d <vprintfmt+0x23f>
+				width = 0;
+  800541:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  800548:	e9 78 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+  80054d:	e9 73 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800552:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  800559:	e9 67 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  80055e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800562:	79 12                	jns    800576 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800564:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800567:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80056a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800571:	e9 4f ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+  800576:	e9 4a ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  80057b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  80057f:	e9 41 ff ff ff       	jmp    8004c5 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800584:	8b 45 14             	mov    0x14(%ebp),%eax
+  800587:	8d 50 04             	lea    0x4(%eax),%edx
+  80058a:	89 55 14             	mov    %edx,0x14(%ebp)
+  80058d:	8b 00                	mov    (%eax),%eax
+  80058f:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800592:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800596:	89 04 24             	mov    %eax,(%esp)
+  800599:	8b 45 08             	mov    0x8(%ebp),%eax
+  80059c:	ff d0                	call   *%eax
+			break;
+  80059e:	e9 a5 02 00 00       	jmp    800848 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  8005a3:	8b 45 14             	mov    0x14(%ebp),%eax
+  8005a6:	8d 50 04             	lea    0x4(%eax),%edx
+  8005a9:	89 55 14             	mov    %edx,0x14(%ebp)
+  8005ac:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  8005ae:	85 db                	test   %ebx,%ebx
+  8005b0:	79 02                	jns    8005b4 <vprintfmt+0x2a6>
+				err = -err;
+  8005b2:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  8005b4:	83 fb 06             	cmp    $0x6,%ebx
+  8005b7:	7f 0b                	jg     8005c4 <vprintfmt+0x2b6>
+  8005b9:	8b 34 9d d8 13 80 00 	mov    0x8013d8(,%ebx,4),%esi
+  8005c0:	85 f6                	test   %esi,%esi
+  8005c2:	75 23                	jne    8005e7 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  8005c4:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  8005c8:	c7 44 24 08 05 14 80 	movl   $0x801405,0x8(%esp)
+  8005cf:	00 
+  8005d0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005d3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005d7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005da:	89 04 24             	mov    %eax,(%esp)
+  8005dd:	e8 73 02 00 00       	call   800855 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8005e2:	e9 61 02 00 00       	jmp    800848 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8005e7:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8005eb:	c7 44 24 08 0e 14 80 	movl   $0x80140e,0x8(%esp)
+  8005f2:	00 
+  8005f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005f6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005fa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005fd:	89 04 24             	mov    %eax,(%esp)
+  800600:	e8 50 02 00 00       	call   800855 <printfmt>
+			break;
+  800605:	e9 3e 02 00 00       	jmp    800848 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  80060a:	8b 45 14             	mov    0x14(%ebp),%eax
+  80060d:	8d 50 04             	lea    0x4(%eax),%edx
+  800610:	89 55 14             	mov    %edx,0x14(%ebp)
+  800613:	8b 30                	mov    (%eax),%esi
+  800615:	85 f6                	test   %esi,%esi
+  800617:	75 05                	jne    80061e <vprintfmt+0x310>
+				p = "(null)";
+  800619:	be 11 14 80 00       	mov    $0x801411,%esi
+			if (width > 0 && padc != '-')
+  80061e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800622:	7e 37                	jle    80065b <vprintfmt+0x34d>
+  800624:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800628:	74 31                	je     80065b <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80062a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80062d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800631:	89 34 24             	mov    %esi,(%esp)
+  800634:	e8 39 03 00 00       	call   800972 <strnlen>
+  800639:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  80063c:	eb 17                	jmp    800655 <vprintfmt+0x347>
+					putch(padc, putdat);
+  80063e:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800642:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800645:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800649:	89 04 24             	mov    %eax,(%esp)
+  80064c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80064f:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800651:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800655:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800659:	7f e3                	jg     80063e <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80065b:	eb 38                	jmp    800695 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  80065d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800661:	74 1f                	je     800682 <vprintfmt+0x374>
+  800663:	83 fb 1f             	cmp    $0x1f,%ebx
+  800666:	7e 05                	jle    80066d <vprintfmt+0x35f>
+  800668:	83 fb 7e             	cmp    $0x7e,%ebx
+  80066b:	7e 15                	jle    800682 <vprintfmt+0x374>
+					putch('?', putdat);
+  80066d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800670:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800674:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  80067b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80067e:	ff d0                	call   *%eax
+  800680:	eb 0f                	jmp    800691 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800682:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800685:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800689:	89 1c 24             	mov    %ebx,(%esp)
+  80068c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80068f:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800691:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800695:	89 f0                	mov    %esi,%eax
+  800697:	8d 70 01             	lea    0x1(%eax),%esi
+  80069a:	0f b6 00             	movzbl (%eax),%eax
+  80069d:	0f be d8             	movsbl %al,%ebx
+  8006a0:	85 db                	test   %ebx,%ebx
+  8006a2:	74 10                	je     8006b4 <vprintfmt+0x3a6>
+  8006a4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006a8:	78 b3                	js     80065d <vprintfmt+0x34f>
+  8006aa:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  8006ae:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006b2:	79 a9                	jns    80065d <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006b4:	eb 17                	jmp    8006cd <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  8006b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006b9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006bd:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  8006c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006c7:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006c9:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8006cd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006d1:	7f e3                	jg     8006b6 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  8006d3:	e9 70 01 00 00       	jmp    800848 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  8006d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8006db:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006df:	8d 45 14             	lea    0x14(%ebp),%eax
+  8006e2:	89 04 24             	mov    %eax,(%esp)
+  8006e5:	e8 dd fb ff ff       	call   8002c7 <getint>
+  8006ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006ed:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8006f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8006f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8006f6:	85 d2                	test   %edx,%edx
+  8006f8:	79 26                	jns    800720 <vprintfmt+0x412>
+				putch('-', putdat);
+  8006fa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006fd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800701:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  800708:	8b 45 08             	mov    0x8(%ebp),%eax
+  80070b:	ff d0                	call   *%eax
+				num = -(long long) num;
+  80070d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800710:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800713:	f7 d8                	neg    %eax
+  800715:	83 d2 00             	adc    $0x0,%edx
+  800718:	f7 da                	neg    %edx
+  80071a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80071d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  800720:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800727:	e9 a8 00 00 00       	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  80072c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80072f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800733:	8d 45 14             	lea    0x14(%ebp),%eax
+  800736:	89 04 24             	mov    %eax,(%esp)
+  800739:	e8 3a fb ff ff       	call   800278 <getuint>
+  80073e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800741:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  800744:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  80074b:	e9 84 00 00 00       	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800750:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800753:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800757:	8d 45 14             	lea    0x14(%ebp),%eax
+  80075a:	89 04 24             	mov    %eax,(%esp)
+  80075d:	e8 16 fb ff ff       	call   800278 <getuint>
+  800762:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800765:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800768:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  80076f:	eb 63                	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800771:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800774:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800778:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  80077f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800782:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800784:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800787:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80078b:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800792:	8b 45 08             	mov    0x8(%ebp),%eax
+  800795:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  800797:	8b 45 14             	mov    0x14(%ebp),%eax
+  80079a:	8d 50 04             	lea    0x4(%eax),%edx
+  80079d:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007a0:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  8007a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  8007ac:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  8007b3:	eb 1f                	jmp    8007d4 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  8007b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8007b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007bc:	8d 45 14             	lea    0x14(%ebp),%eax
+  8007bf:	89 04 24             	mov    %eax,(%esp)
+  8007c2:	e8 b1 fa ff ff       	call   800278 <getuint>
+  8007c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  8007cd:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  8007d4:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  8007d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8007db:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8007df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8007e2:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8007e6:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8007ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8007f0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8007f4:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8007f8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007ff:	8b 45 08             	mov    0x8(%ebp),%eax
+  800802:	89 04 24             	mov    %eax,(%esp)
+  800805:	e8 90 f9 ff ff       	call   80019a <printnum>
+			break;
+  80080a:	eb 3c                	jmp    800848 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  80080c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80080f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800813:	89 1c 24             	mov    %ebx,(%esp)
+  800816:	8b 45 08             	mov    0x8(%ebp),%eax
+  800819:	ff d0                	call   *%eax
+			break;			
+  80081b:	eb 2b                	jmp    800848 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  80081d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800820:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800824:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  80082b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80082e:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  800830:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800834:	eb 04                	jmp    80083a <vprintfmt+0x52c>
+  800836:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80083a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80083d:	83 e8 01             	sub    $0x1,%eax
+  800840:	0f b6 00             	movzbl (%eax),%eax
+  800843:	3c 25                	cmp    $0x25,%al
+  800845:	75 ef                	jne    800836 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800847:	90                   	nop
+		}
+	}
+  800848:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800849:	e9 3f fc ff ff       	jmp    80048d <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  80084e:	83 c4 40             	add    $0x40,%esp
+  800851:	5b                   	pop    %ebx
+  800852:	5e                   	pop    %esi
+  800853:	5d                   	pop    %ebp
+  800854:	c3                   	ret    
+
+00800855 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800855:	55                   	push   %ebp
+  800856:	89 e5                	mov    %esp,%ebp
+  800858:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  80085b:	8d 45 14             	lea    0x14(%ebp),%eax
+  80085e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800861:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800864:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800868:	8b 45 10             	mov    0x10(%ebp),%eax
+  80086b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80086f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800872:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800876:	8b 45 08             	mov    0x8(%ebp),%eax
+  800879:	89 04 24             	mov    %eax,(%esp)
+  80087c:	e8 8d fa ff ff       	call   80030e <vprintfmt>
+	va_end(ap);
+}
+  800881:	c9                   	leave  
+  800882:	c3                   	ret    
+
+00800883 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800883:	55                   	push   %ebp
+  800884:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800886:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800889:	8b 40 08             	mov    0x8(%eax),%eax
+  80088c:	8d 50 01             	lea    0x1(%eax),%edx
+  80088f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800892:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800895:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800898:	8b 10                	mov    (%eax),%edx
+  80089a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80089d:	8b 40 04             	mov    0x4(%eax),%eax
+  8008a0:	39 c2                	cmp    %eax,%edx
+  8008a2:	73 12                	jae    8008b6 <sprintputch+0x33>
+		*b->buf++ = ch;
+  8008a4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008a7:	8b 00                	mov    (%eax),%eax
+  8008a9:	8d 48 01             	lea    0x1(%eax),%ecx
+  8008ac:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8008af:	89 0a                	mov    %ecx,(%edx)
+  8008b1:	8b 55 08             	mov    0x8(%ebp),%edx
+  8008b4:	88 10                	mov    %dl,(%eax)
+}
+  8008b6:	5d                   	pop    %ebp
+  8008b7:	c3                   	ret    
+
+008008b8 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  8008b8:	55                   	push   %ebp
+  8008b9:	89 e5                	mov    %esp,%ebp
+  8008bb:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  8008be:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8008c4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008c7:	8d 50 ff             	lea    -0x1(%eax),%edx
+  8008ca:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008cd:	01 d0                	add    %edx,%eax
+  8008cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  8008d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  8008dd:	74 06                	je     8008e5 <vsnprintf+0x2d>
+  8008df:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8008e3:	7f 07                	jg     8008ec <vsnprintf+0x34>
+		return -E_INVAL;
+  8008e5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  8008ea:	eb 2a                	jmp    800916 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  8008ec:	8b 45 14             	mov    0x14(%ebp),%eax
+  8008ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8008f3:	8b 45 10             	mov    0x10(%ebp),%eax
+  8008f6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8008fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  8008fd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800901:	c7 04 24 83 08 80 00 	movl   $0x800883,(%esp)
+  800908:	e8 01 fa ff ff       	call   80030e <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  80090d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800910:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800913:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800916:	c9                   	leave  
+  800917:	c3                   	ret    
+
+00800918 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800918:	55                   	push   %ebp
+  800919:	89 e5                	mov    %esp,%ebp
+  80091b:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  80091e:	8d 45 14             	lea    0x14(%ebp),%eax
+  800921:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800924:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800927:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  80092b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80092e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800932:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800935:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800939:	8b 45 08             	mov    0x8(%ebp),%eax
+  80093c:	89 04 24             	mov    %eax,(%esp)
+  80093f:	e8 74 ff ff ff       	call   8008b8 <vsnprintf>
+  800944:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800947:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  80094a:	c9                   	leave  
+  80094b:	c3                   	ret    
+
+0080094c <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  80094c:	55                   	push   %ebp
+  80094d:	89 e5                	mov    %esp,%ebp
+  80094f:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800952:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800959:	eb 08                	jmp    800963 <strlen+0x17>
+		n++;
+  80095b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  80095f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800963:	8b 45 08             	mov    0x8(%ebp),%eax
+  800966:	0f b6 00             	movzbl (%eax),%eax
+  800969:	84 c0                	test   %al,%al
+  80096b:	75 ee                	jne    80095b <strlen+0xf>
+		n++;
+	return n;
+  80096d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800970:	c9                   	leave  
+  800971:	c3                   	ret    
+
+00800972 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800972:	55                   	push   %ebp
+  800973:	89 e5                	mov    %esp,%ebp
+  800975:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800978:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  80097f:	eb 0c                	jmp    80098d <strnlen+0x1b>
+		n++;
+  800981:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800985:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800989:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  80098d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800991:	74 0a                	je     80099d <strnlen+0x2b>
+  800993:	8b 45 08             	mov    0x8(%ebp),%eax
+  800996:	0f b6 00             	movzbl (%eax),%eax
+  800999:	84 c0                	test   %al,%al
+  80099b:	75 e4                	jne    800981 <strnlen+0xf>
+		n++;
+	return n;
+  80099d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009a0:	c9                   	leave  
+  8009a1:	c3                   	ret    
+
+008009a2 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  8009a2:	55                   	push   %ebp
+  8009a3:	89 e5                	mov    %esp,%ebp
+  8009a5:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  8009a8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  8009ae:	90                   	nop
+  8009af:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009b2:	8d 50 01             	lea    0x1(%eax),%edx
+  8009b5:	89 55 08             	mov    %edx,0x8(%ebp)
+  8009b8:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8009bb:	8d 4a 01             	lea    0x1(%edx),%ecx
+  8009be:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  8009c1:	0f b6 12             	movzbl (%edx),%edx
+  8009c4:	88 10                	mov    %dl,(%eax)
+  8009c6:	0f b6 00             	movzbl (%eax),%eax
+  8009c9:	84 c0                	test   %al,%al
+  8009cb:	75 e2                	jne    8009af <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  8009cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009d0:	c9                   	leave  
+  8009d1:	c3                   	ret    
+
+008009d2 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  8009d2:	55                   	push   %ebp
+  8009d3:	89 e5                	mov    %esp,%ebp
+  8009d5:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  8009d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009db:	89 04 24             	mov    %eax,(%esp)
+  8009de:	e8 69 ff ff ff       	call   80094c <strlen>
+  8009e3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  8009e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  8009e9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ec:	01 c2                	add    %eax,%edx
+  8009ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009f5:	89 14 24             	mov    %edx,(%esp)
+  8009f8:	e8 a5 ff ff ff       	call   8009a2 <strcpy>
+	return dst;
+  8009fd:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800a00:	c9                   	leave  
+  800a01:	c3                   	ret    
+
+00800a02 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800a02:	55                   	push   %ebp
+  800a03:	89 e5                	mov    %esp,%ebp
+  800a05:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800a08:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a0b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800a0e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800a15:	eb 23                	jmp    800a3a <strncpy+0x38>
+		*dst++ = *src;
+  800a17:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a1a:	8d 50 01             	lea    0x1(%eax),%edx
+  800a1d:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a20:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a23:	0f b6 12             	movzbl (%edx),%edx
+  800a26:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800a28:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a2b:	0f b6 00             	movzbl (%eax),%eax
+  800a2e:	84 c0                	test   %al,%al
+  800a30:	74 04                	je     800a36 <strncpy+0x34>
+			src++;
+  800a32:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800a36:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800a3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a3d:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800a40:	72 d5                	jb     800a17 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800a42:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800a45:	c9                   	leave  
+  800a46:	c3                   	ret    
+
+00800a47 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800a47:	55                   	push   %ebp
+  800a48:	89 e5                	mov    %esp,%ebp
+  800a4a:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800a4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a50:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800a53:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a57:	74 33                	je     800a8c <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800a59:	eb 17                	jmp    800a72 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800a5b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a5e:	8d 50 01             	lea    0x1(%eax),%edx
+  800a61:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a64:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a67:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800a6a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800a6d:	0f b6 12             	movzbl (%edx),%edx
+  800a70:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800a72:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a76:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a7a:	74 0a                	je     800a86 <strlcpy+0x3f>
+  800a7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a7f:	0f b6 00             	movzbl (%eax),%eax
+  800a82:	84 c0                	test   %al,%al
+  800a84:	75 d5                	jne    800a5b <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800a86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a89:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800a8c:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a92:	29 c2                	sub    %eax,%edx
+  800a94:	89 d0                	mov    %edx,%eax
+}
+  800a96:	c9                   	leave  
+  800a97:	c3                   	ret    
+
+00800a98 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800a98:	55                   	push   %ebp
+  800a99:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800a9b:	eb 08                	jmp    800aa5 <strcmp+0xd>
+		p++, q++;
+  800a9d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800aa1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800aa5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aa8:	0f b6 00             	movzbl (%eax),%eax
+  800aab:	84 c0                	test   %al,%al
+  800aad:	74 10                	je     800abf <strcmp+0x27>
+  800aaf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ab2:	0f b6 10             	movzbl (%eax),%edx
+  800ab5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ab8:	0f b6 00             	movzbl (%eax),%eax
+  800abb:	38 c2                	cmp    %al,%dl
+  800abd:	74 de                	je     800a9d <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800abf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ac2:	0f b6 00             	movzbl (%eax),%eax
+  800ac5:	0f b6 d0             	movzbl %al,%edx
+  800ac8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800acb:	0f b6 00             	movzbl (%eax),%eax
+  800ace:	0f b6 c0             	movzbl %al,%eax
+  800ad1:	29 c2                	sub    %eax,%edx
+  800ad3:	89 d0                	mov    %edx,%eax
+}
+  800ad5:	5d                   	pop    %ebp
+  800ad6:	c3                   	ret    
+
+00800ad7 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800ad7:	55                   	push   %ebp
+  800ad8:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800ada:	eb 0c                	jmp    800ae8 <strncmp+0x11>
+		n--, p++, q++;
+  800adc:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800ae0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ae4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800ae8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800aec:	74 1a                	je     800b08 <strncmp+0x31>
+  800aee:	8b 45 08             	mov    0x8(%ebp),%eax
+  800af1:	0f b6 00             	movzbl (%eax),%eax
+  800af4:	84 c0                	test   %al,%al
+  800af6:	74 10                	je     800b08 <strncmp+0x31>
+  800af8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800afb:	0f b6 10             	movzbl (%eax),%edx
+  800afe:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b01:	0f b6 00             	movzbl (%eax),%eax
+  800b04:	38 c2                	cmp    %al,%dl
+  800b06:	74 d4                	je     800adc <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800b08:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b0c:	75 07                	jne    800b15 <strncmp+0x3e>
+		return 0;
+  800b0e:	b8 00 00 00 00       	mov    $0x0,%eax
+  800b13:	eb 16                	jmp    800b2b <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800b15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b18:	0f b6 00             	movzbl (%eax),%eax
+  800b1b:	0f b6 d0             	movzbl %al,%edx
+  800b1e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b21:	0f b6 00             	movzbl (%eax),%eax
+  800b24:	0f b6 c0             	movzbl %al,%eax
+  800b27:	29 c2                	sub    %eax,%edx
+  800b29:	89 d0                	mov    %edx,%eax
+}
+  800b2b:	5d                   	pop    %ebp
+  800b2c:	c3                   	ret    
+
+00800b2d <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800b2d:	55                   	push   %ebp
+  800b2e:	89 e5                	mov    %esp,%ebp
+  800b30:	83 ec 04             	sub    $0x4,%esp
+  800b33:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b36:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b39:	eb 14                	jmp    800b4f <strchr+0x22>
+		if (*s == c)
+  800b3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b3e:	0f b6 00             	movzbl (%eax),%eax
+  800b41:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b44:	75 05                	jne    800b4b <strchr+0x1e>
+			return (char *) s;
+  800b46:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b49:	eb 13                	jmp    800b5e <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800b4b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b4f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b52:	0f b6 00             	movzbl (%eax),%eax
+  800b55:	84 c0                	test   %al,%al
+  800b57:	75 e2                	jne    800b3b <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800b59:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800b5e:	c9                   	leave  
+  800b5f:	c3                   	ret    
+
+00800b60 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800b60:	55                   	push   %ebp
+  800b61:	89 e5                	mov    %esp,%ebp
+  800b63:	83 ec 04             	sub    $0x4,%esp
+  800b66:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b69:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b6c:	eb 11                	jmp    800b7f <strfind+0x1f>
+		if (*s == c)
+  800b6e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b71:	0f b6 00             	movzbl (%eax),%eax
+  800b74:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b77:	75 02                	jne    800b7b <strfind+0x1b>
+			break;
+  800b79:	eb 0e                	jmp    800b89 <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800b7b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b7f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b82:	0f b6 00             	movzbl (%eax),%eax
+  800b85:	84 c0                	test   %al,%al
+  800b87:	75 e5                	jne    800b6e <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800b89:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800b8c:	c9                   	leave  
+  800b8d:	c3                   	ret    
+
+00800b8e <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800b8e:	55                   	push   %ebp
+  800b8f:	89 e5                	mov    %esp,%ebp
+  800b91:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800b92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b96:	75 05                	jne    800b9d <memset+0xf>
+		return v;
+  800b98:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b9b:	eb 5c                	jmp    800bf9 <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800b9d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba0:	83 e0 03             	and    $0x3,%eax
+  800ba3:	85 c0                	test   %eax,%eax
+  800ba5:	75 41                	jne    800be8 <memset+0x5a>
+  800ba7:	8b 45 10             	mov    0x10(%ebp),%eax
+  800baa:	83 e0 03             	and    $0x3,%eax
+  800bad:	85 c0                	test   %eax,%eax
+  800baf:	75 37                	jne    800be8 <memset+0x5a>
+		c &= 0xFF;
+  800bb1:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800bb8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bbb:	c1 e0 18             	shl    $0x18,%eax
+  800bbe:	89 c2                	mov    %eax,%edx
+  800bc0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bc3:	c1 e0 10             	shl    $0x10,%eax
+  800bc6:	09 c2                	or     %eax,%edx
+  800bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bcb:	c1 e0 08             	shl    $0x8,%eax
+  800bce:	09 d0                	or     %edx,%eax
+  800bd0:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800bd3:	8b 45 10             	mov    0x10(%ebp),%eax
+  800bd6:	c1 e8 02             	shr    $0x2,%eax
+  800bd9:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800bdb:	8b 55 08             	mov    0x8(%ebp),%edx
+  800bde:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800be1:	89 d7                	mov    %edx,%edi
+  800be3:	fc                   	cld    
+  800be4:	f3 ab                	rep stos %eax,%es:(%edi)
+  800be6:	eb 0e                	jmp    800bf6 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800be8:	8b 55 08             	mov    0x8(%ebp),%edx
+  800beb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bee:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800bf1:	89 d7                	mov    %edx,%edi
+  800bf3:	fc                   	cld    
+  800bf4:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800bf6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bf9:	5f                   	pop    %edi
+  800bfa:	5d                   	pop    %ebp
+  800bfb:	c3                   	ret    
+
+00800bfc <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800bfc:	55                   	push   %ebp
+  800bfd:	89 e5                	mov    %esp,%ebp
+  800bff:	57                   	push   %edi
+  800c00:	56                   	push   %esi
+  800c01:	53                   	push   %ebx
+  800c02:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800c05:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c08:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800c0b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c0e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800c11:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c14:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c17:	73 6d                	jae    800c86 <memmove+0x8a>
+  800c19:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c1f:	01 d0                	add    %edx,%eax
+  800c21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c24:	76 60                	jbe    800c86 <memmove+0x8a>
+		s += n;
+  800c26:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c29:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800c2c:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c2f:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c35:	83 e0 03             	and    $0x3,%eax
+  800c38:	85 c0                	test   %eax,%eax
+  800c3a:	75 2f                	jne    800c6b <memmove+0x6f>
+  800c3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c3f:	83 e0 03             	and    $0x3,%eax
+  800c42:	85 c0                	test   %eax,%eax
+  800c44:	75 25                	jne    800c6b <memmove+0x6f>
+  800c46:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c49:	83 e0 03             	and    $0x3,%eax
+  800c4c:	85 c0                	test   %eax,%eax
+  800c4e:	75 1b                	jne    800c6b <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800c50:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c53:	83 e8 04             	sub    $0x4,%eax
+  800c56:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c59:	83 ea 04             	sub    $0x4,%edx
+  800c5c:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800c5f:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800c62:	89 c7                	mov    %eax,%edi
+  800c64:	89 d6                	mov    %edx,%esi
+  800c66:	fd                   	std    
+  800c67:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800c69:	eb 18                	jmp    800c83 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800c6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c6e:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800c71:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c74:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800c77:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c7a:	89 d7                	mov    %edx,%edi
+  800c7c:	89 de                	mov    %ebx,%esi
+  800c7e:	89 c1                	mov    %eax,%ecx
+  800c80:	fd                   	std    
+  800c81:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800c83:	fc                   	cld    
+  800c84:	eb 45                	jmp    800ccb <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c89:	83 e0 03             	and    $0x3,%eax
+  800c8c:	85 c0                	test   %eax,%eax
+  800c8e:	75 2b                	jne    800cbb <memmove+0xbf>
+  800c90:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c93:	83 e0 03             	and    $0x3,%eax
+  800c96:	85 c0                	test   %eax,%eax
+  800c98:	75 21                	jne    800cbb <memmove+0xbf>
+  800c9a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c9d:	83 e0 03             	and    $0x3,%eax
+  800ca0:	85 c0                	test   %eax,%eax
+  800ca2:	75 17                	jne    800cbb <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800ca4:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ca7:	c1 e8 02             	shr    $0x2,%eax
+  800caa:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800cac:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800caf:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cb2:	89 c7                	mov    %eax,%edi
+  800cb4:	89 d6                	mov    %edx,%esi
+  800cb6:	fc                   	cld    
+  800cb7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800cb9:	eb 10                	jmp    800ccb <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800cbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800cbe:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cc1:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800cc4:	89 c7                	mov    %eax,%edi
+  800cc6:	89 d6                	mov    %edx,%esi
+  800cc8:	fc                   	cld    
+  800cc9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800ccb:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800cce:	83 c4 10             	add    $0x10,%esp
+  800cd1:	5b                   	pop    %ebx
+  800cd2:	5e                   	pop    %esi
+  800cd3:	5f                   	pop    %edi
+  800cd4:	5d                   	pop    %ebp
+  800cd5:	c3                   	ret    
+
+00800cd6 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800cd6:	55                   	push   %ebp
+  800cd7:	89 e5                	mov    %esp,%ebp
+  800cd9:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800cdc:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cdf:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ce3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800cea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ced:	89 04 24             	mov    %eax,(%esp)
+  800cf0:	e8 07 ff ff ff       	call   800bfc <memmove>
+}
+  800cf5:	c9                   	leave  
+  800cf6:	c3                   	ret    
+
+00800cf7 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800cf7:	55                   	push   %ebp
+  800cf8:	89 e5                	mov    %esp,%ebp
+  800cfa:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800cfd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d00:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800d03:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d06:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800d09:	eb 30                	jmp    800d3b <memcmp+0x44>
+		if (*s1 != *s2)
+  800d0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d0e:	0f b6 10             	movzbl (%eax),%edx
+  800d11:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d14:	0f b6 00             	movzbl (%eax),%eax
+  800d17:	38 c2                	cmp    %al,%dl
+  800d19:	74 18                	je     800d33 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800d1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d1e:	0f b6 00             	movzbl (%eax),%eax
+  800d21:	0f b6 d0             	movzbl %al,%edx
+  800d24:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d27:	0f b6 00             	movzbl (%eax),%eax
+  800d2a:	0f b6 c0             	movzbl %al,%eax
+  800d2d:	29 c2                	sub    %eax,%edx
+  800d2f:	89 d0                	mov    %edx,%eax
+  800d31:	eb 1a                	jmp    800d4d <memcmp+0x56>
+		s1++, s2++;
+  800d33:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800d37:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800d3b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d3e:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800d41:	89 55 10             	mov    %edx,0x10(%ebp)
+  800d44:	85 c0                	test   %eax,%eax
+  800d46:	75 c3                	jne    800d0b <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800d48:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d4d:	c9                   	leave  
+  800d4e:	c3                   	ret    
+
+00800d4f <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800d4f:	55                   	push   %ebp
+  800d50:	89 e5                	mov    %esp,%ebp
+  800d52:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800d55:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d58:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d5b:	01 d0                	add    %edx,%eax
+  800d5d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800d60:	eb 13                	jmp    800d75 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800d62:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d65:	0f b6 10             	movzbl (%eax),%edx
+  800d68:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d6b:	38 c2                	cmp    %al,%dl
+  800d6d:	75 02                	jne    800d71 <memfind+0x22>
+			break;
+  800d6f:	eb 0c                	jmp    800d7d <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800d71:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d78:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800d7b:	72 e5                	jb     800d62 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800d7d:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d80:	c9                   	leave  
+  800d81:	c3                   	ret    
+
+00800d82 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800d82:	55                   	push   %ebp
+  800d83:	89 e5                	mov    %esp,%ebp
+  800d85:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800d88:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800d8f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800d96:	eb 04                	jmp    800d9c <strtol+0x1a>
+		s++;
+  800d98:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800d9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d9f:	0f b6 00             	movzbl (%eax),%eax
+  800da2:	3c 20                	cmp    $0x20,%al
+  800da4:	74 f2                	je     800d98 <strtol+0x16>
+  800da6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800da9:	0f b6 00             	movzbl (%eax),%eax
+  800dac:	3c 09                	cmp    $0x9,%al
+  800dae:	74 e8                	je     800d98 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800db0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800db3:	0f b6 00             	movzbl (%eax),%eax
+  800db6:	3c 2b                	cmp    $0x2b,%al
+  800db8:	75 06                	jne    800dc0 <strtol+0x3e>
+		s++;
+  800dba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800dbe:	eb 15                	jmp    800dd5 <strtol+0x53>
+	else if (*s == '-')
+  800dc0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc3:	0f b6 00             	movzbl (%eax),%eax
+  800dc6:	3c 2d                	cmp    $0x2d,%al
+  800dc8:	75 0b                	jne    800dd5 <strtol+0x53>
+		s++, neg = 1;
+  800dca:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800dce:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800dd5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800dd9:	74 06                	je     800de1 <strtol+0x5f>
+  800ddb:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800ddf:	75 24                	jne    800e05 <strtol+0x83>
+  800de1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800de4:	0f b6 00             	movzbl (%eax),%eax
+  800de7:	3c 30                	cmp    $0x30,%al
+  800de9:	75 1a                	jne    800e05 <strtol+0x83>
+  800deb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dee:	83 c0 01             	add    $0x1,%eax
+  800df1:	0f b6 00             	movzbl (%eax),%eax
+  800df4:	3c 78                	cmp    $0x78,%al
+  800df6:	75 0d                	jne    800e05 <strtol+0x83>
+		s += 2, base = 16;
+  800df8:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800dfc:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800e03:	eb 2a                	jmp    800e2f <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800e05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e09:	75 17                	jne    800e22 <strtol+0xa0>
+  800e0b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e0e:	0f b6 00             	movzbl (%eax),%eax
+  800e11:	3c 30                	cmp    $0x30,%al
+  800e13:	75 0d                	jne    800e22 <strtol+0xa0>
+		s++, base = 8;
+  800e15:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800e19:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800e20:	eb 0d                	jmp    800e2f <strtol+0xad>
+	else if (base == 0)
+  800e22:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e26:	75 07                	jne    800e2f <strtol+0xad>
+		base = 10;
+  800e28:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800e2f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e32:	0f b6 00             	movzbl (%eax),%eax
+  800e35:	3c 2f                	cmp    $0x2f,%al
+  800e37:	7e 1b                	jle    800e54 <strtol+0xd2>
+  800e39:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e3c:	0f b6 00             	movzbl (%eax),%eax
+  800e3f:	3c 39                	cmp    $0x39,%al
+  800e41:	7f 11                	jg     800e54 <strtol+0xd2>
+			dig = *s - '0';
+  800e43:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e46:	0f b6 00             	movzbl (%eax),%eax
+  800e49:	0f be c0             	movsbl %al,%eax
+  800e4c:	83 e8 30             	sub    $0x30,%eax
+  800e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e52:	eb 48                	jmp    800e9c <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  800e54:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e57:	0f b6 00             	movzbl (%eax),%eax
+  800e5a:	3c 60                	cmp    $0x60,%al
+  800e5c:	7e 1b                	jle    800e79 <strtol+0xf7>
+  800e5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e61:	0f b6 00             	movzbl (%eax),%eax
+  800e64:	3c 7a                	cmp    $0x7a,%al
+  800e66:	7f 11                	jg     800e79 <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  800e68:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e6b:	0f b6 00             	movzbl (%eax),%eax
+  800e6e:	0f be c0             	movsbl %al,%eax
+  800e71:	83 e8 57             	sub    $0x57,%eax
+  800e74:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e77:	eb 23                	jmp    800e9c <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  800e79:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e7c:	0f b6 00             	movzbl (%eax),%eax
+  800e7f:	3c 40                	cmp    $0x40,%al
+  800e81:	7e 3d                	jle    800ec0 <strtol+0x13e>
+  800e83:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e86:	0f b6 00             	movzbl (%eax),%eax
+  800e89:	3c 5a                	cmp    $0x5a,%al
+  800e8b:	7f 33                	jg     800ec0 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  800e8d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e90:	0f b6 00             	movzbl (%eax),%eax
+  800e93:	0f be c0             	movsbl %al,%eax
+  800e96:	83 e8 37             	sub    $0x37,%eax
+  800e99:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  800e9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800e9f:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800ea2:	7c 02                	jl     800ea6 <strtol+0x124>
+			break;
+  800ea4:	eb 1a                	jmp    800ec0 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  800ea6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800eaa:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ead:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800eb1:	89 c2                	mov    %eax,%edx
+  800eb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800eb6:	01 d0                	add    %edx,%eax
+  800eb8:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  800ebb:	e9 6f ff ff ff       	jmp    800e2f <strtol+0xad>
+
+	if (endptr)
+  800ec0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800ec4:	74 08                	je     800ece <strtol+0x14c>
+		*endptr = (char *) s;
+  800ec6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ec9:	8b 55 08             	mov    0x8(%ebp),%edx
+  800ecc:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  800ece:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800ed2:	74 07                	je     800edb <strtol+0x159>
+  800ed4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ed7:	f7 d8                	neg    %eax
+  800ed9:	eb 03                	jmp    800ede <strtol+0x15c>
+  800edb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800ede:	c9                   	leave  
+  800edf:	c3                   	ret    
+
+00800ee0 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  800ee0:	55                   	push   %ebp
+  800ee1:	89 e5                	mov    %esp,%ebp
+  800ee3:	57                   	push   %edi
+  800ee4:	56                   	push   %esi
+  800ee5:	53                   	push   %ebx
+  800ee6:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  800ee9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eec:	8b 55 10             	mov    0x10(%ebp),%edx
+  800eef:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  800ef2:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  800ef5:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  800ef8:	8b 75 20             	mov    0x20(%ebp),%esi
+  800efb:	cd 30                	int    $0x30
+  800efd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  800f00:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800f04:	74 30                	je     800f36 <syscall+0x56>
+  800f06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800f0a:	7e 2a                	jle    800f36 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  800f0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800f0f:	89 44 24 10          	mov    %eax,0x10(%esp)
+  800f13:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f16:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800f1a:	c7 44 24 08 70 15 80 	movl   $0x801570,0x8(%esp)
+  800f21:	00 
+  800f22:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  800f29:	00 
+  800f2a:	c7 04 24 8d 15 80 00 	movl   $0x80158d,(%esp)
+  800f31:	e8 18 01 00 00       	call   80104e <_panic>
+
+	return ret;
+  800f36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  800f39:	83 c4 3c             	add    $0x3c,%esp
+  800f3c:	5b                   	pop    %ebx
+  800f3d:	5e                   	pop    %esi
+  800f3e:	5f                   	pop    %edi
+  800f3f:	5d                   	pop    %ebp
+  800f40:	c3                   	ret    
+
+00800f41 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800f41:	55                   	push   %ebp
+  800f42:	89 e5                	mov    %esp,%ebp
+  800f44:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800f47:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f4a:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f51:	00 
+  800f52:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800f59:	00 
+  800f5a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800f61:	00 
+  800f62:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800f65:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800f69:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800f6d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800f74:	00 
+  800f75:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800f7c:	e8 5f ff ff ff       	call   800ee0 <syscall>
+}
+  800f81:	c9                   	leave  
+  800f82:	c3                   	ret    
+
+00800f83 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800f83:	55                   	push   %ebp
+  800f84:	89 e5                	mov    %esp,%ebp
+  800f86:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800f89:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f90:	00 
+  800f91:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800f98:	00 
+  800f99:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800fa0:	00 
+  800fa1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800fa8:	00 
+  800fa9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800fb0:	00 
+  800fb1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800fb8:	00 
+  800fb9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800fc0:	e8 1b ff ff ff       	call   800ee0 <syscall>
+}
+  800fc5:	c9                   	leave  
+  800fc6:	c3                   	ret    
+
+00800fc7 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800fc7:	55                   	push   %ebp
+  800fc8:	89 e5                	mov    %esp,%ebp
+  800fca:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800fcd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fd0:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800fd7:	00 
+  800fd8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800fdf:	00 
+  800fe0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800fe7:	00 
+  800fe8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800fef:	00 
+  800ff0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ff4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  800ffb:	00 
+  800ffc:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  801003:	e8 d8 fe ff ff       	call   800ee0 <syscall>
+}
+  801008:	c9                   	leave  
+  801009:	c3                   	ret    
+
+0080100a <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  80100a:	55                   	push   %ebp
+  80100b:	89 e5                	mov    %esp,%ebp
+  80100d:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  801010:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  801017:	00 
+  801018:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80101f:	00 
+  801020:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  801027:	00 
+  801028:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  80102f:	00 
+  801030:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  801037:	00 
+  801038:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80103f:	00 
+  801040:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  801047:	e8 94 fe ff ff       	call   800ee0 <syscall>
+}
+  80104c:	c9                   	leave  
+  80104d:	c3                   	ret    
+
+0080104e <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80104e:	55                   	push   %ebp
+  80104f:	89 e5                	mov    %esp,%ebp
+  801051:	53                   	push   %ebx
+  801052:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  801055:	8d 45 14             	lea    0x14(%ebp),%eax
+  801058:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80105b:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  801061:	e8 a4 ff ff ff       	call   80100a <sys_getenvid>
+  801066:	8b 55 0c             	mov    0xc(%ebp),%edx
+  801069:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80106d:	8b 55 08             	mov    0x8(%ebp),%edx
+  801070:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  801074:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  801078:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80107c:	c7 04 24 9c 15 80 00 	movl   $0x80159c,(%esp)
+  801083:	e8 ec f0 ff ff       	call   800174 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  801088:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80108b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80108f:	8b 45 10             	mov    0x10(%ebp),%eax
+  801092:	89 04 24             	mov    %eax,(%esp)
+  801095:	e8 76 f0 ff ff       	call   800110 <vcprintf>
+	cprintf("\n");
+  80109a:	c7 04 24 bf 15 80 00 	movl   $0x8015bf,(%esp)
+  8010a1:	e8 ce f0 ff ff       	call   800174 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  8010a6:	cc                   	int3   
+  8010a7:	eb fd                	jmp    8010a6 <_panic+0x58>
+  8010a9:	66 90                	xchg   %ax,%ax
+  8010ab:	66 90                	xchg   %ax,%ax
+  8010ad:	66 90                	xchg   %ax,%ax
+  8010af:	90                   	nop
+
+008010b0 <__udivdi3>:
+  8010b0:	55                   	push   %ebp
+  8010b1:	57                   	push   %edi
+  8010b2:	56                   	push   %esi
+  8010b3:	83 ec 0c             	sub    $0xc,%esp
+  8010b6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ba:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010be:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010c2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010c6:	85 c0                	test   %eax,%eax
+  8010c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010cc:	89 ea                	mov    %ebp,%edx
+  8010ce:	89 0c 24             	mov    %ecx,(%esp)
+  8010d1:	75 2d                	jne    801100 <__udivdi3+0x50>
+  8010d3:	39 e9                	cmp    %ebp,%ecx
+  8010d5:	77 61                	ja     801138 <__udivdi3+0x88>
+  8010d7:	85 c9                	test   %ecx,%ecx
+  8010d9:	89 ce                	mov    %ecx,%esi
+  8010db:	75 0b                	jne    8010e8 <__udivdi3+0x38>
+  8010dd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010e2:	31 d2                	xor    %edx,%edx
+  8010e4:	f7 f1                	div    %ecx
+  8010e6:	89 c6                	mov    %eax,%esi
+  8010e8:	31 d2                	xor    %edx,%edx
+  8010ea:	89 e8                	mov    %ebp,%eax
+  8010ec:	f7 f6                	div    %esi
+  8010ee:	89 c5                	mov    %eax,%ebp
+  8010f0:	89 f8                	mov    %edi,%eax
+  8010f2:	f7 f6                	div    %esi
+  8010f4:	89 ea                	mov    %ebp,%edx
+  8010f6:	83 c4 0c             	add    $0xc,%esp
+  8010f9:	5e                   	pop    %esi
+  8010fa:	5f                   	pop    %edi
+  8010fb:	5d                   	pop    %ebp
+  8010fc:	c3                   	ret    
+  8010fd:	8d 76 00             	lea    0x0(%esi),%esi
+  801100:	39 e8                	cmp    %ebp,%eax
+  801102:	77 24                	ja     801128 <__udivdi3+0x78>
+  801104:	0f bd e8             	bsr    %eax,%ebp
+  801107:	83 f5 1f             	xor    $0x1f,%ebp
+  80110a:	75 3c                	jne    801148 <__udivdi3+0x98>
+  80110c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801110:	39 34 24             	cmp    %esi,(%esp)
+  801113:	0f 86 9f 00 00 00    	jbe    8011b8 <__udivdi3+0x108>
+  801119:	39 d0                	cmp    %edx,%eax
+  80111b:	0f 82 97 00 00 00    	jb     8011b8 <__udivdi3+0x108>
+  801121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801128:	31 d2                	xor    %edx,%edx
+  80112a:	31 c0                	xor    %eax,%eax
+  80112c:	83 c4 0c             	add    $0xc,%esp
+  80112f:	5e                   	pop    %esi
+  801130:	5f                   	pop    %edi
+  801131:	5d                   	pop    %ebp
+  801132:	c3                   	ret    
+  801133:	90                   	nop
+  801134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801138:	89 f8                	mov    %edi,%eax
+  80113a:	f7 f1                	div    %ecx
+  80113c:	31 d2                	xor    %edx,%edx
+  80113e:	83 c4 0c             	add    $0xc,%esp
+  801141:	5e                   	pop    %esi
+  801142:	5f                   	pop    %edi
+  801143:	5d                   	pop    %ebp
+  801144:	c3                   	ret    
+  801145:	8d 76 00             	lea    0x0(%esi),%esi
+  801148:	89 e9                	mov    %ebp,%ecx
+  80114a:	8b 3c 24             	mov    (%esp),%edi
+  80114d:	d3 e0                	shl    %cl,%eax
+  80114f:	89 c6                	mov    %eax,%esi
+  801151:	b8 20 00 00 00       	mov    $0x20,%eax
+  801156:	29 e8                	sub    %ebp,%eax
+  801158:	89 c1                	mov    %eax,%ecx
+  80115a:	d3 ef                	shr    %cl,%edi
+  80115c:	89 e9                	mov    %ebp,%ecx
+  80115e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801162:	8b 3c 24             	mov    (%esp),%edi
+  801165:	09 74 24 08          	or     %esi,0x8(%esp)
+  801169:	89 d6                	mov    %edx,%esi
+  80116b:	d3 e7                	shl    %cl,%edi
+  80116d:	89 c1                	mov    %eax,%ecx
+  80116f:	89 3c 24             	mov    %edi,(%esp)
+  801172:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801176:	d3 ee                	shr    %cl,%esi
+  801178:	89 e9                	mov    %ebp,%ecx
+  80117a:	d3 e2                	shl    %cl,%edx
+  80117c:	89 c1                	mov    %eax,%ecx
+  80117e:	d3 ef                	shr    %cl,%edi
+  801180:	09 d7                	or     %edx,%edi
+  801182:	89 f2                	mov    %esi,%edx
+  801184:	89 f8                	mov    %edi,%eax
+  801186:	f7 74 24 08          	divl   0x8(%esp)
+  80118a:	89 d6                	mov    %edx,%esi
+  80118c:	89 c7                	mov    %eax,%edi
+  80118e:	f7 24 24             	mull   (%esp)
+  801191:	39 d6                	cmp    %edx,%esi
+  801193:	89 14 24             	mov    %edx,(%esp)
+  801196:	72 30                	jb     8011c8 <__udivdi3+0x118>
+  801198:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80119c:	89 e9                	mov    %ebp,%ecx
+  80119e:	d3 e2                	shl    %cl,%edx
+  8011a0:	39 c2                	cmp    %eax,%edx
+  8011a2:	73 05                	jae    8011a9 <__udivdi3+0xf9>
+  8011a4:	3b 34 24             	cmp    (%esp),%esi
+  8011a7:	74 1f                	je     8011c8 <__udivdi3+0x118>
+  8011a9:	89 f8                	mov    %edi,%eax
+  8011ab:	31 d2                	xor    %edx,%edx
+  8011ad:	e9 7a ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011b8:	31 d2                	xor    %edx,%edx
+  8011ba:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011bf:	e9 68 ff ff ff       	jmp    80112c <__udivdi3+0x7c>
+  8011c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011c8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011cb:	31 d2                	xor    %edx,%edx
+  8011cd:	83 c4 0c             	add    $0xc,%esp
+  8011d0:	5e                   	pop    %esi
+  8011d1:	5f                   	pop    %edi
+  8011d2:	5d                   	pop    %ebp
+  8011d3:	c3                   	ret    
+  8011d4:	66 90                	xchg   %ax,%ax
+  8011d6:	66 90                	xchg   %ax,%ax
+  8011d8:	66 90                	xchg   %ax,%ax
+  8011da:	66 90                	xchg   %ax,%ax
+  8011dc:	66 90                	xchg   %ax,%ax
+  8011de:	66 90                	xchg   %ax,%ax
+
+008011e0 <__umoddi3>:
+  8011e0:	55                   	push   %ebp
+  8011e1:	57                   	push   %edi
+  8011e2:	56                   	push   %esi
+  8011e3:	83 ec 14             	sub    $0x14,%esp
+  8011e6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011ee:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011f2:	89 c7                	mov    %eax,%edi
+  8011f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011f8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011fc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801200:	89 34 24             	mov    %esi,(%esp)
+  801203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801207:	85 c0                	test   %eax,%eax
+  801209:	89 c2                	mov    %eax,%edx
+  80120b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80120f:	75 17                	jne    801228 <__umoddi3+0x48>
+  801211:	39 fe                	cmp    %edi,%esi
+  801213:	76 4b                	jbe    801260 <__umoddi3+0x80>
+  801215:	89 c8                	mov    %ecx,%eax
+  801217:	89 fa                	mov    %edi,%edx
+  801219:	f7 f6                	div    %esi
+  80121b:	89 d0                	mov    %edx,%eax
+  80121d:	31 d2                	xor    %edx,%edx
+  80121f:	83 c4 14             	add    $0x14,%esp
+  801222:	5e                   	pop    %esi
+  801223:	5f                   	pop    %edi
+  801224:	5d                   	pop    %ebp
+  801225:	c3                   	ret    
+  801226:	66 90                	xchg   %ax,%ax
+  801228:	39 f8                	cmp    %edi,%eax
+  80122a:	77 54                	ja     801280 <__umoddi3+0xa0>
+  80122c:	0f bd e8             	bsr    %eax,%ebp
+  80122f:	83 f5 1f             	xor    $0x1f,%ebp
+  801232:	75 5c                	jne    801290 <__umoddi3+0xb0>
+  801234:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801238:	39 3c 24             	cmp    %edi,(%esp)
+  80123b:	0f 87 e7 00 00 00    	ja     801328 <__umoddi3+0x148>
+  801241:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801245:	29 f1                	sub    %esi,%ecx
+  801247:	19 c7                	sbb    %eax,%edi
+  801249:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80124d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801251:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801255:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801259:	83 c4 14             	add    $0x14,%esp
+  80125c:	5e                   	pop    %esi
+  80125d:	5f                   	pop    %edi
+  80125e:	5d                   	pop    %ebp
+  80125f:	c3                   	ret    
+  801260:	85 f6                	test   %esi,%esi
+  801262:	89 f5                	mov    %esi,%ebp
+  801264:	75 0b                	jne    801271 <__umoddi3+0x91>
+  801266:	b8 01 00 00 00       	mov    $0x1,%eax
+  80126b:	31 d2                	xor    %edx,%edx
+  80126d:	f7 f6                	div    %esi
+  80126f:	89 c5                	mov    %eax,%ebp
+  801271:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801275:	31 d2                	xor    %edx,%edx
+  801277:	f7 f5                	div    %ebp
+  801279:	89 c8                	mov    %ecx,%eax
+  80127b:	f7 f5                	div    %ebp
+  80127d:	eb 9c                	jmp    80121b <__umoddi3+0x3b>
+  80127f:	90                   	nop
+  801280:	89 c8                	mov    %ecx,%eax
+  801282:	89 fa                	mov    %edi,%edx
+  801284:	83 c4 14             	add    $0x14,%esp
+  801287:	5e                   	pop    %esi
+  801288:	5f                   	pop    %edi
+  801289:	5d                   	pop    %ebp
+  80128a:	c3                   	ret    
+  80128b:	90                   	nop
+  80128c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801290:	8b 04 24             	mov    (%esp),%eax
+  801293:	be 20 00 00 00       	mov    $0x20,%esi
+  801298:	89 e9                	mov    %ebp,%ecx
+  80129a:	29 ee                	sub    %ebp,%esi
+  80129c:	d3 e2                	shl    %cl,%edx
+  80129e:	89 f1                	mov    %esi,%ecx
+  8012a0:	d3 e8                	shr    %cl,%eax
+  8012a2:	89 e9                	mov    %ebp,%ecx
+  8012a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012a8:	8b 04 24             	mov    (%esp),%eax
+  8012ab:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012af:	89 fa                	mov    %edi,%edx
+  8012b1:	d3 e0                	shl    %cl,%eax
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012b9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012bd:	d3 ea                	shr    %cl,%edx
+  8012bf:	89 e9                	mov    %ebp,%ecx
+  8012c1:	d3 e7                	shl    %cl,%edi
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	d3 e8                	shr    %cl,%eax
+  8012c7:	89 e9                	mov    %ebp,%ecx
+  8012c9:	09 f8                	or     %edi,%eax
+  8012cb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012cf:	f7 74 24 04          	divl   0x4(%esp)
+  8012d3:	d3 e7                	shl    %cl,%edi
+  8012d5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012d9:	89 d7                	mov    %edx,%edi
+  8012db:	f7 64 24 08          	mull   0x8(%esp)
+  8012df:	39 d7                	cmp    %edx,%edi
+  8012e1:	89 c1                	mov    %eax,%ecx
+  8012e3:	89 14 24             	mov    %edx,(%esp)
+  8012e6:	72 2c                	jb     801314 <__umoddi3+0x134>
+  8012e8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012ec:	72 22                	jb     801310 <__umoddi3+0x130>
+  8012ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012f2:	29 c8                	sub    %ecx,%eax
+  8012f4:	19 d7                	sbb    %edx,%edi
+  8012f6:	89 e9                	mov    %ebp,%ecx
+  8012f8:	89 fa                	mov    %edi,%edx
+  8012fa:	d3 e8                	shr    %cl,%eax
+  8012fc:	89 f1                	mov    %esi,%ecx
+  8012fe:	d3 e2                	shl    %cl,%edx
+  801300:	89 e9                	mov    %ebp,%ecx
+  801302:	d3 ef                	shr    %cl,%edi
+  801304:	09 d0                	or     %edx,%eax
+  801306:	89 fa                	mov    %edi,%edx
+  801308:	83 c4 14             	add    $0x14,%esp
+  80130b:	5e                   	pop    %esi
+  80130c:	5f                   	pop    %edi
+  80130d:	5d                   	pop    %ebp
+  80130e:	c3                   	ret    
+  80130f:	90                   	nop
+  801310:	39 d7                	cmp    %edx,%edi
+  801312:	75 da                	jne    8012ee <__umoddi3+0x10e>
+  801314:	8b 14 24             	mov    (%esp),%edx
+  801317:	89 c1                	mov    %eax,%ecx
+  801319:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80131d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801321:	eb cb                	jmp    8012ee <__umoddi3+0x10e>
+  801323:	90                   	nop
+  801324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801328:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80132c:	0f 82 0f ff ff ff    	jb     801241 <__umoddi3+0x61>
+  801332:	e9 1a ff ff ff       	jmp    801251 <__umoddi3+0x71>
diff --git a/obj/user/faultreadkernel.o b/obj/user/faultreadkernel.o
new file mode 100644
index 0000000..b79ebd2
Binary files /dev/null and b/obj/user/faultreadkernel.o differ
diff --git a/obj/user/faultreadkernel.sym b/obj/user/faultreadkernel.sym
new file mode 100644
index 0000000..35a4651
--- /dev/null
+++ b/obj/user/faultreadkernel.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040d5 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+00800052 T libmain
+008000a0 T exit
+008000b4 t putch
+00800110 T vcprintf
+00800174 T cprintf
+0080019a t printnum
+00800278 t getuint
+008002c7 t getint
+0080030e T vprintfmt
+00800855 T printfmt
+00800883 t sprintputch
+008008b8 T vsnprintf
+00800918 T snprintf
+0080094c T strlen
+00800972 T strnlen
+008009a2 T strcpy
+008009d2 T strcat
+00800a02 T strncpy
+00800a47 T strlcpy
+00800a98 T strcmp
+00800ad7 T strncmp
+00800b2d T strchr
+00800b60 T strfind
+00800b8e T memset
+00800bfc T memmove
+00800cd6 T memcpy
+00800cf7 T memcmp
+00800d4f T memfind
+00800d82 T strtol
+00800ee0 t syscall
+00800f41 T sys_cputs
+00800f83 T sys_cgetc
+00800fc7 T sys_env_destroy
+0080100a T sys_getenvid
+0080104e T _panic
+008010b0 T __udivdi3
+008011e0 T __umoddi3
+008013d8 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/faultwrite b/obj/user/faultwrite
new file mode 100755
index 0000000..b9e12b1
Binary files /dev/null and b/obj/user/faultwrite differ
diff --git a/obj/user/faultwrite.asm b/obj/user/faultwrite.asm
new file mode 100644
index 0000000..9fa9846
--- /dev/null
+++ b/obj/user/faultwrite.asm
@@ -0,0 +1,2623 @@
+
+obj/user/faultwrite:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 12 00 00 00       	call   800043 <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+	*(unsigned*)0 = 0;
+  800036:	b8 00 00 00 00       	mov    $0x0,%eax
+  80003b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+  800041:	5d                   	pop    %ebp
+  800042:	c3                   	ret    
+
+00800043 <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  800043:	55                   	push   %ebp
+  800044:	89 e5                	mov    %esp,%ebp
+  800046:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800049:	e8 81 01 00 00       	call   8001cf <sys_getenvid>
+  80004e:	25 ff 03 00 00       	and    $0x3ff,%eax
+  800053:	89 c2                	mov    %eax,%edx
+  800055:	89 d0                	mov    %edx,%eax
+  800057:	01 c0                	add    %eax,%eax
+  800059:	01 d0                	add    %edx,%eax
+  80005b:	c1 e0 05             	shl    $0x5,%eax
+  80005e:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  800063:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800068:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  80006c:	7e 0a                	jle    800078 <libmain+0x35>
+		binaryname = argv[0];
+  80006e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800071:	8b 00                	mov    (%eax),%eax
+  800073:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800078:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80007b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80007f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800082:	89 04 24             	mov    %eax,(%esp)
+  800085:	e8 a9 ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  80008a:	e8 02 00 00 00       	call   800091 <exit>
+}
+  80008f:	c9                   	leave  
+  800090:	c3                   	ret    
+
+00800091 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  800091:	55                   	push   %ebp
+  800092:	89 e5                	mov    %esp,%ebp
+  800094:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  800097:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80009e:	e8 e9 00 00 00       	call   80018c <sys_env_destroy>
+}
+  8000a3:	c9                   	leave  
+  8000a4:	c3                   	ret    
+
+008000a5 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000a5:	55                   	push   %ebp
+  8000a6:	89 e5                	mov    %esp,%ebp
+  8000a8:	57                   	push   %edi
+  8000a9:	56                   	push   %esi
+  8000aa:	53                   	push   %ebx
+  8000ab:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000ae:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000b1:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000b4:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000b7:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000ba:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000bd:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000c0:	cd 30                	int    $0x30
+  8000c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000c9:	74 30                	je     8000fb <syscall+0x56>
+  8000cb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000cf:	7e 2a                	jle    8000fb <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000d4:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000db:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000df:	c7 44 24 08 32 13 80 	movl   $0x801332,0x8(%esp)
+  8000e6:	00 
+  8000e7:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000ee:	00 
+  8000ef:	c7 04 24 4f 13 80 00 	movl   $0x80134f,(%esp)
+  8000f6:	e8 18 01 00 00       	call   800213 <_panic>
+
+	return ret;
+  8000fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  8000fe:	83 c4 3c             	add    $0x3c,%esp
+  800101:	5b                   	pop    %ebx
+  800102:	5e                   	pop    %esi
+  800103:	5f                   	pop    %edi
+  800104:	5d                   	pop    %ebp
+  800105:	c3                   	ret    
+
+00800106 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800106:	55                   	push   %ebp
+  800107:	89 e5                	mov    %esp,%ebp
+  800109:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  80010c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80010f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800116:	00 
+  800117:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80011e:	00 
+  80011f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800126:	00 
+  800127:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80012a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80012e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800132:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800139:	00 
+  80013a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800141:	e8 5f ff ff ff       	call   8000a5 <syscall>
+}
+  800146:	c9                   	leave  
+  800147:	c3                   	ret    
+
+00800148 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800148:	55                   	push   %ebp
+  800149:	89 e5                	mov    %esp,%ebp
+  80014b:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  80014e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800155:	00 
+  800156:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80015d:	00 
+  80015e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800165:	00 
+  800166:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  80016d:	00 
+  80016e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800175:	00 
+  800176:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80017d:	00 
+  80017e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800185:	e8 1b ff ff ff       	call   8000a5 <syscall>
+}
+  80018a:	c9                   	leave  
+  80018b:	c3                   	ret    
+
+0080018c <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  80018c:	55                   	push   %ebp
+  80018d:	89 e5                	mov    %esp,%ebp
+  80018f:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800192:	8b 45 08             	mov    0x8(%ebp),%eax
+  800195:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80019c:	00 
+  80019d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001a4:	00 
+  8001a5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001ac:	00 
+  8001ad:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001b4:	00 
+  8001b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001b9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001c0:	00 
+  8001c1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001c8:	e8 d8 fe ff ff       	call   8000a5 <syscall>
+}
+  8001cd:	c9                   	leave  
+  8001ce:	c3                   	ret    
+
+008001cf <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001cf:	55                   	push   %ebp
+  8001d0:	89 e5                	mov    %esp,%ebp
+  8001d2:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001d5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001dc:	00 
+  8001dd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001e4:	00 
+  8001e5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001ec:	00 
+  8001ed:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001f4:	00 
+  8001f5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  8001fc:	00 
+  8001fd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800204:	00 
+  800205:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  80020c:	e8 94 fe ff ff       	call   8000a5 <syscall>
+}
+  800211:	c9                   	leave  
+  800212:	c3                   	ret    
+
+00800213 <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  800213:	55                   	push   %ebp
+  800214:	89 e5                	mov    %esp,%ebp
+  800216:	53                   	push   %ebx
+  800217:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  80021a:	8d 45 14             	lea    0x14(%ebp),%eax
+  80021d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  800220:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  800226:	e8 a4 ff ff ff       	call   8001cf <sys_getenvid>
+  80022b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80022e:	89 54 24 10          	mov    %edx,0x10(%esp)
+  800232:	8b 55 08             	mov    0x8(%ebp),%edx
+  800235:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800239:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  80023d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800241:	c7 04 24 60 13 80 00 	movl   $0x801360,(%esp)
+  800248:	e8 e1 00 00 00       	call   80032e <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  80024d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800250:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800254:	8b 45 10             	mov    0x10(%ebp),%eax
+  800257:	89 04 24             	mov    %eax,(%esp)
+  80025a:	e8 6b 00 00 00       	call   8002ca <vcprintf>
+	cprintf("\n");
+  80025f:	c7 04 24 83 13 80 00 	movl   $0x801383,(%esp)
+  800266:	e8 c3 00 00 00       	call   80032e <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  80026b:	cc                   	int3   
+  80026c:	eb fd                	jmp    80026b <_panic+0x58>
+
+0080026e <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  80026e:	55                   	push   %ebp
+  80026f:	89 e5                	mov    %esp,%ebp
+  800271:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  800274:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800277:	8b 00                	mov    (%eax),%eax
+  800279:	8d 48 01             	lea    0x1(%eax),%ecx
+  80027c:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80027f:	89 0a                	mov    %ecx,(%edx)
+  800281:	8b 55 08             	mov    0x8(%ebp),%edx
+  800284:	89 d1                	mov    %edx,%ecx
+  800286:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800289:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  80028d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800290:	8b 00                	mov    (%eax),%eax
+  800292:	3d ff 00 00 00       	cmp    $0xff,%eax
+  800297:	75 20                	jne    8002b9 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  800299:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80029c:	8b 00                	mov    (%eax),%eax
+  80029e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8002a1:	83 c2 08             	add    $0x8,%edx
+  8002a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002a8:	89 14 24             	mov    %edx,(%esp)
+  8002ab:	e8 56 fe ff ff       	call   800106 <sys_cputs>
+		b->idx = 0;
+  8002b0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002bc:	8b 40 04             	mov    0x4(%eax),%eax
+  8002bf:	8d 50 01             	lea    0x1(%eax),%edx
+  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c5:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002c8:	c9                   	leave  
+  8002c9:	c3                   	ret    
+
+008002ca <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002ca:	55                   	push   %ebp
+  8002cb:	89 e5                	mov    %esp,%ebp
+  8002cd:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002d3:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002da:	00 00 00 
+	b.cnt = 0;
+  8002dd:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002e4:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002e7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002ee:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002f1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8002f5:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  8002fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002ff:	c7 04 24 6e 02 80 00 	movl   $0x80026e,(%esp)
+  800306:	e8 bd 01 00 00       	call   8004c8 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  80030b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800311:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800315:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  80031b:	83 c0 08             	add    $0x8,%eax
+  80031e:	89 04 24             	mov    %eax,(%esp)
+  800321:	e8 e0 fd ff ff       	call   800106 <sys_cputs>
+
+	return b.cnt;
+  800326:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  80032c:	c9                   	leave  
+  80032d:	c3                   	ret    
+
+0080032e <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  80032e:	55                   	push   %ebp
+  80032f:	89 e5                	mov    %esp,%ebp
+  800331:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  800334:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800337:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  80033a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80033d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800341:	8b 45 08             	mov    0x8(%ebp),%eax
+  800344:	89 04 24             	mov    %eax,(%esp)
+  800347:	e8 7e ff ff ff       	call   8002ca <vcprintf>
+  80034c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  80034f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800352:	c9                   	leave  
+  800353:	c3                   	ret    
+
+00800354 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  800354:	55                   	push   %ebp
+  800355:	89 e5                	mov    %esp,%ebp
+  800357:	53                   	push   %ebx
+  800358:	83 ec 34             	sub    $0x34,%esp
+  80035b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80035e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800361:	8b 45 14             	mov    0x14(%ebp),%eax
+  800364:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800367:	8b 45 18             	mov    0x18(%ebp),%eax
+  80036a:	ba 00 00 00 00       	mov    $0x0,%edx
+  80036f:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800372:	77 72                	ja     8003e6 <printnum+0x92>
+  800374:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800377:	72 05                	jb     80037e <printnum+0x2a>
+  800379:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  80037c:	77 68                	ja     8003e6 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  80037e:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  800381:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  800384:	8b 45 18             	mov    0x18(%ebp),%eax
+  800387:	ba 00 00 00 00       	mov    $0x0,%edx
+  80038c:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800390:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800394:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800397:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80039a:	89 04 24             	mov    %eax,(%esp)
+  80039d:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8003a1:	e8 fa 0c 00 00       	call   8010a0 <__udivdi3>
+  8003a6:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003a9:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003ad:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003b1:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003b4:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003b8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003bc:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003c3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003c7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ca:	89 04 24             	mov    %eax,(%esp)
+  8003cd:	e8 82 ff ff ff       	call   800354 <printnum>
+  8003d2:	eb 1c                	jmp    8003f0 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003d4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003db:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003de:	89 04 24             	mov    %eax,(%esp)
+  8003e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003e4:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003e6:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003ea:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003ee:	7f e4                	jg     8003d4 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003f0:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003f3:	bb 00 00 00 00       	mov    $0x0,%ebx
+  8003f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003fe:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  800402:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800406:	89 04 24             	mov    %eax,(%esp)
+  800409:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80040d:	e8 be 0d 00 00       	call   8011d0 <__umoddi3>
+  800412:	05 10 14 80 00       	add    $0x801410,%eax
+  800417:	0f b6 00             	movzbl (%eax),%eax
+  80041a:	0f be c0             	movsbl %al,%eax
+  80041d:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800420:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800424:	89 04 24             	mov    %eax,(%esp)
+  800427:	8b 45 08             	mov    0x8(%ebp),%eax
+  80042a:	ff d0                	call   *%eax
+}
+  80042c:	83 c4 34             	add    $0x34,%esp
+  80042f:	5b                   	pop    %ebx
+  800430:	5d                   	pop    %ebp
+  800431:	c3                   	ret    
+
+00800432 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800432:	55                   	push   %ebp
+  800433:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800435:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800439:	7e 14                	jle    80044f <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  80043b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80043e:	8b 00                	mov    (%eax),%eax
+  800440:	8d 48 08             	lea    0x8(%eax),%ecx
+  800443:	8b 55 08             	mov    0x8(%ebp),%edx
+  800446:	89 0a                	mov    %ecx,(%edx)
+  800448:	8b 50 04             	mov    0x4(%eax),%edx
+  80044b:	8b 00                	mov    (%eax),%eax
+  80044d:	eb 30                	jmp    80047f <getuint+0x4d>
+	else if (lflag)
+  80044f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800453:	74 16                	je     80046b <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  800455:	8b 45 08             	mov    0x8(%ebp),%eax
+  800458:	8b 00                	mov    (%eax),%eax
+  80045a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80045d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800460:	89 0a                	mov    %ecx,(%edx)
+  800462:	8b 00                	mov    (%eax),%eax
+  800464:	ba 00 00 00 00       	mov    $0x0,%edx
+  800469:	eb 14                	jmp    80047f <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  80046b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80046e:	8b 00                	mov    (%eax),%eax
+  800470:	8d 48 04             	lea    0x4(%eax),%ecx
+  800473:	8b 55 08             	mov    0x8(%ebp),%edx
+  800476:	89 0a                	mov    %ecx,(%edx)
+  800478:	8b 00                	mov    (%eax),%eax
+  80047a:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  80047f:	5d                   	pop    %ebp
+  800480:	c3                   	ret    
+
+00800481 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  800481:	55                   	push   %ebp
+  800482:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800484:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800488:	7e 14                	jle    80049e <getint+0x1d>
+		return va_arg(*ap, long long);
+  80048a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80048d:	8b 00                	mov    (%eax),%eax
+  80048f:	8d 48 08             	lea    0x8(%eax),%ecx
+  800492:	8b 55 08             	mov    0x8(%ebp),%edx
+  800495:	89 0a                	mov    %ecx,(%edx)
+  800497:	8b 50 04             	mov    0x4(%eax),%edx
+  80049a:	8b 00                	mov    (%eax),%eax
+  80049c:	eb 28                	jmp    8004c6 <getint+0x45>
+	else if (lflag)
+  80049e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8004a2:	74 12                	je     8004b6 <getint+0x35>
+		return va_arg(*ap, long);
+  8004a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a7:	8b 00                	mov    (%eax),%eax
+  8004a9:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004ac:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004af:	89 0a                	mov    %ecx,(%edx)
+  8004b1:	8b 00                	mov    (%eax),%eax
+  8004b3:	99                   	cltd   
+  8004b4:	eb 10                	jmp    8004c6 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004b6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b9:	8b 00                	mov    (%eax),%eax
+  8004bb:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004be:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004c1:	89 0a                	mov    %ecx,(%edx)
+  8004c3:	8b 00                	mov    (%eax),%eax
+  8004c5:	99                   	cltd   
+}
+  8004c6:	5d                   	pop    %ebp
+  8004c7:	c3                   	ret    
+
+008004c8 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004c8:	55                   	push   %ebp
+  8004c9:	89 e5                	mov    %esp,%ebp
+  8004cb:	56                   	push   %esi
+  8004cc:	53                   	push   %ebx
+  8004cd:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004d0:	e9 72 01 00 00       	jmp    800647 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004d5:	85 db                	test   %ebx,%ebx
+  8004d7:	75 05                	jne    8004de <vprintfmt+0x16>
+				return;
+  8004d9:	e9 2a 05 00 00       	jmp    800a08 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004de:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004e1:	0f 85 51 01 00 00    	jne    800638 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004e7:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004ea:	8d 50 01             	lea    0x1(%eax),%edx
+  8004ed:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004f0:	0f b6 00             	movzbl (%eax),%eax
+  8004f3:	0f b6 d8             	movzbl %al,%ebx
+  8004f6:	83 fb 5b             	cmp    $0x5b,%ebx
+  8004f9:	74 14                	je     80050f <vprintfmt+0x47>
+				    putch(ch, putdat);
+  8004fb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004fe:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800502:	89 1c 24             	mov    %ebx,(%esp)
+  800505:	8b 45 08             	mov    0x8(%ebp),%eax
+  800508:	ff d0                	call   *%eax
+				    continue;
+  80050a:	e9 38 01 00 00       	jmp    800647 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  80050f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800512:	8d 50 01             	lea    0x1(%eax),%edx
+  800515:	89 55 10             	mov    %edx,0x10(%ebp)
+  800518:	0f b6 00             	movzbl (%eax),%eax
+  80051b:	0f b6 c0             	movzbl %al,%eax
+  80051e:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  800523:	8b 45 10             	mov    0x10(%ebp),%eax
+  800526:	8d 50 01             	lea    0x1(%eax),%edx
+  800529:	89 55 10             	mov    %edx,0x10(%ebp)
+  80052c:	0f b6 00             	movzbl (%eax),%eax
+  80052f:	0f b6 c0             	movzbl %al,%eax
+  800532:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800537:	a1 08 20 80 00       	mov    0x802008,%eax
+  80053c:	83 f8 2f             	cmp    $0x2f,%eax
+  80053f:	7e 19                	jle    80055a <vprintfmt+0x92>
+  800541:	a1 08 20 80 00       	mov    0x802008,%eax
+  800546:	83 f8 39             	cmp    $0x39,%eax
+  800549:	7f 0f                	jg     80055a <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  80054b:	a1 08 20 80 00       	mov    0x802008,%eax
+  800550:	83 e8 30             	sub    $0x30,%eax
+  800553:	a3 08 20 80 00       	mov    %eax,0x802008
+  800558:	eb 50                	jmp    8005aa <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  80055a:	a1 08 20 80 00       	mov    0x802008,%eax
+  80055f:	83 f8 60             	cmp    $0x60,%eax
+  800562:	7e 19                	jle    80057d <vprintfmt+0xb5>
+  800564:	a1 08 20 80 00       	mov    0x802008,%eax
+  800569:	83 f8 66             	cmp    $0x66,%eax
+  80056c:	7f 0f                	jg     80057d <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  80056e:	a1 08 20 80 00       	mov    0x802008,%eax
+  800573:	83 e8 57             	sub    $0x57,%eax
+  800576:	a3 08 20 80 00       	mov    %eax,0x802008
+  80057b:	eb 2d                	jmp    8005aa <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  80057d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800582:	83 f8 40             	cmp    $0x40,%eax
+  800585:	7e 19                	jle    8005a0 <vprintfmt+0xd8>
+  800587:	a1 08 20 80 00       	mov    0x802008,%eax
+  80058c:	83 f8 46             	cmp    $0x46,%eax
+  80058f:	7f 0f                	jg     8005a0 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  800591:	a1 08 20 80 00       	mov    0x802008,%eax
+  800596:	83 e8 37             	sub    $0x37,%eax
+  800599:	a3 08 20 80 00       	mov    %eax,0x802008
+  80059e:	eb 0a                	jmp    8005aa <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8005a0:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8005a7:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005aa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005af:	83 f8 2f             	cmp    $0x2f,%eax
+  8005b2:	7e 19                	jle    8005cd <vprintfmt+0x105>
+  8005b4:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005b9:	83 f8 39             	cmp    $0x39,%eax
+  8005bc:	7f 0f                	jg     8005cd <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005be:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005c3:	83 e8 30             	sub    $0x30,%eax
+  8005c6:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005cb:	eb 50                	jmp    80061d <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005cd:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005d2:	83 f8 60             	cmp    $0x60,%eax
+  8005d5:	7e 19                	jle    8005f0 <vprintfmt+0x128>
+  8005d7:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005dc:	83 f8 66             	cmp    $0x66,%eax
+  8005df:	7f 0f                	jg     8005f0 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005e1:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005e6:	83 e8 57             	sub    $0x57,%eax
+  8005e9:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005ee:	eb 2d                	jmp    80061d <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005f0:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f5:	83 f8 40             	cmp    $0x40,%eax
+  8005f8:	7e 19                	jle    800613 <vprintfmt+0x14b>
+  8005fa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005ff:	83 f8 46             	cmp    $0x46,%eax
+  800602:	7f 0f                	jg     800613 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  800604:	a1 10 20 80 00       	mov    0x802010,%eax
+  800609:	83 e8 37             	sub    $0x37,%eax
+  80060c:	a3 10 20 80 00       	mov    %eax,0x802010
+  800611:	eb 0a                	jmp    80061d <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  800613:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  80061a:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  80061d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800622:	c1 e0 0c             	shl    $0xc,%eax
+  800625:	89 c2                	mov    %eax,%edx
+  800627:	a1 10 20 80 00       	mov    0x802010,%eax
+  80062c:	c1 e0 08             	shl    $0x8,%eax
+  80062f:	09 d0                	or     %edx,%eax
+  800631:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800636:	eb 0f                	jmp    800647 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800638:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80063b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80063f:	89 1c 24             	mov    %ebx,(%esp)
+  800642:	8b 45 08             	mov    0x8(%ebp),%eax
+  800645:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800647:	8b 45 10             	mov    0x10(%ebp),%eax
+  80064a:	8d 50 01             	lea    0x1(%eax),%edx
+  80064d:	89 55 10             	mov    %edx,0x10(%ebp)
+  800650:	0f b6 00             	movzbl (%eax),%eax
+  800653:	0f b6 d8             	movzbl %al,%ebx
+  800656:	83 fb 25             	cmp    $0x25,%ebx
+  800659:	0f 85 76 fe ff ff    	jne    8004d5 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  80065f:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  800663:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  80066a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  800671:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800678:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  80067f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800682:	8d 50 01             	lea    0x1(%eax),%edx
+  800685:	89 55 10             	mov    %edx,0x10(%ebp)
+  800688:	0f b6 00             	movzbl (%eax),%eax
+  80068b:	0f b6 d8             	movzbl %al,%ebx
+  80068e:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800691:	83 f8 55             	cmp    $0x55,%eax
+  800694:	0f 87 3d 03 00 00    	ja     8009d7 <vprintfmt+0x50f>
+  80069a:	8b 04 85 34 14 80 00 	mov    0x801434(,%eax,4),%eax
+  8006a1:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8006a3:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006a7:	eb d6                	jmp    80067f <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006a9:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006ad:	eb d0                	jmp    80067f <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006b6:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006b9:	89 d0                	mov    %edx,%eax
+  8006bb:	c1 e0 02             	shl    $0x2,%eax
+  8006be:	01 d0                	add    %edx,%eax
+  8006c0:	01 c0                	add    %eax,%eax
+  8006c2:	01 d8                	add    %ebx,%eax
+  8006c4:	83 e8 30             	sub    $0x30,%eax
+  8006c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006ca:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006cd:	0f b6 00             	movzbl (%eax),%eax
+  8006d0:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006d3:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006d6:	7e 0b                	jle    8006e3 <vprintfmt+0x21b>
+  8006d8:	83 fb 39             	cmp    $0x39,%ebx
+  8006db:	7f 06                	jg     8006e3 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006dd:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006e1:	eb d3                	jmp    8006b6 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006e3:	eb 33                	jmp    800718 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006e5:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006e8:	8d 50 04             	lea    0x4(%eax),%edx
+  8006eb:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006ee:	8b 00                	mov    (%eax),%eax
+  8006f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006f3:	eb 23                	jmp    800718 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  8006f5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006f9:	79 0c                	jns    800707 <vprintfmt+0x23f>
+				width = 0;
+  8006fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  800702:	e9 78 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+  800707:	e9 73 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  80070c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  800713:	e9 67 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800718:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80071c:	79 12                	jns    800730 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  80071e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800721:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800724:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  80072b:	e9 4f ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+  800730:	e9 4a ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800735:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800739:	e9 41 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  80073e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800741:	8d 50 04             	lea    0x4(%eax),%edx
+  800744:	89 55 14             	mov    %edx,0x14(%ebp)
+  800747:	8b 00                	mov    (%eax),%eax
+  800749:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80074c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800750:	89 04 24             	mov    %eax,(%esp)
+  800753:	8b 45 08             	mov    0x8(%ebp),%eax
+  800756:	ff d0                	call   *%eax
+			break;
+  800758:	e9 a5 02 00 00       	jmp    800a02 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  80075d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800760:	8d 50 04             	lea    0x4(%eax),%edx
+  800763:	89 55 14             	mov    %edx,0x14(%ebp)
+  800766:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800768:	85 db                	test   %ebx,%ebx
+  80076a:	79 02                	jns    80076e <vprintfmt+0x2a6>
+				err = -err;
+  80076c:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  80076e:	83 fb 06             	cmp    $0x6,%ebx
+  800771:	7f 0b                	jg     80077e <vprintfmt+0x2b6>
+  800773:	8b 34 9d f4 13 80 00 	mov    0x8013f4(,%ebx,4),%esi
+  80077a:	85 f6                	test   %esi,%esi
+  80077c:	75 23                	jne    8007a1 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  80077e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800782:	c7 44 24 08 21 14 80 	movl   $0x801421,0x8(%esp)
+  800789:	00 
+  80078a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800791:	8b 45 08             	mov    0x8(%ebp),%eax
+  800794:	89 04 24             	mov    %eax,(%esp)
+  800797:	e8 73 02 00 00       	call   800a0f <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  80079c:	e9 61 02 00 00       	jmp    800a02 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8007a1:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007a5:	c7 44 24 08 2a 14 80 	movl   $0x80142a,0x8(%esp)
+  8007ac:	00 
+  8007ad:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007b7:	89 04 24             	mov    %eax,(%esp)
+  8007ba:	e8 50 02 00 00       	call   800a0f <printfmt>
+			break;
+  8007bf:	e9 3e 02 00 00       	jmp    800a02 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007c4:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007c7:	8d 50 04             	lea    0x4(%eax),%edx
+  8007ca:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007cd:	8b 30                	mov    (%eax),%esi
+  8007cf:	85 f6                	test   %esi,%esi
+  8007d1:	75 05                	jne    8007d8 <vprintfmt+0x310>
+				p = "(null)";
+  8007d3:	be 2d 14 80 00       	mov    $0x80142d,%esi
+			if (width > 0 && padc != '-')
+  8007d8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007dc:	7e 37                	jle    800815 <vprintfmt+0x34d>
+  8007de:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007e2:	74 31                	je     800815 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007e7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007eb:	89 34 24             	mov    %esi,(%esp)
+  8007ee:	e8 39 03 00 00       	call   800b2c <strnlen>
+  8007f3:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  8007f6:	eb 17                	jmp    80080f <vprintfmt+0x347>
+					putch(padc, putdat);
+  8007f8:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  8007fc:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8007ff:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800803:	89 04 24             	mov    %eax,(%esp)
+  800806:	8b 45 08             	mov    0x8(%ebp),%eax
+  800809:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80080b:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80080f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800813:	7f e3                	jg     8007f8 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800815:	eb 38                	jmp    80084f <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800817:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  80081b:	74 1f                	je     80083c <vprintfmt+0x374>
+  80081d:	83 fb 1f             	cmp    $0x1f,%ebx
+  800820:	7e 05                	jle    800827 <vprintfmt+0x35f>
+  800822:	83 fb 7e             	cmp    $0x7e,%ebx
+  800825:	7e 15                	jle    80083c <vprintfmt+0x374>
+					putch('?', putdat);
+  800827:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80082a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80082e:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800835:	8b 45 08             	mov    0x8(%ebp),%eax
+  800838:	ff d0                	call   *%eax
+  80083a:	eb 0f                	jmp    80084b <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  80083c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80083f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800843:	89 1c 24             	mov    %ebx,(%esp)
+  800846:	8b 45 08             	mov    0x8(%ebp),%eax
+  800849:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80084b:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80084f:	89 f0                	mov    %esi,%eax
+  800851:	8d 70 01             	lea    0x1(%eax),%esi
+  800854:	0f b6 00             	movzbl (%eax),%eax
+  800857:	0f be d8             	movsbl %al,%ebx
+  80085a:	85 db                	test   %ebx,%ebx
+  80085c:	74 10                	je     80086e <vprintfmt+0x3a6>
+  80085e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800862:	78 b3                	js     800817 <vprintfmt+0x34f>
+  800864:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800868:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80086c:	79 a9                	jns    800817 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80086e:	eb 17                	jmp    800887 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  800870:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800873:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800877:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  80087e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800881:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  800883:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800887:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80088b:	7f e3                	jg     800870 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  80088d:	e9 70 01 00 00       	jmp    800a02 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  800892:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800895:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800899:	8d 45 14             	lea    0x14(%ebp),%eax
+  80089c:	89 04 24             	mov    %eax,(%esp)
+  80089f:	e8 dd fb ff ff       	call   800481 <getint>
+  8008a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008a7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008b0:	85 d2                	test   %edx,%edx
+  8008b2:	79 26                	jns    8008da <vprintfmt+0x412>
+				putch('-', putdat);
+  8008b4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008bb:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008c5:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008cd:	f7 d8                	neg    %eax
+  8008cf:	83 d2 00             	adc    $0x0,%edx
+  8008d2:	f7 da                	neg    %edx
+  8008d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008d7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008da:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008e1:	e9 a8 00 00 00       	jmp    80098e <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008ed:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008f0:	89 04 24             	mov    %eax,(%esp)
+  8008f3:	e8 3a fb ff ff       	call   800432 <getuint>
+  8008f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008fb:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  8008fe:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800905:	e9 84 00 00 00       	jmp    80098e <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  80090a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80090d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800911:	8d 45 14             	lea    0x14(%ebp),%eax
+  800914:	89 04 24             	mov    %eax,(%esp)
+  800917:	e8 16 fb ff ff       	call   800432 <getuint>
+  80091c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80091f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800922:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800929:	eb 63                	jmp    80098e <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  80092b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80092e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800932:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800939:	8b 45 08             	mov    0x8(%ebp),%eax
+  80093c:	ff d0                	call   *%eax
+			putch('x', putdat);
+  80093e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800941:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800945:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  800951:	8b 45 14             	mov    0x14(%ebp),%eax
+  800954:	8d 50 04             	lea    0x4(%eax),%edx
+  800957:	89 55 14             	mov    %edx,0x14(%ebp)
+  80095a:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  80095c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80095f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800966:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  80096d:	eb 1f                	jmp    80098e <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  80096f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800972:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800976:	8d 45 14             	lea    0x14(%ebp),%eax
+  800979:	89 04 24             	mov    %eax,(%esp)
+  80097c:	e8 b1 fa ff ff       	call   800432 <getuint>
+  800981:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800984:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800987:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  80098e:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800992:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800995:	89 54 24 18          	mov    %edx,0x18(%esp)
+  800999:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  80099c:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8009a0:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8009a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009aa:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009ae:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009b2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009b5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009bc:	89 04 24             	mov    %eax,(%esp)
+  8009bf:	e8 90 f9 ff ff       	call   800354 <printnum>
+			break;
+  8009c4:	eb 3c                	jmp    800a02 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009cd:	89 1c 24             	mov    %ebx,(%esp)
+  8009d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009d3:	ff d0                	call   *%eax
+			break;			
+  8009d5:	eb 2b                	jmp    800a02 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009d7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009da:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009de:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e8:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009ea:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009ee:	eb 04                	jmp    8009f4 <vprintfmt+0x52c>
+  8009f0:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009f4:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f7:	83 e8 01             	sub    $0x1,%eax
+  8009fa:	0f b6 00             	movzbl (%eax),%eax
+  8009fd:	3c 25                	cmp    $0x25,%al
+  8009ff:	75 ef                	jne    8009f0 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800a01:	90                   	nop
+		}
+	}
+  800a02:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800a03:	e9 3f fc ff ff       	jmp    800647 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a08:	83 c4 40             	add    $0x40,%esp
+  800a0b:	5b                   	pop    %ebx
+  800a0c:	5e                   	pop    %esi
+  800a0d:	5d                   	pop    %ebp
+  800a0e:	c3                   	ret    
+
+00800a0f <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a0f:	55                   	push   %ebp
+  800a10:	89 e5                	mov    %esp,%ebp
+  800a12:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a15:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a18:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a1e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a22:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a25:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a29:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a2c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a30:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a33:	89 04 24             	mov    %eax,(%esp)
+  800a36:	e8 8d fa ff ff       	call   8004c8 <vprintfmt>
+	va_end(ap);
+}
+  800a3b:	c9                   	leave  
+  800a3c:	c3                   	ret    
+
+00800a3d <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a3d:	55                   	push   %ebp
+  800a3e:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a43:	8b 40 08             	mov    0x8(%eax),%eax
+  800a46:	8d 50 01             	lea    0x1(%eax),%edx
+  800a49:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4c:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a52:	8b 10                	mov    (%eax),%edx
+  800a54:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a57:	8b 40 04             	mov    0x4(%eax),%eax
+  800a5a:	39 c2                	cmp    %eax,%edx
+  800a5c:	73 12                	jae    800a70 <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a61:	8b 00                	mov    (%eax),%eax
+  800a63:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a66:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a69:	89 0a                	mov    %ecx,(%edx)
+  800a6b:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a6e:	88 10                	mov    %dl,(%eax)
+}
+  800a70:	5d                   	pop    %ebp
+  800a71:	c3                   	ret    
+
+00800a72 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a72:	55                   	push   %ebp
+  800a73:	89 e5                	mov    %esp,%ebp
+  800a75:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a78:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a81:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a84:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a87:	01 d0                	add    %edx,%eax
+  800a89:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a93:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800a97:	74 06                	je     800a9f <vsnprintf+0x2d>
+  800a99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800a9d:	7f 07                	jg     800aa6 <vsnprintf+0x34>
+		return -E_INVAL;
+  800a9f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800aa4:	eb 2a                	jmp    800ad0 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800aa6:	8b 45 14             	mov    0x14(%ebp),%eax
+  800aa9:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800aad:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ab0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ab4:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ab7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800abb:	c7 04 24 3d 0a 80 00 	movl   $0x800a3d,(%esp)
+  800ac2:	e8 01 fa ff ff       	call   8004c8 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ac7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800aca:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800ad0:	c9                   	leave  
+  800ad1:	c3                   	ret    
+
+00800ad2 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800ad2:	55                   	push   %ebp
+  800ad3:	89 e5                	mov    %esp,%ebp
+  800ad5:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ad8:	8d 45 14             	lea    0x14(%ebp),%eax
+  800adb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800ade:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800ae1:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800ae5:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ae8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800aec:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800aef:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800af3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800af6:	89 04 24             	mov    %eax,(%esp)
+  800af9:	e8 74 ff ff ff       	call   800a72 <vsnprintf>
+  800afe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800b01:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800b04:	c9                   	leave  
+  800b05:	c3                   	ret    
+
+00800b06 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b06:	55                   	push   %ebp
+  800b07:	89 e5                	mov    %esp,%ebp
+  800b09:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b13:	eb 08                	jmp    800b1d <strlen+0x17>
+		n++;
+  800b15:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b19:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b1d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b20:	0f b6 00             	movzbl (%eax),%eax
+  800b23:	84 c0                	test   %al,%al
+  800b25:	75 ee                	jne    800b15 <strlen+0xf>
+		n++;
+	return n;
+  800b27:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b2a:	c9                   	leave  
+  800b2b:	c3                   	ret    
+
+00800b2c <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b2c:	55                   	push   %ebp
+  800b2d:	89 e5                	mov    %esp,%ebp
+  800b2f:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b32:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b39:	eb 0c                	jmp    800b47 <strnlen+0x1b>
+		n++;
+  800b3b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b43:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b47:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b4b:	74 0a                	je     800b57 <strnlen+0x2b>
+  800b4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b50:	0f b6 00             	movzbl (%eax),%eax
+  800b53:	84 c0                	test   %al,%al
+  800b55:	75 e4                	jne    800b3b <strnlen+0xf>
+		n++;
+	return n;
+  800b57:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b5a:	c9                   	leave  
+  800b5b:	c3                   	ret    
+
+00800b5c <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b5c:	55                   	push   %ebp
+  800b5d:	89 e5                	mov    %esp,%ebp
+  800b5f:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b62:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b65:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b68:	90                   	nop
+  800b69:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b6c:	8d 50 01             	lea    0x1(%eax),%edx
+  800b6f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b72:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b75:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b78:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b7b:	0f b6 12             	movzbl (%edx),%edx
+  800b7e:	88 10                	mov    %dl,(%eax)
+  800b80:	0f b6 00             	movzbl (%eax),%eax
+  800b83:	84 c0                	test   %al,%al
+  800b85:	75 e2                	jne    800b69 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b87:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b8a:	c9                   	leave  
+  800b8b:	c3                   	ret    
+
+00800b8c <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b8c:	55                   	push   %ebp
+  800b8d:	89 e5                	mov    %esp,%ebp
+  800b8f:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b92:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b95:	89 04 24             	mov    %eax,(%esp)
+  800b98:	e8 69 ff ff ff       	call   800b06 <strlen>
+  800b9d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800ba0:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800ba3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba6:	01 c2                	add    %eax,%edx
+  800ba8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bab:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800baf:	89 14 24             	mov    %edx,(%esp)
+  800bb2:	e8 a5 ff ff ff       	call   800b5c <strcpy>
+	return dst;
+  800bb7:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bba:	c9                   	leave  
+  800bbb:	c3                   	ret    
+
+00800bbc <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bbc:	55                   	push   %ebp
+  800bbd:	89 e5                	mov    %esp,%ebp
+  800bbf:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bc2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc5:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bc8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bcf:	eb 23                	jmp    800bf4 <strncpy+0x38>
+		*dst++ = *src;
+  800bd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd4:	8d 50 01             	lea    0x1(%eax),%edx
+  800bd7:	89 55 08             	mov    %edx,0x8(%ebp)
+  800bda:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800bdd:	0f b6 12             	movzbl (%edx),%edx
+  800be0:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800be2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800be5:	0f b6 00             	movzbl (%eax),%eax
+  800be8:	84 c0                	test   %al,%al
+  800bea:	74 04                	je     800bf0 <strncpy+0x34>
+			src++;
+  800bec:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800bf0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800bf4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800bf7:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800bfa:	72 d5                	jb     800bd1 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800bfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800bff:	c9                   	leave  
+  800c00:	c3                   	ret    
+
+00800c01 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800c01:	55                   	push   %ebp
+  800c02:	89 e5                	mov    %esp,%ebp
+  800c04:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c07:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c0a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c0d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c11:	74 33                	je     800c46 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c13:	eb 17                	jmp    800c2c <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c18:	8d 50 01             	lea    0x1(%eax),%edx
+  800c1b:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c1e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c21:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c24:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c27:	0f b6 12             	movzbl (%edx),%edx
+  800c2a:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c2c:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c30:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c34:	74 0a                	je     800c40 <strlcpy+0x3f>
+  800c36:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c39:	0f b6 00             	movzbl (%eax),%eax
+  800c3c:	84 c0                	test   %al,%al
+  800c3e:	75 d5                	jne    800c15 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c40:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c43:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c46:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c49:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c4c:	29 c2                	sub    %eax,%edx
+  800c4e:	89 d0                	mov    %edx,%eax
+}
+  800c50:	c9                   	leave  
+  800c51:	c3                   	ret    
+
+00800c52 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c52:	55                   	push   %ebp
+  800c53:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c55:	eb 08                	jmp    800c5f <strcmp+0xd>
+		p++, q++;
+  800c57:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c5b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c5f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c62:	0f b6 00             	movzbl (%eax),%eax
+  800c65:	84 c0                	test   %al,%al
+  800c67:	74 10                	je     800c79 <strcmp+0x27>
+  800c69:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c6c:	0f b6 10             	movzbl (%eax),%edx
+  800c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c72:	0f b6 00             	movzbl (%eax),%eax
+  800c75:	38 c2                	cmp    %al,%dl
+  800c77:	74 de                	je     800c57 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c79:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c7c:	0f b6 00             	movzbl (%eax),%eax
+  800c7f:	0f b6 d0             	movzbl %al,%edx
+  800c82:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c85:	0f b6 00             	movzbl (%eax),%eax
+  800c88:	0f b6 c0             	movzbl %al,%eax
+  800c8b:	29 c2                	sub    %eax,%edx
+  800c8d:	89 d0                	mov    %edx,%eax
+}
+  800c8f:	5d                   	pop    %ebp
+  800c90:	c3                   	ret    
+
+00800c91 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c91:	55                   	push   %ebp
+  800c92:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800c94:	eb 0c                	jmp    800ca2 <strncmp+0x11>
+		n--, p++, q++;
+  800c96:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c9a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c9e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800ca2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800ca6:	74 1a                	je     800cc2 <strncmp+0x31>
+  800ca8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cab:	0f b6 00             	movzbl (%eax),%eax
+  800cae:	84 c0                	test   %al,%al
+  800cb0:	74 10                	je     800cc2 <strncmp+0x31>
+  800cb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb5:	0f b6 10             	movzbl (%eax),%edx
+  800cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cbb:	0f b6 00             	movzbl (%eax),%eax
+  800cbe:	38 c2                	cmp    %al,%dl
+  800cc0:	74 d4                	je     800c96 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800cc2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cc6:	75 07                	jne    800ccf <strncmp+0x3e>
+		return 0;
+  800cc8:	b8 00 00 00 00       	mov    $0x0,%eax
+  800ccd:	eb 16                	jmp    800ce5 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800ccf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cd2:	0f b6 00             	movzbl (%eax),%eax
+  800cd5:	0f b6 d0             	movzbl %al,%edx
+  800cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cdb:	0f b6 00             	movzbl (%eax),%eax
+  800cde:	0f b6 c0             	movzbl %al,%eax
+  800ce1:	29 c2                	sub    %eax,%edx
+  800ce3:	89 d0                	mov    %edx,%eax
+}
+  800ce5:	5d                   	pop    %ebp
+  800ce6:	c3                   	ret    
+
+00800ce7 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800ce7:	55                   	push   %ebp
+  800ce8:	89 e5                	mov    %esp,%ebp
+  800cea:	83 ec 04             	sub    $0x4,%esp
+  800ced:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cf0:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cf3:	eb 14                	jmp    800d09 <strchr+0x22>
+		if (*s == c)
+  800cf5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cf8:	0f b6 00             	movzbl (%eax),%eax
+  800cfb:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800cfe:	75 05                	jne    800d05 <strchr+0x1e>
+			return (char *) s;
+  800d00:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d03:	eb 13                	jmp    800d18 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d05:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d09:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d0c:	0f b6 00             	movzbl (%eax),%eax
+  800d0f:	84 c0                	test   %al,%al
+  800d11:	75 e2                	jne    800cf5 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d13:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d18:	c9                   	leave  
+  800d19:	c3                   	ret    
+
+00800d1a <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d1a:	55                   	push   %ebp
+  800d1b:	89 e5                	mov    %esp,%ebp
+  800d1d:	83 ec 04             	sub    $0x4,%esp
+  800d20:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d23:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d26:	eb 11                	jmp    800d39 <strfind+0x1f>
+		if (*s == c)
+  800d28:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d2b:	0f b6 00             	movzbl (%eax),%eax
+  800d2e:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d31:	75 02                	jne    800d35 <strfind+0x1b>
+			break;
+  800d33:	eb 0e                	jmp    800d43 <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d35:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d39:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d3c:	0f b6 00             	movzbl (%eax),%eax
+  800d3f:	84 c0                	test   %al,%al
+  800d41:	75 e5                	jne    800d28 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d43:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d46:	c9                   	leave  
+  800d47:	c3                   	ret    
+
+00800d48 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d48:	55                   	push   %ebp
+  800d49:	89 e5                	mov    %esp,%ebp
+  800d4b:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d4c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d50:	75 05                	jne    800d57 <memset+0xf>
+		return v;
+  800d52:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d55:	eb 5c                	jmp    800db3 <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d57:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d5a:	83 e0 03             	and    $0x3,%eax
+  800d5d:	85 c0                	test   %eax,%eax
+  800d5f:	75 41                	jne    800da2 <memset+0x5a>
+  800d61:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d64:	83 e0 03             	and    $0x3,%eax
+  800d67:	85 c0                	test   %eax,%eax
+  800d69:	75 37                	jne    800da2 <memset+0x5a>
+		c &= 0xFF;
+  800d6b:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d72:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d75:	c1 e0 18             	shl    $0x18,%eax
+  800d78:	89 c2                	mov    %eax,%edx
+  800d7a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7d:	c1 e0 10             	shl    $0x10,%eax
+  800d80:	09 c2                	or     %eax,%edx
+  800d82:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d85:	c1 e0 08             	shl    $0x8,%eax
+  800d88:	09 d0                	or     %edx,%eax
+  800d8a:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d8d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d90:	c1 e8 02             	shr    $0x2,%eax
+  800d93:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800d95:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d98:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d9b:	89 d7                	mov    %edx,%edi
+  800d9d:	fc                   	cld    
+  800d9e:	f3 ab                	rep stos %eax,%es:(%edi)
+  800da0:	eb 0e                	jmp    800db0 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800da2:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da8:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800dab:	89 d7                	mov    %edx,%edi
+  800dad:	fc                   	cld    
+  800dae:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800db0:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800db3:	5f                   	pop    %edi
+  800db4:	5d                   	pop    %ebp
+  800db5:	c3                   	ret    
+
+00800db6 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800db6:	55                   	push   %ebp
+  800db7:	89 e5                	mov    %esp,%ebp
+  800db9:	57                   	push   %edi
+  800dba:	56                   	push   %esi
+  800dbb:	53                   	push   %ebx
+  800dbc:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dce:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dd1:	73 6d                	jae    800e40 <memmove+0x8a>
+  800dd3:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dd6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800dd9:	01 d0                	add    %edx,%eax
+  800ddb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dde:	76 60                	jbe    800e40 <memmove+0x8a>
+		s += n;
+  800de0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de3:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800de6:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de9:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800def:	83 e0 03             	and    $0x3,%eax
+  800df2:	85 c0                	test   %eax,%eax
+  800df4:	75 2f                	jne    800e25 <memmove+0x6f>
+  800df6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800df9:	83 e0 03             	and    $0x3,%eax
+  800dfc:	85 c0                	test   %eax,%eax
+  800dfe:	75 25                	jne    800e25 <memmove+0x6f>
+  800e00:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e03:	83 e0 03             	and    $0x3,%eax
+  800e06:	85 c0                	test   %eax,%eax
+  800e08:	75 1b                	jne    800e25 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e0d:	83 e8 04             	sub    $0x4,%eax
+  800e10:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e13:	83 ea 04             	sub    $0x4,%edx
+  800e16:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e19:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e1c:	89 c7                	mov    %eax,%edi
+  800e1e:	89 d6                	mov    %edx,%esi
+  800e20:	fd                   	std    
+  800e21:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e23:	eb 18                	jmp    800e3d <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e25:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e28:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e2e:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e31:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e34:	89 d7                	mov    %edx,%edi
+  800e36:	89 de                	mov    %ebx,%esi
+  800e38:	89 c1                	mov    %eax,%ecx
+  800e3a:	fd                   	std    
+  800e3b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e3d:	fc                   	cld    
+  800e3e:	eb 45                	jmp    800e85 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e40:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e43:	83 e0 03             	and    $0x3,%eax
+  800e46:	85 c0                	test   %eax,%eax
+  800e48:	75 2b                	jne    800e75 <memmove+0xbf>
+  800e4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e4d:	83 e0 03             	and    $0x3,%eax
+  800e50:	85 c0                	test   %eax,%eax
+  800e52:	75 21                	jne    800e75 <memmove+0xbf>
+  800e54:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e57:	83 e0 03             	and    $0x3,%eax
+  800e5a:	85 c0                	test   %eax,%eax
+  800e5c:	75 17                	jne    800e75 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e5e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e61:	c1 e8 02             	shr    $0x2,%eax
+  800e64:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e66:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e69:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e6c:	89 c7                	mov    %eax,%edi
+  800e6e:	89 d6                	mov    %edx,%esi
+  800e70:	fc                   	cld    
+  800e71:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e73:	eb 10                	jmp    800e85 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e75:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e78:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e7b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e7e:	89 c7                	mov    %eax,%edi
+  800e80:	89 d6                	mov    %edx,%esi
+  800e82:	fc                   	cld    
+  800e83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e85:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e88:	83 c4 10             	add    $0x10,%esp
+  800e8b:	5b                   	pop    %ebx
+  800e8c:	5e                   	pop    %esi
+  800e8d:	5f                   	pop    %edi
+  800e8e:	5d                   	pop    %ebp
+  800e8f:	c3                   	ret    
+
+00800e90 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e90:	55                   	push   %ebp
+  800e91:	89 e5                	mov    %esp,%ebp
+  800e93:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800e96:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e99:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800e9d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ea0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ea4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ea7:	89 04 24             	mov    %eax,(%esp)
+  800eaa:	e8 07 ff ff ff       	call   800db6 <memmove>
+}
+  800eaf:	c9                   	leave  
+  800eb0:	c3                   	ret    
+
+00800eb1 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800eb1:	55                   	push   %ebp
+  800eb2:	89 e5                	mov    %esp,%ebp
+  800eb4:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800eb7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eba:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800ebd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ec0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ec3:	eb 30                	jmp    800ef5 <memcmp+0x44>
+		if (*s1 != *s2)
+  800ec5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ec8:	0f b6 10             	movzbl (%eax),%edx
+  800ecb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ece:	0f b6 00             	movzbl (%eax),%eax
+  800ed1:	38 c2                	cmp    %al,%dl
+  800ed3:	74 18                	je     800eed <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ed5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed8:	0f b6 00             	movzbl (%eax),%eax
+  800edb:	0f b6 d0             	movzbl %al,%edx
+  800ede:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ee1:	0f b6 00             	movzbl (%eax),%eax
+  800ee4:	0f b6 c0             	movzbl %al,%eax
+  800ee7:	29 c2                	sub    %eax,%edx
+  800ee9:	89 d0                	mov    %edx,%eax
+  800eeb:	eb 1a                	jmp    800f07 <memcmp+0x56>
+		s1++, s2++;
+  800eed:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800ef1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800ef5:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ef8:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800efb:	89 55 10             	mov    %edx,0x10(%ebp)
+  800efe:	85 c0                	test   %eax,%eax
+  800f00:	75 c3                	jne    800ec5 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800f02:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f07:	c9                   	leave  
+  800f08:	c3                   	ret    
+
+00800f09 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f09:	55                   	push   %ebp
+  800f0a:	89 e5                	mov    %esp,%ebp
+  800f0c:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f0f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f12:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f15:	01 d0                	add    %edx,%eax
+  800f17:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f1a:	eb 13                	jmp    800f2f <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f1c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f1f:	0f b6 10             	movzbl (%eax),%edx
+  800f22:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f25:	38 c2                	cmp    %al,%dl
+  800f27:	75 02                	jne    800f2b <memfind+0x22>
+			break;
+  800f29:	eb 0c                	jmp    800f37 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f2b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f2f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f32:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f35:	72 e5                	jb     800f1c <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f37:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f3a:	c9                   	leave  
+  800f3b:	c3                   	ret    
+
+00800f3c <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f3c:	55                   	push   %ebp
+  800f3d:	89 e5                	mov    %esp,%ebp
+  800f3f:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f42:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f49:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f50:	eb 04                	jmp    800f56 <strtol+0x1a>
+		s++;
+  800f52:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f56:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f59:	0f b6 00             	movzbl (%eax),%eax
+  800f5c:	3c 20                	cmp    $0x20,%al
+  800f5e:	74 f2                	je     800f52 <strtol+0x16>
+  800f60:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f63:	0f b6 00             	movzbl (%eax),%eax
+  800f66:	3c 09                	cmp    $0x9,%al
+  800f68:	74 e8                	je     800f52 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f6a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f6d:	0f b6 00             	movzbl (%eax),%eax
+  800f70:	3c 2b                	cmp    $0x2b,%al
+  800f72:	75 06                	jne    800f7a <strtol+0x3e>
+		s++;
+  800f74:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f78:	eb 15                	jmp    800f8f <strtol+0x53>
+	else if (*s == '-')
+  800f7a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f7d:	0f b6 00             	movzbl (%eax),%eax
+  800f80:	3c 2d                	cmp    $0x2d,%al
+  800f82:	75 0b                	jne    800f8f <strtol+0x53>
+		s++, neg = 1;
+  800f84:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f88:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f8f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f93:	74 06                	je     800f9b <strtol+0x5f>
+  800f95:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800f99:	75 24                	jne    800fbf <strtol+0x83>
+  800f9b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f9e:	0f b6 00             	movzbl (%eax),%eax
+  800fa1:	3c 30                	cmp    $0x30,%al
+  800fa3:	75 1a                	jne    800fbf <strtol+0x83>
+  800fa5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fa8:	83 c0 01             	add    $0x1,%eax
+  800fab:	0f b6 00             	movzbl (%eax),%eax
+  800fae:	3c 78                	cmp    $0x78,%al
+  800fb0:	75 0d                	jne    800fbf <strtol+0x83>
+		s += 2, base = 16;
+  800fb2:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fb6:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fbd:	eb 2a                	jmp    800fe9 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fbf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fc3:	75 17                	jne    800fdc <strtol+0xa0>
+  800fc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fc8:	0f b6 00             	movzbl (%eax),%eax
+  800fcb:	3c 30                	cmp    $0x30,%al
+  800fcd:	75 0d                	jne    800fdc <strtol+0xa0>
+		s++, base = 8;
+  800fcf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fd3:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fda:	eb 0d                	jmp    800fe9 <strtol+0xad>
+	else if (base == 0)
+  800fdc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fe0:	75 07                	jne    800fe9 <strtol+0xad>
+		base = 10;
+  800fe2:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800fe9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fec:	0f b6 00             	movzbl (%eax),%eax
+  800fef:	3c 2f                	cmp    $0x2f,%al
+  800ff1:	7e 1b                	jle    80100e <strtol+0xd2>
+  800ff3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff6:	0f b6 00             	movzbl (%eax),%eax
+  800ff9:	3c 39                	cmp    $0x39,%al
+  800ffb:	7f 11                	jg     80100e <strtol+0xd2>
+			dig = *s - '0';
+  800ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+  801000:	0f b6 00             	movzbl (%eax),%eax
+  801003:	0f be c0             	movsbl %al,%eax
+  801006:	83 e8 30             	sub    $0x30,%eax
+  801009:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80100c:	eb 48                	jmp    801056 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  80100e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801011:	0f b6 00             	movzbl (%eax),%eax
+  801014:	3c 60                	cmp    $0x60,%al
+  801016:	7e 1b                	jle    801033 <strtol+0xf7>
+  801018:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101b:	0f b6 00             	movzbl (%eax),%eax
+  80101e:	3c 7a                	cmp    $0x7a,%al
+  801020:	7f 11                	jg     801033 <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  801022:	8b 45 08             	mov    0x8(%ebp),%eax
+  801025:	0f b6 00             	movzbl (%eax),%eax
+  801028:	0f be c0             	movsbl %al,%eax
+  80102b:	83 e8 57             	sub    $0x57,%eax
+  80102e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801031:	eb 23                	jmp    801056 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  801033:	8b 45 08             	mov    0x8(%ebp),%eax
+  801036:	0f b6 00             	movzbl (%eax),%eax
+  801039:	3c 40                	cmp    $0x40,%al
+  80103b:	7e 3d                	jle    80107a <strtol+0x13e>
+  80103d:	8b 45 08             	mov    0x8(%ebp),%eax
+  801040:	0f b6 00             	movzbl (%eax),%eax
+  801043:	3c 5a                	cmp    $0x5a,%al
+  801045:	7f 33                	jg     80107a <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801047:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104a:	0f b6 00             	movzbl (%eax),%eax
+  80104d:	0f be c0             	movsbl %al,%eax
+  801050:	83 e8 37             	sub    $0x37,%eax
+  801053:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801056:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801059:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80105c:	7c 02                	jl     801060 <strtol+0x124>
+			break;
+  80105e:	eb 1a                	jmp    80107a <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  801060:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  801064:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801067:	0f af 45 10          	imul   0x10(%ebp),%eax
+  80106b:	89 c2                	mov    %eax,%edx
+  80106d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801070:	01 d0                	add    %edx,%eax
+  801072:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  801075:	e9 6f ff ff ff       	jmp    800fe9 <strtol+0xad>
+
+	if (endptr)
+  80107a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80107e:	74 08                	je     801088 <strtol+0x14c>
+		*endptr = (char *) s;
+  801080:	8b 45 0c             	mov    0xc(%ebp),%eax
+  801083:	8b 55 08             	mov    0x8(%ebp),%edx
+  801086:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801088:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  80108c:	74 07                	je     801095 <strtol+0x159>
+  80108e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801091:	f7 d8                	neg    %eax
+  801093:	eb 03                	jmp    801098 <strtol+0x15c>
+  801095:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  801098:	c9                   	leave  
+  801099:	c3                   	ret    
+  80109a:	66 90                	xchg   %ax,%ax
+  80109c:	66 90                	xchg   %ax,%ax
+  80109e:	66 90                	xchg   %ax,%ax
+
+008010a0 <__udivdi3>:
+  8010a0:	55                   	push   %ebp
+  8010a1:	57                   	push   %edi
+  8010a2:	56                   	push   %esi
+  8010a3:	83 ec 0c             	sub    $0xc,%esp
+  8010a6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010aa:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010ae:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010b2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010b6:	85 c0                	test   %eax,%eax
+  8010b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010bc:	89 ea                	mov    %ebp,%edx
+  8010be:	89 0c 24             	mov    %ecx,(%esp)
+  8010c1:	75 2d                	jne    8010f0 <__udivdi3+0x50>
+  8010c3:	39 e9                	cmp    %ebp,%ecx
+  8010c5:	77 61                	ja     801128 <__udivdi3+0x88>
+  8010c7:	85 c9                	test   %ecx,%ecx
+  8010c9:	89 ce                	mov    %ecx,%esi
+  8010cb:	75 0b                	jne    8010d8 <__udivdi3+0x38>
+  8010cd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010d2:	31 d2                	xor    %edx,%edx
+  8010d4:	f7 f1                	div    %ecx
+  8010d6:	89 c6                	mov    %eax,%esi
+  8010d8:	31 d2                	xor    %edx,%edx
+  8010da:	89 e8                	mov    %ebp,%eax
+  8010dc:	f7 f6                	div    %esi
+  8010de:	89 c5                	mov    %eax,%ebp
+  8010e0:	89 f8                	mov    %edi,%eax
+  8010e2:	f7 f6                	div    %esi
+  8010e4:	89 ea                	mov    %ebp,%edx
+  8010e6:	83 c4 0c             	add    $0xc,%esp
+  8010e9:	5e                   	pop    %esi
+  8010ea:	5f                   	pop    %edi
+  8010eb:	5d                   	pop    %ebp
+  8010ec:	c3                   	ret    
+  8010ed:	8d 76 00             	lea    0x0(%esi),%esi
+  8010f0:	39 e8                	cmp    %ebp,%eax
+  8010f2:	77 24                	ja     801118 <__udivdi3+0x78>
+  8010f4:	0f bd e8             	bsr    %eax,%ebp
+  8010f7:	83 f5 1f             	xor    $0x1f,%ebp
+  8010fa:	75 3c                	jne    801138 <__udivdi3+0x98>
+  8010fc:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801100:	39 34 24             	cmp    %esi,(%esp)
+  801103:	0f 86 9f 00 00 00    	jbe    8011a8 <__udivdi3+0x108>
+  801109:	39 d0                	cmp    %edx,%eax
+  80110b:	0f 82 97 00 00 00    	jb     8011a8 <__udivdi3+0x108>
+  801111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801118:	31 d2                	xor    %edx,%edx
+  80111a:	31 c0                	xor    %eax,%eax
+  80111c:	83 c4 0c             	add    $0xc,%esp
+  80111f:	5e                   	pop    %esi
+  801120:	5f                   	pop    %edi
+  801121:	5d                   	pop    %ebp
+  801122:	c3                   	ret    
+  801123:	90                   	nop
+  801124:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801128:	89 f8                	mov    %edi,%eax
+  80112a:	f7 f1                	div    %ecx
+  80112c:	31 d2                	xor    %edx,%edx
+  80112e:	83 c4 0c             	add    $0xc,%esp
+  801131:	5e                   	pop    %esi
+  801132:	5f                   	pop    %edi
+  801133:	5d                   	pop    %ebp
+  801134:	c3                   	ret    
+  801135:	8d 76 00             	lea    0x0(%esi),%esi
+  801138:	89 e9                	mov    %ebp,%ecx
+  80113a:	8b 3c 24             	mov    (%esp),%edi
+  80113d:	d3 e0                	shl    %cl,%eax
+  80113f:	89 c6                	mov    %eax,%esi
+  801141:	b8 20 00 00 00       	mov    $0x20,%eax
+  801146:	29 e8                	sub    %ebp,%eax
+  801148:	89 c1                	mov    %eax,%ecx
+  80114a:	d3 ef                	shr    %cl,%edi
+  80114c:	89 e9                	mov    %ebp,%ecx
+  80114e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801152:	8b 3c 24             	mov    (%esp),%edi
+  801155:	09 74 24 08          	or     %esi,0x8(%esp)
+  801159:	89 d6                	mov    %edx,%esi
+  80115b:	d3 e7                	shl    %cl,%edi
+  80115d:	89 c1                	mov    %eax,%ecx
+  80115f:	89 3c 24             	mov    %edi,(%esp)
+  801162:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801166:	d3 ee                	shr    %cl,%esi
+  801168:	89 e9                	mov    %ebp,%ecx
+  80116a:	d3 e2                	shl    %cl,%edx
+  80116c:	89 c1                	mov    %eax,%ecx
+  80116e:	d3 ef                	shr    %cl,%edi
+  801170:	09 d7                	or     %edx,%edi
+  801172:	89 f2                	mov    %esi,%edx
+  801174:	89 f8                	mov    %edi,%eax
+  801176:	f7 74 24 08          	divl   0x8(%esp)
+  80117a:	89 d6                	mov    %edx,%esi
+  80117c:	89 c7                	mov    %eax,%edi
+  80117e:	f7 24 24             	mull   (%esp)
+  801181:	39 d6                	cmp    %edx,%esi
+  801183:	89 14 24             	mov    %edx,(%esp)
+  801186:	72 30                	jb     8011b8 <__udivdi3+0x118>
+  801188:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80118c:	89 e9                	mov    %ebp,%ecx
+  80118e:	d3 e2                	shl    %cl,%edx
+  801190:	39 c2                	cmp    %eax,%edx
+  801192:	73 05                	jae    801199 <__udivdi3+0xf9>
+  801194:	3b 34 24             	cmp    (%esp),%esi
+  801197:	74 1f                	je     8011b8 <__udivdi3+0x118>
+  801199:	89 f8                	mov    %edi,%eax
+  80119b:	31 d2                	xor    %edx,%edx
+  80119d:	e9 7a ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011a8:	31 d2                	xor    %edx,%edx
+  8011aa:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011af:	e9 68 ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011b8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011bb:	31 d2                	xor    %edx,%edx
+  8011bd:	83 c4 0c             	add    $0xc,%esp
+  8011c0:	5e                   	pop    %esi
+  8011c1:	5f                   	pop    %edi
+  8011c2:	5d                   	pop    %ebp
+  8011c3:	c3                   	ret    
+  8011c4:	66 90                	xchg   %ax,%ax
+  8011c6:	66 90                	xchg   %ax,%ax
+  8011c8:	66 90                	xchg   %ax,%ax
+  8011ca:	66 90                	xchg   %ax,%ax
+  8011cc:	66 90                	xchg   %ax,%ax
+  8011ce:	66 90                	xchg   %ax,%ax
+
+008011d0 <__umoddi3>:
+  8011d0:	55                   	push   %ebp
+  8011d1:	57                   	push   %edi
+  8011d2:	56                   	push   %esi
+  8011d3:	83 ec 14             	sub    $0x14,%esp
+  8011d6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011da:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011de:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011e2:	89 c7                	mov    %eax,%edi
+  8011e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011e8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011ec:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8011f0:	89 34 24             	mov    %esi,(%esp)
+  8011f3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8011f7:	85 c0                	test   %eax,%eax
+  8011f9:	89 c2                	mov    %eax,%edx
+  8011fb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8011ff:	75 17                	jne    801218 <__umoddi3+0x48>
+  801201:	39 fe                	cmp    %edi,%esi
+  801203:	76 4b                	jbe    801250 <__umoddi3+0x80>
+  801205:	89 c8                	mov    %ecx,%eax
+  801207:	89 fa                	mov    %edi,%edx
+  801209:	f7 f6                	div    %esi
+  80120b:	89 d0                	mov    %edx,%eax
+  80120d:	31 d2                	xor    %edx,%edx
+  80120f:	83 c4 14             	add    $0x14,%esp
+  801212:	5e                   	pop    %esi
+  801213:	5f                   	pop    %edi
+  801214:	5d                   	pop    %ebp
+  801215:	c3                   	ret    
+  801216:	66 90                	xchg   %ax,%ax
+  801218:	39 f8                	cmp    %edi,%eax
+  80121a:	77 54                	ja     801270 <__umoddi3+0xa0>
+  80121c:	0f bd e8             	bsr    %eax,%ebp
+  80121f:	83 f5 1f             	xor    $0x1f,%ebp
+  801222:	75 5c                	jne    801280 <__umoddi3+0xb0>
+  801224:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801228:	39 3c 24             	cmp    %edi,(%esp)
+  80122b:	0f 87 e7 00 00 00    	ja     801318 <__umoddi3+0x148>
+  801231:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801235:	29 f1                	sub    %esi,%ecx
+  801237:	19 c7                	sbb    %eax,%edi
+  801239:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80123d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801241:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801245:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801249:	83 c4 14             	add    $0x14,%esp
+  80124c:	5e                   	pop    %esi
+  80124d:	5f                   	pop    %edi
+  80124e:	5d                   	pop    %ebp
+  80124f:	c3                   	ret    
+  801250:	85 f6                	test   %esi,%esi
+  801252:	89 f5                	mov    %esi,%ebp
+  801254:	75 0b                	jne    801261 <__umoddi3+0x91>
+  801256:	b8 01 00 00 00       	mov    $0x1,%eax
+  80125b:	31 d2                	xor    %edx,%edx
+  80125d:	f7 f6                	div    %esi
+  80125f:	89 c5                	mov    %eax,%ebp
+  801261:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801265:	31 d2                	xor    %edx,%edx
+  801267:	f7 f5                	div    %ebp
+  801269:	89 c8                	mov    %ecx,%eax
+  80126b:	f7 f5                	div    %ebp
+  80126d:	eb 9c                	jmp    80120b <__umoddi3+0x3b>
+  80126f:	90                   	nop
+  801270:	89 c8                	mov    %ecx,%eax
+  801272:	89 fa                	mov    %edi,%edx
+  801274:	83 c4 14             	add    $0x14,%esp
+  801277:	5e                   	pop    %esi
+  801278:	5f                   	pop    %edi
+  801279:	5d                   	pop    %ebp
+  80127a:	c3                   	ret    
+  80127b:	90                   	nop
+  80127c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801280:	8b 04 24             	mov    (%esp),%eax
+  801283:	be 20 00 00 00       	mov    $0x20,%esi
+  801288:	89 e9                	mov    %ebp,%ecx
+  80128a:	29 ee                	sub    %ebp,%esi
+  80128c:	d3 e2                	shl    %cl,%edx
+  80128e:	89 f1                	mov    %esi,%ecx
+  801290:	d3 e8                	shr    %cl,%eax
+  801292:	89 e9                	mov    %ebp,%ecx
+  801294:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801298:	8b 04 24             	mov    (%esp),%eax
+  80129b:	09 54 24 04          	or     %edx,0x4(%esp)
+  80129f:	89 fa                	mov    %edi,%edx
+  8012a1:	d3 e0                	shl    %cl,%eax
+  8012a3:	89 f1                	mov    %esi,%ecx
+  8012a5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012a9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012ad:	d3 ea                	shr    %cl,%edx
+  8012af:	89 e9                	mov    %ebp,%ecx
+  8012b1:	d3 e7                	shl    %cl,%edi
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	d3 e8                	shr    %cl,%eax
+  8012b7:	89 e9                	mov    %ebp,%ecx
+  8012b9:	09 f8                	or     %edi,%eax
+  8012bb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012bf:	f7 74 24 04          	divl   0x4(%esp)
+  8012c3:	d3 e7                	shl    %cl,%edi
+  8012c5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012c9:	89 d7                	mov    %edx,%edi
+  8012cb:	f7 64 24 08          	mull   0x8(%esp)
+  8012cf:	39 d7                	cmp    %edx,%edi
+  8012d1:	89 c1                	mov    %eax,%ecx
+  8012d3:	89 14 24             	mov    %edx,(%esp)
+  8012d6:	72 2c                	jb     801304 <__umoddi3+0x134>
+  8012d8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012dc:	72 22                	jb     801300 <__umoddi3+0x130>
+  8012de:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012e2:	29 c8                	sub    %ecx,%eax
+  8012e4:	19 d7                	sbb    %edx,%edi
+  8012e6:	89 e9                	mov    %ebp,%ecx
+  8012e8:	89 fa                	mov    %edi,%edx
+  8012ea:	d3 e8                	shr    %cl,%eax
+  8012ec:	89 f1                	mov    %esi,%ecx
+  8012ee:	d3 e2                	shl    %cl,%edx
+  8012f0:	89 e9                	mov    %ebp,%ecx
+  8012f2:	d3 ef                	shr    %cl,%edi
+  8012f4:	09 d0                	or     %edx,%eax
+  8012f6:	89 fa                	mov    %edi,%edx
+  8012f8:	83 c4 14             	add    $0x14,%esp
+  8012fb:	5e                   	pop    %esi
+  8012fc:	5f                   	pop    %edi
+  8012fd:	5d                   	pop    %ebp
+  8012fe:	c3                   	ret    
+  8012ff:	90                   	nop
+  801300:	39 d7                	cmp    %edx,%edi
+  801302:	75 da                	jne    8012de <__umoddi3+0x10e>
+  801304:	8b 14 24             	mov    (%esp),%edx
+  801307:	89 c1                	mov    %eax,%ecx
+  801309:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80130d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801311:	eb cb                	jmp    8012de <__umoddi3+0x10e>
+  801313:	90                   	nop
+  801314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801318:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80131c:	0f 82 0f ff ff ff    	jb     801231 <__umoddi3+0x61>
+  801322:	e9 1a ff ff ff       	jmp    801241 <__umoddi3+0x71>
diff --git a/obj/user/faultwrite.o b/obj/user/faultwrite.o
new file mode 100644
index 0000000..e6ffb28
Binary files /dev/null and b/obj/user/faultwrite.o differ
diff --git a/obj/user/faultwrite.sym b/obj/user/faultwrite.sym
new file mode 100644
index 0000000..7e388eb
--- /dev/null
+++ b/obj/user/faultwrite.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040d0 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+00800043 T libmain
+00800091 T exit
+008000a5 t syscall
+00800106 T sys_cputs
+00800148 T sys_cgetc
+0080018c T sys_env_destroy
+008001cf T sys_getenvid
+00800213 T _panic
+0080026e t putch
+008002ca T vcprintf
+0080032e T cprintf
+00800354 t printnum
+00800432 t getuint
+00800481 t getint
+008004c8 T vprintfmt
+00800a0f T printfmt
+00800a3d t sprintputch
+00800a72 T vsnprintf
+00800ad2 T snprintf
+00800b06 T strlen
+00800b2c T strnlen
+00800b5c T strcpy
+00800b8c T strcat
+00800bbc T strncpy
+00800c01 T strlcpy
+00800c52 T strcmp
+00800c91 T strncmp
+00800ce7 T strchr
+00800d1a T strfind
+00800d48 T memset
+00800db6 T memmove
+00800e90 T memcpy
+00800eb1 T memcmp
+00800f09 T memfind
+00800f3c T strtol
+008010a0 T __udivdi3
+008011d0 T __umoddi3
+008013f4 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/faultwritekernel b/obj/user/faultwritekernel
new file mode 100755
index 0000000..07369c9
Binary files /dev/null and b/obj/user/faultwritekernel differ
diff --git a/obj/user/faultwritekernel.asm b/obj/user/faultwritekernel.asm
new file mode 100644
index 0000000..e06c86e
--- /dev/null
+++ b/obj/user/faultwritekernel.asm
@@ -0,0 +1,2623 @@
+
+obj/user/faultwritekernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 12 00 00 00       	call   800043 <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+	*(unsigned*)0xf0100000 = 0;
+  800036:	b8 00 00 10 f0       	mov    $0xf0100000,%eax
+  80003b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+}
+  800041:	5d                   	pop    %ebp
+  800042:	c3                   	ret    
+
+00800043 <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  800043:	55                   	push   %ebp
+  800044:	89 e5                	mov    %esp,%ebp
+  800046:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800049:	e8 81 01 00 00       	call   8001cf <sys_getenvid>
+  80004e:	25 ff 03 00 00       	and    $0x3ff,%eax
+  800053:	89 c2                	mov    %eax,%edx
+  800055:	89 d0                	mov    %edx,%eax
+  800057:	01 c0                	add    %eax,%eax
+  800059:	01 d0                	add    %edx,%eax
+  80005b:	c1 e0 05             	shl    $0x5,%eax
+  80005e:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  800063:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800068:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  80006c:	7e 0a                	jle    800078 <libmain+0x35>
+		binaryname = argv[0];
+  80006e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800071:	8b 00                	mov    (%eax),%eax
+  800073:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800078:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80007b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80007f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800082:	89 04 24             	mov    %eax,(%esp)
+  800085:	e8 a9 ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  80008a:	e8 02 00 00 00       	call   800091 <exit>
+}
+  80008f:	c9                   	leave  
+  800090:	c3                   	ret    
+
+00800091 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  800091:	55                   	push   %ebp
+  800092:	89 e5                	mov    %esp,%ebp
+  800094:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  800097:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  80009e:	e8 e9 00 00 00       	call   80018c <sys_env_destroy>
+}
+  8000a3:	c9                   	leave  
+  8000a4:	c3                   	ret    
+
+008000a5 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  8000a5:	55                   	push   %ebp
+  8000a6:	89 e5                	mov    %esp,%ebp
+  8000a8:	57                   	push   %edi
+  8000a9:	56                   	push   %esi
+  8000aa:	53                   	push   %ebx
+  8000ab:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000ae:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000b1:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000b4:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000b7:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000ba:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000bd:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000c0:	cd 30                	int    $0x30
+  8000c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000c9:	74 30                	je     8000fb <syscall+0x56>
+  8000cb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000cf:	7e 2a                	jle    8000fb <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000d4:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000db:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000df:	c7 44 24 08 32 13 80 	movl   $0x801332,0x8(%esp)
+  8000e6:	00 
+  8000e7:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000ee:	00 
+  8000ef:	c7 04 24 4f 13 80 00 	movl   $0x80134f,(%esp)
+  8000f6:	e8 18 01 00 00       	call   800213 <_panic>
+
+	return ret;
+  8000fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  8000fe:	83 c4 3c             	add    $0x3c,%esp
+  800101:	5b                   	pop    %ebx
+  800102:	5e                   	pop    %esi
+  800103:	5f                   	pop    %edi
+  800104:	5d                   	pop    %ebp
+  800105:	c3                   	ret    
+
+00800106 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800106:	55                   	push   %ebp
+  800107:	89 e5                	mov    %esp,%ebp
+  800109:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  80010c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80010f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800116:	00 
+  800117:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80011e:	00 
+  80011f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800126:	00 
+  800127:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80012a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80012e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800132:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800139:	00 
+  80013a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800141:	e8 5f ff ff ff       	call   8000a5 <syscall>
+}
+  800146:	c9                   	leave  
+  800147:	c3                   	ret    
+
+00800148 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800148:	55                   	push   %ebp
+  800149:	89 e5                	mov    %esp,%ebp
+  80014b:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  80014e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800155:	00 
+  800156:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80015d:	00 
+  80015e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800165:	00 
+  800166:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  80016d:	00 
+  80016e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800175:	00 
+  800176:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80017d:	00 
+  80017e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800185:	e8 1b ff ff ff       	call   8000a5 <syscall>
+}
+  80018a:	c9                   	leave  
+  80018b:	c3                   	ret    
+
+0080018c <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  80018c:	55                   	push   %ebp
+  80018d:	89 e5                	mov    %esp,%ebp
+  80018f:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800192:	8b 45 08             	mov    0x8(%ebp),%eax
+  800195:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80019c:	00 
+  80019d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001a4:	00 
+  8001a5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001ac:	00 
+  8001ad:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001b4:	00 
+  8001b5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001b9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001c0:	00 
+  8001c1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001c8:	e8 d8 fe ff ff       	call   8000a5 <syscall>
+}
+  8001cd:	c9                   	leave  
+  8001ce:	c3                   	ret    
+
+008001cf <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001cf:	55                   	push   %ebp
+  8001d0:	89 e5                	mov    %esp,%ebp
+  8001d2:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001d5:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001dc:	00 
+  8001dd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001e4:	00 
+  8001e5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001ec:	00 
+  8001ed:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001f4:	00 
+  8001f5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  8001fc:	00 
+  8001fd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800204:	00 
+  800205:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  80020c:	e8 94 fe ff ff       	call   8000a5 <syscall>
+}
+  800211:	c9                   	leave  
+  800212:	c3                   	ret    
+
+00800213 <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  800213:	55                   	push   %ebp
+  800214:	89 e5                	mov    %esp,%ebp
+  800216:	53                   	push   %ebx
+  800217:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  80021a:	8d 45 14             	lea    0x14(%ebp),%eax
+  80021d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  800220:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  800226:	e8 a4 ff ff ff       	call   8001cf <sys_getenvid>
+  80022b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80022e:	89 54 24 10          	mov    %edx,0x10(%esp)
+  800232:	8b 55 08             	mov    0x8(%ebp),%edx
+  800235:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800239:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  80023d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800241:	c7 04 24 60 13 80 00 	movl   $0x801360,(%esp)
+  800248:	e8 e1 00 00 00       	call   80032e <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  80024d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800250:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800254:	8b 45 10             	mov    0x10(%ebp),%eax
+  800257:	89 04 24             	mov    %eax,(%esp)
+  80025a:	e8 6b 00 00 00       	call   8002ca <vcprintf>
+	cprintf("\n");
+  80025f:	c7 04 24 83 13 80 00 	movl   $0x801383,(%esp)
+  800266:	e8 c3 00 00 00       	call   80032e <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  80026b:	cc                   	int3   
+  80026c:	eb fd                	jmp    80026b <_panic+0x58>
+
+0080026e <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  80026e:	55                   	push   %ebp
+  80026f:	89 e5                	mov    %esp,%ebp
+  800271:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  800274:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800277:	8b 00                	mov    (%eax),%eax
+  800279:	8d 48 01             	lea    0x1(%eax),%ecx
+  80027c:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80027f:	89 0a                	mov    %ecx,(%edx)
+  800281:	8b 55 08             	mov    0x8(%ebp),%edx
+  800284:	89 d1                	mov    %edx,%ecx
+  800286:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800289:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  80028d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800290:	8b 00                	mov    (%eax),%eax
+  800292:	3d ff 00 00 00       	cmp    $0xff,%eax
+  800297:	75 20                	jne    8002b9 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  800299:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80029c:	8b 00                	mov    (%eax),%eax
+  80029e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8002a1:	83 c2 08             	add    $0x8,%edx
+  8002a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002a8:	89 14 24             	mov    %edx,(%esp)
+  8002ab:	e8 56 fe ff ff       	call   800106 <sys_cputs>
+		b->idx = 0;
+  8002b0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002bc:	8b 40 04             	mov    0x4(%eax),%eax
+  8002bf:	8d 50 01             	lea    0x1(%eax),%edx
+  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002c5:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002c8:	c9                   	leave  
+  8002c9:	c3                   	ret    
+
+008002ca <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002ca:	55                   	push   %ebp
+  8002cb:	89 e5                	mov    %esp,%ebp
+  8002cd:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002d3:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002da:	00 00 00 
+	b.cnt = 0;
+  8002dd:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002e4:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002e7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002ee:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002f1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8002f5:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  8002fb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002ff:	c7 04 24 6e 02 80 00 	movl   $0x80026e,(%esp)
+  800306:	e8 bd 01 00 00       	call   8004c8 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  80030b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800311:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800315:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  80031b:	83 c0 08             	add    $0x8,%eax
+  80031e:	89 04 24             	mov    %eax,(%esp)
+  800321:	e8 e0 fd ff ff       	call   800106 <sys_cputs>
+
+	return b.cnt;
+  800326:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  80032c:	c9                   	leave  
+  80032d:	c3                   	ret    
+
+0080032e <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  80032e:	55                   	push   %ebp
+  80032f:	89 e5                	mov    %esp,%ebp
+  800331:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  800334:	8d 45 0c             	lea    0xc(%ebp),%eax
+  800337:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  80033a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80033d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800341:	8b 45 08             	mov    0x8(%ebp),%eax
+  800344:	89 04 24             	mov    %eax,(%esp)
+  800347:	e8 7e ff ff ff       	call   8002ca <vcprintf>
+  80034c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  80034f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800352:	c9                   	leave  
+  800353:	c3                   	ret    
+
+00800354 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  800354:	55                   	push   %ebp
+  800355:	89 e5                	mov    %esp,%ebp
+  800357:	53                   	push   %ebx
+  800358:	83 ec 34             	sub    $0x34,%esp
+  80035b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80035e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800361:	8b 45 14             	mov    0x14(%ebp),%eax
+  800364:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  800367:	8b 45 18             	mov    0x18(%ebp),%eax
+  80036a:	ba 00 00 00 00       	mov    $0x0,%edx
+  80036f:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800372:	77 72                	ja     8003e6 <printnum+0x92>
+  800374:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800377:	72 05                	jb     80037e <printnum+0x2a>
+  800379:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  80037c:	77 68                	ja     8003e6 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  80037e:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  800381:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  800384:	8b 45 18             	mov    0x18(%ebp),%eax
+  800387:	ba 00 00 00 00       	mov    $0x0,%edx
+  80038c:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800390:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800394:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800397:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80039a:	89 04 24             	mov    %eax,(%esp)
+  80039d:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8003a1:	e8 fa 0c 00 00       	call   8010a0 <__udivdi3>
+  8003a6:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003a9:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003ad:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003b1:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003b4:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003b8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003bc:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003c0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003c3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003c7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003ca:	89 04 24             	mov    %eax,(%esp)
+  8003cd:	e8 82 ff ff ff       	call   800354 <printnum>
+  8003d2:	eb 1c                	jmp    8003f0 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003d4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003d7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003db:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003de:	89 04 24             	mov    %eax,(%esp)
+  8003e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003e4:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003e6:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003ea:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003ee:	7f e4                	jg     8003d4 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003f0:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003f3:	bb 00 00 00 00       	mov    $0x0,%ebx
+  8003f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003fe:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  800402:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800406:	89 04 24             	mov    %eax,(%esp)
+  800409:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80040d:	e8 be 0d 00 00       	call   8011d0 <__umoddi3>
+  800412:	05 10 14 80 00       	add    $0x801410,%eax
+  800417:	0f b6 00             	movzbl (%eax),%eax
+  80041a:	0f be c0             	movsbl %al,%eax
+  80041d:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800420:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800424:	89 04 24             	mov    %eax,(%esp)
+  800427:	8b 45 08             	mov    0x8(%ebp),%eax
+  80042a:	ff d0                	call   *%eax
+}
+  80042c:	83 c4 34             	add    $0x34,%esp
+  80042f:	5b                   	pop    %ebx
+  800430:	5d                   	pop    %ebp
+  800431:	c3                   	ret    
+
+00800432 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800432:	55                   	push   %ebp
+  800433:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800435:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800439:	7e 14                	jle    80044f <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  80043b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80043e:	8b 00                	mov    (%eax),%eax
+  800440:	8d 48 08             	lea    0x8(%eax),%ecx
+  800443:	8b 55 08             	mov    0x8(%ebp),%edx
+  800446:	89 0a                	mov    %ecx,(%edx)
+  800448:	8b 50 04             	mov    0x4(%eax),%edx
+  80044b:	8b 00                	mov    (%eax),%eax
+  80044d:	eb 30                	jmp    80047f <getuint+0x4d>
+	else if (lflag)
+  80044f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800453:	74 16                	je     80046b <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  800455:	8b 45 08             	mov    0x8(%ebp),%eax
+  800458:	8b 00                	mov    (%eax),%eax
+  80045a:	8d 48 04             	lea    0x4(%eax),%ecx
+  80045d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800460:	89 0a                	mov    %ecx,(%edx)
+  800462:	8b 00                	mov    (%eax),%eax
+  800464:	ba 00 00 00 00       	mov    $0x0,%edx
+  800469:	eb 14                	jmp    80047f <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  80046b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80046e:	8b 00                	mov    (%eax),%eax
+  800470:	8d 48 04             	lea    0x4(%eax),%ecx
+  800473:	8b 55 08             	mov    0x8(%ebp),%edx
+  800476:	89 0a                	mov    %ecx,(%edx)
+  800478:	8b 00                	mov    (%eax),%eax
+  80047a:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  80047f:	5d                   	pop    %ebp
+  800480:	c3                   	ret    
+
+00800481 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  800481:	55                   	push   %ebp
+  800482:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800484:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800488:	7e 14                	jle    80049e <getint+0x1d>
+		return va_arg(*ap, long long);
+  80048a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80048d:	8b 00                	mov    (%eax),%eax
+  80048f:	8d 48 08             	lea    0x8(%eax),%ecx
+  800492:	8b 55 08             	mov    0x8(%ebp),%edx
+  800495:	89 0a                	mov    %ecx,(%edx)
+  800497:	8b 50 04             	mov    0x4(%eax),%edx
+  80049a:	8b 00                	mov    (%eax),%eax
+  80049c:	eb 28                	jmp    8004c6 <getint+0x45>
+	else if (lflag)
+  80049e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8004a2:	74 12                	je     8004b6 <getint+0x35>
+		return va_arg(*ap, long);
+  8004a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004a7:	8b 00                	mov    (%eax),%eax
+  8004a9:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004ac:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004af:	89 0a                	mov    %ecx,(%edx)
+  8004b1:	8b 00                	mov    (%eax),%eax
+  8004b3:	99                   	cltd   
+  8004b4:	eb 10                	jmp    8004c6 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004b6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b9:	8b 00                	mov    (%eax),%eax
+  8004bb:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004be:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004c1:	89 0a                	mov    %ecx,(%edx)
+  8004c3:	8b 00                	mov    (%eax),%eax
+  8004c5:	99                   	cltd   
+}
+  8004c6:	5d                   	pop    %ebp
+  8004c7:	c3                   	ret    
+
+008004c8 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004c8:	55                   	push   %ebp
+  8004c9:	89 e5                	mov    %esp,%ebp
+  8004cb:	56                   	push   %esi
+  8004cc:	53                   	push   %ebx
+  8004cd:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004d0:	e9 72 01 00 00       	jmp    800647 <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004d5:	85 db                	test   %ebx,%ebx
+  8004d7:	75 05                	jne    8004de <vprintfmt+0x16>
+				return;
+  8004d9:	e9 2a 05 00 00       	jmp    800a08 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004de:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004e1:	0f 85 51 01 00 00    	jne    800638 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004e7:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004ea:	8d 50 01             	lea    0x1(%eax),%edx
+  8004ed:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004f0:	0f b6 00             	movzbl (%eax),%eax
+  8004f3:	0f b6 d8             	movzbl %al,%ebx
+  8004f6:	83 fb 5b             	cmp    $0x5b,%ebx
+  8004f9:	74 14                	je     80050f <vprintfmt+0x47>
+				    putch(ch, putdat);
+  8004fb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004fe:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800502:	89 1c 24             	mov    %ebx,(%esp)
+  800505:	8b 45 08             	mov    0x8(%ebp),%eax
+  800508:	ff d0                	call   *%eax
+				    continue;
+  80050a:	e9 38 01 00 00       	jmp    800647 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  80050f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800512:	8d 50 01             	lea    0x1(%eax),%edx
+  800515:	89 55 10             	mov    %edx,0x10(%ebp)
+  800518:	0f b6 00             	movzbl (%eax),%eax
+  80051b:	0f b6 c0             	movzbl %al,%eax
+  80051e:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  800523:	8b 45 10             	mov    0x10(%ebp),%eax
+  800526:	8d 50 01             	lea    0x1(%eax),%edx
+  800529:	89 55 10             	mov    %edx,0x10(%ebp)
+  80052c:	0f b6 00             	movzbl (%eax),%eax
+  80052f:	0f b6 c0             	movzbl %al,%eax
+  800532:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  800537:	a1 08 20 80 00       	mov    0x802008,%eax
+  80053c:	83 f8 2f             	cmp    $0x2f,%eax
+  80053f:	7e 19                	jle    80055a <vprintfmt+0x92>
+  800541:	a1 08 20 80 00       	mov    0x802008,%eax
+  800546:	83 f8 39             	cmp    $0x39,%eax
+  800549:	7f 0f                	jg     80055a <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  80054b:	a1 08 20 80 00       	mov    0x802008,%eax
+  800550:	83 e8 30             	sub    $0x30,%eax
+  800553:	a3 08 20 80 00       	mov    %eax,0x802008
+  800558:	eb 50                	jmp    8005aa <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  80055a:	a1 08 20 80 00       	mov    0x802008,%eax
+  80055f:	83 f8 60             	cmp    $0x60,%eax
+  800562:	7e 19                	jle    80057d <vprintfmt+0xb5>
+  800564:	a1 08 20 80 00       	mov    0x802008,%eax
+  800569:	83 f8 66             	cmp    $0x66,%eax
+  80056c:	7f 0f                	jg     80057d <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  80056e:	a1 08 20 80 00       	mov    0x802008,%eax
+  800573:	83 e8 57             	sub    $0x57,%eax
+  800576:	a3 08 20 80 00       	mov    %eax,0x802008
+  80057b:	eb 2d                	jmp    8005aa <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  80057d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800582:	83 f8 40             	cmp    $0x40,%eax
+  800585:	7e 19                	jle    8005a0 <vprintfmt+0xd8>
+  800587:	a1 08 20 80 00       	mov    0x802008,%eax
+  80058c:	83 f8 46             	cmp    $0x46,%eax
+  80058f:	7f 0f                	jg     8005a0 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  800591:	a1 08 20 80 00       	mov    0x802008,%eax
+  800596:	83 e8 37             	sub    $0x37,%eax
+  800599:	a3 08 20 80 00       	mov    %eax,0x802008
+  80059e:	eb 0a                	jmp    8005aa <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8005a0:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8005a7:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005aa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005af:	83 f8 2f             	cmp    $0x2f,%eax
+  8005b2:	7e 19                	jle    8005cd <vprintfmt+0x105>
+  8005b4:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005b9:	83 f8 39             	cmp    $0x39,%eax
+  8005bc:	7f 0f                	jg     8005cd <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005be:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005c3:	83 e8 30             	sub    $0x30,%eax
+  8005c6:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005cb:	eb 50                	jmp    80061d <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005cd:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005d2:	83 f8 60             	cmp    $0x60,%eax
+  8005d5:	7e 19                	jle    8005f0 <vprintfmt+0x128>
+  8005d7:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005dc:	83 f8 66             	cmp    $0x66,%eax
+  8005df:	7f 0f                	jg     8005f0 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005e1:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005e6:	83 e8 57             	sub    $0x57,%eax
+  8005e9:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005ee:	eb 2d                	jmp    80061d <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005f0:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f5:	83 f8 40             	cmp    $0x40,%eax
+  8005f8:	7e 19                	jle    800613 <vprintfmt+0x14b>
+  8005fa:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005ff:	83 f8 46             	cmp    $0x46,%eax
+  800602:	7f 0f                	jg     800613 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  800604:	a1 10 20 80 00       	mov    0x802010,%eax
+  800609:	83 e8 37             	sub    $0x37,%eax
+  80060c:	a3 10 20 80 00       	mov    %eax,0x802010
+  800611:	eb 0a                	jmp    80061d <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  800613:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  80061a:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  80061d:	a1 08 20 80 00       	mov    0x802008,%eax
+  800622:	c1 e0 0c             	shl    $0xc,%eax
+  800625:	89 c2                	mov    %eax,%edx
+  800627:	a1 10 20 80 00       	mov    0x802010,%eax
+  80062c:	c1 e0 08             	shl    $0x8,%eax
+  80062f:	09 d0                	or     %edx,%eax
+  800631:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800636:	eb 0f                	jmp    800647 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  800638:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80063b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80063f:	89 1c 24             	mov    %ebx,(%esp)
+  800642:	8b 45 08             	mov    0x8(%ebp),%eax
+  800645:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800647:	8b 45 10             	mov    0x10(%ebp),%eax
+  80064a:	8d 50 01             	lea    0x1(%eax),%edx
+  80064d:	89 55 10             	mov    %edx,0x10(%ebp)
+  800650:	0f b6 00             	movzbl (%eax),%eax
+  800653:	0f b6 d8             	movzbl %al,%ebx
+  800656:	83 fb 25             	cmp    $0x25,%ebx
+  800659:	0f 85 76 fe ff ff    	jne    8004d5 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  80065f:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  800663:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  80066a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  800671:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  800678:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  80067f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800682:	8d 50 01             	lea    0x1(%eax),%edx
+  800685:	89 55 10             	mov    %edx,0x10(%ebp)
+  800688:	0f b6 00             	movzbl (%eax),%eax
+  80068b:	0f b6 d8             	movzbl %al,%ebx
+  80068e:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800691:	83 f8 55             	cmp    $0x55,%eax
+  800694:	0f 87 3d 03 00 00    	ja     8009d7 <vprintfmt+0x50f>
+  80069a:	8b 04 85 34 14 80 00 	mov    0x801434(,%eax,4),%eax
+  8006a1:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8006a3:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8006a7:	eb d6                	jmp    80067f <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006a9:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006ad:	eb d0                	jmp    80067f <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006b6:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006b9:	89 d0                	mov    %edx,%eax
+  8006bb:	c1 e0 02             	shl    $0x2,%eax
+  8006be:	01 d0                	add    %edx,%eax
+  8006c0:	01 c0                	add    %eax,%eax
+  8006c2:	01 d8                	add    %ebx,%eax
+  8006c4:	83 e8 30             	sub    $0x30,%eax
+  8006c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006ca:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006cd:	0f b6 00             	movzbl (%eax),%eax
+  8006d0:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006d3:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006d6:	7e 0b                	jle    8006e3 <vprintfmt+0x21b>
+  8006d8:	83 fb 39             	cmp    $0x39,%ebx
+  8006db:	7f 06                	jg     8006e3 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006dd:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006e1:	eb d3                	jmp    8006b6 <vprintfmt+0x1ee>
+			goto process_precision;
+  8006e3:	eb 33                	jmp    800718 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006e5:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006e8:	8d 50 04             	lea    0x4(%eax),%edx
+  8006eb:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006ee:	8b 00                	mov    (%eax),%eax
+  8006f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006f3:	eb 23                	jmp    800718 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  8006f5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006f9:	79 0c                	jns    800707 <vprintfmt+0x23f>
+				width = 0;
+  8006fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  800702:	e9 78 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+  800707:	e9 73 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  80070c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  800713:	e9 67 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800718:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80071c:	79 12                	jns    800730 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  80071e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800721:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800724:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  80072b:	e9 4f ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+  800730:	e9 4a ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800735:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800739:	e9 41 ff ff ff       	jmp    80067f <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  80073e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800741:	8d 50 04             	lea    0x4(%eax),%edx
+  800744:	89 55 14             	mov    %edx,0x14(%ebp)
+  800747:	8b 00                	mov    (%eax),%eax
+  800749:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80074c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800750:	89 04 24             	mov    %eax,(%esp)
+  800753:	8b 45 08             	mov    0x8(%ebp),%eax
+  800756:	ff d0                	call   *%eax
+			break;
+  800758:	e9 a5 02 00 00       	jmp    800a02 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  80075d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800760:	8d 50 04             	lea    0x4(%eax),%edx
+  800763:	89 55 14             	mov    %edx,0x14(%ebp)
+  800766:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  800768:	85 db                	test   %ebx,%ebx
+  80076a:	79 02                	jns    80076e <vprintfmt+0x2a6>
+				err = -err;
+  80076c:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  80076e:	83 fb 06             	cmp    $0x6,%ebx
+  800771:	7f 0b                	jg     80077e <vprintfmt+0x2b6>
+  800773:	8b 34 9d f4 13 80 00 	mov    0x8013f4(,%ebx,4),%esi
+  80077a:	85 f6                	test   %esi,%esi
+  80077c:	75 23                	jne    8007a1 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  80077e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800782:	c7 44 24 08 21 14 80 	movl   $0x801421,0x8(%esp)
+  800789:	00 
+  80078a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80078d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800791:	8b 45 08             	mov    0x8(%ebp),%eax
+  800794:	89 04 24             	mov    %eax,(%esp)
+  800797:	e8 73 02 00 00       	call   800a0f <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  80079c:	e9 61 02 00 00       	jmp    800a02 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8007a1:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8007a5:	c7 44 24 08 2a 14 80 	movl   $0x80142a,0x8(%esp)
+  8007ac:	00 
+  8007ad:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007b7:	89 04 24             	mov    %eax,(%esp)
+  8007ba:	e8 50 02 00 00       	call   800a0f <printfmt>
+			break;
+  8007bf:	e9 3e 02 00 00       	jmp    800a02 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007c4:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007c7:	8d 50 04             	lea    0x4(%eax),%edx
+  8007ca:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007cd:	8b 30                	mov    (%eax),%esi
+  8007cf:	85 f6                	test   %esi,%esi
+  8007d1:	75 05                	jne    8007d8 <vprintfmt+0x310>
+				p = "(null)";
+  8007d3:	be 2d 14 80 00       	mov    $0x80142d,%esi
+			if (width > 0 && padc != '-')
+  8007d8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007dc:	7e 37                	jle    800815 <vprintfmt+0x34d>
+  8007de:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007e2:	74 31                	je     800815 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007e7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007eb:	89 34 24             	mov    %esi,(%esp)
+  8007ee:	e8 39 03 00 00       	call   800b2c <strnlen>
+  8007f3:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  8007f6:	eb 17                	jmp    80080f <vprintfmt+0x347>
+					putch(padc, putdat);
+  8007f8:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  8007fc:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8007ff:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800803:	89 04 24             	mov    %eax,(%esp)
+  800806:	8b 45 08             	mov    0x8(%ebp),%eax
+  800809:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80080b:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80080f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800813:	7f e3                	jg     8007f8 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800815:	eb 38                	jmp    80084f <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800817:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  80081b:	74 1f                	je     80083c <vprintfmt+0x374>
+  80081d:	83 fb 1f             	cmp    $0x1f,%ebx
+  800820:	7e 05                	jle    800827 <vprintfmt+0x35f>
+  800822:	83 fb 7e             	cmp    $0x7e,%ebx
+  800825:	7e 15                	jle    80083c <vprintfmt+0x374>
+					putch('?', putdat);
+  800827:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80082a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80082e:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800835:	8b 45 08             	mov    0x8(%ebp),%eax
+  800838:	ff d0                	call   *%eax
+  80083a:	eb 0f                	jmp    80084b <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  80083c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80083f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800843:	89 1c 24             	mov    %ebx,(%esp)
+  800846:	8b 45 08             	mov    0x8(%ebp),%eax
+  800849:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80084b:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80084f:	89 f0                	mov    %esi,%eax
+  800851:	8d 70 01             	lea    0x1(%eax),%esi
+  800854:	0f b6 00             	movzbl (%eax),%eax
+  800857:	0f be d8             	movsbl %al,%ebx
+  80085a:	85 db                	test   %ebx,%ebx
+  80085c:	74 10                	je     80086e <vprintfmt+0x3a6>
+  80085e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800862:	78 b3                	js     800817 <vprintfmt+0x34f>
+  800864:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  800868:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  80086c:	79 a9                	jns    800817 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80086e:	eb 17                	jmp    800887 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  800870:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800873:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800877:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  80087e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800881:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  800883:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800887:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80088b:	7f e3                	jg     800870 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  80088d:	e9 70 01 00 00       	jmp    800a02 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  800892:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800895:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800899:	8d 45 14             	lea    0x14(%ebp),%eax
+  80089c:	89 04 24             	mov    %eax,(%esp)
+  80089f:	e8 dd fb ff ff       	call   800481 <getint>
+  8008a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008a7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008b0:	85 d2                	test   %edx,%edx
+  8008b2:	79 26                	jns    8008da <vprintfmt+0x412>
+				putch('-', putdat);
+  8008b4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008bb:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008c5:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008cd:	f7 d8                	neg    %eax
+  8008cf:	83 d2 00             	adc    $0x0,%edx
+  8008d2:	f7 da                	neg    %edx
+  8008d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008d7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008da:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008e1:	e9 a8 00 00 00       	jmp    80098e <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008ed:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008f0:	89 04 24             	mov    %eax,(%esp)
+  8008f3:	e8 3a fb ff ff       	call   800432 <getuint>
+  8008f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008fb:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  8008fe:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800905:	e9 84 00 00 00       	jmp    80098e <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  80090a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80090d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800911:	8d 45 14             	lea    0x14(%ebp),%eax
+  800914:	89 04 24             	mov    %eax,(%esp)
+  800917:	e8 16 fb ff ff       	call   800432 <getuint>
+  80091c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80091f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800922:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800929:	eb 63                	jmp    80098e <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  80092b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80092e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800932:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800939:	8b 45 08             	mov    0x8(%ebp),%eax
+  80093c:	ff d0                	call   *%eax
+			putch('x', putdat);
+  80093e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800941:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800945:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  80094c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094f:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  800951:	8b 45 14             	mov    0x14(%ebp),%eax
+  800954:	8d 50 04             	lea    0x4(%eax),%edx
+  800957:	89 55 14             	mov    %edx,0x14(%ebp)
+  80095a:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  80095c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80095f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  800966:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  80096d:	eb 1f                	jmp    80098e <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  80096f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800972:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800976:	8d 45 14             	lea    0x14(%ebp),%eax
+  800979:	89 04 24             	mov    %eax,(%esp)
+  80097c:	e8 b1 fa ff ff       	call   800432 <getuint>
+  800981:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800984:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800987:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  80098e:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800992:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800995:	89 54 24 18          	mov    %edx,0x18(%esp)
+  800999:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  80099c:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8009a0:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8009a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8009a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009aa:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009ae:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009b2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009b5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009bc:	89 04 24             	mov    %eax,(%esp)
+  8009bf:	e8 90 f9 ff ff       	call   800354 <printnum>
+			break;
+  8009c4:	eb 3c                	jmp    800a02 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009cd:	89 1c 24             	mov    %ebx,(%esp)
+  8009d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009d3:	ff d0                	call   *%eax
+			break;			
+  8009d5:	eb 2b                	jmp    800a02 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009d7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009da:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009de:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e8:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009ea:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009ee:	eb 04                	jmp    8009f4 <vprintfmt+0x52c>
+  8009f0:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009f4:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009f7:	83 e8 01             	sub    $0x1,%eax
+  8009fa:	0f b6 00             	movzbl (%eax),%eax
+  8009fd:	3c 25                	cmp    $0x25,%al
+  8009ff:	75 ef                	jne    8009f0 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800a01:	90                   	nop
+		}
+	}
+  800a02:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800a03:	e9 3f fc ff ff       	jmp    800647 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800a08:	83 c4 40             	add    $0x40,%esp
+  800a0b:	5b                   	pop    %ebx
+  800a0c:	5e                   	pop    %esi
+  800a0d:	5d                   	pop    %ebp
+  800a0e:	c3                   	ret    
+
+00800a0f <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a0f:	55                   	push   %ebp
+  800a10:	89 e5                	mov    %esp,%ebp
+  800a12:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a15:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a18:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a1e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a22:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a25:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a29:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a2c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a30:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a33:	89 04 24             	mov    %eax,(%esp)
+  800a36:	e8 8d fa ff ff       	call   8004c8 <vprintfmt>
+	va_end(ap);
+}
+  800a3b:	c9                   	leave  
+  800a3c:	c3                   	ret    
+
+00800a3d <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a3d:	55                   	push   %ebp
+  800a3e:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a43:	8b 40 08             	mov    0x8(%eax),%eax
+  800a46:	8d 50 01             	lea    0x1(%eax),%edx
+  800a49:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4c:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a52:	8b 10                	mov    (%eax),%edx
+  800a54:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a57:	8b 40 04             	mov    0x4(%eax),%eax
+  800a5a:	39 c2                	cmp    %eax,%edx
+  800a5c:	73 12                	jae    800a70 <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a61:	8b 00                	mov    (%eax),%eax
+  800a63:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a66:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a69:	89 0a                	mov    %ecx,(%edx)
+  800a6b:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a6e:	88 10                	mov    %dl,(%eax)
+}
+  800a70:	5d                   	pop    %ebp
+  800a71:	c3                   	ret    
+
+00800a72 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a72:	55                   	push   %ebp
+  800a73:	89 e5                	mov    %esp,%ebp
+  800a75:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a78:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a81:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a84:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a87:	01 d0                	add    %edx,%eax
+  800a89:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a93:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800a97:	74 06                	je     800a9f <vsnprintf+0x2d>
+  800a99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800a9d:	7f 07                	jg     800aa6 <vsnprintf+0x34>
+		return -E_INVAL;
+  800a9f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800aa4:	eb 2a                	jmp    800ad0 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800aa6:	8b 45 14             	mov    0x14(%ebp),%eax
+  800aa9:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800aad:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ab0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ab4:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800ab7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800abb:	c7 04 24 3d 0a 80 00 	movl   $0x800a3d,(%esp)
+  800ac2:	e8 01 fa ff ff       	call   8004c8 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800ac7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800aca:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800ad0:	c9                   	leave  
+  800ad1:	c3                   	ret    
+
+00800ad2 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800ad2:	55                   	push   %ebp
+  800ad3:	89 e5                	mov    %esp,%ebp
+  800ad5:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800ad8:	8d 45 14             	lea    0x14(%ebp),%eax
+  800adb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800ade:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800ae1:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800ae5:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ae8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800aec:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800aef:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800af3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800af6:	89 04 24             	mov    %eax,(%esp)
+  800af9:	e8 74 ff ff ff       	call   800a72 <vsnprintf>
+  800afe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800b01:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800b04:	c9                   	leave  
+  800b05:	c3                   	ret    
+
+00800b06 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800b06:	55                   	push   %ebp
+  800b07:	89 e5                	mov    %esp,%ebp
+  800b09:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b13:	eb 08                	jmp    800b1d <strlen+0x17>
+		n++;
+  800b15:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b19:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b1d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b20:	0f b6 00             	movzbl (%eax),%eax
+  800b23:	84 c0                	test   %al,%al
+  800b25:	75 ee                	jne    800b15 <strlen+0xf>
+		n++;
+	return n;
+  800b27:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b2a:	c9                   	leave  
+  800b2b:	c3                   	ret    
+
+00800b2c <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b2c:	55                   	push   %ebp
+  800b2d:	89 e5                	mov    %esp,%ebp
+  800b2f:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b32:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b39:	eb 0c                	jmp    800b47 <strnlen+0x1b>
+		n++;
+  800b3b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b3f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b43:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b47:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b4b:	74 0a                	je     800b57 <strnlen+0x2b>
+  800b4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b50:	0f b6 00             	movzbl (%eax),%eax
+  800b53:	84 c0                	test   %al,%al
+  800b55:	75 e4                	jne    800b3b <strnlen+0xf>
+		n++;
+	return n;
+  800b57:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b5a:	c9                   	leave  
+  800b5b:	c3                   	ret    
+
+00800b5c <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b5c:	55                   	push   %ebp
+  800b5d:	89 e5                	mov    %esp,%ebp
+  800b5f:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b62:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b65:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b68:	90                   	nop
+  800b69:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b6c:	8d 50 01             	lea    0x1(%eax),%edx
+  800b6f:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b72:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b75:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b78:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b7b:	0f b6 12             	movzbl (%edx),%edx
+  800b7e:	88 10                	mov    %dl,(%eax)
+  800b80:	0f b6 00             	movzbl (%eax),%eax
+  800b83:	84 c0                	test   %al,%al
+  800b85:	75 e2                	jne    800b69 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b87:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b8a:	c9                   	leave  
+  800b8b:	c3                   	ret    
+
+00800b8c <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b8c:	55                   	push   %ebp
+  800b8d:	89 e5                	mov    %esp,%ebp
+  800b8f:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b92:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b95:	89 04 24             	mov    %eax,(%esp)
+  800b98:	e8 69 ff ff ff       	call   800b06 <strlen>
+  800b9d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800ba0:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800ba3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba6:	01 c2                	add    %eax,%edx
+  800ba8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bab:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800baf:	89 14 24             	mov    %edx,(%esp)
+  800bb2:	e8 a5 ff ff ff       	call   800b5c <strcpy>
+	return dst;
+  800bb7:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bba:	c9                   	leave  
+  800bbb:	c3                   	ret    
+
+00800bbc <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bbc:	55                   	push   %ebp
+  800bbd:	89 e5                	mov    %esp,%ebp
+  800bbf:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bc2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bc5:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bc8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bcf:	eb 23                	jmp    800bf4 <strncpy+0x38>
+		*dst++ = *src;
+  800bd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bd4:	8d 50 01             	lea    0x1(%eax),%edx
+  800bd7:	89 55 08             	mov    %edx,0x8(%ebp)
+  800bda:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800bdd:	0f b6 12             	movzbl (%edx),%edx
+  800be0:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800be2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800be5:	0f b6 00             	movzbl (%eax),%eax
+  800be8:	84 c0                	test   %al,%al
+  800bea:	74 04                	je     800bf0 <strncpy+0x34>
+			src++;
+  800bec:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800bf0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800bf4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800bf7:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800bfa:	72 d5                	jb     800bd1 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800bfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800bff:	c9                   	leave  
+  800c00:	c3                   	ret    
+
+00800c01 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800c01:	55                   	push   %ebp
+  800c02:	89 e5                	mov    %esp,%ebp
+  800c04:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800c07:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c0a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c0d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c11:	74 33                	je     800c46 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c13:	eb 17                	jmp    800c2c <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c18:	8d 50 01             	lea    0x1(%eax),%edx
+  800c1b:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c1e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c21:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c24:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c27:	0f b6 12             	movzbl (%edx),%edx
+  800c2a:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c2c:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c30:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c34:	74 0a                	je     800c40 <strlcpy+0x3f>
+  800c36:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c39:	0f b6 00             	movzbl (%eax),%eax
+  800c3c:	84 c0                	test   %al,%al
+  800c3e:	75 d5                	jne    800c15 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c40:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c43:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c46:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c49:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c4c:	29 c2                	sub    %eax,%edx
+  800c4e:	89 d0                	mov    %edx,%eax
+}
+  800c50:	c9                   	leave  
+  800c51:	c3                   	ret    
+
+00800c52 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c52:	55                   	push   %ebp
+  800c53:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c55:	eb 08                	jmp    800c5f <strcmp+0xd>
+		p++, q++;
+  800c57:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c5b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c5f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c62:	0f b6 00             	movzbl (%eax),%eax
+  800c65:	84 c0                	test   %al,%al
+  800c67:	74 10                	je     800c79 <strcmp+0x27>
+  800c69:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c6c:	0f b6 10             	movzbl (%eax),%edx
+  800c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c72:	0f b6 00             	movzbl (%eax),%eax
+  800c75:	38 c2                	cmp    %al,%dl
+  800c77:	74 de                	je     800c57 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c79:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c7c:	0f b6 00             	movzbl (%eax),%eax
+  800c7f:	0f b6 d0             	movzbl %al,%edx
+  800c82:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c85:	0f b6 00             	movzbl (%eax),%eax
+  800c88:	0f b6 c0             	movzbl %al,%eax
+  800c8b:	29 c2                	sub    %eax,%edx
+  800c8d:	89 d0                	mov    %edx,%eax
+}
+  800c8f:	5d                   	pop    %ebp
+  800c90:	c3                   	ret    
+
+00800c91 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c91:	55                   	push   %ebp
+  800c92:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800c94:	eb 0c                	jmp    800ca2 <strncmp+0x11>
+		n--, p++, q++;
+  800c96:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c9a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c9e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800ca2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800ca6:	74 1a                	je     800cc2 <strncmp+0x31>
+  800ca8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cab:	0f b6 00             	movzbl (%eax),%eax
+  800cae:	84 c0                	test   %al,%al
+  800cb0:	74 10                	je     800cc2 <strncmp+0x31>
+  800cb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb5:	0f b6 10             	movzbl (%eax),%edx
+  800cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cbb:	0f b6 00             	movzbl (%eax),%eax
+  800cbe:	38 c2                	cmp    %al,%dl
+  800cc0:	74 d4                	je     800c96 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800cc2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cc6:	75 07                	jne    800ccf <strncmp+0x3e>
+		return 0;
+  800cc8:	b8 00 00 00 00       	mov    $0x0,%eax
+  800ccd:	eb 16                	jmp    800ce5 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800ccf:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cd2:	0f b6 00             	movzbl (%eax),%eax
+  800cd5:	0f b6 d0             	movzbl %al,%edx
+  800cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cdb:	0f b6 00             	movzbl (%eax),%eax
+  800cde:	0f b6 c0             	movzbl %al,%eax
+  800ce1:	29 c2                	sub    %eax,%edx
+  800ce3:	89 d0                	mov    %edx,%eax
+}
+  800ce5:	5d                   	pop    %ebp
+  800ce6:	c3                   	ret    
+
+00800ce7 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800ce7:	55                   	push   %ebp
+  800ce8:	89 e5                	mov    %esp,%ebp
+  800cea:	83 ec 04             	sub    $0x4,%esp
+  800ced:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cf0:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cf3:	eb 14                	jmp    800d09 <strchr+0x22>
+		if (*s == c)
+  800cf5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cf8:	0f b6 00             	movzbl (%eax),%eax
+  800cfb:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800cfe:	75 05                	jne    800d05 <strchr+0x1e>
+			return (char *) s;
+  800d00:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d03:	eb 13                	jmp    800d18 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800d05:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d09:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d0c:	0f b6 00             	movzbl (%eax),%eax
+  800d0f:	84 c0                	test   %al,%al
+  800d11:	75 e2                	jne    800cf5 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d13:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d18:	c9                   	leave  
+  800d19:	c3                   	ret    
+
+00800d1a <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d1a:	55                   	push   %ebp
+  800d1b:	89 e5                	mov    %esp,%ebp
+  800d1d:	83 ec 04             	sub    $0x4,%esp
+  800d20:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d23:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d26:	eb 11                	jmp    800d39 <strfind+0x1f>
+		if (*s == c)
+  800d28:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d2b:	0f b6 00             	movzbl (%eax),%eax
+  800d2e:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d31:	75 02                	jne    800d35 <strfind+0x1b>
+			break;
+  800d33:	eb 0e                	jmp    800d43 <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d35:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d39:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d3c:	0f b6 00             	movzbl (%eax),%eax
+  800d3f:	84 c0                	test   %al,%al
+  800d41:	75 e5                	jne    800d28 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d43:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d46:	c9                   	leave  
+  800d47:	c3                   	ret    
+
+00800d48 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d48:	55                   	push   %ebp
+  800d49:	89 e5                	mov    %esp,%ebp
+  800d4b:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d4c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d50:	75 05                	jne    800d57 <memset+0xf>
+		return v;
+  800d52:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d55:	eb 5c                	jmp    800db3 <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d57:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d5a:	83 e0 03             	and    $0x3,%eax
+  800d5d:	85 c0                	test   %eax,%eax
+  800d5f:	75 41                	jne    800da2 <memset+0x5a>
+  800d61:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d64:	83 e0 03             	and    $0x3,%eax
+  800d67:	85 c0                	test   %eax,%eax
+  800d69:	75 37                	jne    800da2 <memset+0x5a>
+		c &= 0xFF;
+  800d6b:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d72:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d75:	c1 e0 18             	shl    $0x18,%eax
+  800d78:	89 c2                	mov    %eax,%edx
+  800d7a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7d:	c1 e0 10             	shl    $0x10,%eax
+  800d80:	09 c2                	or     %eax,%edx
+  800d82:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d85:	c1 e0 08             	shl    $0x8,%eax
+  800d88:	09 d0                	or     %edx,%eax
+  800d8a:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d8d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d90:	c1 e8 02             	shr    $0x2,%eax
+  800d93:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800d95:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d98:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d9b:	89 d7                	mov    %edx,%edi
+  800d9d:	fc                   	cld    
+  800d9e:	f3 ab                	rep stos %eax,%es:(%edi)
+  800da0:	eb 0e                	jmp    800db0 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800da2:	8b 55 08             	mov    0x8(%ebp),%edx
+  800da5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800da8:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800dab:	89 d7                	mov    %edx,%edi
+  800dad:	fc                   	cld    
+  800dae:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800db0:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800db3:	5f                   	pop    %edi
+  800db4:	5d                   	pop    %ebp
+  800db5:	c3                   	ret    
+
+00800db6 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800db6:	55                   	push   %ebp
+  800db7:	89 e5                	mov    %esp,%ebp
+  800db9:	57                   	push   %edi
+  800dba:	56                   	push   %esi
+  800dbb:	53                   	push   %ebx
+  800dbc:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800dc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dce:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dd1:	73 6d                	jae    800e40 <memmove+0x8a>
+  800dd3:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dd6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800dd9:	01 d0                	add    %edx,%eax
+  800ddb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dde:	76 60                	jbe    800e40 <memmove+0x8a>
+		s += n;
+  800de0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de3:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800de6:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de9:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800def:	83 e0 03             	and    $0x3,%eax
+  800df2:	85 c0                	test   %eax,%eax
+  800df4:	75 2f                	jne    800e25 <memmove+0x6f>
+  800df6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800df9:	83 e0 03             	and    $0x3,%eax
+  800dfc:	85 c0                	test   %eax,%eax
+  800dfe:	75 25                	jne    800e25 <memmove+0x6f>
+  800e00:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e03:	83 e0 03             	and    $0x3,%eax
+  800e06:	85 c0                	test   %eax,%eax
+  800e08:	75 1b                	jne    800e25 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e0d:	83 e8 04             	sub    $0x4,%eax
+  800e10:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e13:	83 ea 04             	sub    $0x4,%edx
+  800e16:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e19:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e1c:	89 c7                	mov    %eax,%edi
+  800e1e:	89 d6                	mov    %edx,%esi
+  800e20:	fd                   	std    
+  800e21:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e23:	eb 18                	jmp    800e3d <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e25:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e28:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e2e:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e31:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e34:	89 d7                	mov    %edx,%edi
+  800e36:	89 de                	mov    %ebx,%esi
+  800e38:	89 c1                	mov    %eax,%ecx
+  800e3a:	fd                   	std    
+  800e3b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e3d:	fc                   	cld    
+  800e3e:	eb 45                	jmp    800e85 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e40:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e43:	83 e0 03             	and    $0x3,%eax
+  800e46:	85 c0                	test   %eax,%eax
+  800e48:	75 2b                	jne    800e75 <memmove+0xbf>
+  800e4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e4d:	83 e0 03             	and    $0x3,%eax
+  800e50:	85 c0                	test   %eax,%eax
+  800e52:	75 21                	jne    800e75 <memmove+0xbf>
+  800e54:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e57:	83 e0 03             	and    $0x3,%eax
+  800e5a:	85 c0                	test   %eax,%eax
+  800e5c:	75 17                	jne    800e75 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e5e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e61:	c1 e8 02             	shr    $0x2,%eax
+  800e64:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e66:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e69:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e6c:	89 c7                	mov    %eax,%edi
+  800e6e:	89 d6                	mov    %edx,%esi
+  800e70:	fc                   	cld    
+  800e71:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e73:	eb 10                	jmp    800e85 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e75:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e78:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e7b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e7e:	89 c7                	mov    %eax,%edi
+  800e80:	89 d6                	mov    %edx,%esi
+  800e82:	fc                   	cld    
+  800e83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e85:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e88:	83 c4 10             	add    $0x10,%esp
+  800e8b:	5b                   	pop    %ebx
+  800e8c:	5e                   	pop    %esi
+  800e8d:	5f                   	pop    %edi
+  800e8e:	5d                   	pop    %ebp
+  800e8f:	c3                   	ret    
+
+00800e90 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e90:	55                   	push   %ebp
+  800e91:	89 e5                	mov    %esp,%ebp
+  800e93:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800e96:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e99:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800e9d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ea0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ea4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ea7:	89 04 24             	mov    %eax,(%esp)
+  800eaa:	e8 07 ff ff ff       	call   800db6 <memmove>
+}
+  800eaf:	c9                   	leave  
+  800eb0:	c3                   	ret    
+
+00800eb1 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800eb1:	55                   	push   %ebp
+  800eb2:	89 e5                	mov    %esp,%ebp
+  800eb4:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800eb7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eba:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800ebd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ec0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800ec3:	eb 30                	jmp    800ef5 <memcmp+0x44>
+		if (*s1 != *s2)
+  800ec5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ec8:	0f b6 10             	movzbl (%eax),%edx
+  800ecb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ece:	0f b6 00             	movzbl (%eax),%eax
+  800ed1:	38 c2                	cmp    %al,%dl
+  800ed3:	74 18                	je     800eed <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ed5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ed8:	0f b6 00             	movzbl (%eax),%eax
+  800edb:	0f b6 d0             	movzbl %al,%edx
+  800ede:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ee1:	0f b6 00             	movzbl (%eax),%eax
+  800ee4:	0f b6 c0             	movzbl %al,%eax
+  800ee7:	29 c2                	sub    %eax,%edx
+  800ee9:	89 d0                	mov    %edx,%eax
+  800eeb:	eb 1a                	jmp    800f07 <memcmp+0x56>
+		s1++, s2++;
+  800eed:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800ef1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800ef5:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ef8:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800efb:	89 55 10             	mov    %edx,0x10(%ebp)
+  800efe:	85 c0                	test   %eax,%eax
+  800f00:	75 c3                	jne    800ec5 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800f02:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800f07:	c9                   	leave  
+  800f08:	c3                   	ret    
+
+00800f09 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f09:	55                   	push   %ebp
+  800f0a:	89 e5                	mov    %esp,%ebp
+  800f0c:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f0f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f12:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f15:	01 d0                	add    %edx,%eax
+  800f17:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f1a:	eb 13                	jmp    800f2f <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f1c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f1f:	0f b6 10             	movzbl (%eax),%edx
+  800f22:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f25:	38 c2                	cmp    %al,%dl
+  800f27:	75 02                	jne    800f2b <memfind+0x22>
+			break;
+  800f29:	eb 0c                	jmp    800f37 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f2b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f2f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f32:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f35:	72 e5                	jb     800f1c <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f37:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f3a:	c9                   	leave  
+  800f3b:	c3                   	ret    
+
+00800f3c <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f3c:	55                   	push   %ebp
+  800f3d:	89 e5                	mov    %esp,%ebp
+  800f3f:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f42:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f49:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f50:	eb 04                	jmp    800f56 <strtol+0x1a>
+		s++;
+  800f52:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f56:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f59:	0f b6 00             	movzbl (%eax),%eax
+  800f5c:	3c 20                	cmp    $0x20,%al
+  800f5e:	74 f2                	je     800f52 <strtol+0x16>
+  800f60:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f63:	0f b6 00             	movzbl (%eax),%eax
+  800f66:	3c 09                	cmp    $0x9,%al
+  800f68:	74 e8                	je     800f52 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f6a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f6d:	0f b6 00             	movzbl (%eax),%eax
+  800f70:	3c 2b                	cmp    $0x2b,%al
+  800f72:	75 06                	jne    800f7a <strtol+0x3e>
+		s++;
+  800f74:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f78:	eb 15                	jmp    800f8f <strtol+0x53>
+	else if (*s == '-')
+  800f7a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f7d:	0f b6 00             	movzbl (%eax),%eax
+  800f80:	3c 2d                	cmp    $0x2d,%al
+  800f82:	75 0b                	jne    800f8f <strtol+0x53>
+		s++, neg = 1;
+  800f84:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f88:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f8f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f93:	74 06                	je     800f9b <strtol+0x5f>
+  800f95:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800f99:	75 24                	jne    800fbf <strtol+0x83>
+  800f9b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f9e:	0f b6 00             	movzbl (%eax),%eax
+  800fa1:	3c 30                	cmp    $0x30,%al
+  800fa3:	75 1a                	jne    800fbf <strtol+0x83>
+  800fa5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fa8:	83 c0 01             	add    $0x1,%eax
+  800fab:	0f b6 00             	movzbl (%eax),%eax
+  800fae:	3c 78                	cmp    $0x78,%al
+  800fb0:	75 0d                	jne    800fbf <strtol+0x83>
+		s += 2, base = 16;
+  800fb2:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fb6:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fbd:	eb 2a                	jmp    800fe9 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fbf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fc3:	75 17                	jne    800fdc <strtol+0xa0>
+  800fc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fc8:	0f b6 00             	movzbl (%eax),%eax
+  800fcb:	3c 30                	cmp    $0x30,%al
+  800fcd:	75 0d                	jne    800fdc <strtol+0xa0>
+		s++, base = 8;
+  800fcf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fd3:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fda:	eb 0d                	jmp    800fe9 <strtol+0xad>
+	else if (base == 0)
+  800fdc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fe0:	75 07                	jne    800fe9 <strtol+0xad>
+		base = 10;
+  800fe2:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800fe9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fec:	0f b6 00             	movzbl (%eax),%eax
+  800fef:	3c 2f                	cmp    $0x2f,%al
+  800ff1:	7e 1b                	jle    80100e <strtol+0xd2>
+  800ff3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff6:	0f b6 00             	movzbl (%eax),%eax
+  800ff9:	3c 39                	cmp    $0x39,%al
+  800ffb:	7f 11                	jg     80100e <strtol+0xd2>
+			dig = *s - '0';
+  800ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+  801000:	0f b6 00             	movzbl (%eax),%eax
+  801003:	0f be c0             	movsbl %al,%eax
+  801006:	83 e8 30             	sub    $0x30,%eax
+  801009:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  80100c:	eb 48                	jmp    801056 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  80100e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801011:	0f b6 00             	movzbl (%eax),%eax
+  801014:	3c 60                	cmp    $0x60,%al
+  801016:	7e 1b                	jle    801033 <strtol+0xf7>
+  801018:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101b:	0f b6 00             	movzbl (%eax),%eax
+  80101e:	3c 7a                	cmp    $0x7a,%al
+  801020:	7f 11                	jg     801033 <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  801022:	8b 45 08             	mov    0x8(%ebp),%eax
+  801025:	0f b6 00             	movzbl (%eax),%eax
+  801028:	0f be c0             	movsbl %al,%eax
+  80102b:	83 e8 57             	sub    $0x57,%eax
+  80102e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801031:	eb 23                	jmp    801056 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  801033:	8b 45 08             	mov    0x8(%ebp),%eax
+  801036:	0f b6 00             	movzbl (%eax),%eax
+  801039:	3c 40                	cmp    $0x40,%al
+  80103b:	7e 3d                	jle    80107a <strtol+0x13e>
+  80103d:	8b 45 08             	mov    0x8(%ebp),%eax
+  801040:	0f b6 00             	movzbl (%eax),%eax
+  801043:	3c 5a                	cmp    $0x5a,%al
+  801045:	7f 33                	jg     80107a <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  801047:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104a:	0f b6 00             	movzbl (%eax),%eax
+  80104d:	0f be c0             	movsbl %al,%eax
+  801050:	83 e8 37             	sub    $0x37,%eax
+  801053:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  801056:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801059:	3b 45 10             	cmp    0x10(%ebp),%eax
+  80105c:	7c 02                	jl     801060 <strtol+0x124>
+			break;
+  80105e:	eb 1a                	jmp    80107a <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  801060:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  801064:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801067:	0f af 45 10          	imul   0x10(%ebp),%eax
+  80106b:	89 c2                	mov    %eax,%edx
+  80106d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801070:	01 d0                	add    %edx,%eax
+  801072:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  801075:	e9 6f ff ff ff       	jmp    800fe9 <strtol+0xad>
+
+	if (endptr)
+  80107a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80107e:	74 08                	je     801088 <strtol+0x14c>
+		*endptr = (char *) s;
+  801080:	8b 45 0c             	mov    0xc(%ebp),%eax
+  801083:	8b 55 08             	mov    0x8(%ebp),%edx
+  801086:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801088:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  80108c:	74 07                	je     801095 <strtol+0x159>
+  80108e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801091:	f7 d8                	neg    %eax
+  801093:	eb 03                	jmp    801098 <strtol+0x15c>
+  801095:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  801098:	c9                   	leave  
+  801099:	c3                   	ret    
+  80109a:	66 90                	xchg   %ax,%ax
+  80109c:	66 90                	xchg   %ax,%ax
+  80109e:	66 90                	xchg   %ax,%ax
+
+008010a0 <__udivdi3>:
+  8010a0:	55                   	push   %ebp
+  8010a1:	57                   	push   %edi
+  8010a2:	56                   	push   %esi
+  8010a3:	83 ec 0c             	sub    $0xc,%esp
+  8010a6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010aa:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010ae:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010b2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010b6:	85 c0                	test   %eax,%eax
+  8010b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010bc:	89 ea                	mov    %ebp,%edx
+  8010be:	89 0c 24             	mov    %ecx,(%esp)
+  8010c1:	75 2d                	jne    8010f0 <__udivdi3+0x50>
+  8010c3:	39 e9                	cmp    %ebp,%ecx
+  8010c5:	77 61                	ja     801128 <__udivdi3+0x88>
+  8010c7:	85 c9                	test   %ecx,%ecx
+  8010c9:	89 ce                	mov    %ecx,%esi
+  8010cb:	75 0b                	jne    8010d8 <__udivdi3+0x38>
+  8010cd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010d2:	31 d2                	xor    %edx,%edx
+  8010d4:	f7 f1                	div    %ecx
+  8010d6:	89 c6                	mov    %eax,%esi
+  8010d8:	31 d2                	xor    %edx,%edx
+  8010da:	89 e8                	mov    %ebp,%eax
+  8010dc:	f7 f6                	div    %esi
+  8010de:	89 c5                	mov    %eax,%ebp
+  8010e0:	89 f8                	mov    %edi,%eax
+  8010e2:	f7 f6                	div    %esi
+  8010e4:	89 ea                	mov    %ebp,%edx
+  8010e6:	83 c4 0c             	add    $0xc,%esp
+  8010e9:	5e                   	pop    %esi
+  8010ea:	5f                   	pop    %edi
+  8010eb:	5d                   	pop    %ebp
+  8010ec:	c3                   	ret    
+  8010ed:	8d 76 00             	lea    0x0(%esi),%esi
+  8010f0:	39 e8                	cmp    %ebp,%eax
+  8010f2:	77 24                	ja     801118 <__udivdi3+0x78>
+  8010f4:	0f bd e8             	bsr    %eax,%ebp
+  8010f7:	83 f5 1f             	xor    $0x1f,%ebp
+  8010fa:	75 3c                	jne    801138 <__udivdi3+0x98>
+  8010fc:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801100:	39 34 24             	cmp    %esi,(%esp)
+  801103:	0f 86 9f 00 00 00    	jbe    8011a8 <__udivdi3+0x108>
+  801109:	39 d0                	cmp    %edx,%eax
+  80110b:	0f 82 97 00 00 00    	jb     8011a8 <__udivdi3+0x108>
+  801111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801118:	31 d2                	xor    %edx,%edx
+  80111a:	31 c0                	xor    %eax,%eax
+  80111c:	83 c4 0c             	add    $0xc,%esp
+  80111f:	5e                   	pop    %esi
+  801120:	5f                   	pop    %edi
+  801121:	5d                   	pop    %ebp
+  801122:	c3                   	ret    
+  801123:	90                   	nop
+  801124:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801128:	89 f8                	mov    %edi,%eax
+  80112a:	f7 f1                	div    %ecx
+  80112c:	31 d2                	xor    %edx,%edx
+  80112e:	83 c4 0c             	add    $0xc,%esp
+  801131:	5e                   	pop    %esi
+  801132:	5f                   	pop    %edi
+  801133:	5d                   	pop    %ebp
+  801134:	c3                   	ret    
+  801135:	8d 76 00             	lea    0x0(%esi),%esi
+  801138:	89 e9                	mov    %ebp,%ecx
+  80113a:	8b 3c 24             	mov    (%esp),%edi
+  80113d:	d3 e0                	shl    %cl,%eax
+  80113f:	89 c6                	mov    %eax,%esi
+  801141:	b8 20 00 00 00       	mov    $0x20,%eax
+  801146:	29 e8                	sub    %ebp,%eax
+  801148:	89 c1                	mov    %eax,%ecx
+  80114a:	d3 ef                	shr    %cl,%edi
+  80114c:	89 e9                	mov    %ebp,%ecx
+  80114e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801152:	8b 3c 24             	mov    (%esp),%edi
+  801155:	09 74 24 08          	or     %esi,0x8(%esp)
+  801159:	89 d6                	mov    %edx,%esi
+  80115b:	d3 e7                	shl    %cl,%edi
+  80115d:	89 c1                	mov    %eax,%ecx
+  80115f:	89 3c 24             	mov    %edi,(%esp)
+  801162:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801166:	d3 ee                	shr    %cl,%esi
+  801168:	89 e9                	mov    %ebp,%ecx
+  80116a:	d3 e2                	shl    %cl,%edx
+  80116c:	89 c1                	mov    %eax,%ecx
+  80116e:	d3 ef                	shr    %cl,%edi
+  801170:	09 d7                	or     %edx,%edi
+  801172:	89 f2                	mov    %esi,%edx
+  801174:	89 f8                	mov    %edi,%eax
+  801176:	f7 74 24 08          	divl   0x8(%esp)
+  80117a:	89 d6                	mov    %edx,%esi
+  80117c:	89 c7                	mov    %eax,%edi
+  80117e:	f7 24 24             	mull   (%esp)
+  801181:	39 d6                	cmp    %edx,%esi
+  801183:	89 14 24             	mov    %edx,(%esp)
+  801186:	72 30                	jb     8011b8 <__udivdi3+0x118>
+  801188:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80118c:	89 e9                	mov    %ebp,%ecx
+  80118e:	d3 e2                	shl    %cl,%edx
+  801190:	39 c2                	cmp    %eax,%edx
+  801192:	73 05                	jae    801199 <__udivdi3+0xf9>
+  801194:	3b 34 24             	cmp    (%esp),%esi
+  801197:	74 1f                	je     8011b8 <__udivdi3+0x118>
+  801199:	89 f8                	mov    %edi,%eax
+  80119b:	31 d2                	xor    %edx,%edx
+  80119d:	e9 7a ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011a8:	31 d2                	xor    %edx,%edx
+  8011aa:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011af:	e9 68 ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011b8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011bb:	31 d2                	xor    %edx,%edx
+  8011bd:	83 c4 0c             	add    $0xc,%esp
+  8011c0:	5e                   	pop    %esi
+  8011c1:	5f                   	pop    %edi
+  8011c2:	5d                   	pop    %ebp
+  8011c3:	c3                   	ret    
+  8011c4:	66 90                	xchg   %ax,%ax
+  8011c6:	66 90                	xchg   %ax,%ax
+  8011c8:	66 90                	xchg   %ax,%ax
+  8011ca:	66 90                	xchg   %ax,%ax
+  8011cc:	66 90                	xchg   %ax,%ax
+  8011ce:	66 90                	xchg   %ax,%ax
+
+008011d0 <__umoddi3>:
+  8011d0:	55                   	push   %ebp
+  8011d1:	57                   	push   %edi
+  8011d2:	56                   	push   %esi
+  8011d3:	83 ec 14             	sub    $0x14,%esp
+  8011d6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011da:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011de:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011e2:	89 c7                	mov    %eax,%edi
+  8011e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011e8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011ec:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8011f0:	89 34 24             	mov    %esi,(%esp)
+  8011f3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8011f7:	85 c0                	test   %eax,%eax
+  8011f9:	89 c2                	mov    %eax,%edx
+  8011fb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8011ff:	75 17                	jne    801218 <__umoddi3+0x48>
+  801201:	39 fe                	cmp    %edi,%esi
+  801203:	76 4b                	jbe    801250 <__umoddi3+0x80>
+  801205:	89 c8                	mov    %ecx,%eax
+  801207:	89 fa                	mov    %edi,%edx
+  801209:	f7 f6                	div    %esi
+  80120b:	89 d0                	mov    %edx,%eax
+  80120d:	31 d2                	xor    %edx,%edx
+  80120f:	83 c4 14             	add    $0x14,%esp
+  801212:	5e                   	pop    %esi
+  801213:	5f                   	pop    %edi
+  801214:	5d                   	pop    %ebp
+  801215:	c3                   	ret    
+  801216:	66 90                	xchg   %ax,%ax
+  801218:	39 f8                	cmp    %edi,%eax
+  80121a:	77 54                	ja     801270 <__umoddi3+0xa0>
+  80121c:	0f bd e8             	bsr    %eax,%ebp
+  80121f:	83 f5 1f             	xor    $0x1f,%ebp
+  801222:	75 5c                	jne    801280 <__umoddi3+0xb0>
+  801224:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801228:	39 3c 24             	cmp    %edi,(%esp)
+  80122b:	0f 87 e7 00 00 00    	ja     801318 <__umoddi3+0x148>
+  801231:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801235:	29 f1                	sub    %esi,%ecx
+  801237:	19 c7                	sbb    %eax,%edi
+  801239:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80123d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801241:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801245:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801249:	83 c4 14             	add    $0x14,%esp
+  80124c:	5e                   	pop    %esi
+  80124d:	5f                   	pop    %edi
+  80124e:	5d                   	pop    %ebp
+  80124f:	c3                   	ret    
+  801250:	85 f6                	test   %esi,%esi
+  801252:	89 f5                	mov    %esi,%ebp
+  801254:	75 0b                	jne    801261 <__umoddi3+0x91>
+  801256:	b8 01 00 00 00       	mov    $0x1,%eax
+  80125b:	31 d2                	xor    %edx,%edx
+  80125d:	f7 f6                	div    %esi
+  80125f:	89 c5                	mov    %eax,%ebp
+  801261:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801265:	31 d2                	xor    %edx,%edx
+  801267:	f7 f5                	div    %ebp
+  801269:	89 c8                	mov    %ecx,%eax
+  80126b:	f7 f5                	div    %ebp
+  80126d:	eb 9c                	jmp    80120b <__umoddi3+0x3b>
+  80126f:	90                   	nop
+  801270:	89 c8                	mov    %ecx,%eax
+  801272:	89 fa                	mov    %edi,%edx
+  801274:	83 c4 14             	add    $0x14,%esp
+  801277:	5e                   	pop    %esi
+  801278:	5f                   	pop    %edi
+  801279:	5d                   	pop    %ebp
+  80127a:	c3                   	ret    
+  80127b:	90                   	nop
+  80127c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801280:	8b 04 24             	mov    (%esp),%eax
+  801283:	be 20 00 00 00       	mov    $0x20,%esi
+  801288:	89 e9                	mov    %ebp,%ecx
+  80128a:	29 ee                	sub    %ebp,%esi
+  80128c:	d3 e2                	shl    %cl,%edx
+  80128e:	89 f1                	mov    %esi,%ecx
+  801290:	d3 e8                	shr    %cl,%eax
+  801292:	89 e9                	mov    %ebp,%ecx
+  801294:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801298:	8b 04 24             	mov    (%esp),%eax
+  80129b:	09 54 24 04          	or     %edx,0x4(%esp)
+  80129f:	89 fa                	mov    %edi,%edx
+  8012a1:	d3 e0                	shl    %cl,%eax
+  8012a3:	89 f1                	mov    %esi,%ecx
+  8012a5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012a9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012ad:	d3 ea                	shr    %cl,%edx
+  8012af:	89 e9                	mov    %ebp,%ecx
+  8012b1:	d3 e7                	shl    %cl,%edi
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	d3 e8                	shr    %cl,%eax
+  8012b7:	89 e9                	mov    %ebp,%ecx
+  8012b9:	09 f8                	or     %edi,%eax
+  8012bb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012bf:	f7 74 24 04          	divl   0x4(%esp)
+  8012c3:	d3 e7                	shl    %cl,%edi
+  8012c5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012c9:	89 d7                	mov    %edx,%edi
+  8012cb:	f7 64 24 08          	mull   0x8(%esp)
+  8012cf:	39 d7                	cmp    %edx,%edi
+  8012d1:	89 c1                	mov    %eax,%ecx
+  8012d3:	89 14 24             	mov    %edx,(%esp)
+  8012d6:	72 2c                	jb     801304 <__umoddi3+0x134>
+  8012d8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012dc:	72 22                	jb     801300 <__umoddi3+0x130>
+  8012de:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012e2:	29 c8                	sub    %ecx,%eax
+  8012e4:	19 d7                	sbb    %edx,%edi
+  8012e6:	89 e9                	mov    %ebp,%ecx
+  8012e8:	89 fa                	mov    %edi,%edx
+  8012ea:	d3 e8                	shr    %cl,%eax
+  8012ec:	89 f1                	mov    %esi,%ecx
+  8012ee:	d3 e2                	shl    %cl,%edx
+  8012f0:	89 e9                	mov    %ebp,%ecx
+  8012f2:	d3 ef                	shr    %cl,%edi
+  8012f4:	09 d0                	or     %edx,%eax
+  8012f6:	89 fa                	mov    %edi,%edx
+  8012f8:	83 c4 14             	add    $0x14,%esp
+  8012fb:	5e                   	pop    %esi
+  8012fc:	5f                   	pop    %edi
+  8012fd:	5d                   	pop    %ebp
+  8012fe:	c3                   	ret    
+  8012ff:	90                   	nop
+  801300:	39 d7                	cmp    %edx,%edi
+  801302:	75 da                	jne    8012de <__umoddi3+0x10e>
+  801304:	8b 14 24             	mov    (%esp),%edx
+  801307:	89 c1                	mov    %eax,%ecx
+  801309:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80130d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801311:	eb cb                	jmp    8012de <__umoddi3+0x10e>
+  801313:	90                   	nop
+  801314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801318:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80131c:	0f 82 0f ff ff ff    	jb     801231 <__umoddi3+0x61>
+  801322:	e9 1a ff ff ff       	jmp    801241 <__umoddi3+0x71>
diff --git a/obj/user/faultwritekernel.o b/obj/user/faultwritekernel.o
new file mode 100644
index 0000000..cddcbaf
Binary files /dev/null and b/obj/user/faultwritekernel.o differ
diff --git a/obj/user/faultwritekernel.sym b/obj/user/faultwritekernel.sym
new file mode 100644
index 0000000..c366f92
--- /dev/null
+++ b/obj/user/faultwritekernel.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040d6 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+00800043 T libmain
+00800091 T exit
+008000a5 t syscall
+00800106 T sys_cputs
+00800148 T sys_cgetc
+0080018c T sys_env_destroy
+008001cf T sys_getenvid
+00800213 T _panic
+0080026e t putch
+008002ca T vcprintf
+0080032e T cprintf
+00800354 t printnum
+00800432 t getuint
+00800481 t getint
+008004c8 T vprintfmt
+00800a0f T printfmt
+00800a3d t sprintputch
+00800a72 T vsnprintf
+00800ad2 T snprintf
+00800b06 T strlen
+00800b2c T strnlen
+00800b5c T strcpy
+00800b8c T strcat
+00800bbc T strncpy
+00800c01 T strlcpy
+00800c52 T strcmp
+00800c91 T strncmp
+00800ce7 T strchr
+00800d1a T strfind
+00800d48 T memset
+00800db6 T memmove
+00800e90 T memcpy
+00800eb1 T memcmp
+00800f09 T memfind
+00800f3c T strtol
+008010a0 T __udivdi3
+008011d0 T __umoddi3
+008013f4 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/hello b/obj/user/hello
new file mode 100755
index 0000000..2fb6f2b
Binary files /dev/null and b/obj/user/hello differ
diff --git a/obj/user/hello.asm b/obj/user/hello.asm
new file mode 100644
index 0000000..280d93f
--- /dev/null
+++ b/obj/user/hello.asm
@@ -0,0 +1,2632 @@
+
+obj/user/hello:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 2e 00 00 00       	call   80005f <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+// hello, world
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 18             	sub    $0x18,%esp
+	cprintf("hello, world\n");
+  800039:	c7 04 24 48 13 80 00 	movl   $0x801348,(%esp)
+  800040:	e8 3c 01 00 00       	call   800181 <cprintf>
+	cprintf("i am environment %08x\n", thisenv->env_id);
+  800045:	a1 04 20 80 00       	mov    0x802004,%eax
+  80004a:	8b 40 48             	mov    0x48(%eax),%eax
+  80004d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800051:	c7 04 24 56 13 80 00 	movl   $0x801356,(%esp)
+  800058:	e8 24 01 00 00       	call   800181 <cprintf>
+}
+  80005d:	c9                   	leave  
+  80005e:	c3                   	ret    
+
+0080005f <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80005f:	55                   	push   %ebp
+  800060:	89 e5                	mov    %esp,%ebp
+  800062:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800065:	e8 ad 0f 00 00       	call   801017 <sys_getenvid>
+  80006a:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80006f:	89 c2                	mov    %eax,%edx
+  800071:	89 d0                	mov    %edx,%eax
+  800073:	01 c0                	add    %eax,%eax
+  800075:	01 d0                	add    %edx,%eax
+  800077:	c1 e0 05             	shl    $0x5,%eax
+  80007a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80007f:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800084:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800088:	7e 0a                	jle    800094 <libmain+0x35>
+		binaryname = argv[0];
+  80008a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80008d:	8b 00                	mov    (%eax),%eax
+  80008f:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800094:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800097:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80009b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80009e:	89 04 24             	mov    %eax,(%esp)
+  8000a1:	e8 8d ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  8000a6:	e8 02 00 00 00       	call   8000ad <exit>
+}
+  8000ab:	c9                   	leave  
+  8000ac:	c3                   	ret    
+
+008000ad <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  8000ad:	55                   	push   %ebp
+  8000ae:	89 e5                	mov    %esp,%ebp
+  8000b0:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  8000b3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8000ba:	e8 15 0f 00 00       	call   800fd4 <sys_env_destroy>
+}
+  8000bf:	c9                   	leave  
+  8000c0:	c3                   	ret    
+
+008000c1 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  8000c1:	55                   	push   %ebp
+  8000c2:	89 e5                	mov    %esp,%ebp
+  8000c4:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  8000c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000ca:	8b 00                	mov    (%eax),%eax
+  8000cc:	8d 48 01             	lea    0x1(%eax),%ecx
+  8000cf:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000d2:	89 0a                	mov    %ecx,(%edx)
+  8000d4:	8b 55 08             	mov    0x8(%ebp),%edx
+  8000d7:	89 d1                	mov    %edx,%ecx
+  8000d9:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000dc:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  8000e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000e3:	8b 00                	mov    (%eax),%eax
+  8000e5:	3d ff 00 00 00       	cmp    $0xff,%eax
+  8000ea:	75 20                	jne    80010c <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  8000ec:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8000ef:	8b 00                	mov    (%eax),%eax
+  8000f1:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8000f4:	83 c2 08             	add    $0x8,%edx
+  8000f7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8000fb:	89 14 24             	mov    %edx,(%esp)
+  8000fe:	e8 4b 0e 00 00       	call   800f4e <sys_cputs>
+		b->idx = 0;
+  800103:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800106:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  80010c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80010f:	8b 40 04             	mov    0x4(%eax),%eax
+  800112:	8d 50 01             	lea    0x1(%eax),%edx
+  800115:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800118:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  80011b:	c9                   	leave  
+  80011c:	c3                   	ret    
+
+0080011d <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  80011d:	55                   	push   %ebp
+  80011e:	89 e5                	mov    %esp,%ebp
+  800120:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  800126:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  80012d:	00 00 00 
+	b.cnt = 0;
+  800130:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  800137:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  80013a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80013d:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800141:	8b 45 08             	mov    0x8(%ebp),%eax
+  800144:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800148:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  80014e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800152:	c7 04 24 c1 00 80 00 	movl   $0x8000c1,(%esp)
+  800159:	e8 bd 01 00 00       	call   80031b <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  80015e:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800164:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800168:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  80016e:	83 c0 08             	add    $0x8,%eax
+  800171:	89 04 24             	mov    %eax,(%esp)
+  800174:	e8 d5 0d 00 00       	call   800f4e <sys_cputs>
+
+	return b.cnt;
+  800179:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  80017f:	c9                   	leave  
+  800180:	c3                   	ret    
+
+00800181 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800181:	55                   	push   %ebp
+  800182:	89 e5                	mov    %esp,%ebp
+  800184:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  800187:	8d 45 0c             	lea    0xc(%ebp),%eax
+  80018a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  80018d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800190:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800194:	8b 45 08             	mov    0x8(%ebp),%eax
+  800197:	89 04 24             	mov    %eax,(%esp)
+  80019a:	e8 7e ff ff ff       	call   80011d <vcprintf>
+  80019f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  8001a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8001a5:	c9                   	leave  
+  8001a6:	c3                   	ret    
+
+008001a7 <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  8001a7:	55                   	push   %ebp
+  8001a8:	89 e5                	mov    %esp,%ebp
+  8001aa:	53                   	push   %ebx
+  8001ab:	83 ec 34             	sub    $0x34,%esp
+  8001ae:	8b 45 10             	mov    0x10(%ebp),%eax
+  8001b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8001b4:	8b 45 14             	mov    0x14(%ebp),%eax
+  8001b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  8001ba:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001bd:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001c2:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001c5:	77 72                	ja     800239 <printnum+0x92>
+  8001c7:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8001ca:	72 05                	jb     8001d1 <printnum+0x2a>
+  8001cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  8001cf:	77 68                	ja     800239 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  8001d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8001d4:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  8001d7:	8b 45 18             	mov    0x18(%ebp),%eax
+  8001da:	ba 00 00 00 00       	mov    $0x0,%edx
+  8001df:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001e3:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8001e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8001ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8001ed:	89 04 24             	mov    %eax,(%esp)
+  8001f0:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8001f4:	e8 c7 0e 00 00       	call   8010c0 <__udivdi3>
+  8001f9:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8001fc:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  800200:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  800204:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  800207:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  80020b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80020f:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800213:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800216:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80021a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80021d:	89 04 24             	mov    %eax,(%esp)
+  800220:	e8 82 ff ff ff       	call   8001a7 <printnum>
+  800225:	eb 1c                	jmp    800243 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  800227:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80022a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80022e:	8b 45 20             	mov    0x20(%ebp),%eax
+  800231:	89 04 24             	mov    %eax,(%esp)
+  800234:	8b 45 08             	mov    0x8(%ebp),%eax
+  800237:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  800239:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  80023d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  800241:	7f e4                	jg     800227 <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  800243:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  800246:	bb 00 00 00 00       	mov    $0x0,%ebx
+  80024b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80024e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800251:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  800255:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800259:	89 04 24             	mov    %eax,(%esp)
+  80025c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800260:	e8 8b 0f 00 00       	call   8011f0 <__umoddi3>
+  800265:	05 00 14 80 00       	add    $0x801400,%eax
+  80026a:	0f b6 00             	movzbl (%eax),%eax
+  80026d:	0f be c0             	movsbl %al,%eax
+  800270:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800273:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800277:	89 04 24             	mov    %eax,(%esp)
+  80027a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80027d:	ff d0                	call   *%eax
+}
+  80027f:	83 c4 34             	add    $0x34,%esp
+  800282:	5b                   	pop    %ebx
+  800283:	5d                   	pop    %ebp
+  800284:	c3                   	ret    
+
+00800285 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800285:	55                   	push   %ebp
+  800286:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  800288:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80028c:	7e 14                	jle    8002a2 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  80028e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800291:	8b 00                	mov    (%eax),%eax
+  800293:	8d 48 08             	lea    0x8(%eax),%ecx
+  800296:	8b 55 08             	mov    0x8(%ebp),%edx
+  800299:	89 0a                	mov    %ecx,(%edx)
+  80029b:	8b 50 04             	mov    0x4(%eax),%edx
+  80029e:	8b 00                	mov    (%eax),%eax
+  8002a0:	eb 30                	jmp    8002d2 <getuint+0x4d>
+	else if (lflag)
+  8002a2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8002a6:	74 16                	je     8002be <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  8002a8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002ab:	8b 00                	mov    (%eax),%eax
+  8002ad:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002b0:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002b3:	89 0a                	mov    %ecx,(%edx)
+  8002b5:	8b 00                	mov    (%eax),%eax
+  8002b7:	ba 00 00 00 00       	mov    $0x0,%edx
+  8002bc:	eb 14                	jmp    8002d2 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  8002be:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002c1:	8b 00                	mov    (%eax),%eax
+  8002c3:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002c6:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002c9:	89 0a                	mov    %ecx,(%edx)
+  8002cb:	8b 00                	mov    (%eax),%eax
+  8002cd:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  8002d2:	5d                   	pop    %ebp
+  8002d3:	c3                   	ret    
+
+008002d4 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  8002d4:	55                   	push   %ebp
+  8002d5:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  8002d7:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  8002db:	7e 14                	jle    8002f1 <getint+0x1d>
+		return va_arg(*ap, long long);
+  8002dd:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002e0:	8b 00                	mov    (%eax),%eax
+  8002e2:	8d 48 08             	lea    0x8(%eax),%ecx
+  8002e5:	8b 55 08             	mov    0x8(%ebp),%edx
+  8002e8:	89 0a                	mov    %ecx,(%edx)
+  8002ea:	8b 50 04             	mov    0x4(%eax),%edx
+  8002ed:	8b 00                	mov    (%eax),%eax
+  8002ef:	eb 28                	jmp    800319 <getint+0x45>
+	else if (lflag)
+  8002f1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8002f5:	74 12                	je     800309 <getint+0x35>
+		return va_arg(*ap, long);
+  8002f7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002fa:	8b 00                	mov    (%eax),%eax
+  8002fc:	8d 48 04             	lea    0x4(%eax),%ecx
+  8002ff:	8b 55 08             	mov    0x8(%ebp),%edx
+  800302:	89 0a                	mov    %ecx,(%edx)
+  800304:	8b 00                	mov    (%eax),%eax
+  800306:	99                   	cltd   
+  800307:	eb 10                	jmp    800319 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  800309:	8b 45 08             	mov    0x8(%ebp),%eax
+  80030c:	8b 00                	mov    (%eax),%eax
+  80030e:	8d 48 04             	lea    0x4(%eax),%ecx
+  800311:	8b 55 08             	mov    0x8(%ebp),%edx
+  800314:	89 0a                	mov    %ecx,(%edx)
+  800316:	8b 00                	mov    (%eax),%eax
+  800318:	99                   	cltd   
+}
+  800319:	5d                   	pop    %ebp
+  80031a:	c3                   	ret    
+
+0080031b <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  80031b:	55                   	push   %ebp
+  80031c:	89 e5                	mov    %esp,%ebp
+  80031e:	56                   	push   %esi
+  80031f:	53                   	push   %ebx
+  800320:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800323:	e9 72 01 00 00       	jmp    80049a <vprintfmt+0x17f>
+			if (ch == '\0')
+  800328:	85 db                	test   %ebx,%ebx
+  80032a:	75 05                	jne    800331 <vprintfmt+0x16>
+				return;
+  80032c:	e9 2a 05 00 00       	jmp    80085b <vprintfmt+0x540>
+			else if(ch == '\033'){
+  800331:	83 fb 1b             	cmp    $0x1b,%ebx
+  800334:	0f 85 51 01 00 00    	jne    80048b <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  80033a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80033d:	8d 50 01             	lea    0x1(%eax),%edx
+  800340:	89 55 10             	mov    %edx,0x10(%ebp)
+  800343:	0f b6 00             	movzbl (%eax),%eax
+  800346:	0f b6 d8             	movzbl %al,%ebx
+  800349:	83 fb 5b             	cmp    $0x5b,%ebx
+  80034c:	74 14                	je     800362 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  80034e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800351:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800355:	89 1c 24             	mov    %ebx,(%esp)
+  800358:	8b 45 08             	mov    0x8(%ebp),%eax
+  80035b:	ff d0                	call   *%eax
+				    continue;
+  80035d:	e9 38 01 00 00       	jmp    80049a <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800362:	8b 45 10             	mov    0x10(%ebp),%eax
+  800365:	8d 50 01             	lea    0x1(%eax),%edx
+  800368:	89 55 10             	mov    %edx,0x10(%ebp)
+  80036b:	0f b6 00             	movzbl (%eax),%eax
+  80036e:	0f b6 c0             	movzbl %al,%eax
+  800371:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  800376:	8b 45 10             	mov    0x10(%ebp),%eax
+  800379:	8d 50 01             	lea    0x1(%eax),%edx
+  80037c:	89 55 10             	mov    %edx,0x10(%ebp)
+  80037f:	0f b6 00             	movzbl (%eax),%eax
+  800382:	0f b6 c0             	movzbl %al,%eax
+  800385:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  80038a:	a1 08 20 80 00       	mov    0x802008,%eax
+  80038f:	83 f8 2f             	cmp    $0x2f,%eax
+  800392:	7e 19                	jle    8003ad <vprintfmt+0x92>
+  800394:	a1 08 20 80 00       	mov    0x802008,%eax
+  800399:	83 f8 39             	cmp    $0x39,%eax
+  80039c:	7f 0f                	jg     8003ad <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  80039e:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003a3:	83 e8 30             	sub    $0x30,%eax
+  8003a6:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003ab:	eb 50                	jmp    8003fd <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  8003ad:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003b2:	83 f8 60             	cmp    $0x60,%eax
+  8003b5:	7e 19                	jle    8003d0 <vprintfmt+0xb5>
+  8003b7:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003bc:	83 f8 66             	cmp    $0x66,%eax
+  8003bf:	7f 0f                	jg     8003d0 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  8003c1:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003c6:	83 e8 57             	sub    $0x57,%eax
+  8003c9:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003ce:	eb 2d                	jmp    8003fd <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  8003d0:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003d5:	83 f8 40             	cmp    $0x40,%eax
+  8003d8:	7e 19                	jle    8003f3 <vprintfmt+0xd8>
+  8003da:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003df:	83 f8 46             	cmp    $0x46,%eax
+  8003e2:	7f 0f                	jg     8003f3 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  8003e4:	a1 08 20 80 00       	mov    0x802008,%eax
+  8003e9:	83 e8 37             	sub    $0x37,%eax
+  8003ec:	a3 08 20 80 00       	mov    %eax,0x802008
+  8003f1:	eb 0a                	jmp    8003fd <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  8003f3:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  8003fa:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8003fd:	a1 10 20 80 00       	mov    0x802010,%eax
+  800402:	83 f8 2f             	cmp    $0x2f,%eax
+  800405:	7e 19                	jle    800420 <vprintfmt+0x105>
+  800407:	a1 10 20 80 00       	mov    0x802010,%eax
+  80040c:	83 f8 39             	cmp    $0x39,%eax
+  80040f:	7f 0f                	jg     800420 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  800411:	a1 10 20 80 00       	mov    0x802010,%eax
+  800416:	83 e8 30             	sub    $0x30,%eax
+  800419:	a3 10 20 80 00       	mov    %eax,0x802010
+  80041e:	eb 50                	jmp    800470 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  800420:	a1 10 20 80 00       	mov    0x802010,%eax
+  800425:	83 f8 60             	cmp    $0x60,%eax
+  800428:	7e 19                	jle    800443 <vprintfmt+0x128>
+  80042a:	a1 10 20 80 00       	mov    0x802010,%eax
+  80042f:	83 f8 66             	cmp    $0x66,%eax
+  800432:	7f 0f                	jg     800443 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  800434:	a1 10 20 80 00       	mov    0x802010,%eax
+  800439:	83 e8 57             	sub    $0x57,%eax
+  80043c:	a3 10 20 80 00       	mov    %eax,0x802010
+  800441:	eb 2d                	jmp    800470 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  800443:	a1 10 20 80 00       	mov    0x802010,%eax
+  800448:	83 f8 40             	cmp    $0x40,%eax
+  80044b:	7e 19                	jle    800466 <vprintfmt+0x14b>
+  80044d:	a1 10 20 80 00       	mov    0x802010,%eax
+  800452:	83 f8 46             	cmp    $0x46,%eax
+  800455:	7f 0f                	jg     800466 <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  800457:	a1 10 20 80 00       	mov    0x802010,%eax
+  80045c:	83 e8 37             	sub    $0x37,%eax
+  80045f:	a3 10 20 80 00       	mov    %eax,0x802010
+  800464:	eb 0a                	jmp    800470 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  800466:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  80046d:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800470:	a1 08 20 80 00       	mov    0x802008,%eax
+  800475:	c1 e0 0c             	shl    $0xc,%eax
+  800478:	89 c2                	mov    %eax,%edx
+  80047a:	a1 10 20 80 00       	mov    0x802010,%eax
+  80047f:	c1 e0 08             	shl    $0x8,%eax
+  800482:	09 d0                	or     %edx,%eax
+  800484:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  800489:	eb 0f                	jmp    80049a <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  80048b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80048e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800492:	89 1c 24             	mov    %ebx,(%esp)
+  800495:	8b 45 08             	mov    0x8(%ebp),%eax
+  800498:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80049a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80049d:	8d 50 01             	lea    0x1(%eax),%edx
+  8004a0:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004a3:	0f b6 00             	movzbl (%eax),%eax
+  8004a6:	0f b6 d8             	movzbl %al,%ebx
+  8004a9:	83 fb 25             	cmp    $0x25,%ebx
+  8004ac:	0f 85 76 fe ff ff    	jne    800328 <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  8004b2:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  8004b6:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  8004bd:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  8004c4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  8004cb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  8004d2:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004d5:	8d 50 01             	lea    0x1(%eax),%edx
+  8004d8:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004db:	0f b6 00             	movzbl (%eax),%eax
+  8004de:	0f b6 d8             	movzbl %al,%ebx
+  8004e1:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  8004e4:	83 f8 55             	cmp    $0x55,%eax
+  8004e7:	0f 87 3d 03 00 00    	ja     80082a <vprintfmt+0x50f>
+  8004ed:	8b 04 85 24 14 80 00 	mov    0x801424(,%eax,4),%eax
+  8004f4:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  8004f6:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  8004fa:	eb d6                	jmp    8004d2 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8004fc:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  800500:	eb d0                	jmp    8004d2 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800502:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  800509:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  80050c:	89 d0                	mov    %edx,%eax
+  80050e:	c1 e0 02             	shl    $0x2,%eax
+  800511:	01 d0                	add    %edx,%eax
+  800513:	01 c0                	add    %eax,%eax
+  800515:	01 d8                	add    %ebx,%eax
+  800517:	83 e8 30             	sub    $0x30,%eax
+  80051a:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  80051d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800520:	0f b6 00             	movzbl (%eax),%eax
+  800523:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  800526:	83 fb 2f             	cmp    $0x2f,%ebx
+  800529:	7e 0b                	jle    800536 <vprintfmt+0x21b>
+  80052b:	83 fb 39             	cmp    $0x39,%ebx
+  80052e:	7f 06                	jg     800536 <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800530:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  800534:	eb d3                	jmp    800509 <vprintfmt+0x1ee>
+			goto process_precision;
+  800536:	eb 33                	jmp    80056b <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  800538:	8b 45 14             	mov    0x14(%ebp),%eax
+  80053b:	8d 50 04             	lea    0x4(%eax),%edx
+  80053e:	89 55 14             	mov    %edx,0x14(%ebp)
+  800541:	8b 00                	mov    (%eax),%eax
+  800543:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  800546:	eb 23                	jmp    80056b <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  800548:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80054c:	79 0c                	jns    80055a <vprintfmt+0x23f>
+				width = 0;
+  80054e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  800555:	e9 78 ff ff ff       	jmp    8004d2 <vprintfmt+0x1b7>
+  80055a:	e9 73 ff ff ff       	jmp    8004d2 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  80055f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  800566:	e9 67 ff ff ff       	jmp    8004d2 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  80056b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80056f:	79 12                	jns    800583 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800571:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800574:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  800577:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  80057e:	e9 4f ff ff ff       	jmp    8004d2 <vprintfmt+0x1b7>
+  800583:	e9 4a ff ff ff       	jmp    8004d2 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  800588:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  80058c:	e9 41 ff ff ff       	jmp    8004d2 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800591:	8b 45 14             	mov    0x14(%ebp),%eax
+  800594:	8d 50 04             	lea    0x4(%eax),%edx
+  800597:	89 55 14             	mov    %edx,0x14(%ebp)
+  80059a:	8b 00                	mov    (%eax),%eax
+  80059c:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80059f:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8005a3:	89 04 24             	mov    %eax,(%esp)
+  8005a6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005a9:	ff d0                	call   *%eax
+			break;
+  8005ab:	e9 a5 02 00 00       	jmp    800855 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  8005b0:	8b 45 14             	mov    0x14(%ebp),%eax
+  8005b3:	8d 50 04             	lea    0x4(%eax),%edx
+  8005b6:	89 55 14             	mov    %edx,0x14(%ebp)
+  8005b9:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  8005bb:	85 db                	test   %ebx,%ebx
+  8005bd:	79 02                	jns    8005c1 <vprintfmt+0x2a6>
+				err = -err;
+  8005bf:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  8005c1:	83 fb 06             	cmp    $0x6,%ebx
+  8005c4:	7f 0b                	jg     8005d1 <vprintfmt+0x2b6>
+  8005c6:	8b 34 9d e4 13 80 00 	mov    0x8013e4(,%ebx,4),%esi
+  8005cd:	85 f6                	test   %esi,%esi
+  8005cf:	75 23                	jne    8005f4 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  8005d1:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  8005d5:	c7 44 24 08 11 14 80 	movl   $0x801411,0x8(%esp)
+  8005dc:	00 
+  8005dd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005e0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005e4:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005e7:	89 04 24             	mov    %eax,(%esp)
+  8005ea:	e8 73 02 00 00       	call   800862 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  8005ef:	e9 61 02 00 00       	jmp    800855 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  8005f4:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  8005f8:	c7 44 24 08 1a 14 80 	movl   $0x80141a,0x8(%esp)
+  8005ff:	00 
+  800600:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800603:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800607:	8b 45 08             	mov    0x8(%ebp),%eax
+  80060a:	89 04 24             	mov    %eax,(%esp)
+  80060d:	e8 50 02 00 00       	call   800862 <printfmt>
+			break;
+  800612:	e9 3e 02 00 00       	jmp    800855 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  800617:	8b 45 14             	mov    0x14(%ebp),%eax
+  80061a:	8d 50 04             	lea    0x4(%eax),%edx
+  80061d:	89 55 14             	mov    %edx,0x14(%ebp)
+  800620:	8b 30                	mov    (%eax),%esi
+  800622:	85 f6                	test   %esi,%esi
+  800624:	75 05                	jne    80062b <vprintfmt+0x310>
+				p = "(null)";
+  800626:	be 1d 14 80 00       	mov    $0x80141d,%esi
+			if (width > 0 && padc != '-')
+  80062b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80062f:	7e 37                	jle    800668 <vprintfmt+0x34d>
+  800631:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  800635:	74 31                	je     800668 <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800637:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80063a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80063e:	89 34 24             	mov    %esi,(%esp)
+  800641:	e8 39 03 00 00       	call   80097f <strnlen>
+  800646:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  800649:	eb 17                	jmp    800662 <vprintfmt+0x347>
+					putch(padc, putdat);
+  80064b:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  80064f:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800652:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800656:	89 04 24             	mov    %eax,(%esp)
+  800659:	8b 45 08             	mov    0x8(%ebp),%eax
+  80065c:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80065e:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800662:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800666:	7f e3                	jg     80064b <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800668:	eb 38                	jmp    8006a2 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  80066a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  80066e:	74 1f                	je     80068f <vprintfmt+0x374>
+  800670:	83 fb 1f             	cmp    $0x1f,%ebx
+  800673:	7e 05                	jle    80067a <vprintfmt+0x35f>
+  800675:	83 fb 7e             	cmp    $0x7e,%ebx
+  800678:	7e 15                	jle    80068f <vprintfmt+0x374>
+					putch('?', putdat);
+  80067a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80067d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800681:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  800688:	8b 45 08             	mov    0x8(%ebp),%eax
+  80068b:	ff d0                	call   *%eax
+  80068d:	eb 0f                	jmp    80069e <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  80068f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800692:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800696:	89 1c 24             	mov    %ebx,(%esp)
+  800699:	8b 45 08             	mov    0x8(%ebp),%eax
+  80069c:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80069e:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8006a2:	89 f0                	mov    %esi,%eax
+  8006a4:	8d 70 01             	lea    0x1(%eax),%esi
+  8006a7:	0f b6 00             	movzbl (%eax),%eax
+  8006aa:	0f be d8             	movsbl %al,%ebx
+  8006ad:	85 db                	test   %ebx,%ebx
+  8006af:	74 10                	je     8006c1 <vprintfmt+0x3a6>
+  8006b1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006b5:	78 b3                	js     80066a <vprintfmt+0x34f>
+  8006b7:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  8006bb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8006bf:	79 a9                	jns    80066a <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006c1:	eb 17                	jmp    8006da <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  8006c3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8006c6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006ca:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  8006d1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006d4:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8006d6:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8006da:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006de:	7f e3                	jg     8006c3 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  8006e0:	e9 70 01 00 00       	jmp    800855 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  8006e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8006e8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8006ec:	8d 45 14             	lea    0x14(%ebp),%eax
+  8006ef:	89 04 24             	mov    %eax,(%esp)
+  8006f2:	e8 dd fb ff ff       	call   8002d4 <getint>
+  8006f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8006fa:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8006fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800700:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800703:	85 d2                	test   %edx,%edx
+  800705:	79 26                	jns    80072d <vprintfmt+0x412>
+				putch('-', putdat);
+  800707:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80070a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80070e:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  800715:	8b 45 08             	mov    0x8(%ebp),%eax
+  800718:	ff d0                	call   *%eax
+				num = -(long long) num;
+  80071a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80071d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800720:	f7 d8                	neg    %eax
+  800722:	83 d2 00             	adc    $0x0,%edx
+  800725:	f7 da                	neg    %edx
+  800727:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80072a:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  80072d:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800734:	e9 a8 00 00 00       	jmp    8007e1 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  800739:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80073c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800740:	8d 45 14             	lea    0x14(%ebp),%eax
+  800743:	89 04 24             	mov    %eax,(%esp)
+  800746:	e8 3a fb ff ff       	call   800285 <getuint>
+  80074b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80074e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  800751:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  800758:	e9 84 00 00 00       	jmp    8007e1 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  80075d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800760:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800764:	8d 45 14             	lea    0x14(%ebp),%eax
+  800767:	89 04 24             	mov    %eax,(%esp)
+  80076a:	e8 16 fb ff ff       	call   800285 <getuint>
+  80076f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800772:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800775:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  80077c:	eb 63                	jmp    8007e1 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  80077e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800781:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800785:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  80078c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80078f:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800791:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800794:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800798:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  80079f:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007a2:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  8007a4:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007a7:	8d 50 04             	lea    0x4(%eax),%edx
+  8007aa:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007ad:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  8007af:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  8007b9:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  8007c0:	eb 1f                	jmp    8007e1 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  8007c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8007c5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007c9:	8d 45 14             	lea    0x14(%ebp),%eax
+  8007cc:	89 04 24             	mov    %eax,(%esp)
+  8007cf:	e8 b1 fa ff ff       	call   800285 <getuint>
+  8007d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8007d7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  8007da:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  8007e1:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  8007e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  8007e8:	89 54 24 18          	mov    %edx,0x18(%esp)
+  8007ec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  8007ef:	89 54 24 14          	mov    %edx,0x14(%esp)
+  8007f3:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8007f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8007fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8007fd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800801:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800805:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800808:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80080c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80080f:	89 04 24             	mov    %eax,(%esp)
+  800812:	e8 90 f9 ff ff       	call   8001a7 <printnum>
+			break;
+  800817:	eb 3c                	jmp    800855 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  800819:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80081c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800820:	89 1c 24             	mov    %ebx,(%esp)
+  800823:	8b 45 08             	mov    0x8(%ebp),%eax
+  800826:	ff d0                	call   *%eax
+			break;			
+  800828:	eb 2b                	jmp    800855 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  80082a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80082d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800831:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  800838:	8b 45 08             	mov    0x8(%ebp),%eax
+  80083b:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  80083d:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800841:	eb 04                	jmp    800847 <vprintfmt+0x52c>
+  800843:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800847:	8b 45 10             	mov    0x10(%ebp),%eax
+  80084a:	83 e8 01             	sub    $0x1,%eax
+  80084d:	0f b6 00             	movzbl (%eax),%eax
+  800850:	3c 25                	cmp    $0x25,%al
+  800852:	75 ef                	jne    800843 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  800854:	90                   	nop
+		}
+	}
+  800855:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  800856:	e9 3f fc ff ff       	jmp    80049a <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  80085b:	83 c4 40             	add    $0x40,%esp
+  80085e:	5b                   	pop    %ebx
+  80085f:	5e                   	pop    %esi
+  800860:	5d                   	pop    %ebp
+  800861:	c3                   	ret    
+
+00800862 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800862:	55                   	push   %ebp
+  800863:	89 e5                	mov    %esp,%ebp
+  800865:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800868:	8d 45 14             	lea    0x14(%ebp),%eax
+  80086b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  80086e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800871:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800875:	8b 45 10             	mov    0x10(%ebp),%eax
+  800878:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80087c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80087f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800883:	8b 45 08             	mov    0x8(%ebp),%eax
+  800886:	89 04 24             	mov    %eax,(%esp)
+  800889:	e8 8d fa ff ff       	call   80031b <vprintfmt>
+	va_end(ap);
+}
+  80088e:	c9                   	leave  
+  80088f:	c3                   	ret    
+
+00800890 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800890:	55                   	push   %ebp
+  800891:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800893:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800896:	8b 40 08             	mov    0x8(%eax),%eax
+  800899:	8d 50 01             	lea    0x1(%eax),%edx
+  80089c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80089f:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  8008a2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008a5:	8b 10                	mov    (%eax),%edx
+  8008a7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008aa:	8b 40 04             	mov    0x4(%eax),%eax
+  8008ad:	39 c2                	cmp    %eax,%edx
+  8008af:	73 12                	jae    8008c3 <sprintputch+0x33>
+		*b->buf++ = ch;
+  8008b1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008b4:	8b 00                	mov    (%eax),%eax
+  8008b6:	8d 48 01             	lea    0x1(%eax),%ecx
+  8008b9:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8008bc:	89 0a                	mov    %ecx,(%edx)
+  8008be:	8b 55 08             	mov    0x8(%ebp),%edx
+  8008c1:	88 10                	mov    %dl,(%eax)
+}
+  8008c3:	5d                   	pop    %ebp
+  8008c4:	c3                   	ret    
+
+008008c5 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  8008c5:	55                   	push   %ebp
+  8008c6:	89 e5                	mov    %esp,%ebp
+  8008c8:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  8008cb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8008d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008d4:	8d 50 ff             	lea    -0x1(%eax),%edx
+  8008d7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008da:	01 d0                	add    %edx,%eax
+  8008dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  8008e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  8008ea:	74 06                	je     8008f2 <vsnprintf+0x2d>
+  8008ec:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8008f0:	7f 07                	jg     8008f9 <vsnprintf+0x34>
+		return -E_INVAL;
+  8008f2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  8008f7:	eb 2a                	jmp    800923 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  8008f9:	8b 45 14             	mov    0x14(%ebp),%eax
+  8008fc:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800900:	8b 45 10             	mov    0x10(%ebp),%eax
+  800903:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800907:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  80090a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80090e:	c7 04 24 90 08 80 00 	movl   $0x800890,(%esp)
+  800915:	e8 01 fa ff ff       	call   80031b <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  80091a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  80091d:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800920:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800923:	c9                   	leave  
+  800924:	c3                   	ret    
+
+00800925 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800925:	55                   	push   %ebp
+  800926:	89 e5                	mov    %esp,%ebp
+  800928:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  80092b:	8d 45 14             	lea    0x14(%ebp),%eax
+  80092e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800931:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800934:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800938:	8b 45 10             	mov    0x10(%ebp),%eax
+  80093b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80093f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800942:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800946:	8b 45 08             	mov    0x8(%ebp),%eax
+  800949:	89 04 24             	mov    %eax,(%esp)
+  80094c:	e8 74 ff ff ff       	call   8008c5 <vsnprintf>
+  800951:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800954:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800957:	c9                   	leave  
+  800958:	c3                   	ret    
+
+00800959 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800959:	55                   	push   %ebp
+  80095a:	89 e5                	mov    %esp,%ebp
+  80095c:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  80095f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800966:	eb 08                	jmp    800970 <strlen+0x17>
+		n++;
+  800968:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  80096c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800970:	8b 45 08             	mov    0x8(%ebp),%eax
+  800973:	0f b6 00             	movzbl (%eax),%eax
+  800976:	84 c0                	test   %al,%al
+  800978:	75 ee                	jne    800968 <strlen+0xf>
+		n++;
+	return n;
+  80097a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  80097d:	c9                   	leave  
+  80097e:	c3                   	ret    
+
+0080097f <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  80097f:	55                   	push   %ebp
+  800980:	89 e5                	mov    %esp,%ebp
+  800982:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800985:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  80098c:	eb 0c                	jmp    80099a <strnlen+0x1b>
+		n++;
+  80098e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800992:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800996:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  80099a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80099e:	74 0a                	je     8009aa <strnlen+0x2b>
+  8009a0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009a3:	0f b6 00             	movzbl (%eax),%eax
+  8009a6:	84 c0                	test   %al,%al
+  8009a8:	75 e4                	jne    80098e <strnlen+0xf>
+		n++;
+	return n;
+  8009aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009ad:	c9                   	leave  
+  8009ae:	c3                   	ret    
+
+008009af <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  8009af:	55                   	push   %ebp
+  8009b0:	89 e5                	mov    %esp,%ebp
+  8009b2:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  8009b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  8009bb:	90                   	nop
+  8009bc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009bf:	8d 50 01             	lea    0x1(%eax),%edx
+  8009c2:	89 55 08             	mov    %edx,0x8(%ebp)
+  8009c5:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8009c8:	8d 4a 01             	lea    0x1(%edx),%ecx
+  8009cb:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  8009ce:	0f b6 12             	movzbl (%edx),%edx
+  8009d1:	88 10                	mov    %dl,(%eax)
+  8009d3:	0f b6 00             	movzbl (%eax),%eax
+  8009d6:	84 c0                	test   %al,%al
+  8009d8:	75 e2                	jne    8009bc <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  8009da:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  8009dd:	c9                   	leave  
+  8009de:	c3                   	ret    
+
+008009df <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  8009df:	55                   	push   %ebp
+  8009e0:	89 e5                	mov    %esp,%ebp
+  8009e2:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  8009e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009e8:	89 04 24             	mov    %eax,(%esp)
+  8009eb:	e8 69 ff ff ff       	call   800959 <strlen>
+  8009f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  8009f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  8009f6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009f9:	01 c2                	add    %eax,%edx
+  8009fb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009fe:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a02:	89 14 24             	mov    %edx,(%esp)
+  800a05:	e8 a5 ff ff ff       	call   8009af <strcpy>
+	return dst;
+  800a0a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800a0d:	c9                   	leave  
+  800a0e:	c3                   	ret    
+
+00800a0f <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800a0f:	55                   	push   %ebp
+  800a10:	89 e5                	mov    %esp,%ebp
+  800a12:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800a15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a18:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800a1b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800a22:	eb 23                	jmp    800a47 <strncpy+0x38>
+		*dst++ = *src;
+  800a24:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a27:	8d 50 01             	lea    0x1(%eax),%edx
+  800a2a:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a2d:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a30:	0f b6 12             	movzbl (%edx),%edx
+  800a33:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800a35:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a38:	0f b6 00             	movzbl (%eax),%eax
+  800a3b:	84 c0                	test   %al,%al
+  800a3d:	74 04                	je     800a43 <strncpy+0x34>
+			src++;
+  800a3f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800a43:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800a47:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a4a:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800a4d:	72 d5                	jb     800a24 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800a4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800a52:	c9                   	leave  
+  800a53:	c3                   	ret    
+
+00800a54 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800a54:	55                   	push   %ebp
+  800a55:	89 e5                	mov    %esp,%ebp
+  800a57:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800a5a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a5d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800a60:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a64:	74 33                	je     800a99 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800a66:	eb 17                	jmp    800a7f <strlcpy+0x2b>
+			*dst++ = *src++;
+  800a68:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a6b:	8d 50 01             	lea    0x1(%eax),%edx
+  800a6e:	89 55 08             	mov    %edx,0x8(%ebp)
+  800a71:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a74:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800a77:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800a7a:	0f b6 12             	movzbl (%edx),%edx
+  800a7d:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800a7f:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800a83:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800a87:	74 0a                	je     800a93 <strlcpy+0x3f>
+  800a89:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a8c:	0f b6 00             	movzbl (%eax),%eax
+  800a8f:	84 c0                	test   %al,%al
+  800a91:	75 d5                	jne    800a68 <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800a93:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a96:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800a99:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800a9f:	29 c2                	sub    %eax,%edx
+  800aa1:	89 d0                	mov    %edx,%eax
+}
+  800aa3:	c9                   	leave  
+  800aa4:	c3                   	ret    
+
+00800aa5 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800aa5:	55                   	push   %ebp
+  800aa6:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800aa8:	eb 08                	jmp    800ab2 <strcmp+0xd>
+		p++, q++;
+  800aaa:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800aae:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800ab2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ab5:	0f b6 00             	movzbl (%eax),%eax
+  800ab8:	84 c0                	test   %al,%al
+  800aba:	74 10                	je     800acc <strcmp+0x27>
+  800abc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800abf:	0f b6 10             	movzbl (%eax),%edx
+  800ac2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ac5:	0f b6 00             	movzbl (%eax),%eax
+  800ac8:	38 c2                	cmp    %al,%dl
+  800aca:	74 de                	je     800aaa <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800acc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800acf:	0f b6 00             	movzbl (%eax),%eax
+  800ad2:	0f b6 d0             	movzbl %al,%edx
+  800ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ad8:	0f b6 00             	movzbl (%eax),%eax
+  800adb:	0f b6 c0             	movzbl %al,%eax
+  800ade:	29 c2                	sub    %eax,%edx
+  800ae0:	89 d0                	mov    %edx,%eax
+}
+  800ae2:	5d                   	pop    %ebp
+  800ae3:	c3                   	ret    
+
+00800ae4 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800ae4:	55                   	push   %ebp
+  800ae5:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800ae7:	eb 0c                	jmp    800af5 <strncmp+0x11>
+		n--, p++, q++;
+  800ae9:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800aed:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800af1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800af5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800af9:	74 1a                	je     800b15 <strncmp+0x31>
+  800afb:	8b 45 08             	mov    0x8(%ebp),%eax
+  800afe:	0f b6 00             	movzbl (%eax),%eax
+  800b01:	84 c0                	test   %al,%al
+  800b03:	74 10                	je     800b15 <strncmp+0x31>
+  800b05:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b08:	0f b6 10             	movzbl (%eax),%edx
+  800b0b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b0e:	0f b6 00             	movzbl (%eax),%eax
+  800b11:	38 c2                	cmp    %al,%dl
+  800b13:	74 d4                	je     800ae9 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800b15:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b19:	75 07                	jne    800b22 <strncmp+0x3e>
+		return 0;
+  800b1b:	b8 00 00 00 00       	mov    $0x0,%eax
+  800b20:	eb 16                	jmp    800b38 <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800b22:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b25:	0f b6 00             	movzbl (%eax),%eax
+  800b28:	0f b6 d0             	movzbl %al,%edx
+  800b2b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b2e:	0f b6 00             	movzbl (%eax),%eax
+  800b31:	0f b6 c0             	movzbl %al,%eax
+  800b34:	29 c2                	sub    %eax,%edx
+  800b36:	89 d0                	mov    %edx,%eax
+}
+  800b38:	5d                   	pop    %ebp
+  800b39:	c3                   	ret    
+
+00800b3a <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800b3a:	55                   	push   %ebp
+  800b3b:	89 e5                	mov    %esp,%ebp
+  800b3d:	83 ec 04             	sub    $0x4,%esp
+  800b40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b43:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b46:	eb 14                	jmp    800b5c <strchr+0x22>
+		if (*s == c)
+  800b48:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b4b:	0f b6 00             	movzbl (%eax),%eax
+  800b4e:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b51:	75 05                	jne    800b58 <strchr+0x1e>
+			return (char *) s;
+  800b53:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b56:	eb 13                	jmp    800b6b <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800b58:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b5c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5f:	0f b6 00             	movzbl (%eax),%eax
+  800b62:	84 c0                	test   %al,%al
+  800b64:	75 e2                	jne    800b48 <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800b66:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800b6b:	c9                   	leave  
+  800b6c:	c3                   	ret    
+
+00800b6d <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800b6d:	55                   	push   %ebp
+  800b6e:	89 e5                	mov    %esp,%ebp
+  800b70:	83 ec 04             	sub    $0x4,%esp
+  800b73:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b76:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800b79:	eb 11                	jmp    800b8c <strfind+0x1f>
+		if (*s == c)
+  800b7b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b7e:	0f b6 00             	movzbl (%eax),%eax
+  800b81:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800b84:	75 02                	jne    800b88 <strfind+0x1b>
+			break;
+  800b86:	eb 0e                	jmp    800b96 <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800b88:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b8c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b8f:	0f b6 00             	movzbl (%eax),%eax
+  800b92:	84 c0                	test   %al,%al
+  800b94:	75 e5                	jne    800b7b <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800b96:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800b99:	c9                   	leave  
+  800b9a:	c3                   	ret    
+
+00800b9b <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800b9b:	55                   	push   %ebp
+  800b9c:	89 e5                	mov    %esp,%ebp
+  800b9e:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800b9f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800ba3:	75 05                	jne    800baa <memset+0xf>
+		return v;
+  800ba5:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ba8:	eb 5c                	jmp    800c06 <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800baa:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bad:	83 e0 03             	and    $0x3,%eax
+  800bb0:	85 c0                	test   %eax,%eax
+  800bb2:	75 41                	jne    800bf5 <memset+0x5a>
+  800bb4:	8b 45 10             	mov    0x10(%ebp),%eax
+  800bb7:	83 e0 03             	and    $0x3,%eax
+  800bba:	85 c0                	test   %eax,%eax
+  800bbc:	75 37                	jne    800bf5 <memset+0x5a>
+		c &= 0xFF;
+  800bbe:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bc8:	c1 e0 18             	shl    $0x18,%eax
+  800bcb:	89 c2                	mov    %eax,%edx
+  800bcd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bd0:	c1 e0 10             	shl    $0x10,%eax
+  800bd3:	09 c2                	or     %eax,%edx
+  800bd5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bd8:	c1 e0 08             	shl    $0x8,%eax
+  800bdb:	09 d0                	or     %edx,%eax
+  800bdd:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800be0:	8b 45 10             	mov    0x10(%ebp),%eax
+  800be3:	c1 e8 02             	shr    $0x2,%eax
+  800be6:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800be8:	8b 55 08             	mov    0x8(%ebp),%edx
+  800beb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bee:	89 d7                	mov    %edx,%edi
+  800bf0:	fc                   	cld    
+  800bf1:	f3 ab                	rep stos %eax,%es:(%edi)
+  800bf3:	eb 0e                	jmp    800c03 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800bf5:	8b 55 08             	mov    0x8(%ebp),%edx
+  800bf8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bfb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800bfe:	89 d7                	mov    %edx,%edi
+  800c00:	fc                   	cld    
+  800c01:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800c03:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800c06:	5f                   	pop    %edi
+  800c07:	5d                   	pop    %ebp
+  800c08:	c3                   	ret    
+
+00800c09 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800c09:	55                   	push   %ebp
+  800c0a:	89 e5                	mov    %esp,%ebp
+  800c0c:	57                   	push   %edi
+  800c0d:	56                   	push   %esi
+  800c0e:	53                   	push   %ebx
+  800c0f:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800c12:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c15:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800c18:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800c1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c24:	73 6d                	jae    800c93 <memmove+0x8a>
+  800c26:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c29:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c2c:	01 d0                	add    %edx,%eax
+  800c2e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800c31:	76 60                	jbe    800c93 <memmove+0x8a>
+		s += n;
+  800c33:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c36:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800c39:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c3c:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c42:	83 e0 03             	and    $0x3,%eax
+  800c45:	85 c0                	test   %eax,%eax
+  800c47:	75 2f                	jne    800c78 <memmove+0x6f>
+  800c49:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c4c:	83 e0 03             	and    $0x3,%eax
+  800c4f:	85 c0                	test   %eax,%eax
+  800c51:	75 25                	jne    800c78 <memmove+0x6f>
+  800c53:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c56:	83 e0 03             	and    $0x3,%eax
+  800c59:	85 c0                	test   %eax,%eax
+  800c5b:	75 1b                	jne    800c78 <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800c5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c60:	83 e8 04             	sub    $0x4,%eax
+  800c63:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800c66:	83 ea 04             	sub    $0x4,%edx
+  800c69:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800c6c:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800c6f:	89 c7                	mov    %eax,%edi
+  800c71:	89 d6                	mov    %edx,%esi
+  800c73:	fd                   	std    
+  800c74:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800c76:	eb 18                	jmp    800c90 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800c78:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800c7b:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800c7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c81:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800c84:	8b 45 10             	mov    0x10(%ebp),%eax
+  800c87:	89 d7                	mov    %edx,%edi
+  800c89:	89 de                	mov    %ebx,%esi
+  800c8b:	89 c1                	mov    %eax,%ecx
+  800c8d:	fd                   	std    
+  800c8e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800c90:	fc                   	cld    
+  800c91:	eb 45                	jmp    800cd8 <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800c93:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800c96:	83 e0 03             	and    $0x3,%eax
+  800c99:	85 c0                	test   %eax,%eax
+  800c9b:	75 2b                	jne    800cc8 <memmove+0xbf>
+  800c9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ca0:	83 e0 03             	and    $0x3,%eax
+  800ca3:	85 c0                	test   %eax,%eax
+  800ca5:	75 21                	jne    800cc8 <memmove+0xbf>
+  800ca7:	8b 45 10             	mov    0x10(%ebp),%eax
+  800caa:	83 e0 03             	and    $0x3,%eax
+  800cad:	85 c0                	test   %eax,%eax
+  800caf:	75 17                	jne    800cc8 <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800cb1:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cb4:	c1 e8 02             	shr    $0x2,%eax
+  800cb7:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800cb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800cbc:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cbf:	89 c7                	mov    %eax,%edi
+  800cc1:	89 d6                	mov    %edx,%esi
+  800cc3:	fc                   	cld    
+  800cc4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800cc6:	eb 10                	jmp    800cd8 <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800cc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ccb:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800cce:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800cd1:	89 c7                	mov    %eax,%edi
+  800cd3:	89 d6                	mov    %edx,%esi
+  800cd5:	fc                   	cld    
+  800cd6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800cd8:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800cdb:	83 c4 10             	add    $0x10,%esp
+  800cde:	5b                   	pop    %ebx
+  800cdf:	5e                   	pop    %esi
+  800ce0:	5f                   	pop    %edi
+  800ce1:	5d                   	pop    %ebp
+  800ce2:	c3                   	ret    
+
+00800ce3 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800ce3:	55                   	push   %ebp
+  800ce4:	89 e5                	mov    %esp,%ebp
+  800ce6:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800ce9:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cec:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800cf0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cf3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800cf7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cfa:	89 04 24             	mov    %eax,(%esp)
+  800cfd:	e8 07 ff ff ff       	call   800c09 <memmove>
+}
+  800d02:	c9                   	leave  
+  800d03:	c3                   	ret    
+
+00800d04 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800d04:	55                   	push   %ebp
+  800d05:	89 e5                	mov    %esp,%ebp
+  800d07:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800d0a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d0d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800d10:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d13:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800d16:	eb 30                	jmp    800d48 <memcmp+0x44>
+		if (*s1 != *s2)
+  800d18:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d1b:	0f b6 10             	movzbl (%eax),%edx
+  800d1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d21:	0f b6 00             	movzbl (%eax),%eax
+  800d24:	38 c2                	cmp    %al,%dl
+  800d26:	74 18                	je     800d40 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800d28:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800d2b:	0f b6 00             	movzbl (%eax),%eax
+  800d2e:	0f b6 d0             	movzbl %al,%edx
+  800d31:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800d34:	0f b6 00             	movzbl (%eax),%eax
+  800d37:	0f b6 c0             	movzbl %al,%eax
+  800d3a:	29 c2                	sub    %eax,%edx
+  800d3c:	89 d0                	mov    %edx,%eax
+  800d3e:	eb 1a                	jmp    800d5a <memcmp+0x56>
+		s1++, s2++;
+  800d40:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800d44:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800d48:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d4b:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800d4e:	89 55 10             	mov    %edx,0x10(%ebp)
+  800d51:	85 c0                	test   %eax,%eax
+  800d53:	75 c3                	jne    800d18 <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800d55:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d5a:	c9                   	leave  
+  800d5b:	c3                   	ret    
+
+00800d5c <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800d5c:	55                   	push   %ebp
+  800d5d:	89 e5                	mov    %esp,%ebp
+  800d5f:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800d62:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d65:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d68:	01 d0                	add    %edx,%eax
+  800d6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800d6d:	eb 13                	jmp    800d82 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800d6f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d72:	0f b6 10             	movzbl (%eax),%edx
+  800d75:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d78:	38 c2                	cmp    %al,%dl
+  800d7a:	75 02                	jne    800d7e <memfind+0x22>
+			break;
+  800d7c:	eb 0c                	jmp    800d8a <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800d7e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d82:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d85:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800d88:	72 e5                	jb     800d6f <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800d8a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d8d:	c9                   	leave  
+  800d8e:	c3                   	ret    
+
+00800d8f <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800d8f:	55                   	push   %ebp
+  800d90:	89 e5                	mov    %esp,%ebp
+  800d92:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800d95:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800d9c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800da3:	eb 04                	jmp    800da9 <strtol+0x1a>
+		s++;
+  800da5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800da9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dac:	0f b6 00             	movzbl (%eax),%eax
+  800daf:	3c 20                	cmp    $0x20,%al
+  800db1:	74 f2                	je     800da5 <strtol+0x16>
+  800db3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800db6:	0f b6 00             	movzbl (%eax),%eax
+  800db9:	3c 09                	cmp    $0x9,%al
+  800dbb:	74 e8                	je     800da5 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800dbd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dc0:	0f b6 00             	movzbl (%eax),%eax
+  800dc3:	3c 2b                	cmp    $0x2b,%al
+  800dc5:	75 06                	jne    800dcd <strtol+0x3e>
+		s++;
+  800dc7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800dcb:	eb 15                	jmp    800de2 <strtol+0x53>
+	else if (*s == '-')
+  800dcd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dd0:	0f b6 00             	movzbl (%eax),%eax
+  800dd3:	3c 2d                	cmp    $0x2d,%al
+  800dd5:	75 0b                	jne    800de2 <strtol+0x53>
+		s++, neg = 1;
+  800dd7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ddb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800de2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800de6:	74 06                	je     800dee <strtol+0x5f>
+  800de8:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800dec:	75 24                	jne    800e12 <strtol+0x83>
+  800dee:	8b 45 08             	mov    0x8(%ebp),%eax
+  800df1:	0f b6 00             	movzbl (%eax),%eax
+  800df4:	3c 30                	cmp    $0x30,%al
+  800df6:	75 1a                	jne    800e12 <strtol+0x83>
+  800df8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dfb:	83 c0 01             	add    $0x1,%eax
+  800dfe:	0f b6 00             	movzbl (%eax),%eax
+  800e01:	3c 78                	cmp    $0x78,%al
+  800e03:	75 0d                	jne    800e12 <strtol+0x83>
+		s += 2, base = 16;
+  800e05:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800e09:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800e10:	eb 2a                	jmp    800e3c <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800e12:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e16:	75 17                	jne    800e2f <strtol+0xa0>
+  800e18:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e1b:	0f b6 00             	movzbl (%eax),%eax
+  800e1e:	3c 30                	cmp    $0x30,%al
+  800e20:	75 0d                	jne    800e2f <strtol+0xa0>
+		s++, base = 8;
+  800e22:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800e26:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800e2d:	eb 0d                	jmp    800e3c <strtol+0xad>
+	else if (base == 0)
+  800e2f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800e33:	75 07                	jne    800e3c <strtol+0xad>
+		base = 10;
+  800e35:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800e3c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e3f:	0f b6 00             	movzbl (%eax),%eax
+  800e42:	3c 2f                	cmp    $0x2f,%al
+  800e44:	7e 1b                	jle    800e61 <strtol+0xd2>
+  800e46:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e49:	0f b6 00             	movzbl (%eax),%eax
+  800e4c:	3c 39                	cmp    $0x39,%al
+  800e4e:	7f 11                	jg     800e61 <strtol+0xd2>
+			dig = *s - '0';
+  800e50:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e53:	0f b6 00             	movzbl (%eax),%eax
+  800e56:	0f be c0             	movsbl %al,%eax
+  800e59:	83 e8 30             	sub    $0x30,%eax
+  800e5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e5f:	eb 48                	jmp    800ea9 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  800e61:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e64:	0f b6 00             	movzbl (%eax),%eax
+  800e67:	3c 60                	cmp    $0x60,%al
+  800e69:	7e 1b                	jle    800e86 <strtol+0xf7>
+  800e6b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e6e:	0f b6 00             	movzbl (%eax),%eax
+  800e71:	3c 7a                	cmp    $0x7a,%al
+  800e73:	7f 11                	jg     800e86 <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  800e75:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e78:	0f b6 00             	movzbl (%eax),%eax
+  800e7b:	0f be c0             	movsbl %al,%eax
+  800e7e:	83 e8 57             	sub    $0x57,%eax
+  800e81:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800e84:	eb 23                	jmp    800ea9 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  800e86:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e89:	0f b6 00             	movzbl (%eax),%eax
+  800e8c:	3c 40                	cmp    $0x40,%al
+  800e8e:	7e 3d                	jle    800ecd <strtol+0x13e>
+  800e90:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e93:	0f b6 00             	movzbl (%eax),%eax
+  800e96:	3c 5a                	cmp    $0x5a,%al
+  800e98:	7f 33                	jg     800ecd <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  800e9a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e9d:	0f b6 00             	movzbl (%eax),%eax
+  800ea0:	0f be c0             	movsbl %al,%eax
+  800ea3:	83 e8 37             	sub    $0x37,%eax
+  800ea6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  800ea9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800eac:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800eaf:	7c 02                	jl     800eb3 <strtol+0x124>
+			break;
+  800eb1:	eb 1a                	jmp    800ecd <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  800eb3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800eb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800eba:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800ebe:	89 c2                	mov    %eax,%edx
+  800ec0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800ec3:	01 d0                	add    %edx,%eax
+  800ec5:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  800ec8:	e9 6f ff ff ff       	jmp    800e3c <strtol+0xad>
+
+	if (endptr)
+  800ecd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800ed1:	74 08                	je     800edb <strtol+0x14c>
+		*endptr = (char *) s;
+  800ed3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ed6:	8b 55 08             	mov    0x8(%ebp),%edx
+  800ed9:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  800edb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  800edf:	74 07                	je     800ee8 <strtol+0x159>
+  800ee1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ee4:	f7 d8                	neg    %eax
+  800ee6:	eb 03                	jmp    800eeb <strtol+0x15c>
+  800ee8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800eeb:	c9                   	leave  
+  800eec:	c3                   	ret    
+
+00800eed <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  800eed:	55                   	push   %ebp
+  800eee:	89 e5                	mov    %esp,%ebp
+  800ef0:	57                   	push   %edi
+  800ef1:	56                   	push   %esi
+  800ef2:	53                   	push   %ebx
+  800ef3:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  800ef6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ef9:	8b 55 10             	mov    0x10(%ebp),%edx
+  800efc:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  800eff:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  800f02:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  800f05:	8b 75 20             	mov    0x20(%ebp),%esi
+  800f08:	cd 30                	int    $0x30
+  800f0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  800f0d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800f11:	74 30                	je     800f43 <syscall+0x56>
+  800f13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800f17:	7e 2a                	jle    800f43 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  800f19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  800f1c:	89 44 24 10          	mov    %eax,0x10(%esp)
+  800f20:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f23:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800f27:	c7 44 24 08 7c 15 80 	movl   $0x80157c,0x8(%esp)
+  800f2e:	00 
+  800f2f:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  800f36:	00 
+  800f37:	c7 04 24 99 15 80 00 	movl   $0x801599,(%esp)
+  800f3e:	e8 18 01 00 00       	call   80105b <_panic>
+
+	return ret;
+  800f43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  800f46:	83 c4 3c             	add    $0x3c,%esp
+  800f49:	5b                   	pop    %ebx
+  800f4a:	5e                   	pop    %esi
+  800f4b:	5f                   	pop    %edi
+  800f4c:	5d                   	pop    %ebp
+  800f4d:	c3                   	ret    
+
+00800f4e <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  800f4e:	55                   	push   %ebp
+  800f4f:	89 e5                	mov    %esp,%ebp
+  800f51:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800f54:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f57:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f5e:	00 
+  800f5f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800f66:	00 
+  800f67:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800f6e:	00 
+  800f6f:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800f72:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800f76:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800f7a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800f81:	00 
+  800f82:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800f89:	e8 5f ff ff ff       	call   800eed <syscall>
+}
+  800f8e:	c9                   	leave  
+  800f8f:	c3                   	ret    
+
+00800f90 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  800f90:	55                   	push   %ebp
+  800f91:	89 e5                	mov    %esp,%ebp
+  800f93:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800f96:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800f9d:	00 
+  800f9e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800fa5:	00 
+  800fa6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800fad:	00 
+  800fae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800fb5:	00 
+  800fb6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  800fbd:	00 
+  800fbe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800fc5:	00 
+  800fc6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  800fcd:	e8 1b ff ff ff       	call   800eed <syscall>
+}
+  800fd2:	c9                   	leave  
+  800fd3:	c3                   	ret    
+
+00800fd4 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800fd4:	55                   	push   %ebp
+  800fd5:	89 e5                	mov    %esp,%ebp
+  800fd7:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800fda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fdd:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800fe4:	00 
+  800fe5:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800fec:	00 
+  800fed:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  800ff4:	00 
+  800ff5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800ffc:	00 
+  800ffd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  801001:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  801008:	00 
+  801009:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  801010:	e8 d8 fe ff ff       	call   800eed <syscall>
+}
+  801015:	c9                   	leave  
+  801016:	c3                   	ret    
+
+00801017 <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  801017:	55                   	push   %ebp
+  801018:	89 e5                	mov    %esp,%ebp
+  80101a:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  80101d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  801024:	00 
+  801025:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80102c:	00 
+  80102d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  801034:	00 
+  801035:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  80103c:	00 
+  80103d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  801044:	00 
+  801045:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  80104c:	00 
+  80104d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  801054:	e8 94 fe ff ff       	call   800eed <syscall>
+}
+  801059:	c9                   	leave  
+  80105a:	c3                   	ret    
+
+0080105b <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80105b:	55                   	push   %ebp
+  80105c:	89 e5                	mov    %esp,%ebp
+  80105e:	53                   	push   %ebx
+  80105f:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  801062:	8d 45 14             	lea    0x14(%ebp),%eax
+  801065:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  801068:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  80106e:	e8 a4 ff ff ff       	call   801017 <sys_getenvid>
+  801073:	8b 55 0c             	mov    0xc(%ebp),%edx
+  801076:	89 54 24 10          	mov    %edx,0x10(%esp)
+  80107a:	8b 55 08             	mov    0x8(%ebp),%edx
+  80107d:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  801081:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  801085:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801089:	c7 04 24 a8 15 80 00 	movl   $0x8015a8,(%esp)
+  801090:	e8 ec f0 ff ff       	call   800181 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  801095:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801098:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80109c:	8b 45 10             	mov    0x10(%ebp),%eax
+  80109f:	89 04 24             	mov    %eax,(%esp)
+  8010a2:	e8 76 f0 ff ff       	call   80011d <vcprintf>
+	cprintf("\n");
+  8010a7:	c7 04 24 cb 15 80 00 	movl   $0x8015cb,(%esp)
+  8010ae:	e8 ce f0 ff ff       	call   800181 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  8010b3:	cc                   	int3   
+  8010b4:	eb fd                	jmp    8010b3 <_panic+0x58>
+  8010b6:	66 90                	xchg   %ax,%ax
+  8010b8:	66 90                	xchg   %ax,%ax
+  8010ba:	66 90                	xchg   %ax,%ax
+  8010bc:	66 90                	xchg   %ax,%ax
+  8010be:	66 90                	xchg   %ax,%ax
+
+008010c0 <__udivdi3>:
+  8010c0:	55                   	push   %ebp
+  8010c1:	57                   	push   %edi
+  8010c2:	56                   	push   %esi
+  8010c3:	83 ec 0c             	sub    $0xc,%esp
+  8010c6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010ca:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010ce:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010d2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010d6:	85 c0                	test   %eax,%eax
+  8010d8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010dc:	89 ea                	mov    %ebp,%edx
+  8010de:	89 0c 24             	mov    %ecx,(%esp)
+  8010e1:	75 2d                	jne    801110 <__udivdi3+0x50>
+  8010e3:	39 e9                	cmp    %ebp,%ecx
+  8010e5:	77 61                	ja     801148 <__udivdi3+0x88>
+  8010e7:	85 c9                	test   %ecx,%ecx
+  8010e9:	89 ce                	mov    %ecx,%esi
+  8010eb:	75 0b                	jne    8010f8 <__udivdi3+0x38>
+  8010ed:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010f2:	31 d2                	xor    %edx,%edx
+  8010f4:	f7 f1                	div    %ecx
+  8010f6:	89 c6                	mov    %eax,%esi
+  8010f8:	31 d2                	xor    %edx,%edx
+  8010fa:	89 e8                	mov    %ebp,%eax
+  8010fc:	f7 f6                	div    %esi
+  8010fe:	89 c5                	mov    %eax,%ebp
+  801100:	89 f8                	mov    %edi,%eax
+  801102:	f7 f6                	div    %esi
+  801104:	89 ea                	mov    %ebp,%edx
+  801106:	83 c4 0c             	add    $0xc,%esp
+  801109:	5e                   	pop    %esi
+  80110a:	5f                   	pop    %edi
+  80110b:	5d                   	pop    %ebp
+  80110c:	c3                   	ret    
+  80110d:	8d 76 00             	lea    0x0(%esi),%esi
+  801110:	39 e8                	cmp    %ebp,%eax
+  801112:	77 24                	ja     801138 <__udivdi3+0x78>
+  801114:	0f bd e8             	bsr    %eax,%ebp
+  801117:	83 f5 1f             	xor    $0x1f,%ebp
+  80111a:	75 3c                	jne    801158 <__udivdi3+0x98>
+  80111c:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801120:	39 34 24             	cmp    %esi,(%esp)
+  801123:	0f 86 9f 00 00 00    	jbe    8011c8 <__udivdi3+0x108>
+  801129:	39 d0                	cmp    %edx,%eax
+  80112b:	0f 82 97 00 00 00    	jb     8011c8 <__udivdi3+0x108>
+  801131:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801138:	31 d2                	xor    %edx,%edx
+  80113a:	31 c0                	xor    %eax,%eax
+  80113c:	83 c4 0c             	add    $0xc,%esp
+  80113f:	5e                   	pop    %esi
+  801140:	5f                   	pop    %edi
+  801141:	5d                   	pop    %ebp
+  801142:	c3                   	ret    
+  801143:	90                   	nop
+  801144:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801148:	89 f8                	mov    %edi,%eax
+  80114a:	f7 f1                	div    %ecx
+  80114c:	31 d2                	xor    %edx,%edx
+  80114e:	83 c4 0c             	add    $0xc,%esp
+  801151:	5e                   	pop    %esi
+  801152:	5f                   	pop    %edi
+  801153:	5d                   	pop    %ebp
+  801154:	c3                   	ret    
+  801155:	8d 76 00             	lea    0x0(%esi),%esi
+  801158:	89 e9                	mov    %ebp,%ecx
+  80115a:	8b 3c 24             	mov    (%esp),%edi
+  80115d:	d3 e0                	shl    %cl,%eax
+  80115f:	89 c6                	mov    %eax,%esi
+  801161:	b8 20 00 00 00       	mov    $0x20,%eax
+  801166:	29 e8                	sub    %ebp,%eax
+  801168:	89 c1                	mov    %eax,%ecx
+  80116a:	d3 ef                	shr    %cl,%edi
+  80116c:	89 e9                	mov    %ebp,%ecx
+  80116e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801172:	8b 3c 24             	mov    (%esp),%edi
+  801175:	09 74 24 08          	or     %esi,0x8(%esp)
+  801179:	89 d6                	mov    %edx,%esi
+  80117b:	d3 e7                	shl    %cl,%edi
+  80117d:	89 c1                	mov    %eax,%ecx
+  80117f:	89 3c 24             	mov    %edi,(%esp)
+  801182:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801186:	d3 ee                	shr    %cl,%esi
+  801188:	89 e9                	mov    %ebp,%ecx
+  80118a:	d3 e2                	shl    %cl,%edx
+  80118c:	89 c1                	mov    %eax,%ecx
+  80118e:	d3 ef                	shr    %cl,%edi
+  801190:	09 d7                	or     %edx,%edi
+  801192:	89 f2                	mov    %esi,%edx
+  801194:	89 f8                	mov    %edi,%eax
+  801196:	f7 74 24 08          	divl   0x8(%esp)
+  80119a:	89 d6                	mov    %edx,%esi
+  80119c:	89 c7                	mov    %eax,%edi
+  80119e:	f7 24 24             	mull   (%esp)
+  8011a1:	39 d6                	cmp    %edx,%esi
+  8011a3:	89 14 24             	mov    %edx,(%esp)
+  8011a6:	72 30                	jb     8011d8 <__udivdi3+0x118>
+  8011a8:	8b 54 24 04          	mov    0x4(%esp),%edx
+  8011ac:	89 e9                	mov    %ebp,%ecx
+  8011ae:	d3 e2                	shl    %cl,%edx
+  8011b0:	39 c2                	cmp    %eax,%edx
+  8011b2:	73 05                	jae    8011b9 <__udivdi3+0xf9>
+  8011b4:	3b 34 24             	cmp    (%esp),%esi
+  8011b7:	74 1f                	je     8011d8 <__udivdi3+0x118>
+  8011b9:	89 f8                	mov    %edi,%eax
+  8011bb:	31 d2                	xor    %edx,%edx
+  8011bd:	e9 7a ff ff ff       	jmp    80113c <__udivdi3+0x7c>
+  8011c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011c8:	31 d2                	xor    %edx,%edx
+  8011ca:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011cf:	e9 68 ff ff ff       	jmp    80113c <__udivdi3+0x7c>
+  8011d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011d8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011db:	31 d2                	xor    %edx,%edx
+  8011dd:	83 c4 0c             	add    $0xc,%esp
+  8011e0:	5e                   	pop    %esi
+  8011e1:	5f                   	pop    %edi
+  8011e2:	5d                   	pop    %ebp
+  8011e3:	c3                   	ret    
+  8011e4:	66 90                	xchg   %ax,%ax
+  8011e6:	66 90                	xchg   %ax,%ax
+  8011e8:	66 90                	xchg   %ax,%ax
+  8011ea:	66 90                	xchg   %ax,%ax
+  8011ec:	66 90                	xchg   %ax,%ax
+  8011ee:	66 90                	xchg   %ax,%ax
+
+008011f0 <__umoddi3>:
+  8011f0:	55                   	push   %ebp
+  8011f1:	57                   	push   %edi
+  8011f2:	56                   	push   %esi
+  8011f3:	83 ec 14             	sub    $0x14,%esp
+  8011f6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011fa:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011fe:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  801202:	89 c7                	mov    %eax,%edi
+  801204:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801208:	8b 44 24 30          	mov    0x30(%esp),%eax
+  80120c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  801210:	89 34 24             	mov    %esi,(%esp)
+  801213:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  801217:	85 c0                	test   %eax,%eax
+  801219:	89 c2                	mov    %eax,%edx
+  80121b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  80121f:	75 17                	jne    801238 <__umoddi3+0x48>
+  801221:	39 fe                	cmp    %edi,%esi
+  801223:	76 4b                	jbe    801270 <__umoddi3+0x80>
+  801225:	89 c8                	mov    %ecx,%eax
+  801227:	89 fa                	mov    %edi,%edx
+  801229:	f7 f6                	div    %esi
+  80122b:	89 d0                	mov    %edx,%eax
+  80122d:	31 d2                	xor    %edx,%edx
+  80122f:	83 c4 14             	add    $0x14,%esp
+  801232:	5e                   	pop    %esi
+  801233:	5f                   	pop    %edi
+  801234:	5d                   	pop    %ebp
+  801235:	c3                   	ret    
+  801236:	66 90                	xchg   %ax,%ax
+  801238:	39 f8                	cmp    %edi,%eax
+  80123a:	77 54                	ja     801290 <__umoddi3+0xa0>
+  80123c:	0f bd e8             	bsr    %eax,%ebp
+  80123f:	83 f5 1f             	xor    $0x1f,%ebp
+  801242:	75 5c                	jne    8012a0 <__umoddi3+0xb0>
+  801244:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801248:	39 3c 24             	cmp    %edi,(%esp)
+  80124b:	0f 87 e7 00 00 00    	ja     801338 <__umoddi3+0x148>
+  801251:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801255:	29 f1                	sub    %esi,%ecx
+  801257:	19 c7                	sbb    %eax,%edi
+  801259:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80125d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801261:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801265:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801269:	83 c4 14             	add    $0x14,%esp
+  80126c:	5e                   	pop    %esi
+  80126d:	5f                   	pop    %edi
+  80126e:	5d                   	pop    %ebp
+  80126f:	c3                   	ret    
+  801270:	85 f6                	test   %esi,%esi
+  801272:	89 f5                	mov    %esi,%ebp
+  801274:	75 0b                	jne    801281 <__umoddi3+0x91>
+  801276:	b8 01 00 00 00       	mov    $0x1,%eax
+  80127b:	31 d2                	xor    %edx,%edx
+  80127d:	f7 f6                	div    %esi
+  80127f:	89 c5                	mov    %eax,%ebp
+  801281:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801285:	31 d2                	xor    %edx,%edx
+  801287:	f7 f5                	div    %ebp
+  801289:	89 c8                	mov    %ecx,%eax
+  80128b:	f7 f5                	div    %ebp
+  80128d:	eb 9c                	jmp    80122b <__umoddi3+0x3b>
+  80128f:	90                   	nop
+  801290:	89 c8                	mov    %ecx,%eax
+  801292:	89 fa                	mov    %edi,%edx
+  801294:	83 c4 14             	add    $0x14,%esp
+  801297:	5e                   	pop    %esi
+  801298:	5f                   	pop    %edi
+  801299:	5d                   	pop    %ebp
+  80129a:	c3                   	ret    
+  80129b:	90                   	nop
+  80129c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8012a0:	8b 04 24             	mov    (%esp),%eax
+  8012a3:	be 20 00 00 00       	mov    $0x20,%esi
+  8012a8:	89 e9                	mov    %ebp,%ecx
+  8012aa:	29 ee                	sub    %ebp,%esi
+  8012ac:	d3 e2                	shl    %cl,%edx
+  8012ae:	89 f1                	mov    %esi,%ecx
+  8012b0:	d3 e8                	shr    %cl,%eax
+  8012b2:	89 e9                	mov    %ebp,%ecx
+  8012b4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012b8:	8b 04 24             	mov    (%esp),%eax
+  8012bb:	09 54 24 04          	or     %edx,0x4(%esp)
+  8012bf:	89 fa                	mov    %edi,%edx
+  8012c1:	d3 e0                	shl    %cl,%eax
+  8012c3:	89 f1                	mov    %esi,%ecx
+  8012c5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012c9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012cd:	d3 ea                	shr    %cl,%edx
+  8012cf:	89 e9                	mov    %ebp,%ecx
+  8012d1:	d3 e7                	shl    %cl,%edi
+  8012d3:	89 f1                	mov    %esi,%ecx
+  8012d5:	d3 e8                	shr    %cl,%eax
+  8012d7:	89 e9                	mov    %ebp,%ecx
+  8012d9:	09 f8                	or     %edi,%eax
+  8012db:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012df:	f7 74 24 04          	divl   0x4(%esp)
+  8012e3:	d3 e7                	shl    %cl,%edi
+  8012e5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012e9:	89 d7                	mov    %edx,%edi
+  8012eb:	f7 64 24 08          	mull   0x8(%esp)
+  8012ef:	39 d7                	cmp    %edx,%edi
+  8012f1:	89 c1                	mov    %eax,%ecx
+  8012f3:	89 14 24             	mov    %edx,(%esp)
+  8012f6:	72 2c                	jb     801324 <__umoddi3+0x134>
+  8012f8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012fc:	72 22                	jb     801320 <__umoddi3+0x130>
+  8012fe:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  801302:	29 c8                	sub    %ecx,%eax
+  801304:	19 d7                	sbb    %edx,%edi
+  801306:	89 e9                	mov    %ebp,%ecx
+  801308:	89 fa                	mov    %edi,%edx
+  80130a:	d3 e8                	shr    %cl,%eax
+  80130c:	89 f1                	mov    %esi,%ecx
+  80130e:	d3 e2                	shl    %cl,%edx
+  801310:	89 e9                	mov    %ebp,%ecx
+  801312:	d3 ef                	shr    %cl,%edi
+  801314:	09 d0                	or     %edx,%eax
+  801316:	89 fa                	mov    %edi,%edx
+  801318:	83 c4 14             	add    $0x14,%esp
+  80131b:	5e                   	pop    %esi
+  80131c:	5f                   	pop    %edi
+  80131d:	5d                   	pop    %ebp
+  80131e:	c3                   	ret    
+  80131f:	90                   	nop
+  801320:	39 d7                	cmp    %edx,%edi
+  801322:	75 da                	jne    8012fe <__umoddi3+0x10e>
+  801324:	8b 14 24             	mov    (%esp),%edx
+  801327:	89 c1                	mov    %eax,%ecx
+  801329:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80132d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801331:	eb cb                	jmp    8012fe <__umoddi3+0x10e>
+  801333:	90                   	nop
+  801334:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801338:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80133c:	0f 82 0f ff ff ff    	jb     801251 <__umoddi3+0x61>
+  801342:	e9 1a ff ff ff       	jmp    801261 <__umoddi3+0x71>
diff --git a/obj/user/hello.o b/obj/user/hello.o
new file mode 100644
index 0000000..d9eb337
Binary files /dev/null and b/obj/user/hello.o differ
diff --git a/obj/user/hello.sym b/obj/user/hello.sym
new file mode 100644
index 0000000..a588338
--- /dev/null
+++ b/obj/user/hello.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a1c R __STAB_END__
+00202a1d R __STABSTR_BEGIN__
+002040d7 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080005f T libmain
+008000ad T exit
+008000c1 t putch
+0080011d T vcprintf
+00800181 T cprintf
+008001a7 t printnum
+00800285 t getuint
+008002d4 t getint
+0080031b T vprintfmt
+00800862 T printfmt
+00800890 t sprintputch
+008008c5 T vsnprintf
+00800925 T snprintf
+00800959 T strlen
+0080097f T strnlen
+008009af T strcpy
+008009df T strcat
+00800a0f T strncpy
+00800a54 T strlcpy
+00800aa5 T strcmp
+00800ae4 T strncmp
+00800b3a T strchr
+00800b6d T strfind
+00800b9b T memset
+00800c09 T memmove
+00800ce3 T memcpy
+00800d04 T memcmp
+00800d5c T memfind
+00800d8f T strtol
+00800eed t syscall
+00800f4e T sys_cputs
+00800f90 T sys_cgetc
+00800fd4 T sys_env_destroy
+00801017 T sys_getenvid
+0080105b T _panic
+008010c0 T __udivdi3
+008011f0 T __umoddi3
+008013e4 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/softint b/obj/user/softint
new file mode 100755
index 0000000..d0cdea4
Binary files /dev/null and b/obj/user/softint differ
diff --git a/obj/user/softint.asm b/obj/user/softint.asm
new file mode 100644
index 0000000..38b9ed3
--- /dev/null
+++ b/obj/user/softint.asm
@@ -0,0 +1,2627 @@
+
+obj/user/softint:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 09 00 00 00       	call   80003a <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+#include <inc/lib.h>
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+	asm volatile("int $14");	// page fault
+  800036:	cd 0e                	int    $0xe
+}
+  800038:	5d                   	pop    %ebp
+  800039:	c3                   	ret    
+
+0080003a <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80003a:	55                   	push   %ebp
+  80003b:	89 e5                	mov    %esp,%ebp
+  80003d:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800040:	e8 81 01 00 00       	call   8001c6 <sys_getenvid>
+  800045:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80004a:	89 c2                	mov    %eax,%edx
+  80004c:	89 d0                	mov    %edx,%eax
+  80004e:	01 c0                	add    %eax,%eax
+  800050:	01 d0                	add    %edx,%eax
+  800052:	c1 e0 05             	shl    $0x5,%eax
+  800055:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80005a:	a3 04 20 80 00       	mov    %eax,0x802004
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  80005f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800063:	7e 0a                	jle    80006f <libmain+0x35>
+		binaryname = argv[0];
+  800065:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800068:	8b 00                	mov    (%eax),%eax
+  80006a:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  80006f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800072:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800076:	8b 45 08             	mov    0x8(%ebp),%eax
+  800079:	89 04 24             	mov    %eax,(%esp)
+  80007c:	e8 b2 ff ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800081:	e8 02 00 00 00       	call   800088 <exit>
+}
+  800086:	c9                   	leave  
+  800087:	c3                   	ret    
+
+00800088 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  800088:	55                   	push   %ebp
+  800089:	89 e5                	mov    %esp,%ebp
+  80008b:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  80008e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800095:	e8 e9 00 00 00       	call   800183 <sys_env_destroy>
+}
+  80009a:	c9                   	leave  
+  80009b:	c3                   	ret    
+
+0080009c <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  80009c:	55                   	push   %ebp
+  80009d:	89 e5                	mov    %esp,%ebp
+  80009f:	57                   	push   %edi
+  8000a0:	56                   	push   %esi
+  8000a1:	53                   	push   %ebx
+  8000a2:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  8000a5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000a8:	8b 55 10             	mov    0x10(%ebp),%edx
+  8000ab:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  8000ae:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  8000b1:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  8000b4:	8b 75 20             	mov    0x20(%ebp),%esi
+  8000b7:	cd 30                	int    $0x30
+  8000b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  8000bc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8000c0:	74 30                	je     8000f2 <syscall+0x56>
+  8000c2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8000c6:	7e 2a                	jle    8000f2 <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  8000c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  8000cb:	89 44 24 10          	mov    %eax,0x10(%esp)
+  8000cf:	8b 45 08             	mov    0x8(%ebp),%eax
+  8000d2:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000d6:	c7 44 24 08 32 13 80 	movl   $0x801332,0x8(%esp)
+  8000dd:	00 
+  8000de:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  8000e5:	00 
+  8000e6:	c7 04 24 4f 13 80 00 	movl   $0x80134f,(%esp)
+  8000ed:	e8 18 01 00 00       	call   80020a <_panic>
+
+	return ret;
+  8000f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  8000f5:	83 c4 3c             	add    $0x3c,%esp
+  8000f8:	5b                   	pop    %ebx
+  8000f9:	5e                   	pop    %esi
+  8000fa:	5f                   	pop    %edi
+  8000fb:	5d                   	pop    %ebp
+  8000fc:	c3                   	ret    
+
+008000fd <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  8000fd:	55                   	push   %ebp
+  8000fe:	89 e5                	mov    %esp,%ebp
+  800100:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  800103:	8b 45 08             	mov    0x8(%ebp),%eax
+  800106:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80010d:	00 
+  80010e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800115:	00 
+  800116:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  80011d:	00 
+  80011e:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800121:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800125:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800129:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800130:	00 
+  800131:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800138:	e8 5f ff ff ff       	call   80009c <syscall>
+}
+  80013d:	c9                   	leave  
+  80013e:	c3                   	ret    
+
+0080013f <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  80013f:	55                   	push   %ebp
+  800140:	89 e5                	mov    %esp,%ebp
+  800142:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  800145:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80014c:	00 
+  80014d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  800154:	00 
+  800155:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  80015c:	00 
+  80015d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  800164:	00 
+  800165:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  80016c:	00 
+  80016d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  800174:	00 
+  800175:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  80017c:	e8 1b ff ff ff       	call   80009c <syscall>
+}
+  800181:	c9                   	leave  
+  800182:	c3                   	ret    
+
+00800183 <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  800183:	55                   	push   %ebp
+  800184:	89 e5                	mov    %esp,%ebp
+  800186:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  800189:	8b 45 08             	mov    0x8(%ebp),%eax
+  80018c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  800193:	00 
+  800194:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80019b:	00 
+  80019c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001a3:	00 
+  8001a4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001ab:	00 
+  8001ac:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8001b0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  8001b7:	00 
+  8001b8:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  8001bf:	e8 d8 fe ff ff       	call   80009c <syscall>
+}
+  8001c4:	c9                   	leave  
+  8001c5:	c3                   	ret    
+
+008001c6 <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  8001c6:	55                   	push   %ebp
+  8001c7:	89 e5                	mov    %esp,%ebp
+  8001c9:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  8001cc:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8001d3:	00 
+  8001d4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8001db:	00 
+  8001dc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8001e3:	00 
+  8001e4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8001eb:	00 
+  8001ec:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  8001f3:	00 
+  8001f4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  8001fb:	00 
+  8001fc:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  800203:	e8 94 fe ff ff       	call   80009c <syscall>
+}
+  800208:	c9                   	leave  
+  800209:	c3                   	ret    
+
+0080020a <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80020a:	55                   	push   %ebp
+  80020b:	89 e5                	mov    %esp,%ebp
+  80020d:	53                   	push   %ebx
+  80020e:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800211:	8d 45 14             	lea    0x14(%ebp),%eax
+  800214:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  800217:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  80021d:	e8 a4 ff ff ff       	call   8001c6 <sys_getenvid>
+  800222:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800225:	89 54 24 10          	mov    %edx,0x10(%esp)
+  800229:	8b 55 08             	mov    0x8(%ebp),%edx
+  80022c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  800230:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  800234:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800238:	c7 04 24 60 13 80 00 	movl   $0x801360,(%esp)
+  80023f:	e8 e1 00 00 00       	call   800325 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  800244:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800247:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80024b:	8b 45 10             	mov    0x10(%ebp),%eax
+  80024e:	89 04 24             	mov    %eax,(%esp)
+  800251:	e8 6b 00 00 00       	call   8002c1 <vcprintf>
+	cprintf("\n");
+  800256:	c7 04 24 83 13 80 00 	movl   $0x801383,(%esp)
+  80025d:	e8 c3 00 00 00       	call   800325 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  800262:	cc                   	int3   
+  800263:	eb fd                	jmp    800262 <_panic+0x58>
+
+00800265 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  800265:	55                   	push   %ebp
+  800266:	89 e5                	mov    %esp,%ebp
+  800268:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  80026b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80026e:	8b 00                	mov    (%eax),%eax
+  800270:	8d 48 01             	lea    0x1(%eax),%ecx
+  800273:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800276:	89 0a                	mov    %ecx,(%edx)
+  800278:	8b 55 08             	mov    0x8(%ebp),%edx
+  80027b:	89 d1                	mov    %edx,%ecx
+  80027d:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800280:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  800284:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800287:	8b 00                	mov    (%eax),%eax
+  800289:	3d ff 00 00 00       	cmp    $0xff,%eax
+  80028e:	75 20                	jne    8002b0 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  800290:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800293:	8b 00                	mov    (%eax),%eax
+  800295:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800298:	83 c2 08             	add    $0x8,%edx
+  80029b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80029f:	89 14 24             	mov    %edx,(%esp)
+  8002a2:	e8 56 fe ff ff       	call   8000fd <sys_cputs>
+		b->idx = 0;
+  8002a7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  8002b0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002b3:	8b 40 04             	mov    0x4(%eax),%eax
+  8002b6:	8d 50 01             	lea    0x1(%eax),%edx
+  8002b9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002bc:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  8002bf:	c9                   	leave  
+  8002c0:	c3                   	ret    
+
+008002c1 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  8002c1:	55                   	push   %ebp
+  8002c2:	89 e5                	mov    %esp,%ebp
+  8002c4:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  8002ca:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  8002d1:	00 00 00 
+	b.cnt = 0;
+  8002d4:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  8002db:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  8002de:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8002e1:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8002e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002e8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8002ec:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  8002f2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002f6:	c7 04 24 65 02 80 00 	movl   $0x800265,(%esp)
+  8002fd:	e8 bd 01 00 00       	call   8004bf <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800302:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  800308:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80030c:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800312:	83 c0 08             	add    $0x8,%eax
+  800315:	89 04 24             	mov    %eax,(%esp)
+  800318:	e8 e0 fd ff ff       	call   8000fd <sys_cputs>
+
+	return b.cnt;
+  80031d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  800323:	c9                   	leave  
+  800324:	c3                   	ret    
+
+00800325 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  800325:	55                   	push   %ebp
+  800326:	89 e5                	mov    %esp,%ebp
+  800328:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  80032b:	8d 45 0c             	lea    0xc(%ebp),%eax
+  80032e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  800331:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800334:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800338:	8b 45 08             	mov    0x8(%ebp),%eax
+  80033b:	89 04 24             	mov    %eax,(%esp)
+  80033e:	e8 7e ff ff ff       	call   8002c1 <vcprintf>
+  800343:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  800346:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800349:	c9                   	leave  
+  80034a:	c3                   	ret    
+
+0080034b <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  80034b:	55                   	push   %ebp
+  80034c:	89 e5                	mov    %esp,%ebp
+  80034e:	53                   	push   %ebx
+  80034f:	83 ec 34             	sub    $0x34,%esp
+  800352:	8b 45 10             	mov    0x10(%ebp),%eax
+  800355:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800358:	8b 45 14             	mov    0x14(%ebp),%eax
+  80035b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  80035e:	8b 45 18             	mov    0x18(%ebp),%eax
+  800361:	ba 00 00 00 00       	mov    $0x0,%edx
+  800366:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  800369:	77 72                	ja     8003dd <printnum+0x92>
+  80036b:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  80036e:	72 05                	jb     800375 <printnum+0x2a>
+  800370:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  800373:	77 68                	ja     8003dd <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  800375:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  800378:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  80037b:	8b 45 18             	mov    0x18(%ebp),%eax
+  80037e:	ba 00 00 00 00       	mov    $0x0,%edx
+  800383:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800387:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80038b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80038e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800391:	89 04 24             	mov    %eax,(%esp)
+  800394:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800398:	e8 03 0d 00 00       	call   8010a0 <__udivdi3>
+  80039d:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  8003a0:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  8003a4:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  8003a8:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003ab:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8003af:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8003b3:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8003b7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003ba:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003be:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003c1:	89 04 24             	mov    %eax,(%esp)
+  8003c4:	e8 82 ff ff ff       	call   80034b <printnum>
+  8003c9:	eb 1c                	jmp    8003e7 <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  8003cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8003ce:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8003d2:	8b 45 20             	mov    0x20(%ebp),%eax
+  8003d5:	89 04 24             	mov    %eax,(%esp)
+  8003d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003db:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  8003dd:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  8003e1:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  8003e5:	7f e4                	jg     8003cb <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  8003e7:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  8003ea:	bb 00 00 00 00       	mov    $0x0,%ebx
+  8003ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8003f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8003f5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8003f9:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  8003fd:	89 04 24             	mov    %eax,(%esp)
+  800400:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800404:	e8 c7 0d 00 00       	call   8011d0 <__umoddi3>
+  800409:	05 10 14 80 00       	add    $0x801410,%eax
+  80040e:	0f b6 00             	movzbl (%eax),%eax
+  800411:	0f be c0             	movsbl %al,%eax
+  800414:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800417:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80041b:	89 04 24             	mov    %eax,(%esp)
+  80041e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800421:	ff d0                	call   *%eax
+}
+  800423:	83 c4 34             	add    $0x34,%esp
+  800426:	5b                   	pop    %ebx
+  800427:	5d                   	pop    %ebp
+  800428:	c3                   	ret    
+
+00800429 <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  800429:	55                   	push   %ebp
+  80042a:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80042c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800430:	7e 14                	jle    800446 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  800432:	8b 45 08             	mov    0x8(%ebp),%eax
+  800435:	8b 00                	mov    (%eax),%eax
+  800437:	8d 48 08             	lea    0x8(%eax),%ecx
+  80043a:	8b 55 08             	mov    0x8(%ebp),%edx
+  80043d:	89 0a                	mov    %ecx,(%edx)
+  80043f:	8b 50 04             	mov    0x4(%eax),%edx
+  800442:	8b 00                	mov    (%eax),%eax
+  800444:	eb 30                	jmp    800476 <getuint+0x4d>
+	else if (lflag)
+  800446:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80044a:	74 16                	je     800462 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  80044c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80044f:	8b 00                	mov    (%eax),%eax
+  800451:	8d 48 04             	lea    0x4(%eax),%ecx
+  800454:	8b 55 08             	mov    0x8(%ebp),%edx
+  800457:	89 0a                	mov    %ecx,(%edx)
+  800459:	8b 00                	mov    (%eax),%eax
+  80045b:	ba 00 00 00 00       	mov    $0x0,%edx
+  800460:	eb 14                	jmp    800476 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  800462:	8b 45 08             	mov    0x8(%ebp),%eax
+  800465:	8b 00                	mov    (%eax),%eax
+  800467:	8d 48 04             	lea    0x4(%eax),%ecx
+  80046a:	8b 55 08             	mov    0x8(%ebp),%edx
+  80046d:	89 0a                	mov    %ecx,(%edx)
+  80046f:	8b 00                	mov    (%eax),%eax
+  800471:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  800476:	5d                   	pop    %ebp
+  800477:	c3                   	ret    
+
+00800478 <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  800478:	55                   	push   %ebp
+  800479:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  80047b:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  80047f:	7e 14                	jle    800495 <getint+0x1d>
+		return va_arg(*ap, long long);
+  800481:	8b 45 08             	mov    0x8(%ebp),%eax
+  800484:	8b 00                	mov    (%eax),%eax
+  800486:	8d 48 08             	lea    0x8(%eax),%ecx
+  800489:	8b 55 08             	mov    0x8(%ebp),%edx
+  80048c:	89 0a                	mov    %ecx,(%edx)
+  80048e:	8b 50 04             	mov    0x4(%eax),%edx
+  800491:	8b 00                	mov    (%eax),%eax
+  800493:	eb 28                	jmp    8004bd <getint+0x45>
+	else if (lflag)
+  800495:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800499:	74 12                	je     8004ad <getint+0x35>
+		return va_arg(*ap, long);
+  80049b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80049e:	8b 00                	mov    (%eax),%eax
+  8004a0:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004a3:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004a6:	89 0a                	mov    %ecx,(%edx)
+  8004a8:	8b 00                	mov    (%eax),%eax
+  8004aa:	99                   	cltd   
+  8004ab:	eb 10                	jmp    8004bd <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  8004ad:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004b0:	8b 00                	mov    (%eax),%eax
+  8004b2:	8d 48 04             	lea    0x4(%eax),%ecx
+  8004b5:	8b 55 08             	mov    0x8(%ebp),%edx
+  8004b8:	89 0a                	mov    %ecx,(%edx)
+  8004ba:	8b 00                	mov    (%eax),%eax
+  8004bc:	99                   	cltd   
+}
+  8004bd:	5d                   	pop    %ebp
+  8004be:	c3                   	ret    
+
+008004bf <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  8004bf:	55                   	push   %ebp
+  8004c0:	89 e5                	mov    %esp,%ebp
+  8004c2:	56                   	push   %esi
+  8004c3:	53                   	push   %ebx
+  8004c4:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8004c7:	e9 72 01 00 00       	jmp    80063e <vprintfmt+0x17f>
+			if (ch == '\0')
+  8004cc:	85 db                	test   %ebx,%ebx
+  8004ce:	75 05                	jne    8004d5 <vprintfmt+0x16>
+				return;
+  8004d0:	e9 2a 05 00 00       	jmp    8009ff <vprintfmt+0x540>
+			else if(ch == '\033'){
+  8004d5:	83 fb 1b             	cmp    $0x1b,%ebx
+  8004d8:	0f 85 51 01 00 00    	jne    80062f <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  8004de:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004e1:	8d 50 01             	lea    0x1(%eax),%edx
+  8004e4:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004e7:	0f b6 00             	movzbl (%eax),%eax
+  8004ea:	0f b6 d8             	movzbl %al,%ebx
+  8004ed:	83 fb 5b             	cmp    $0x5b,%ebx
+  8004f0:	74 14                	je     800506 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  8004f2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8004f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8004f9:	89 1c 24             	mov    %ebx,(%esp)
+  8004fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8004ff:	ff d0                	call   *%eax
+				    continue;
+  800501:	e9 38 01 00 00       	jmp    80063e <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800506:	8b 45 10             	mov    0x10(%ebp),%eax
+  800509:	8d 50 01             	lea    0x1(%eax),%edx
+  80050c:	89 55 10             	mov    %edx,0x10(%ebp)
+  80050f:	0f b6 00             	movzbl (%eax),%eax
+  800512:	0f b6 c0             	movzbl %al,%eax
+  800515:	a3 08 20 80 00       	mov    %eax,0x802008
+				FG_COLOR = *(unsigned char *) fmt++;
+  80051a:	8b 45 10             	mov    0x10(%ebp),%eax
+  80051d:	8d 50 01             	lea    0x1(%eax),%edx
+  800520:	89 55 10             	mov    %edx,0x10(%ebp)
+  800523:	0f b6 00             	movzbl (%eax),%eax
+  800526:	0f b6 c0             	movzbl %al,%eax
+  800529:	a3 10 20 80 00       	mov    %eax,0x802010
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  80052e:	a1 08 20 80 00       	mov    0x802008,%eax
+  800533:	83 f8 2f             	cmp    $0x2f,%eax
+  800536:	7e 19                	jle    800551 <vprintfmt+0x92>
+  800538:	a1 08 20 80 00       	mov    0x802008,%eax
+  80053d:	83 f8 39             	cmp    $0x39,%eax
+  800540:	7f 0f                	jg     800551 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  800542:	a1 08 20 80 00       	mov    0x802008,%eax
+  800547:	83 e8 30             	sub    $0x30,%eax
+  80054a:	a3 08 20 80 00       	mov    %eax,0x802008
+  80054f:	eb 50                	jmp    8005a1 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  800551:	a1 08 20 80 00       	mov    0x802008,%eax
+  800556:	83 f8 60             	cmp    $0x60,%eax
+  800559:	7e 19                	jle    800574 <vprintfmt+0xb5>
+  80055b:	a1 08 20 80 00       	mov    0x802008,%eax
+  800560:	83 f8 66             	cmp    $0x66,%eax
+  800563:	7f 0f                	jg     800574 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  800565:	a1 08 20 80 00       	mov    0x802008,%eax
+  80056a:	83 e8 57             	sub    $0x57,%eax
+  80056d:	a3 08 20 80 00       	mov    %eax,0x802008
+  800572:	eb 2d                	jmp    8005a1 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  800574:	a1 08 20 80 00       	mov    0x802008,%eax
+  800579:	83 f8 40             	cmp    $0x40,%eax
+  80057c:	7e 19                	jle    800597 <vprintfmt+0xd8>
+  80057e:	a1 08 20 80 00       	mov    0x802008,%eax
+  800583:	83 f8 46             	cmp    $0x46,%eax
+  800586:	7f 0f                	jg     800597 <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  800588:	a1 08 20 80 00       	mov    0x802008,%eax
+  80058d:	83 e8 37             	sub    $0x37,%eax
+  800590:	a3 08 20 80 00       	mov    %eax,0x802008
+  800595:	eb 0a                	jmp    8005a1 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  800597:	c7 05 08 20 80 00 00 	movl   $0x0,0x802008
+  80059e:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  8005a1:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005a6:	83 f8 2f             	cmp    $0x2f,%eax
+  8005a9:	7e 19                	jle    8005c4 <vprintfmt+0x105>
+  8005ab:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005b0:	83 f8 39             	cmp    $0x39,%eax
+  8005b3:	7f 0f                	jg     8005c4 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  8005b5:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005ba:	83 e8 30             	sub    $0x30,%eax
+  8005bd:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005c2:	eb 50                	jmp    800614 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  8005c4:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005c9:	83 f8 60             	cmp    $0x60,%eax
+  8005cc:	7e 19                	jle    8005e7 <vprintfmt+0x128>
+  8005ce:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005d3:	83 f8 66             	cmp    $0x66,%eax
+  8005d6:	7f 0f                	jg     8005e7 <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  8005d8:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005dd:	83 e8 57             	sub    $0x57,%eax
+  8005e0:	a3 10 20 80 00       	mov    %eax,0x802010
+  8005e5:	eb 2d                	jmp    800614 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  8005e7:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005ec:	83 f8 40             	cmp    $0x40,%eax
+  8005ef:	7e 19                	jle    80060a <vprintfmt+0x14b>
+  8005f1:	a1 10 20 80 00       	mov    0x802010,%eax
+  8005f6:	83 f8 46             	cmp    $0x46,%eax
+  8005f9:	7f 0f                	jg     80060a <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  8005fb:	a1 10 20 80 00       	mov    0x802010,%eax
+  800600:	83 e8 37             	sub    $0x37,%eax
+  800603:	a3 10 20 80 00       	mov    %eax,0x802010
+  800608:	eb 0a                	jmp    800614 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80060a:	c7 05 08 20 80 00 07 	movl   $0x7,0x802008
+  800611:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800614:	a1 08 20 80 00       	mov    0x802008,%eax
+  800619:	c1 e0 0c             	shl    $0xc,%eax
+  80061c:	89 c2                	mov    %eax,%edx
+  80061e:	a1 10 20 80 00       	mov    0x802010,%eax
+  800623:	c1 e0 08             	shl    $0x8,%eax
+  800626:	09 d0                	or     %edx,%eax
+  800628:	a3 0c 20 80 00       	mov    %eax,0x80200c
+				continue;
+  80062d:	eb 0f                	jmp    80063e <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  80062f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800632:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800636:	89 1c 24             	mov    %ebx,(%esp)
+  800639:	8b 45 08             	mov    0x8(%ebp),%eax
+  80063c:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80063e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800641:	8d 50 01             	lea    0x1(%eax),%edx
+  800644:	89 55 10             	mov    %edx,0x10(%ebp)
+  800647:	0f b6 00             	movzbl (%eax),%eax
+  80064a:	0f b6 d8             	movzbl %al,%ebx
+  80064d:	83 fb 25             	cmp    $0x25,%ebx
+  800650:	0f 85 76 fe ff ff    	jne    8004cc <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  800656:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  80065a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  800661:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  800668:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  80066f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  800676:	8b 45 10             	mov    0x10(%ebp),%eax
+  800679:	8d 50 01             	lea    0x1(%eax),%edx
+  80067c:	89 55 10             	mov    %edx,0x10(%ebp)
+  80067f:	0f b6 00             	movzbl (%eax),%eax
+  800682:	0f b6 d8             	movzbl %al,%ebx
+  800685:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  800688:	83 f8 55             	cmp    $0x55,%eax
+  80068b:	0f 87 3d 03 00 00    	ja     8009ce <vprintfmt+0x50f>
+  800691:	8b 04 85 34 14 80 00 	mov    0x801434(,%eax,4),%eax
+  800698:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  80069a:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  80069e:	eb d6                	jmp    800676 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  8006a0:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  8006a4:	eb d0                	jmp    800676 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  8006ad:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  8006b0:	89 d0                	mov    %edx,%eax
+  8006b2:	c1 e0 02             	shl    $0x2,%eax
+  8006b5:	01 d0                	add    %edx,%eax
+  8006b7:	01 c0                	add    %eax,%eax
+  8006b9:	01 d8                	add    %ebx,%eax
+  8006bb:	83 e8 30             	sub    $0x30,%eax
+  8006be:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  8006c1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8006c4:	0f b6 00             	movzbl (%eax),%eax
+  8006c7:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  8006ca:	83 fb 2f             	cmp    $0x2f,%ebx
+  8006cd:	7e 0b                	jle    8006da <vprintfmt+0x21b>
+  8006cf:	83 fb 39             	cmp    $0x39,%ebx
+  8006d2:	7f 06                	jg     8006da <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  8006d4:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  8006d8:	eb d3                	jmp    8006ad <vprintfmt+0x1ee>
+			goto process_precision;
+  8006da:	eb 33                	jmp    80070f <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  8006dc:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006df:	8d 50 04             	lea    0x4(%eax),%edx
+  8006e2:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006e5:	8b 00                	mov    (%eax),%eax
+  8006e7:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  8006ea:	eb 23                	jmp    80070f <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  8006ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8006f0:	79 0c                	jns    8006fe <vprintfmt+0x23f>
+				width = 0;
+  8006f2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  8006f9:	e9 78 ff ff ff       	jmp    800676 <vprintfmt+0x1b7>
+  8006fe:	e9 73 ff ff ff       	jmp    800676 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800703:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80070a:	e9 67 ff ff ff       	jmp    800676 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  80070f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800713:	79 12                	jns    800727 <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800715:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800718:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80071b:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  800722:	e9 4f ff ff ff       	jmp    800676 <vprintfmt+0x1b7>
+  800727:	e9 4a ff ff ff       	jmp    800676 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  80072c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  800730:	e9 41 ff ff ff       	jmp    800676 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  800735:	8b 45 14             	mov    0x14(%ebp),%eax
+  800738:	8d 50 04             	lea    0x4(%eax),%edx
+  80073b:	89 55 14             	mov    %edx,0x14(%ebp)
+  80073e:	8b 00                	mov    (%eax),%eax
+  800740:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800743:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800747:	89 04 24             	mov    %eax,(%esp)
+  80074a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80074d:	ff d0                	call   *%eax
+			break;
+  80074f:	e9 a5 02 00 00       	jmp    8009f9 <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  800754:	8b 45 14             	mov    0x14(%ebp),%eax
+  800757:	8d 50 04             	lea    0x4(%eax),%edx
+  80075a:	89 55 14             	mov    %edx,0x14(%ebp)
+  80075d:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  80075f:	85 db                	test   %ebx,%ebx
+  800761:	79 02                	jns    800765 <vprintfmt+0x2a6>
+				err = -err;
+  800763:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  800765:	83 fb 06             	cmp    $0x6,%ebx
+  800768:	7f 0b                	jg     800775 <vprintfmt+0x2b6>
+  80076a:	8b 34 9d f4 13 80 00 	mov    0x8013f4(,%ebx,4),%esi
+  800771:	85 f6                	test   %esi,%esi
+  800773:	75 23                	jne    800798 <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  800775:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800779:	c7 44 24 08 21 14 80 	movl   $0x801421,0x8(%esp)
+  800780:	00 
+  800781:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800784:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800788:	8b 45 08             	mov    0x8(%ebp),%eax
+  80078b:	89 04 24             	mov    %eax,(%esp)
+  80078e:	e8 73 02 00 00       	call   800a06 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  800793:	e9 61 02 00 00       	jmp    8009f9 <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  800798:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  80079c:	c7 44 24 08 2a 14 80 	movl   $0x80142a,0x8(%esp)
+  8007a3:	00 
+  8007a4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007ab:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007ae:	89 04 24             	mov    %eax,(%esp)
+  8007b1:	e8 50 02 00 00       	call   800a06 <printfmt>
+			break;
+  8007b6:	e9 3e 02 00 00       	jmp    8009f9 <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  8007bb:	8b 45 14             	mov    0x14(%ebp),%eax
+  8007be:	8d 50 04             	lea    0x4(%eax),%edx
+  8007c1:	89 55 14             	mov    %edx,0x14(%ebp)
+  8007c4:	8b 30                	mov    (%eax),%esi
+  8007c6:	85 f6                	test   %esi,%esi
+  8007c8:	75 05                	jne    8007cf <vprintfmt+0x310>
+				p = "(null)";
+  8007ca:	be 2d 14 80 00       	mov    $0x80142d,%esi
+			if (width > 0 && padc != '-')
+  8007cf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  8007d3:	7e 37                	jle    80080c <vprintfmt+0x34d>
+  8007d5:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  8007d9:	74 31                	je     80080c <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  8007db:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  8007de:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007e2:	89 34 24             	mov    %esi,(%esp)
+  8007e5:	e8 39 03 00 00       	call   800b23 <strnlen>
+  8007ea:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  8007ed:	eb 17                	jmp    800806 <vprintfmt+0x347>
+					putch(padc, putdat);
+  8007ef:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  8007f3:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8007f6:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8007fa:	89 04 24             	mov    %eax,(%esp)
+  8007fd:	8b 45 08             	mov    0x8(%ebp),%eax
+  800800:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800802:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800806:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80080a:	7f e3                	jg     8007ef <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80080c:	eb 38                	jmp    800846 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  80080e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800812:	74 1f                	je     800833 <vprintfmt+0x374>
+  800814:	83 fb 1f             	cmp    $0x1f,%ebx
+  800817:	7e 05                	jle    80081e <vprintfmt+0x35f>
+  800819:	83 fb 7e             	cmp    $0x7e,%ebx
+  80081c:	7e 15                	jle    800833 <vprintfmt+0x374>
+					putch('?', putdat);
+  80081e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800821:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800825:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  80082c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80082f:	ff d0                	call   *%eax
+  800831:	eb 0f                	jmp    800842 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  800833:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800836:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80083a:	89 1c 24             	mov    %ebx,(%esp)
+  80083d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800840:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  800842:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800846:	89 f0                	mov    %esi,%eax
+  800848:	8d 70 01             	lea    0x1(%eax),%esi
+  80084b:	0f b6 00             	movzbl (%eax),%eax
+  80084e:	0f be d8             	movsbl %al,%ebx
+  800851:	85 db                	test   %ebx,%ebx
+  800853:	74 10                	je     800865 <vprintfmt+0x3a6>
+  800855:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800859:	78 b3                	js     80080e <vprintfmt+0x34f>
+  80085b:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  80085f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  800863:	79 a9                	jns    80080e <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  800865:	eb 17                	jmp    80087e <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  800867:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80086a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80086e:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  800875:	8b 45 08             	mov    0x8(%ebp),%eax
+  800878:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  80087a:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  80087e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800882:	7f e3                	jg     800867 <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  800884:	e9 70 01 00 00       	jmp    8009f9 <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  800889:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80088c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800890:	8d 45 14             	lea    0x14(%ebp),%eax
+  800893:	89 04 24             	mov    %eax,(%esp)
+  800896:	e8 dd fb ff ff       	call   800478 <getint>
+  80089b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80089e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  8008a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008a7:	85 d2                	test   %edx,%edx
+  8008a9:	79 26                	jns    8008d1 <vprintfmt+0x412>
+				putch('-', putdat);
+  8008ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008ae:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008b2:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  8008b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008bc:	ff d0                	call   *%eax
+				num = -(long long) num;
+  8008be:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8008c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8008c4:	f7 d8                	neg    %eax
+  8008c6:	83 d2 00             	adc    $0x0,%edx
+  8008c9:	f7 da                	neg    %edx
+  8008cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008ce:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  8008d1:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008d8:	e9 a8 00 00 00       	jmp    800985 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  8008dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008e0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008e4:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008e7:	89 04 24             	mov    %eax,(%esp)
+  8008ea:	e8 3a fb ff ff       	call   800429 <getuint>
+  8008ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008f2:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  8008f5:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  8008fc:	e9 84 00 00 00       	jmp    800985 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800901:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800904:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800908:	8d 45 14             	lea    0x14(%ebp),%eax
+  80090b:	89 04 24             	mov    %eax,(%esp)
+  80090e:	e8 16 fb ff ff       	call   800429 <getuint>
+  800913:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800916:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  800919:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  800920:	eb 63                	jmp    800985 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  800922:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800925:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800929:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  800930:	8b 45 08             	mov    0x8(%ebp),%eax
+  800933:	ff d0                	call   *%eax
+			putch('x', putdat);
+  800935:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800938:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80093c:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  800943:	8b 45 08             	mov    0x8(%ebp),%eax
+  800946:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  800948:	8b 45 14             	mov    0x14(%ebp),%eax
+  80094b:	8d 50 04             	lea    0x4(%eax),%edx
+  80094e:	89 55 14             	mov    %edx,0x14(%ebp)
+  800951:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  800953:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800956:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  80095d:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  800964:	eb 1f                	jmp    800985 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  800966:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800969:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80096d:	8d 45 14             	lea    0x14(%ebp),%eax
+  800970:	89 04 24             	mov    %eax,(%esp)
+  800973:	e8 b1 fa ff ff       	call   800429 <getuint>
+  800978:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  80097b:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  80097e:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  800985:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  800989:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  80098c:	89 54 24 18          	mov    %edx,0x18(%esp)
+  800990:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800993:	89 54 24 14          	mov    %edx,0x14(%esp)
+  800997:	89 44 24 10          	mov    %eax,0x10(%esp)
+  80099b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  80099e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  8009a1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009a5:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8009a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009ac:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009b0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009b3:	89 04 24             	mov    %eax,(%esp)
+  8009b6:	e8 90 f9 ff ff       	call   80034b <printnum>
+			break;
+  8009bb:	eb 3c                	jmp    8009f9 <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  8009bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009c4:	89 1c 24             	mov    %ebx,(%esp)
+  8009c7:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ca:	ff d0                	call   *%eax
+			break;			
+  8009cc:	eb 2b                	jmp    8009f9 <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  8009ce:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009d5:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  8009dc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009df:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  8009e1:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009e5:	eb 04                	jmp    8009eb <vprintfmt+0x52c>
+  8009e7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  8009eb:	8b 45 10             	mov    0x10(%ebp),%eax
+  8009ee:	83 e8 01             	sub    $0x1,%eax
+  8009f1:	0f b6 00             	movzbl (%eax),%eax
+  8009f4:	3c 25                	cmp    $0x25,%al
+  8009f6:	75 ef                	jne    8009e7 <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  8009f8:	90                   	nop
+		}
+	}
+  8009f9:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8009fa:	e9 3f fc ff ff       	jmp    80063e <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  8009ff:	83 c4 40             	add    $0x40,%esp
+  800a02:	5b                   	pop    %ebx
+  800a03:	5e                   	pop    %esi
+  800a04:	5d                   	pop    %ebp
+  800a05:	c3                   	ret    
+
+00800a06 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800a06:	55                   	push   %ebp
+  800a07:	89 e5                	mov    %esp,%ebp
+  800a09:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800a0c:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800a12:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800a15:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a19:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a1c:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a20:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a23:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a27:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a2a:	89 04 24             	mov    %eax,(%esp)
+  800a2d:	e8 8d fa ff ff       	call   8004bf <vprintfmt>
+	va_end(ap);
+}
+  800a32:	c9                   	leave  
+  800a33:	c3                   	ret    
+
+00800a34 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  800a34:	55                   	push   %ebp
+  800a35:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  800a37:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a3a:	8b 40 08             	mov    0x8(%eax),%eax
+  800a3d:	8d 50 01             	lea    0x1(%eax),%edx
+  800a40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a43:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  800a46:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a49:	8b 10                	mov    (%eax),%edx
+  800a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a4e:	8b 40 04             	mov    0x4(%eax),%eax
+  800a51:	39 c2                	cmp    %eax,%edx
+  800a53:	73 12                	jae    800a67 <sprintputch+0x33>
+		*b->buf++ = ch;
+  800a55:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a58:	8b 00                	mov    (%eax),%eax
+  800a5a:	8d 48 01             	lea    0x1(%eax),%ecx
+  800a5d:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800a60:	89 0a                	mov    %ecx,(%edx)
+  800a62:	8b 55 08             	mov    0x8(%ebp),%edx
+  800a65:	88 10                	mov    %dl,(%eax)
+}
+  800a67:	5d                   	pop    %ebp
+  800a68:	c3                   	ret    
+
+00800a69 <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  800a69:	55                   	push   %ebp
+  800a6a:	89 e5                	mov    %esp,%ebp
+  800a6c:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  800a6f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a72:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  800a75:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a78:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800a7b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a7e:	01 d0                	add    %edx,%eax
+  800a80:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a8a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800a8e:	74 06                	je     800a96 <vsnprintf+0x2d>
+  800a90:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800a94:	7f 07                	jg     800a9d <vsnprintf+0x34>
+		return -E_INVAL;
+  800a96:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800a9b:	eb 2a                	jmp    800ac7 <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800a9d:	8b 45 14             	mov    0x14(%ebp),%eax
+  800aa0:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800aa4:	8b 45 10             	mov    0x10(%ebp),%eax
+  800aa7:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800aab:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800aae:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ab2:	c7 04 24 34 0a 80 00 	movl   $0x800a34,(%esp)
+  800ab9:	e8 01 fa ff ff       	call   8004bf <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800abe:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800ac1:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800ac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800ac7:	c9                   	leave  
+  800ac8:	c3                   	ret    
+
+00800ac9 <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800ac9:	55                   	push   %ebp
+  800aca:	89 e5                	mov    %esp,%ebp
+  800acc:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800acf:	8d 45 14             	lea    0x14(%ebp),%eax
+  800ad2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800ad5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800ad8:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800adc:	8b 45 10             	mov    0x10(%ebp),%eax
+  800adf:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800ae3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ae6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800aea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aed:	89 04 24             	mov    %eax,(%esp)
+  800af0:	e8 74 ff ff ff       	call   800a69 <vsnprintf>
+  800af5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800afb:	c9                   	leave  
+  800afc:	c3                   	ret    
+
+00800afd <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800afd:	55                   	push   %ebp
+  800afe:	89 e5                	mov    %esp,%ebp
+  800b00:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b03:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b0a:	eb 08                	jmp    800b14 <strlen+0x17>
+		n++;
+  800b0c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800b10:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b14:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b17:	0f b6 00             	movzbl (%eax),%eax
+  800b1a:	84 c0                	test   %al,%al
+  800b1c:	75 ee                	jne    800b0c <strlen+0xf>
+		n++;
+	return n;
+  800b1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b21:	c9                   	leave  
+  800b22:	c3                   	ret    
+
+00800b23 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800b23:	55                   	push   %ebp
+  800b24:	89 e5                	mov    %esp,%ebp
+  800b26:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b29:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b30:	eb 0c                	jmp    800b3e <strnlen+0x1b>
+		n++;
+  800b32:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800b36:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800b3a:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800b3e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800b42:	74 0a                	je     800b4e <strnlen+0x2b>
+  800b44:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b47:	0f b6 00             	movzbl (%eax),%eax
+  800b4a:	84 c0                	test   %al,%al
+  800b4c:	75 e4                	jne    800b32 <strnlen+0xf>
+		n++;
+	return n;
+  800b4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b51:	c9                   	leave  
+  800b52:	c3                   	ret    
+
+00800b53 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800b53:	55                   	push   %ebp
+  800b54:	89 e5                	mov    %esp,%ebp
+  800b56:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800b59:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b5c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800b5f:	90                   	nop
+  800b60:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b63:	8d 50 01             	lea    0x1(%eax),%edx
+  800b66:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b69:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b6c:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b6f:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800b72:	0f b6 12             	movzbl (%edx),%edx
+  800b75:	88 10                	mov    %dl,(%eax)
+  800b77:	0f b6 00             	movzbl (%eax),%eax
+  800b7a:	84 c0                	test   %al,%al
+  800b7c:	75 e2                	jne    800b60 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b81:	c9                   	leave  
+  800b82:	c3                   	ret    
+
+00800b83 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b83:	55                   	push   %ebp
+  800b84:	89 e5                	mov    %esp,%ebp
+  800b86:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b89:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b8c:	89 04 24             	mov    %eax,(%esp)
+  800b8f:	e8 69 ff ff ff       	call   800afd <strlen>
+  800b94:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800b97:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800b9a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b9d:	01 c2                	add    %eax,%edx
+  800b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ba2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800ba6:	89 14 24             	mov    %edx,(%esp)
+  800ba9:	e8 a5 ff ff ff       	call   800b53 <strcpy>
+	return dst;
+  800bae:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800bb1:	c9                   	leave  
+  800bb2:	c3                   	ret    
+
+00800bb3 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800bb3:	55                   	push   %ebp
+  800bb4:	89 e5                	mov    %esp,%ebp
+  800bb6:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800bb9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bbc:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800bbf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800bc6:	eb 23                	jmp    800beb <strncpy+0x38>
+		*dst++ = *src;
+  800bc8:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bcb:	8d 50 01             	lea    0x1(%eax),%edx
+  800bce:	89 55 08             	mov    %edx,0x8(%ebp)
+  800bd1:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800bd4:	0f b6 12             	movzbl (%edx),%edx
+  800bd7:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800bd9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bdc:	0f b6 00             	movzbl (%eax),%eax
+  800bdf:	84 c0                	test   %al,%al
+  800be1:	74 04                	je     800be7 <strncpy+0x34>
+			src++;
+  800be3:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800be7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800beb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800bee:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800bf1:	72 d5                	jb     800bc8 <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800bf3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800bf6:	c9                   	leave  
+  800bf7:	c3                   	ret    
+
+00800bf8 <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800bf8:	55                   	push   %ebp
+  800bf9:	89 e5                	mov    %esp,%ebp
+  800bfb:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800bfe:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c01:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800c04:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c08:	74 33                	je     800c3d <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800c0a:	eb 17                	jmp    800c23 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800c0c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c0f:	8d 50 01             	lea    0x1(%eax),%edx
+  800c12:	89 55 08             	mov    %edx,0x8(%ebp)
+  800c15:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800c18:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800c1b:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800c1e:	0f b6 12             	movzbl (%edx),%edx
+  800c21:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800c23:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c27:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c2b:	74 0a                	je     800c37 <strlcpy+0x3f>
+  800c2d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c30:	0f b6 00             	movzbl (%eax),%eax
+  800c33:	84 c0                	test   %al,%al
+  800c35:	75 d5                	jne    800c0c <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800c37:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c3a:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800c3d:	8b 55 08             	mov    0x8(%ebp),%edx
+  800c40:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800c43:	29 c2                	sub    %eax,%edx
+  800c45:	89 d0                	mov    %edx,%eax
+}
+  800c47:	c9                   	leave  
+  800c48:	c3                   	ret    
+
+00800c49 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800c49:	55                   	push   %ebp
+  800c4a:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800c4c:	eb 08                	jmp    800c56 <strcmp+0xd>
+		p++, q++;
+  800c4e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c52:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800c56:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c59:	0f b6 00             	movzbl (%eax),%eax
+  800c5c:	84 c0                	test   %al,%al
+  800c5e:	74 10                	je     800c70 <strcmp+0x27>
+  800c60:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c63:	0f b6 10             	movzbl (%eax),%edx
+  800c66:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c69:	0f b6 00             	movzbl (%eax),%eax
+  800c6c:	38 c2                	cmp    %al,%dl
+  800c6e:	74 de                	je     800c4e <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c70:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c73:	0f b6 00             	movzbl (%eax),%eax
+  800c76:	0f b6 d0             	movzbl %al,%edx
+  800c79:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c7c:	0f b6 00             	movzbl (%eax),%eax
+  800c7f:	0f b6 c0             	movzbl %al,%eax
+  800c82:	29 c2                	sub    %eax,%edx
+  800c84:	89 d0                	mov    %edx,%eax
+}
+  800c86:	5d                   	pop    %ebp
+  800c87:	c3                   	ret    
+
+00800c88 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c88:	55                   	push   %ebp
+  800c89:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800c8b:	eb 0c                	jmp    800c99 <strncmp+0x11>
+		n--, p++, q++;
+  800c8d:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c91:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c95:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800c99:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c9d:	74 1a                	je     800cb9 <strncmp+0x31>
+  800c9f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ca2:	0f b6 00             	movzbl (%eax),%eax
+  800ca5:	84 c0                	test   %al,%al
+  800ca7:	74 10                	je     800cb9 <strncmp+0x31>
+  800ca9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cac:	0f b6 10             	movzbl (%eax),%edx
+  800caf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cb2:	0f b6 00             	movzbl (%eax),%eax
+  800cb5:	38 c2                	cmp    %al,%dl
+  800cb7:	74 d4                	je     800c8d <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800cb9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cbd:	75 07                	jne    800cc6 <strncmp+0x3e>
+		return 0;
+  800cbf:	b8 00 00 00 00       	mov    $0x0,%eax
+  800cc4:	eb 16                	jmp    800cdc <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800cc6:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cc9:	0f b6 00             	movzbl (%eax),%eax
+  800ccc:	0f b6 d0             	movzbl %al,%edx
+  800ccf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cd2:	0f b6 00             	movzbl (%eax),%eax
+  800cd5:	0f b6 c0             	movzbl %al,%eax
+  800cd8:	29 c2                	sub    %eax,%edx
+  800cda:	89 d0                	mov    %edx,%eax
+}
+  800cdc:	5d                   	pop    %ebp
+  800cdd:	c3                   	ret    
+
+00800cde <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800cde:	55                   	push   %ebp
+  800cdf:	89 e5                	mov    %esp,%ebp
+  800ce1:	83 ec 04             	sub    $0x4,%esp
+  800ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ce7:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800cea:	eb 14                	jmp    800d00 <strchr+0x22>
+		if (*s == c)
+  800cec:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cef:	0f b6 00             	movzbl (%eax),%eax
+  800cf2:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800cf5:	75 05                	jne    800cfc <strchr+0x1e>
+			return (char *) s;
+  800cf7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cfa:	eb 13                	jmp    800d0f <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800cfc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d00:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d03:	0f b6 00             	movzbl (%eax),%eax
+  800d06:	84 c0                	test   %al,%al
+  800d08:	75 e2                	jne    800cec <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800d0a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800d0f:	c9                   	leave  
+  800d10:	c3                   	ret    
+
+00800d11 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800d11:	55                   	push   %ebp
+  800d12:	89 e5                	mov    %esp,%ebp
+  800d14:	83 ec 04             	sub    $0x4,%esp
+  800d17:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d1a:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800d1d:	eb 11                	jmp    800d30 <strfind+0x1f>
+		if (*s == c)
+  800d1f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d22:	0f b6 00             	movzbl (%eax),%eax
+  800d25:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800d28:	75 02                	jne    800d2c <strfind+0x1b>
+			break;
+  800d2a:	eb 0e                	jmp    800d3a <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800d2c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800d30:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d33:	0f b6 00             	movzbl (%eax),%eax
+  800d36:	84 c0                	test   %al,%al
+  800d38:	75 e5                	jne    800d1f <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800d3a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d3d:	c9                   	leave  
+  800d3e:	c3                   	ret    
+
+00800d3f <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800d3f:	55                   	push   %ebp
+  800d40:	89 e5                	mov    %esp,%ebp
+  800d42:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800d43:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800d47:	75 05                	jne    800d4e <memset+0xf>
+		return v;
+  800d49:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d4c:	eb 5c                	jmp    800daa <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800d4e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d51:	83 e0 03             	and    $0x3,%eax
+  800d54:	85 c0                	test   %eax,%eax
+  800d56:	75 41                	jne    800d99 <memset+0x5a>
+  800d58:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5b:	83 e0 03             	and    $0x3,%eax
+  800d5e:	85 c0                	test   %eax,%eax
+  800d60:	75 37                	jne    800d99 <memset+0x5a>
+		c &= 0xFF;
+  800d62:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800d69:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d6c:	c1 e0 18             	shl    $0x18,%eax
+  800d6f:	89 c2                	mov    %eax,%edx
+  800d71:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d74:	c1 e0 10             	shl    $0x10,%eax
+  800d77:	09 c2                	or     %eax,%edx
+  800d79:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d7c:	c1 e0 08             	shl    $0x8,%eax
+  800d7f:	09 d0                	or     %edx,%eax
+  800d81:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d84:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d87:	c1 e8 02             	shr    $0x2,%eax
+  800d8a:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800d8c:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d92:	89 d7                	mov    %edx,%edi
+  800d94:	fc                   	cld    
+  800d95:	f3 ab                	rep stos %eax,%es:(%edi)
+  800d97:	eb 0e                	jmp    800da7 <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800d99:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d9c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d9f:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800da2:	89 d7                	mov    %edx,%edi
+  800da4:	fc                   	cld    
+  800da5:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800da7:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800daa:	5f                   	pop    %edi
+  800dab:	5d                   	pop    %ebp
+  800dac:	c3                   	ret    
+
+00800dad <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800dad:	55                   	push   %ebp
+  800dae:	89 e5                	mov    %esp,%ebp
+  800db0:	57                   	push   %edi
+  800db1:	56                   	push   %esi
+  800db2:	53                   	push   %ebx
+  800db3:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800db6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800db9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800dbc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800dbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800dc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dc5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dc8:	73 6d                	jae    800e37 <memmove+0x8a>
+  800dca:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dcd:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800dd0:	01 d0                	add    %edx,%eax
+  800dd2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800dd5:	76 60                	jbe    800e37 <memmove+0x8a>
+		s += n;
+  800dd7:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dda:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800ddd:	8b 45 10             	mov    0x10(%ebp),%eax
+  800de0:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800de3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800de6:	83 e0 03             	and    $0x3,%eax
+  800de9:	85 c0                	test   %eax,%eax
+  800deb:	75 2f                	jne    800e1c <memmove+0x6f>
+  800ded:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800df0:	83 e0 03             	and    $0x3,%eax
+  800df3:	85 c0                	test   %eax,%eax
+  800df5:	75 25                	jne    800e1c <memmove+0x6f>
+  800df7:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dfa:	83 e0 03             	and    $0x3,%eax
+  800dfd:	85 c0                	test   %eax,%eax
+  800dff:	75 1b                	jne    800e1c <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800e01:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e04:	83 e8 04             	sub    $0x4,%eax
+  800e07:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e0a:	83 ea 04             	sub    $0x4,%edx
+  800e0d:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e10:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800e13:	89 c7                	mov    %eax,%edi
+  800e15:	89 d6                	mov    %edx,%esi
+  800e17:	fd                   	std    
+  800e18:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e1a:	eb 18                	jmp    800e34 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800e1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e1f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e22:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e25:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800e28:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e2b:	89 d7                	mov    %edx,%edi
+  800e2d:	89 de                	mov    %ebx,%esi
+  800e2f:	89 c1                	mov    %eax,%ecx
+  800e31:	fd                   	std    
+  800e32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800e34:	fc                   	cld    
+  800e35:	eb 45                	jmp    800e7c <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800e3a:	83 e0 03             	and    $0x3,%eax
+  800e3d:	85 c0                	test   %eax,%eax
+  800e3f:	75 2b                	jne    800e6c <memmove+0xbf>
+  800e41:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e44:	83 e0 03             	and    $0x3,%eax
+  800e47:	85 c0                	test   %eax,%eax
+  800e49:	75 21                	jne    800e6c <memmove+0xbf>
+  800e4b:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e4e:	83 e0 03             	and    $0x3,%eax
+  800e51:	85 c0                	test   %eax,%eax
+  800e53:	75 17                	jne    800e6c <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800e55:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e58:	c1 e8 02             	shr    $0x2,%eax
+  800e5b:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800e5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e60:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e63:	89 c7                	mov    %eax,%edi
+  800e65:	89 d6                	mov    %edx,%esi
+  800e67:	fc                   	cld    
+  800e68:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800e6a:	eb 10                	jmp    800e7c <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800e6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800e6f:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800e72:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800e75:	89 c7                	mov    %eax,%edi
+  800e77:	89 d6                	mov    %edx,%esi
+  800e79:	fc                   	cld    
+  800e7a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800e7c:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e7f:	83 c4 10             	add    $0x10,%esp
+  800e82:	5b                   	pop    %ebx
+  800e83:	5e                   	pop    %esi
+  800e84:	5f                   	pop    %edi
+  800e85:	5d                   	pop    %ebp
+  800e86:	c3                   	ret    
+
+00800e87 <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e87:	55                   	push   %ebp
+  800e88:	89 e5                	mov    %esp,%ebp
+  800e8a:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800e8d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e90:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800e94:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800e97:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800e9b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e9e:	89 04 24             	mov    %eax,(%esp)
+  800ea1:	e8 07 ff ff ff       	call   800dad <memmove>
+}
+  800ea6:	c9                   	leave  
+  800ea7:	c3                   	ret    
+
+00800ea8 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800ea8:	55                   	push   %ebp
+  800ea9:	89 e5                	mov    %esp,%ebp
+  800eab:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800eae:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eb1:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800eb7:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800eba:	eb 30                	jmp    800eec <memcmp+0x44>
+		if (*s1 != *s2)
+  800ebc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ebf:	0f b6 10             	movzbl (%eax),%edx
+  800ec2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ec5:	0f b6 00             	movzbl (%eax),%eax
+  800ec8:	38 c2                	cmp    %al,%dl
+  800eca:	74 18                	je     800ee4 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800ecc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800ecf:	0f b6 00             	movzbl (%eax),%eax
+  800ed2:	0f b6 d0             	movzbl %al,%edx
+  800ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800ed8:	0f b6 00             	movzbl (%eax),%eax
+  800edb:	0f b6 c0             	movzbl %al,%eax
+  800ede:	29 c2                	sub    %eax,%edx
+  800ee0:	89 d0                	mov    %edx,%eax
+  800ee2:	eb 1a                	jmp    800efe <memcmp+0x56>
+		s1++, s2++;
+  800ee4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800ee8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800eec:	8b 45 10             	mov    0x10(%ebp),%eax
+  800eef:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800ef2:	89 55 10             	mov    %edx,0x10(%ebp)
+  800ef5:	85 c0                	test   %eax,%eax
+  800ef7:	75 c3                	jne    800ebc <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800ef9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800efe:	c9                   	leave  
+  800eff:	c3                   	ret    
+
+00800f00 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800f00:	55                   	push   %ebp
+  800f01:	89 e5                	mov    %esp,%ebp
+  800f03:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800f06:	8b 45 10             	mov    0x10(%ebp),%eax
+  800f09:	8b 55 08             	mov    0x8(%ebp),%edx
+  800f0c:	01 d0                	add    %edx,%eax
+  800f0e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800f11:	eb 13                	jmp    800f26 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800f13:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f16:	0f b6 10             	movzbl (%eax),%edx
+  800f19:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800f1c:	38 c2                	cmp    %al,%dl
+  800f1e:	75 02                	jne    800f22 <memfind+0x22>
+			break;
+  800f20:	eb 0c                	jmp    800f2e <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800f22:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f26:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f29:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800f2c:	72 e5                	jb     800f13 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800f2e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800f31:	c9                   	leave  
+  800f32:	c3                   	ret    
+
+00800f33 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800f33:	55                   	push   %ebp
+  800f34:	89 e5                	mov    %esp,%ebp
+  800f36:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800f39:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800f40:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f47:	eb 04                	jmp    800f4d <strtol+0x1a>
+		s++;
+  800f49:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800f4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f50:	0f b6 00             	movzbl (%eax),%eax
+  800f53:	3c 20                	cmp    $0x20,%al
+  800f55:	74 f2                	je     800f49 <strtol+0x16>
+  800f57:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f5a:	0f b6 00             	movzbl (%eax),%eax
+  800f5d:	3c 09                	cmp    $0x9,%al
+  800f5f:	74 e8                	je     800f49 <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800f61:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f64:	0f b6 00             	movzbl (%eax),%eax
+  800f67:	3c 2b                	cmp    $0x2b,%al
+  800f69:	75 06                	jne    800f71 <strtol+0x3e>
+		s++;
+  800f6b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f6f:	eb 15                	jmp    800f86 <strtol+0x53>
+	else if (*s == '-')
+  800f71:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f74:	0f b6 00             	movzbl (%eax),%eax
+  800f77:	3c 2d                	cmp    $0x2d,%al
+  800f79:	75 0b                	jne    800f86 <strtol+0x53>
+		s++, neg = 1;
+  800f7b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f7f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f86:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f8a:	74 06                	je     800f92 <strtol+0x5f>
+  800f8c:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800f90:	75 24                	jne    800fb6 <strtol+0x83>
+  800f92:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f95:	0f b6 00             	movzbl (%eax),%eax
+  800f98:	3c 30                	cmp    $0x30,%al
+  800f9a:	75 1a                	jne    800fb6 <strtol+0x83>
+  800f9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f9f:	83 c0 01             	add    $0x1,%eax
+  800fa2:	0f b6 00             	movzbl (%eax),%eax
+  800fa5:	3c 78                	cmp    $0x78,%al
+  800fa7:	75 0d                	jne    800fb6 <strtol+0x83>
+		s += 2, base = 16;
+  800fa9:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800fad:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800fb4:	eb 2a                	jmp    800fe0 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800fb6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fba:	75 17                	jne    800fd3 <strtol+0xa0>
+  800fbc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fbf:	0f b6 00             	movzbl (%eax),%eax
+  800fc2:	3c 30                	cmp    $0x30,%al
+  800fc4:	75 0d                	jne    800fd3 <strtol+0xa0>
+		s++, base = 8;
+  800fc6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fca:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800fd1:	eb 0d                	jmp    800fe0 <strtol+0xad>
+	else if (base == 0)
+  800fd3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800fd7:	75 07                	jne    800fe0 <strtol+0xad>
+		base = 10;
+  800fd9:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800fe0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fe3:	0f b6 00             	movzbl (%eax),%eax
+  800fe6:	3c 2f                	cmp    $0x2f,%al
+  800fe8:	7e 1b                	jle    801005 <strtol+0xd2>
+  800fea:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fed:	0f b6 00             	movzbl (%eax),%eax
+  800ff0:	3c 39                	cmp    $0x39,%al
+  800ff2:	7f 11                	jg     801005 <strtol+0xd2>
+			dig = *s - '0';
+  800ff4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ff7:	0f b6 00             	movzbl (%eax),%eax
+  800ffa:	0f be c0             	movsbl %al,%eax
+  800ffd:	83 e8 30             	sub    $0x30,%eax
+  801000:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801003:	eb 48                	jmp    80104d <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  801005:	8b 45 08             	mov    0x8(%ebp),%eax
+  801008:	0f b6 00             	movzbl (%eax),%eax
+  80100b:	3c 60                	cmp    $0x60,%al
+  80100d:	7e 1b                	jle    80102a <strtol+0xf7>
+  80100f:	8b 45 08             	mov    0x8(%ebp),%eax
+  801012:	0f b6 00             	movzbl (%eax),%eax
+  801015:	3c 7a                	cmp    $0x7a,%al
+  801017:	7f 11                	jg     80102a <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  801019:	8b 45 08             	mov    0x8(%ebp),%eax
+  80101c:	0f b6 00             	movzbl (%eax),%eax
+  80101f:	0f be c0             	movsbl %al,%eax
+  801022:	83 e8 57             	sub    $0x57,%eax
+  801025:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  801028:	eb 23                	jmp    80104d <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  80102a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80102d:	0f b6 00             	movzbl (%eax),%eax
+  801030:	3c 40                	cmp    $0x40,%al
+  801032:	7e 3d                	jle    801071 <strtol+0x13e>
+  801034:	8b 45 08             	mov    0x8(%ebp),%eax
+  801037:	0f b6 00             	movzbl (%eax),%eax
+  80103a:	3c 5a                	cmp    $0x5a,%al
+  80103c:	7f 33                	jg     801071 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  80103e:	8b 45 08             	mov    0x8(%ebp),%eax
+  801041:	0f b6 00             	movzbl (%eax),%eax
+  801044:	0f be c0             	movsbl %al,%eax
+  801047:	83 e8 37             	sub    $0x37,%eax
+  80104a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  80104d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801050:	3b 45 10             	cmp    0x10(%ebp),%eax
+  801053:	7c 02                	jl     801057 <strtol+0x124>
+			break;
+  801055:	eb 1a                	jmp    801071 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  801057:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  80105b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80105e:	0f af 45 10          	imul   0x10(%ebp),%eax
+  801062:	89 c2                	mov    %eax,%edx
+  801064:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  801067:	01 d0                	add    %edx,%eax
+  801069:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  80106c:	e9 6f ff ff ff       	jmp    800fe0 <strtol+0xad>
+
+	if (endptr)
+  801071:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  801075:	74 08                	je     80107f <strtol+0x14c>
+		*endptr = (char *) s;
+  801077:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80107a:	8b 55 08             	mov    0x8(%ebp),%edx
+  80107d:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  80107f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801083:	74 07                	je     80108c <strtol+0x159>
+  801085:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  801088:	f7 d8                	neg    %eax
+  80108a:	eb 03                	jmp    80108f <strtol+0x15c>
+  80108c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  80108f:	c9                   	leave  
+  801090:	c3                   	ret    
+  801091:	66 90                	xchg   %ax,%ax
+  801093:	66 90                	xchg   %ax,%ax
+  801095:	66 90                	xchg   %ax,%ax
+  801097:	66 90                	xchg   %ax,%ax
+  801099:	66 90                	xchg   %ax,%ax
+  80109b:	66 90                	xchg   %ax,%ax
+  80109d:	66 90                	xchg   %ax,%ax
+  80109f:	90                   	nop
+
+008010a0 <__udivdi3>:
+  8010a0:	55                   	push   %ebp
+  8010a1:	57                   	push   %edi
+  8010a2:	56                   	push   %esi
+  8010a3:	83 ec 0c             	sub    $0xc,%esp
+  8010a6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8010aa:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  8010ae:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8010b2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8010b6:	85 c0                	test   %eax,%eax
+  8010b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8010bc:	89 ea                	mov    %ebp,%edx
+  8010be:	89 0c 24             	mov    %ecx,(%esp)
+  8010c1:	75 2d                	jne    8010f0 <__udivdi3+0x50>
+  8010c3:	39 e9                	cmp    %ebp,%ecx
+  8010c5:	77 61                	ja     801128 <__udivdi3+0x88>
+  8010c7:	85 c9                	test   %ecx,%ecx
+  8010c9:	89 ce                	mov    %ecx,%esi
+  8010cb:	75 0b                	jne    8010d8 <__udivdi3+0x38>
+  8010cd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8010d2:	31 d2                	xor    %edx,%edx
+  8010d4:	f7 f1                	div    %ecx
+  8010d6:	89 c6                	mov    %eax,%esi
+  8010d8:	31 d2                	xor    %edx,%edx
+  8010da:	89 e8                	mov    %ebp,%eax
+  8010dc:	f7 f6                	div    %esi
+  8010de:	89 c5                	mov    %eax,%ebp
+  8010e0:	89 f8                	mov    %edi,%eax
+  8010e2:	f7 f6                	div    %esi
+  8010e4:	89 ea                	mov    %ebp,%edx
+  8010e6:	83 c4 0c             	add    $0xc,%esp
+  8010e9:	5e                   	pop    %esi
+  8010ea:	5f                   	pop    %edi
+  8010eb:	5d                   	pop    %ebp
+  8010ec:	c3                   	ret    
+  8010ed:	8d 76 00             	lea    0x0(%esi),%esi
+  8010f0:	39 e8                	cmp    %ebp,%eax
+  8010f2:	77 24                	ja     801118 <__udivdi3+0x78>
+  8010f4:	0f bd e8             	bsr    %eax,%ebp
+  8010f7:	83 f5 1f             	xor    $0x1f,%ebp
+  8010fa:	75 3c                	jne    801138 <__udivdi3+0x98>
+  8010fc:	8b 74 24 04          	mov    0x4(%esp),%esi
+  801100:	39 34 24             	cmp    %esi,(%esp)
+  801103:	0f 86 9f 00 00 00    	jbe    8011a8 <__udivdi3+0x108>
+  801109:	39 d0                	cmp    %edx,%eax
+  80110b:	0f 82 97 00 00 00    	jb     8011a8 <__udivdi3+0x108>
+  801111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801118:	31 d2                	xor    %edx,%edx
+  80111a:	31 c0                	xor    %eax,%eax
+  80111c:	83 c4 0c             	add    $0xc,%esp
+  80111f:	5e                   	pop    %esi
+  801120:	5f                   	pop    %edi
+  801121:	5d                   	pop    %ebp
+  801122:	c3                   	ret    
+  801123:	90                   	nop
+  801124:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801128:	89 f8                	mov    %edi,%eax
+  80112a:	f7 f1                	div    %ecx
+  80112c:	31 d2                	xor    %edx,%edx
+  80112e:	83 c4 0c             	add    $0xc,%esp
+  801131:	5e                   	pop    %esi
+  801132:	5f                   	pop    %edi
+  801133:	5d                   	pop    %ebp
+  801134:	c3                   	ret    
+  801135:	8d 76 00             	lea    0x0(%esi),%esi
+  801138:	89 e9                	mov    %ebp,%ecx
+  80113a:	8b 3c 24             	mov    (%esp),%edi
+  80113d:	d3 e0                	shl    %cl,%eax
+  80113f:	89 c6                	mov    %eax,%esi
+  801141:	b8 20 00 00 00       	mov    $0x20,%eax
+  801146:	29 e8                	sub    %ebp,%eax
+  801148:	89 c1                	mov    %eax,%ecx
+  80114a:	d3 ef                	shr    %cl,%edi
+  80114c:	89 e9                	mov    %ebp,%ecx
+  80114e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801152:	8b 3c 24             	mov    (%esp),%edi
+  801155:	09 74 24 08          	or     %esi,0x8(%esp)
+  801159:	89 d6                	mov    %edx,%esi
+  80115b:	d3 e7                	shl    %cl,%edi
+  80115d:	89 c1                	mov    %eax,%ecx
+  80115f:	89 3c 24             	mov    %edi,(%esp)
+  801162:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801166:	d3 ee                	shr    %cl,%esi
+  801168:	89 e9                	mov    %ebp,%ecx
+  80116a:	d3 e2                	shl    %cl,%edx
+  80116c:	89 c1                	mov    %eax,%ecx
+  80116e:	d3 ef                	shr    %cl,%edi
+  801170:	09 d7                	or     %edx,%edi
+  801172:	89 f2                	mov    %esi,%edx
+  801174:	89 f8                	mov    %edi,%eax
+  801176:	f7 74 24 08          	divl   0x8(%esp)
+  80117a:	89 d6                	mov    %edx,%esi
+  80117c:	89 c7                	mov    %eax,%edi
+  80117e:	f7 24 24             	mull   (%esp)
+  801181:	39 d6                	cmp    %edx,%esi
+  801183:	89 14 24             	mov    %edx,(%esp)
+  801186:	72 30                	jb     8011b8 <__udivdi3+0x118>
+  801188:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80118c:	89 e9                	mov    %ebp,%ecx
+  80118e:	d3 e2                	shl    %cl,%edx
+  801190:	39 c2                	cmp    %eax,%edx
+  801192:	73 05                	jae    801199 <__udivdi3+0xf9>
+  801194:	3b 34 24             	cmp    (%esp),%esi
+  801197:	74 1f                	je     8011b8 <__udivdi3+0x118>
+  801199:	89 f8                	mov    %edi,%eax
+  80119b:	31 d2                	xor    %edx,%edx
+  80119d:	e9 7a ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  8011a8:	31 d2                	xor    %edx,%edx
+  8011aa:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011af:	e9 68 ff ff ff       	jmp    80111c <__udivdi3+0x7c>
+  8011b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8011b8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8011bb:	31 d2                	xor    %edx,%edx
+  8011bd:	83 c4 0c             	add    $0xc,%esp
+  8011c0:	5e                   	pop    %esi
+  8011c1:	5f                   	pop    %edi
+  8011c2:	5d                   	pop    %ebp
+  8011c3:	c3                   	ret    
+  8011c4:	66 90                	xchg   %ax,%ax
+  8011c6:	66 90                	xchg   %ax,%ax
+  8011c8:	66 90                	xchg   %ax,%ax
+  8011ca:	66 90                	xchg   %ax,%ax
+  8011cc:	66 90                	xchg   %ax,%ax
+  8011ce:	66 90                	xchg   %ax,%ax
+
+008011d0 <__umoddi3>:
+  8011d0:	55                   	push   %ebp
+  8011d1:	57                   	push   %edi
+  8011d2:	56                   	push   %esi
+  8011d3:	83 ec 14             	sub    $0x14,%esp
+  8011d6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8011da:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011de:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8011e2:	89 c7                	mov    %eax,%edi
+  8011e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8011e8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8011ec:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8011f0:	89 34 24             	mov    %esi,(%esp)
+  8011f3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8011f7:	85 c0                	test   %eax,%eax
+  8011f9:	89 c2                	mov    %eax,%edx
+  8011fb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8011ff:	75 17                	jne    801218 <__umoddi3+0x48>
+  801201:	39 fe                	cmp    %edi,%esi
+  801203:	76 4b                	jbe    801250 <__umoddi3+0x80>
+  801205:	89 c8                	mov    %ecx,%eax
+  801207:	89 fa                	mov    %edi,%edx
+  801209:	f7 f6                	div    %esi
+  80120b:	89 d0                	mov    %edx,%eax
+  80120d:	31 d2                	xor    %edx,%edx
+  80120f:	83 c4 14             	add    $0x14,%esp
+  801212:	5e                   	pop    %esi
+  801213:	5f                   	pop    %edi
+  801214:	5d                   	pop    %ebp
+  801215:	c3                   	ret    
+  801216:	66 90                	xchg   %ax,%ax
+  801218:	39 f8                	cmp    %edi,%eax
+  80121a:	77 54                	ja     801270 <__umoddi3+0xa0>
+  80121c:	0f bd e8             	bsr    %eax,%ebp
+  80121f:	83 f5 1f             	xor    $0x1f,%ebp
+  801222:	75 5c                	jne    801280 <__umoddi3+0xb0>
+  801224:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801228:	39 3c 24             	cmp    %edi,(%esp)
+  80122b:	0f 87 e7 00 00 00    	ja     801318 <__umoddi3+0x148>
+  801231:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801235:	29 f1                	sub    %esi,%ecx
+  801237:	19 c7                	sbb    %eax,%edi
+  801239:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80123d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801241:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801245:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801249:	83 c4 14             	add    $0x14,%esp
+  80124c:	5e                   	pop    %esi
+  80124d:	5f                   	pop    %edi
+  80124e:	5d                   	pop    %ebp
+  80124f:	c3                   	ret    
+  801250:	85 f6                	test   %esi,%esi
+  801252:	89 f5                	mov    %esi,%ebp
+  801254:	75 0b                	jne    801261 <__umoddi3+0x91>
+  801256:	b8 01 00 00 00       	mov    $0x1,%eax
+  80125b:	31 d2                	xor    %edx,%edx
+  80125d:	f7 f6                	div    %esi
+  80125f:	89 c5                	mov    %eax,%ebp
+  801261:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801265:	31 d2                	xor    %edx,%edx
+  801267:	f7 f5                	div    %ebp
+  801269:	89 c8                	mov    %ecx,%eax
+  80126b:	f7 f5                	div    %ebp
+  80126d:	eb 9c                	jmp    80120b <__umoddi3+0x3b>
+  80126f:	90                   	nop
+  801270:	89 c8                	mov    %ecx,%eax
+  801272:	89 fa                	mov    %edi,%edx
+  801274:	83 c4 14             	add    $0x14,%esp
+  801277:	5e                   	pop    %esi
+  801278:	5f                   	pop    %edi
+  801279:	5d                   	pop    %ebp
+  80127a:	c3                   	ret    
+  80127b:	90                   	nop
+  80127c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801280:	8b 04 24             	mov    (%esp),%eax
+  801283:	be 20 00 00 00       	mov    $0x20,%esi
+  801288:	89 e9                	mov    %ebp,%ecx
+  80128a:	29 ee                	sub    %ebp,%esi
+  80128c:	d3 e2                	shl    %cl,%edx
+  80128e:	89 f1                	mov    %esi,%ecx
+  801290:	d3 e8                	shr    %cl,%eax
+  801292:	89 e9                	mov    %ebp,%ecx
+  801294:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801298:	8b 04 24             	mov    (%esp),%eax
+  80129b:	09 54 24 04          	or     %edx,0x4(%esp)
+  80129f:	89 fa                	mov    %edi,%edx
+  8012a1:	d3 e0                	shl    %cl,%eax
+  8012a3:	89 f1                	mov    %esi,%ecx
+  8012a5:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8012a9:	8b 44 24 10          	mov    0x10(%esp),%eax
+  8012ad:	d3 ea                	shr    %cl,%edx
+  8012af:	89 e9                	mov    %ebp,%ecx
+  8012b1:	d3 e7                	shl    %cl,%edi
+  8012b3:	89 f1                	mov    %esi,%ecx
+  8012b5:	d3 e8                	shr    %cl,%eax
+  8012b7:	89 e9                	mov    %ebp,%ecx
+  8012b9:	09 f8                	or     %edi,%eax
+  8012bb:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8012bf:	f7 74 24 04          	divl   0x4(%esp)
+  8012c3:	d3 e7                	shl    %cl,%edi
+  8012c5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012c9:	89 d7                	mov    %edx,%edi
+  8012cb:	f7 64 24 08          	mull   0x8(%esp)
+  8012cf:	39 d7                	cmp    %edx,%edi
+  8012d1:	89 c1                	mov    %eax,%ecx
+  8012d3:	89 14 24             	mov    %edx,(%esp)
+  8012d6:	72 2c                	jb     801304 <__umoddi3+0x134>
+  8012d8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8012dc:	72 22                	jb     801300 <__umoddi3+0x130>
+  8012de:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8012e2:	29 c8                	sub    %ecx,%eax
+  8012e4:	19 d7                	sbb    %edx,%edi
+  8012e6:	89 e9                	mov    %ebp,%ecx
+  8012e8:	89 fa                	mov    %edi,%edx
+  8012ea:	d3 e8                	shr    %cl,%eax
+  8012ec:	89 f1                	mov    %esi,%ecx
+  8012ee:	d3 e2                	shl    %cl,%edx
+  8012f0:	89 e9                	mov    %ebp,%ecx
+  8012f2:	d3 ef                	shr    %cl,%edi
+  8012f4:	09 d0                	or     %edx,%eax
+  8012f6:	89 fa                	mov    %edi,%edx
+  8012f8:	83 c4 14             	add    $0x14,%esp
+  8012fb:	5e                   	pop    %esi
+  8012fc:	5f                   	pop    %edi
+  8012fd:	5d                   	pop    %ebp
+  8012fe:	c3                   	ret    
+  8012ff:	90                   	nop
+  801300:	39 d7                	cmp    %edx,%edi
+  801302:	75 da                	jne    8012de <__umoddi3+0x10e>
+  801304:	8b 14 24             	mov    (%esp),%edx
+  801307:	89 c1                	mov    %eax,%ecx
+  801309:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  80130d:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801311:	eb cb                	jmp    8012de <__umoddi3+0x10e>
+  801313:	90                   	nop
+  801314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801318:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80131c:	0f 82 0f ff ff ff    	jb     801231 <__umoddi3+0x61>
+  801322:	e9 1a ff ff ff       	jmp    801241 <__umoddi3+0x71>
diff --git a/obj/user/softint.o b/obj/user/softint.o
new file mode 100644
index 0000000..a9e1b9f
Binary files /dev/null and b/obj/user/softint.o differ
diff --git a/obj/user/softint.sym b/obj/user/softint.sym
new file mode 100644
index 0000000..d3e7137
--- /dev/null
+++ b/obj/user/softint.sym
@@ -0,0 +1,54 @@
+00200010 R __STAB_BEGIN__
+00202a10 R __STAB_END__
+00202a11 R __STABSTR_BEGIN__
+002040cd R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080003a T libmain
+00800088 T exit
+0080009c t syscall
+008000fd T sys_cputs
+0080013f T sys_cgetc
+00800183 T sys_env_destroy
+008001c6 T sys_getenvid
+0080020a T _panic
+00800265 t putch
+008002c1 T vcprintf
+00800325 T cprintf
+0080034b t printnum
+00800429 t getuint
+00800478 t getint
+008004bf T vprintfmt
+00800a06 T printfmt
+00800a34 t sprintputch
+00800a69 T vsnprintf
+00800ac9 T snprintf
+00800afd T strlen
+00800b23 T strnlen
+00800b53 T strcpy
+00800b83 T strcat
+00800bb3 T strncpy
+00800bf8 T strlcpy
+00800c49 T strcmp
+00800c88 T strncmp
+00800cde T strchr
+00800d11 T strfind
+00800d3f T memset
+00800dad T memmove
+00800e87 T memcpy
+00800ea8 T memcmp
+00800f00 T memfind
+00800f33 T strtol
+008010a0 T __udivdi3
+008011d0 T __umoddi3
+008013f4 r error_string
+00802000 D binaryname
+00802004 B thisenv
+00802008 B BG_COLOR
+0080200c B COLOR
+00802010 B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/obj/user/testbss b/obj/user/testbss
new file mode 100755
index 0000000..51303fc
Binary files /dev/null and b/obj/user/testbss differ
diff --git a/obj/user/testbss.asm b/obj/user/testbss.asm
new file mode 100644
index 0000000..9fa3ee4
--- /dev/null
+++ b/obj/user/testbss.asm
@@ -0,0 +1,2715 @@
+
+obj/user/testbss:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00800020 <_start>:
+// starts us running when we are initially loaded into a new environment.
+.text
+.globl _start
+_start:
+	// See if we were started with arguments on the stack
+	cmpl $USTACKTOP, %esp
+  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
+	jne args_exist
+  800026:	75 04                	jne    80002c <args_exist>
+
+	// If not, push dummy argc/argv arguments.
+	// This happens when we are loaded by the kernel,
+	// because the kernel does not know about passing arguments.
+	pushl $0
+  800028:	6a 00                	push   $0x0
+	pushl $0
+  80002a:	6a 00                	push   $0x0
+
+0080002c <args_exist>:
+
+args_exist:
+	call libmain
+  80002c:	e8 fa 00 00 00       	call   80012b <libmain>
+1:	jmp 1b
+  800031:	eb fe                	jmp    800031 <args_exist+0x5>
+
+00800033 <umain>:
+
+uint32_t bigarray[ARRAYSIZE];
+
+void
+umain(int argc, char **argv)
+{
+  800033:	55                   	push   %ebp
+  800034:	89 e5                	mov    %esp,%ebp
+  800036:	83 ec 28             	sub    $0x28,%esp
+	int i;
+
+	cprintf("Making sure bss works right...\n");
+  800039:	c7 04 24 18 14 80 00 	movl   $0x801418,(%esp)
+  800040:	e8 63 02 00 00       	call   8002a8 <cprintf>
+	for (i = 0; i < ARRAYSIZE; i++)
+  800045:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  80004c:	eb 35                	jmp    800083 <umain+0x50>
+		if (bigarray[i] != 0)
+  80004e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800051:	8b 04 85 20 20 80 00 	mov    0x802020(,%eax,4),%eax
+  800058:	85 c0                	test   %eax,%eax
+  80005a:	74 23                	je     80007f <umain+0x4c>
+			panic("bigarray[%d] isn't cleared!\n", i);
+  80005c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80005f:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800063:	c7 44 24 08 38 14 80 	movl   $0x801438,0x8(%esp)
+  80006a:	00 
+  80006b:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
+  800072:	00 
+  800073:	c7 04 24 55 14 80 00 	movl   $0x801455,(%esp)
+  80007a:	e8 0e 01 00 00       	call   80018d <_panic>
+umain(int argc, char **argv)
+{
+	int i;
+
+	cprintf("Making sure bss works right...\n");
+	for (i = 0; i < ARRAYSIZE; i++)
+  80007f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  800083:	81 7d f4 ff ff 0f 00 	cmpl   $0xfffff,-0xc(%ebp)
+  80008a:	7e c2                	jle    80004e <umain+0x1b>
+		if (bigarray[i] != 0)
+			panic("bigarray[%d] isn't cleared!\n", i);
+	for (i = 0; i < ARRAYSIZE; i++)
+  80008c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  800093:	eb 11                	jmp    8000a6 <umain+0x73>
+		bigarray[i] = i;
+  800095:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800098:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  80009b:	89 14 85 20 20 80 00 	mov    %edx,0x802020(,%eax,4)
+
+	cprintf("Making sure bss works right...\n");
+	for (i = 0; i < ARRAYSIZE; i++)
+		if (bigarray[i] != 0)
+			panic("bigarray[%d] isn't cleared!\n", i);
+	for (i = 0; i < ARRAYSIZE; i++)
+  8000a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  8000a6:	81 7d f4 ff ff 0f 00 	cmpl   $0xfffff,-0xc(%ebp)
+  8000ad:	7e e6                	jle    800095 <umain+0x62>
+		bigarray[i] = i;
+	for (i = 0; i < ARRAYSIZE; i++)
+  8000af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  8000b6:	eb 38                	jmp    8000f0 <umain+0xbd>
+		if (bigarray[i] != i)
+  8000b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8000bb:	8b 14 85 20 20 80 00 	mov    0x802020(,%eax,4),%edx
+  8000c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8000c5:	39 c2                	cmp    %eax,%edx
+  8000c7:	74 23                	je     8000ec <umain+0xb9>
+			panic("bigarray[%d] didn't hold its value!\n", i);
+  8000c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8000cc:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  8000d0:	c7 44 24 08 64 14 80 	movl   $0x801464,0x8(%esp)
+  8000d7:	00 
+  8000d8:	c7 44 24 04 16 00 00 	movl   $0x16,0x4(%esp)
+  8000df:	00 
+  8000e0:	c7 04 24 55 14 80 00 	movl   $0x801455,(%esp)
+  8000e7:	e8 a1 00 00 00       	call   80018d <_panic>
+	for (i = 0; i < ARRAYSIZE; i++)
+		if (bigarray[i] != 0)
+			panic("bigarray[%d] isn't cleared!\n", i);
+	for (i = 0; i < ARRAYSIZE; i++)
+		bigarray[i] = i;
+	for (i = 0; i < ARRAYSIZE; i++)
+  8000ec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  8000f0:	81 7d f4 ff ff 0f 00 	cmpl   $0xfffff,-0xc(%ebp)
+  8000f7:	7e bf                	jle    8000b8 <umain+0x85>
+		if (bigarray[i] != i)
+			panic("bigarray[%d] didn't hold its value!\n", i);
+
+	cprintf("Yes, good.  Now doing a wild write off the end...\n");
+  8000f9:	c7 04 24 8c 14 80 00 	movl   $0x80148c,(%esp)
+  800100:	e8 a3 01 00 00       	call   8002a8 <cprintf>
+	bigarray[ARRAYSIZE+1024] = 0;
+  800105:	c7 05 20 30 c0 00 00 	movl   $0x0,0xc03020
+  80010c:	00 00 00 
+	panic("SHOULD HAVE TRAPPED!!!");
+  80010f:	c7 44 24 08 bf 14 80 	movl   $0x8014bf,0x8(%esp)
+  800116:	00 
+  800117:	c7 44 24 04 1a 00 00 	movl   $0x1a,0x4(%esp)
+  80011e:	00 
+  80011f:	c7 04 24 55 14 80 00 	movl   $0x801455,(%esp)
+  800126:	e8 62 00 00 00       	call   80018d <_panic>
+
+0080012b <libmain>:
+const volatile struct Env *thisenv;
+const char *binaryname = "<unknown>";
+
+void
+libmain(int argc, char **argv)
+{
+  80012b:	55                   	push   %ebp
+  80012c:	89 e5                	mov    %esp,%ebp
+  80012e:	83 ec 18             	sub    $0x18,%esp
+	// set thisenv to point at our Env structure in envs[].
+	// LAB 3: Your code here.
+        thisenv = envs + ENVX(sys_getenvid());
+  800131:	e8 08 10 00 00       	call   80113e <sys_getenvid>
+  800136:	25 ff 03 00 00       	and    $0x3ff,%eax
+  80013b:	89 c2                	mov    %eax,%edx
+  80013d:	89 d0                	mov    %edx,%eax
+  80013f:	01 c0                	add    %eax,%eax
+  800141:	01 d0                	add    %edx,%eax
+  800143:	c1 e0 05             	shl    $0x5,%eax
+  800146:	05 00 00 c0 ee       	add    $0xeec00000,%eax
+  80014b:	a3 20 20 c0 00       	mov    %eax,0xc02020
+    
+	// save the name of the program so that panic() can use it
+	if (argc > 0)
+  800150:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800154:	7e 0a                	jle    800160 <libmain+0x35>
+		binaryname = argv[0];
+  800156:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800159:	8b 00                	mov    (%eax),%eax
+  80015b:	a3 00 20 80 00       	mov    %eax,0x802000
+
+	// call user main routine
+	umain(argc, argv);
+  800160:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800163:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800167:	8b 45 08             	mov    0x8(%ebp),%eax
+  80016a:	89 04 24             	mov    %eax,(%esp)
+  80016d:	e8 c1 fe ff ff       	call   800033 <umain>
+
+	// exit gracefully
+	exit();
+  800172:	e8 02 00 00 00       	call   800179 <exit>
+}
+  800177:	c9                   	leave  
+  800178:	c3                   	ret    
+
+00800179 <exit>:
+
+#include <inc/lib.h>
+
+void
+exit(void)
+{
+  800179:	55                   	push   %ebp
+  80017a:	89 e5                	mov    %esp,%ebp
+  80017c:	83 ec 18             	sub    $0x18,%esp
+	sys_env_destroy(0);
+  80017f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  800186:	e8 70 0f 00 00       	call   8010fb <sys_env_destroy>
+}
+  80018b:	c9                   	leave  
+  80018c:	c3                   	ret    
+
+0080018d <_panic>:
+ * It prints "panic: <message>", then causes a breakpoint exception,
+ * which causes JOS to enter the JOS kernel monitor.
+ */
+void
+_panic(const char *file, int line, const char *fmt, ...)
+{
+  80018d:	55                   	push   %ebp
+  80018e:	89 e5                	mov    %esp,%ebp
+  800190:	53                   	push   %ebx
+  800191:	83 ec 34             	sub    $0x34,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  800194:	8d 45 14             	lea    0x14(%ebp),%eax
+  800197:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+	// Print the panic message
+	cprintf("[%08x] user panic in %s at %s:%d: ",
+  80019a:	8b 1d 00 20 80 00    	mov    0x802000,%ebx
+  8001a0:	e8 99 0f 00 00       	call   80113e <sys_getenvid>
+  8001a5:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8001a8:	89 54 24 10          	mov    %edx,0x10(%esp)
+  8001ac:	8b 55 08             	mov    0x8(%ebp),%edx
+  8001af:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  8001b3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  8001b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8001bb:	c7 04 24 e0 14 80 00 	movl   $0x8014e0,(%esp)
+  8001c2:	e8 e1 00 00 00       	call   8002a8 <cprintf>
+		sys_getenvid(), binaryname, file, line);
+	vcprintf(fmt, ap);
+  8001c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8001ca:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8001ce:	8b 45 10             	mov    0x10(%ebp),%eax
+  8001d1:	89 04 24             	mov    %eax,(%esp)
+  8001d4:	e8 6b 00 00 00       	call   800244 <vcprintf>
+	cprintf("\n");
+  8001d9:	c7 04 24 03 15 80 00 	movl   $0x801503,(%esp)
+  8001e0:	e8 c3 00 00 00       	call   8002a8 <cprintf>
+
+	// Cause a breakpoint exception
+	while (1)
+		asm volatile("int3");
+  8001e5:	cc                   	int3   
+  8001e6:	eb fd                	jmp    8001e5 <_panic+0x58>
+
+008001e8 <putch>:
+};
+
+
+static void
+putch(int ch, struct printbuf *b)
+{
+  8001e8:	55                   	push   %ebp
+  8001e9:	89 e5                	mov    %esp,%ebp
+  8001eb:	83 ec 18             	sub    $0x18,%esp
+	b->buf[b->idx++] = ch;
+  8001ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8001f1:	8b 00                	mov    (%eax),%eax
+  8001f3:	8d 48 01             	lea    0x1(%eax),%ecx
+  8001f6:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8001f9:	89 0a                	mov    %ecx,(%edx)
+  8001fb:	8b 55 08             	mov    0x8(%ebp),%edx
+  8001fe:	89 d1                	mov    %edx,%ecx
+  800200:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800203:	88 4c 02 08          	mov    %cl,0x8(%edx,%eax,1)
+	if (b->idx == 256-1) {
+  800207:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80020a:	8b 00                	mov    (%eax),%eax
+  80020c:	3d ff 00 00 00       	cmp    $0xff,%eax
+  800211:	75 20                	jne    800233 <putch+0x4b>
+		sys_cputs(b->buf, b->idx);
+  800213:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800216:	8b 00                	mov    (%eax),%eax
+  800218:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80021b:	83 c2 08             	add    $0x8,%edx
+  80021e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800222:	89 14 24             	mov    %edx,(%esp)
+  800225:	e8 4b 0e 00 00       	call   801075 <sys_cputs>
+		b->idx = 0;
+  80022a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80022d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+	}
+	b->cnt++;
+  800233:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800236:	8b 40 04             	mov    0x4(%eax),%eax
+  800239:	8d 50 01             	lea    0x1(%eax),%edx
+  80023c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80023f:	89 50 04             	mov    %edx,0x4(%eax)
+}
+  800242:	c9                   	leave  
+  800243:	c3                   	ret    
+
+00800244 <vcprintf>:
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  800244:	55                   	push   %ebp
+  800245:	89 e5                	mov    %esp,%ebp
+  800247:	81 ec 28 01 00 00    	sub    $0x128,%esp
+	struct printbuf b;
+
+	b.idx = 0;
+  80024d:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
+  800254:	00 00 00 
+	b.cnt = 0;
+  800257:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
+  80025e:	00 00 00 
+	vprintfmt((void*)putch, &b, fmt, ap);
+  800261:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800264:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800268:	8b 45 08             	mov    0x8(%ebp),%eax
+  80026b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80026f:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800275:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800279:	c7 04 24 e8 01 80 00 	movl   $0x8001e8,(%esp)
+  800280:	e8 bd 01 00 00       	call   800442 <vprintfmt>
+	sys_cputs(b.buf, b.idx);
+  800285:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+  80028b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80028f:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
+  800295:	83 c0 08             	add    $0x8,%eax
+  800298:	89 04 24             	mov    %eax,(%esp)
+  80029b:	e8 d5 0d 00 00       	call   801075 <sys_cputs>
+
+	return b.cnt;
+  8002a0:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
+}
+  8002a6:	c9                   	leave  
+  8002a7:	c3                   	ret    
+
+008002a8 <cprintf>:
+
+int
+cprintf(const char *fmt, ...)
+{
+  8002a8:	55                   	push   %ebp
+  8002a9:	89 e5                	mov    %esp,%ebp
+  8002ab:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int cnt;
+
+	va_start(ap, fmt);
+  8002ae:	8d 45 0c             	lea    0xc(%ebp),%eax
+  8002b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	cnt = vcprintf(fmt, ap);
+  8002b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  8002b7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8002bb:	8b 45 08             	mov    0x8(%ebp),%eax
+  8002be:	89 04 24             	mov    %eax,(%esp)
+  8002c1:	e8 7e ff ff ff       	call   800244 <vcprintf>
+  8002c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return cnt;
+  8002c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  8002cc:	c9                   	leave  
+  8002cd:	c3                   	ret    
+
+008002ce <printnum>:
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+  8002ce:	55                   	push   %ebp
+  8002cf:	89 e5                	mov    %esp,%ebp
+  8002d1:	53                   	push   %ebx
+  8002d2:	83 ec 34             	sub    $0x34,%esp
+  8002d5:	8b 45 10             	mov    0x10(%ebp),%eax
+  8002d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8002db:	8b 45 14             	mov    0x14(%ebp),%eax
+  8002de:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+  8002e1:	8b 45 18             	mov    0x18(%ebp),%eax
+  8002e4:	ba 00 00 00 00       	mov    $0x0,%edx
+  8002e9:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8002ec:	77 72                	ja     800360 <printnum+0x92>
+  8002ee:	3b 55 f4             	cmp    -0xc(%ebp),%edx
+  8002f1:	72 05                	jb     8002f8 <printnum+0x2a>
+  8002f3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  8002f6:	77 68                	ja     800360 <printnum+0x92>
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+  8002f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  8002fb:	8d 58 ff             	lea    -0x1(%eax),%ebx
+  8002fe:	8b 45 18             	mov    0x18(%ebp),%eax
+  800301:	ba 00 00 00 00       	mov    $0x0,%edx
+  800306:	89 44 24 08          	mov    %eax,0x8(%esp)
+  80030a:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80030e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800311:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800314:	89 04 24             	mov    %eax,(%esp)
+  800317:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80031b:	e8 70 0e 00 00       	call   801190 <__udivdi3>
+  800320:	8b 4d 20             	mov    0x20(%ebp),%ecx
+  800323:	89 4c 24 18          	mov    %ecx,0x18(%esp)
+  800327:	89 5c 24 14          	mov    %ebx,0x14(%esp)
+  80032b:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  80032e:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  800332:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800336:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80033a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80033d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800341:	8b 45 08             	mov    0x8(%ebp),%eax
+  800344:	89 04 24             	mov    %eax,(%esp)
+  800347:	e8 82 ff ff ff       	call   8002ce <printnum>
+  80034c:	eb 1c                	jmp    80036a <printnum+0x9c>
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+  80034e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800351:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800355:	8b 45 20             	mov    0x20(%ebp),%eax
+  800358:	89 04 24             	mov    %eax,(%esp)
+  80035b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80035e:	ff d0                	call   *%eax
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+  800360:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  800364:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  800368:	7f e4                	jg     80034e <printnum+0x80>
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+  80036a:	8b 4d 18             	mov    0x18(%ebp),%ecx
+  80036d:	bb 00 00 00 00       	mov    $0x0,%ebx
+  800372:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800375:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800378:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80037c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  800380:	89 04 24             	mov    %eax,(%esp)
+  800383:	89 54 24 04          	mov    %edx,0x4(%esp)
+  800387:	e8 34 0f 00 00       	call   8012c0 <__umoddi3>
+  80038c:	05 90 15 80 00       	add    $0x801590,%eax
+  800391:	0f b6 00             	movzbl (%eax),%eax
+  800394:	0f be c0             	movsbl %al,%eax
+  800397:	8b 55 0c             	mov    0xc(%ebp),%edx
+  80039a:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80039e:	89 04 24             	mov    %eax,(%esp)
+  8003a1:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003a4:	ff d0                	call   *%eax
+}
+  8003a6:	83 c4 34             	add    $0x34,%esp
+  8003a9:	5b                   	pop    %ebx
+  8003aa:	5d                   	pop    %ebp
+  8003ab:	c3                   	ret    
+
+008003ac <getuint>:
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+  8003ac:	55                   	push   %ebp
+  8003ad:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  8003af:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  8003b3:	7e 14                	jle    8003c9 <getuint+0x1d>
+		return va_arg(*ap, unsigned long long);
+  8003b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003b8:	8b 00                	mov    (%eax),%eax
+  8003ba:	8d 48 08             	lea    0x8(%eax),%ecx
+  8003bd:	8b 55 08             	mov    0x8(%ebp),%edx
+  8003c0:	89 0a                	mov    %ecx,(%edx)
+  8003c2:	8b 50 04             	mov    0x4(%eax),%edx
+  8003c5:	8b 00                	mov    (%eax),%eax
+  8003c7:	eb 30                	jmp    8003f9 <getuint+0x4d>
+	else if (lflag)
+  8003c9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  8003cd:	74 16                	je     8003e5 <getuint+0x39>
+		return va_arg(*ap, unsigned long);
+  8003cf:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003d2:	8b 00                	mov    (%eax),%eax
+  8003d4:	8d 48 04             	lea    0x4(%eax),%ecx
+  8003d7:	8b 55 08             	mov    0x8(%ebp),%edx
+  8003da:	89 0a                	mov    %ecx,(%edx)
+  8003dc:	8b 00                	mov    (%eax),%eax
+  8003de:	ba 00 00 00 00       	mov    $0x0,%edx
+  8003e3:	eb 14                	jmp    8003f9 <getuint+0x4d>
+	else
+		return va_arg(*ap, unsigned int);
+  8003e5:	8b 45 08             	mov    0x8(%ebp),%eax
+  8003e8:	8b 00                	mov    (%eax),%eax
+  8003ea:	8d 48 04             	lea    0x4(%eax),%ecx
+  8003ed:	8b 55 08             	mov    0x8(%ebp),%edx
+  8003f0:	89 0a                	mov    %ecx,(%edx)
+  8003f2:	8b 00                	mov    (%eax),%eax
+  8003f4:	ba 00 00 00 00       	mov    $0x0,%edx
+}
+  8003f9:	5d                   	pop    %ebp
+  8003fa:	c3                   	ret    
+
+008003fb <getint>:
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+  8003fb:	55                   	push   %ebp
+  8003fc:	89 e5                	mov    %esp,%ebp
+	if (lflag >= 2)
+  8003fe:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  800402:	7e 14                	jle    800418 <getint+0x1d>
+		return va_arg(*ap, long long);
+  800404:	8b 45 08             	mov    0x8(%ebp),%eax
+  800407:	8b 00                	mov    (%eax),%eax
+  800409:	8d 48 08             	lea    0x8(%eax),%ecx
+  80040c:	8b 55 08             	mov    0x8(%ebp),%edx
+  80040f:	89 0a                	mov    %ecx,(%edx)
+  800411:	8b 50 04             	mov    0x4(%eax),%edx
+  800414:	8b 00                	mov    (%eax),%eax
+  800416:	eb 28                	jmp    800440 <getint+0x45>
+	else if (lflag)
+  800418:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  80041c:	74 12                	je     800430 <getint+0x35>
+		return va_arg(*ap, long);
+  80041e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800421:	8b 00                	mov    (%eax),%eax
+  800423:	8d 48 04             	lea    0x4(%eax),%ecx
+  800426:	8b 55 08             	mov    0x8(%ebp),%edx
+  800429:	89 0a                	mov    %ecx,(%edx)
+  80042b:	8b 00                	mov    (%eax),%eax
+  80042d:	99                   	cltd   
+  80042e:	eb 10                	jmp    800440 <getint+0x45>
+	else
+		return va_arg(*ap, int);
+  800430:	8b 45 08             	mov    0x8(%ebp),%eax
+  800433:	8b 00                	mov    (%eax),%eax
+  800435:	8d 48 04             	lea    0x4(%eax),%ecx
+  800438:	8b 55 08             	mov    0x8(%ebp),%edx
+  80043b:	89 0a                	mov    %ecx,(%edx)
+  80043d:	8b 00                	mov    (%eax),%eax
+  80043f:	99                   	cltd   
+}
+  800440:	5d                   	pop    %ebp
+  800441:	c3                   	ret    
+
+00800442 <vprintfmt>:
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+  800442:	55                   	push   %ebp
+  800443:	89 e5                	mov    %esp,%ebp
+  800445:	56                   	push   %esi
+  800446:	53                   	push   %ebx
+  800447:	83 ec 40             	sub    $0x40,%esp
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80044a:	e9 72 01 00 00       	jmp    8005c1 <vprintfmt+0x17f>
+			if (ch == '\0')
+  80044f:	85 db                	test   %ebx,%ebx
+  800451:	75 05                	jne    800458 <vprintfmt+0x16>
+				return;
+  800453:	e9 2a 05 00 00       	jmp    800982 <vprintfmt+0x540>
+			else if(ch == '\033'){
+  800458:	83 fb 1b             	cmp    $0x1b,%ebx
+  80045b:	0f 85 51 01 00 00    	jne    8005b2 <vprintfmt+0x170>
+				if((ch = *(unsigned char *) fmt++) != '[') {
+  800461:	8b 45 10             	mov    0x10(%ebp),%eax
+  800464:	8d 50 01             	lea    0x1(%eax),%edx
+  800467:	89 55 10             	mov    %edx,0x10(%ebp)
+  80046a:	0f b6 00             	movzbl (%eax),%eax
+  80046d:	0f b6 d8             	movzbl %al,%ebx
+  800470:	83 fb 5b             	cmp    $0x5b,%ebx
+  800473:	74 14                	je     800489 <vprintfmt+0x47>
+				    putch(ch, putdat);
+  800475:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800478:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80047c:	89 1c 24             	mov    %ebx,(%esp)
+  80047f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800482:	ff d0                	call   *%eax
+				    continue;
+  800484:	e9 38 01 00 00       	jmp    8005c1 <vprintfmt+0x17f>
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+  800489:	8b 45 10             	mov    0x10(%ebp),%eax
+  80048c:	8d 50 01             	lea    0x1(%eax),%edx
+  80048f:	89 55 10             	mov    %edx,0x10(%ebp)
+  800492:	0f b6 00             	movzbl (%eax),%eax
+  800495:	0f b6 c0             	movzbl %al,%eax
+  800498:	a3 24 20 c0 00       	mov    %eax,0xc02024
+				FG_COLOR = *(unsigned char *) fmt++;
+  80049d:	8b 45 10             	mov    0x10(%ebp),%eax
+  8004a0:	8d 50 01             	lea    0x1(%eax),%edx
+  8004a3:	89 55 10             	mov    %edx,0x10(%ebp)
+  8004a6:	0f b6 00             	movzbl (%eax),%eax
+  8004a9:	0f b6 c0             	movzbl %al,%eax
+  8004ac:	a3 2c 20 c0 00       	mov    %eax,0xc0202c
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+  8004b1:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004b6:	83 f8 2f             	cmp    $0x2f,%eax
+  8004b9:	7e 19                	jle    8004d4 <vprintfmt+0x92>
+  8004bb:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004c0:	83 f8 39             	cmp    $0x39,%eax
+  8004c3:	7f 0f                	jg     8004d4 <vprintfmt+0x92>
+				    BG_COLOR -= '0';
+  8004c5:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004ca:	83 e8 30             	sub    $0x30,%eax
+  8004cd:	a3 24 20 c0 00       	mov    %eax,0xc02024
+  8004d2:	eb 50                	jmp    800524 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+  8004d4:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004d9:	83 f8 60             	cmp    $0x60,%eax
+  8004dc:	7e 19                	jle    8004f7 <vprintfmt+0xb5>
+  8004de:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004e3:	83 f8 66             	cmp    $0x66,%eax
+  8004e6:	7f 0f                	jg     8004f7 <vprintfmt+0xb5>
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+  8004e8:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004ed:	83 e8 57             	sub    $0x57,%eax
+  8004f0:	a3 24 20 c0 00       	mov    %eax,0xc02024
+  8004f5:	eb 2d                	jmp    800524 <vprintfmt+0xe2>
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+  8004f7:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  8004fc:	83 f8 40             	cmp    $0x40,%eax
+  8004ff:	7e 19                	jle    80051a <vprintfmt+0xd8>
+  800501:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  800506:	83 f8 46             	cmp    $0x46,%eax
+  800509:	7f 0f                	jg     80051a <vprintfmt+0xd8>
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+  80050b:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  800510:	83 e8 37             	sub    $0x37,%eax
+  800513:	a3 24 20 c0 00       	mov    %eax,0xc02024
+  800518:	eb 0a                	jmp    800524 <vprintfmt+0xe2>
+				else BG_COLOR = 0;
+  80051a:	c7 05 24 20 c0 00 00 	movl   $0x0,0xc02024
+  800521:	00 00 00 
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+  800524:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  800529:	83 f8 2f             	cmp    $0x2f,%eax
+  80052c:	7e 19                	jle    800547 <vprintfmt+0x105>
+  80052e:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  800533:	83 f8 39             	cmp    $0x39,%eax
+  800536:	7f 0f                	jg     800547 <vprintfmt+0x105>
+				    FG_COLOR -= '0';
+  800538:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  80053d:	83 e8 30             	sub    $0x30,%eax
+  800540:	a3 2c 20 c0 00       	mov    %eax,0xc0202c
+  800545:	eb 50                	jmp    800597 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+  800547:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  80054c:	83 f8 60             	cmp    $0x60,%eax
+  80054f:	7e 19                	jle    80056a <vprintfmt+0x128>
+  800551:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  800556:	83 f8 66             	cmp    $0x66,%eax
+  800559:	7f 0f                	jg     80056a <vprintfmt+0x128>
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+  80055b:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  800560:	83 e8 57             	sub    $0x57,%eax
+  800563:	a3 2c 20 c0 00       	mov    %eax,0xc0202c
+  800568:	eb 2d                	jmp    800597 <vprintfmt+0x155>
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+  80056a:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  80056f:	83 f8 40             	cmp    $0x40,%eax
+  800572:	7e 19                	jle    80058d <vprintfmt+0x14b>
+  800574:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  800579:	83 f8 46             	cmp    $0x46,%eax
+  80057c:	7f 0f                	jg     80058d <vprintfmt+0x14b>
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+  80057e:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  800583:	83 e8 37             	sub    $0x37,%eax
+  800586:	a3 2c 20 c0 00       	mov    %eax,0xc0202c
+  80058b:	eb 0a                	jmp    800597 <vprintfmt+0x155>
+				else BG_COLOR = 7;
+  80058d:	c7 05 24 20 c0 00 07 	movl   $0x7,0xc02024
+  800594:	00 00 00 
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+  800597:	a1 24 20 c0 00       	mov    0xc02024,%eax
+  80059c:	c1 e0 0c             	shl    $0xc,%eax
+  80059f:	89 c2                	mov    %eax,%edx
+  8005a1:	a1 2c 20 c0 00       	mov    0xc0202c,%eax
+  8005a6:	c1 e0 08             	shl    $0x8,%eax
+  8005a9:	09 d0                	or     %edx,%eax
+  8005ab:	a3 28 20 c0 00       	mov    %eax,0xc02028
+				continue;
+  8005b0:	eb 0f                	jmp    8005c1 <vprintfmt+0x17f>
+			}	
+			putch(ch, putdat);
+  8005b2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8005b5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8005b9:	89 1c 24             	mov    %ebx,(%esp)
+  8005bc:	8b 45 08             	mov    0x8(%ebp),%eax
+  8005bf:	ff d0                	call   *%eax
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  8005c1:	8b 45 10             	mov    0x10(%ebp),%eax
+  8005c4:	8d 50 01             	lea    0x1(%eax),%edx
+  8005c7:	89 55 10             	mov    %edx,0x10(%ebp)
+  8005ca:	0f b6 00             	movzbl (%eax),%eax
+  8005cd:	0f b6 d8             	movzbl %al,%ebx
+  8005d0:	83 fb 25             	cmp    $0x25,%ebx
+  8005d3:	0f 85 76 fe ff ff    	jne    80044f <vprintfmt+0xd>
+			}	
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+  8005d9:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+		width = -1;
+  8005dd:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+		precision = -1;
+  8005e4:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+		lflag = 0;
+  8005eb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+		altflag = 0;
+  8005f2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+  8005f9:	8b 45 10             	mov    0x10(%ebp),%eax
+  8005fc:	8d 50 01             	lea    0x1(%eax),%edx
+  8005ff:	89 55 10             	mov    %edx,0x10(%ebp)
+  800602:	0f b6 00             	movzbl (%eax),%eax
+  800605:	0f b6 d8             	movzbl %al,%ebx
+  800608:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  80060b:	83 f8 55             	cmp    $0x55,%eax
+  80060e:	0f 87 3d 03 00 00    	ja     800951 <vprintfmt+0x50f>
+  800614:	8b 04 85 b4 15 80 00 	mov    0x8015b4(,%eax,4),%eax
+  80061b:	ff e0                	jmp    *%eax
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+  80061d:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+			goto reswitch;
+  800621:	eb d6                	jmp    8005f9 <vprintfmt+0x1b7>
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+  800623:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+			goto reswitch;
+  800627:	eb d0                	jmp    8005f9 <vprintfmt+0x1b7>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800629:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+				precision = precision * 10 + ch - '0';
+  800630:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  800633:	89 d0                	mov    %edx,%eax
+  800635:	c1 e0 02             	shl    $0x2,%eax
+  800638:	01 d0                	add    %edx,%eax
+  80063a:	01 c0                	add    %eax,%eax
+  80063c:	01 d8                	add    %ebx,%eax
+  80063e:	83 e8 30             	sub    $0x30,%eax
+  800641:	89 45 e0             	mov    %eax,-0x20(%ebp)
+				ch = *fmt;
+  800644:	8b 45 10             	mov    0x10(%ebp),%eax
+  800647:	0f b6 00             	movzbl (%eax),%eax
+  80064a:	0f be d8             	movsbl %al,%ebx
+				if (ch < '0' || ch > '9')
+  80064d:	83 fb 2f             	cmp    $0x2f,%ebx
+  800650:	7e 0b                	jle    80065d <vprintfmt+0x21b>
+  800652:	83 fb 39             	cmp    $0x39,%ebx
+  800655:	7f 06                	jg     80065d <vprintfmt+0x21b>
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+  800657:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+  80065b:	eb d3                	jmp    800630 <vprintfmt+0x1ee>
+			goto process_precision;
+  80065d:	eb 33                	jmp    800692 <vprintfmt+0x250>
+
+		case '*':
+			precision = va_arg(ap, int);
+  80065f:	8b 45 14             	mov    0x14(%ebp),%eax
+  800662:	8d 50 04             	lea    0x4(%eax),%edx
+  800665:	89 55 14             	mov    %edx,0x14(%ebp)
+  800668:	8b 00                	mov    (%eax),%eax
+  80066a:	89 45 e0             	mov    %eax,-0x20(%ebp)
+			goto process_precision;
+  80066d:	eb 23                	jmp    800692 <vprintfmt+0x250>
+
+		case '.':
+			if (width < 0)
+  80066f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800673:	79 0c                	jns    800681 <vprintfmt+0x23f>
+				width = 0;
+  800675:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+			goto reswitch;
+  80067c:	e9 78 ff ff ff       	jmp    8005f9 <vprintfmt+0x1b7>
+  800681:	e9 73 ff ff ff       	jmp    8005f9 <vprintfmt+0x1b7>
+
+		case '#':
+			altflag = 1;
+  800686:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+			goto reswitch;
+  80068d:	e9 67 ff ff ff       	jmp    8005f9 <vprintfmt+0x1b7>
+
+		process_precision:
+			if (width < 0)
+  800692:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800696:	79 12                	jns    8006aa <vprintfmt+0x268>
+				width = precision, precision = -1;
+  800698:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  80069b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  80069e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
+			goto reswitch;
+  8006a5:	e9 4f ff ff ff       	jmp    8005f9 <vprintfmt+0x1b7>
+  8006aa:	e9 4a ff ff ff       	jmp    8005f9 <vprintfmt+0x1b7>
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+  8006af:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+			goto reswitch;
+  8006b3:	e9 41 ff ff ff       	jmp    8005f9 <vprintfmt+0x1b7>
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+  8006b8:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006bb:	8d 50 04             	lea    0x4(%eax),%edx
+  8006be:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006c1:	8b 00                	mov    (%eax),%eax
+  8006c3:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8006c6:	89 54 24 04          	mov    %edx,0x4(%esp)
+  8006ca:	89 04 24             	mov    %eax,(%esp)
+  8006cd:	8b 45 08             	mov    0x8(%ebp),%eax
+  8006d0:	ff d0                	call   *%eax
+			break;
+  8006d2:	e9 a5 02 00 00       	jmp    80097c <vprintfmt+0x53a>
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+  8006d7:	8b 45 14             	mov    0x14(%ebp),%eax
+  8006da:	8d 50 04             	lea    0x4(%eax),%edx
+  8006dd:	89 55 14             	mov    %edx,0x14(%ebp)
+  8006e0:	8b 18                	mov    (%eax),%ebx
+			if (err < 0)
+  8006e2:	85 db                	test   %ebx,%ebx
+  8006e4:	79 02                	jns    8006e8 <vprintfmt+0x2a6>
+				err = -err;
+  8006e6:	f7 db                	neg    %ebx
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+  8006e8:	83 fb 06             	cmp    $0x6,%ebx
+  8006eb:	7f 0b                	jg     8006f8 <vprintfmt+0x2b6>
+  8006ed:	8b 34 9d 74 15 80 00 	mov    0x801574(,%ebx,4),%esi
+  8006f4:	85 f6                	test   %esi,%esi
+  8006f6:	75 23                	jne    80071b <vprintfmt+0x2d9>
+				printfmt(putch, putdat, "error %d", err);
+  8006f8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  8006fc:	c7 44 24 08 a1 15 80 	movl   $0x8015a1,0x8(%esp)
+  800703:	00 
+  800704:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800707:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80070b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80070e:	89 04 24             	mov    %eax,(%esp)
+  800711:	e8 73 02 00 00       	call   800989 <printfmt>
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+  800716:	e9 61 02 00 00       	jmp    80097c <vprintfmt+0x53a>
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+  80071b:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  80071f:	c7 44 24 08 aa 15 80 	movl   $0x8015aa,0x8(%esp)
+  800726:	00 
+  800727:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80072a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80072e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800731:	89 04 24             	mov    %eax,(%esp)
+  800734:	e8 50 02 00 00       	call   800989 <printfmt>
+			break;
+  800739:	e9 3e 02 00 00       	jmp    80097c <vprintfmt+0x53a>
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+  80073e:	8b 45 14             	mov    0x14(%ebp),%eax
+  800741:	8d 50 04             	lea    0x4(%eax),%edx
+  800744:	89 55 14             	mov    %edx,0x14(%ebp)
+  800747:	8b 30                	mov    (%eax),%esi
+  800749:	85 f6                	test   %esi,%esi
+  80074b:	75 05                	jne    800752 <vprintfmt+0x310>
+				p = "(null)";
+  80074d:	be ad 15 80 00       	mov    $0x8015ad,%esi
+			if (width > 0 && padc != '-')
+  800752:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800756:	7e 37                	jle    80078f <vprintfmt+0x34d>
+  800758:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  80075c:	74 31                	je     80078f <vprintfmt+0x34d>
+				for (width -= strnlen(p, precision); width > 0; width--)
+  80075e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  800761:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800765:	89 34 24             	mov    %esi,(%esp)
+  800768:	e8 39 03 00 00       	call   800aa6 <strnlen>
+  80076d:	29 45 e4             	sub    %eax,-0x1c(%ebp)
+  800770:	eb 17                	jmp    800789 <vprintfmt+0x347>
+					putch(padc, putdat);
+  800772:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  800776:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800779:	89 54 24 04          	mov    %edx,0x4(%esp)
+  80077d:	89 04 24             	mov    %eax,(%esp)
+  800780:	8b 45 08             	mov    0x8(%ebp),%eax
+  800783:	ff d0                	call   *%eax
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+  800785:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800789:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80078d:	7f e3                	jg     800772 <vprintfmt+0x330>
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  80078f:	eb 38                	jmp    8007c9 <vprintfmt+0x387>
+				if (altflag && (ch < ' ' || ch > '~'))
+  800791:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  800795:	74 1f                	je     8007b6 <vprintfmt+0x374>
+  800797:	83 fb 1f             	cmp    $0x1f,%ebx
+  80079a:	7e 05                	jle    8007a1 <vprintfmt+0x35f>
+  80079c:	83 fb 7e             	cmp    $0x7e,%ebx
+  80079f:	7e 15                	jle    8007b6 <vprintfmt+0x374>
+					putch('?', putdat);
+  8007a1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007a8:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  8007af:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007b2:	ff d0                	call   *%eax
+  8007b4:	eb 0f                	jmp    8007c5 <vprintfmt+0x383>
+				else
+					putch(ch, putdat);
+  8007b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007b9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007bd:	89 1c 24             	mov    %ebx,(%esp)
+  8007c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007c3:	ff d0                	call   *%eax
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+  8007c5:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  8007c9:	89 f0                	mov    %esi,%eax
+  8007cb:	8d 70 01             	lea    0x1(%eax),%esi
+  8007ce:	0f b6 00             	movzbl (%eax),%eax
+  8007d1:	0f be d8             	movsbl %al,%ebx
+  8007d4:	85 db                	test   %ebx,%ebx
+  8007d6:	74 10                	je     8007e8 <vprintfmt+0x3a6>
+  8007d8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8007dc:	78 b3                	js     800791 <vprintfmt+0x34f>
+  8007de:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
+  8007e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  8007e6:	79 a9                	jns    800791 <vprintfmt+0x34f>
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8007e8:	eb 17                	jmp    800801 <vprintfmt+0x3bf>
+				putch(' ', putdat);
+  8007ea:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8007ed:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8007f1:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  8007f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  8007fb:	ff d0                	call   *%eax
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+  8007fd:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  800801:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  800805:	7f e3                	jg     8007ea <vprintfmt+0x3a8>
+				putch(' ', putdat);
+			break;
+  800807:	e9 70 01 00 00       	jmp    80097c <vprintfmt+0x53a>
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+  80080c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  80080f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800813:	8d 45 14             	lea    0x14(%ebp),%eax
+  800816:	89 04 24             	mov    %eax,(%esp)
+  800819:	e8 dd fb ff ff       	call   8003fb <getint>
+  80081e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800821:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			if ((long long) num < 0) {
+  800824:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800827:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  80082a:	85 d2                	test   %edx,%edx
+  80082c:	79 26                	jns    800854 <vprintfmt+0x412>
+				putch('-', putdat);
+  80082e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800831:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800835:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  80083c:	8b 45 08             	mov    0x8(%ebp),%eax
+  80083f:	ff d0                	call   *%eax
+				num = -(long long) num;
+  800841:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800844:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800847:	f7 d8                	neg    %eax
+  800849:	83 d2 00             	adc    $0x0,%edx
+  80084c:	f7 da                	neg    %edx
+  80084e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800851:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			}
+			base = 10;
+  800854:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  80085b:	e9 a8 00 00 00       	jmp    800908 <vprintfmt+0x4c6>
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+  800860:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800863:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800867:	8d 45 14             	lea    0x14(%ebp),%eax
+  80086a:	89 04 24             	mov    %eax,(%esp)
+  80086d:	e8 3a fb ff ff       	call   8003ac <getuint>
+  800872:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800875:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 10;
+  800878:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+			goto number;
+  80087f:	e9 84 00 00 00       	jmp    800908 <vprintfmt+0x4c6>
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap,lflag);
+  800884:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  800887:	89 44 24 04          	mov    %eax,0x4(%esp)
+  80088b:	8d 45 14             	lea    0x14(%ebp),%eax
+  80088e:	89 04 24             	mov    %eax,(%esp)
+  800891:	e8 16 fb ff ff       	call   8003ac <getuint>
+  800896:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800899:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 8;
+  80089c:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+			goto number;
+  8008a3:	eb 63                	jmp    800908 <vprintfmt+0x4c6>
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+  8008a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008a8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008ac:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  8008b3:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008b6:	ff d0                	call   *%eax
+			putch('x', putdat);
+  8008b8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8008bb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008bf:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  8008c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  8008c9:	ff d0                	call   *%eax
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+  8008cb:	8b 45 14             	mov    0x14(%ebp),%eax
+  8008ce:	8d 50 04             	lea    0x4(%eax),%edx
+  8008d1:	89 55 14             	mov    %edx,0x14(%ebp)
+  8008d4:	8b 00                	mov    (%eax),%eax
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+  8008d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+  8008e0:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+			goto number;
+  8008e7:	eb 1f                	jmp    800908 <vprintfmt+0x4c6>
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+  8008e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  8008ec:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8008f0:	8d 45 14             	lea    0x14(%ebp),%eax
+  8008f3:	89 04 24             	mov    %eax,(%esp)
+  8008f6:	e8 b1 fa ff ff       	call   8003ac <getuint>
+  8008fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  8008fe:	89 55 f4             	mov    %edx,-0xc(%ebp)
+			base = 16;
+  800901:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+  800908:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  80090c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  80090f:	89 54 24 18          	mov    %edx,0x18(%esp)
+  800913:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  800916:	89 54 24 14          	mov    %edx,0x14(%esp)
+  80091a:	89 44 24 10          	mov    %eax,0x10(%esp)
+  80091e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800921:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  800924:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800928:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80092c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  80092f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800933:	8b 45 08             	mov    0x8(%ebp),%eax
+  800936:	89 04 24             	mov    %eax,(%esp)
+  800939:	e8 90 f9 ff ff       	call   8002ce <printnum>
+			break;
+  80093e:	eb 3c                	jmp    80097c <vprintfmt+0x53a>
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+  800940:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800943:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800947:	89 1c 24             	mov    %ebx,(%esp)
+  80094a:	8b 45 08             	mov    0x8(%ebp),%eax
+  80094d:	ff d0                	call   *%eax
+			break;			
+  80094f:	eb 2b                	jmp    80097c <vprintfmt+0x53a>
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+  800951:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800954:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800958:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  80095f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800962:	ff d0                	call   *%eax
+			for (fmt--; fmt[-1] != '%'; fmt--)
+  800964:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800968:	eb 04                	jmp    80096e <vprintfmt+0x52c>
+  80096a:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  80096e:	8b 45 10             	mov    0x10(%ebp),%eax
+  800971:	83 e8 01             	sub    $0x1,%eax
+  800974:	0f b6 00             	movzbl (%eax),%eax
+  800977:	3c 25                	cmp    $0x25,%al
+  800979:	75 ef                	jne    80096a <vprintfmt+0x528>
+				/* do nothing */;
+			break;
+  80097b:	90                   	nop
+		}
+	}
+  80097c:	90                   	nop
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+  80097d:	e9 3f fc ff ff       	jmp    8005c1 <vprintfmt+0x17f>
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+  800982:	83 c4 40             	add    $0x40,%esp
+  800985:	5b                   	pop    %ebx
+  800986:	5e                   	pop    %esi
+  800987:	5d                   	pop    %ebp
+  800988:	c3                   	ret    
+
+00800989 <printfmt>:
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+  800989:	55                   	push   %ebp
+  80098a:	89 e5                	mov    %esp,%ebp
+  80098c:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+
+	va_start(ap, fmt);
+  80098f:	8d 45 14             	lea    0x14(%ebp),%eax
+  800992:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	vprintfmt(putch, putdat, fmt, ap);
+  800995:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800998:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  80099c:	8b 45 10             	mov    0x10(%ebp),%eax
+  80099f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8009a3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8009aa:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009ad:	89 04 24             	mov    %eax,(%esp)
+  8009b0:	e8 8d fa ff ff       	call   800442 <vprintfmt>
+	va_end(ap);
+}
+  8009b5:	c9                   	leave  
+  8009b6:	c3                   	ret    
+
+008009b7 <sprintputch>:
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+  8009b7:	55                   	push   %ebp
+  8009b8:	89 e5                	mov    %esp,%ebp
+	b->cnt++;
+  8009ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009bd:	8b 40 08             	mov    0x8(%eax),%eax
+  8009c0:	8d 50 01             	lea    0x1(%eax),%edx
+  8009c3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009c6:	89 50 08             	mov    %edx,0x8(%eax)
+	if (b->buf < b->ebuf)
+  8009c9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009cc:	8b 10                	mov    (%eax),%edx
+  8009ce:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009d1:	8b 40 04             	mov    0x4(%eax),%eax
+  8009d4:	39 c2                	cmp    %eax,%edx
+  8009d6:	73 12                	jae    8009ea <sprintputch+0x33>
+		*b->buf++ = ch;
+  8009d8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009db:	8b 00                	mov    (%eax),%eax
+  8009dd:	8d 48 01             	lea    0x1(%eax),%ecx
+  8009e0:	8b 55 0c             	mov    0xc(%ebp),%edx
+  8009e3:	89 0a                	mov    %ecx,(%edx)
+  8009e5:	8b 55 08             	mov    0x8(%ebp),%edx
+  8009e8:	88 10                	mov    %dl,(%eax)
+}
+  8009ea:	5d                   	pop    %ebp
+  8009eb:	c3                   	ret    
+
+008009ec <vsnprintf>:
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+  8009ec:	55                   	push   %ebp
+  8009ed:	89 e5                	mov    %esp,%ebp
+  8009ef:	83 ec 28             	sub    $0x28,%esp
+	struct sprintbuf b = {buf, buf+n-1, 0};
+  8009f2:	8b 45 08             	mov    0x8(%ebp),%eax
+  8009f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  8009f8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  8009fb:	8d 50 ff             	lea    -0x1(%eax),%edx
+  8009fe:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a01:	01 d0                	add    %edx,%eax
+  800a03:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  800a06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+	if (buf == NULL || n < 1)
+  800a0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  800a11:	74 06                	je     800a19 <vsnprintf+0x2d>
+  800a13:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800a17:	7f 07                	jg     800a20 <vsnprintf+0x34>
+		return -E_INVAL;
+  800a19:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  800a1e:	eb 2a                	jmp    800a4a <vsnprintf+0x5e>
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+  800a20:	8b 45 14             	mov    0x14(%ebp),%eax
+  800a23:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a27:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a2a:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a2e:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  800a31:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a35:	c7 04 24 b7 09 80 00 	movl   $0x8009b7,(%esp)
+  800a3c:	e8 01 fa ff ff       	call   800442 <vprintfmt>
+
+	// null terminate the buffer
+	*b.buf = '\0';
+  800a41:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800a44:	c6 00 00             	movb   $0x0,(%eax)
+
+	return b.cnt;
+  800a47:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800a4a:	c9                   	leave  
+  800a4b:	c3                   	ret    
+
+00800a4c <snprintf>:
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+  800a4c:	55                   	push   %ebp
+  800a4d:	89 e5                	mov    %esp,%ebp
+  800a4f:	83 ec 28             	sub    $0x28,%esp
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+  800a52:	8d 45 14             	lea    0x14(%ebp),%eax
+  800a55:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	rc = vsnprintf(buf, n, fmt, ap);
+  800a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800a5b:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  800a5f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800a62:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800a66:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800a69:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800a6d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a70:	89 04 24             	mov    %eax,(%esp)
+  800a73:	e8 74 ff ff ff       	call   8009ec <vsnprintf>
+  800a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	va_end(ap);
+
+	return rc;
+  800a7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  800a7e:	c9                   	leave  
+  800a7f:	c3                   	ret    
+
+00800a80 <strlen>:
+// Primespipe runs 3x faster this way.
+#define ASM 1
+
+int
+strlen(const char *s)
+{
+  800a80:	55                   	push   %ebp
+  800a81:	89 e5                	mov    %esp,%ebp
+  800a83:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800a86:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800a8d:	eb 08                	jmp    800a97 <strlen+0x17>
+		n++;
+  800a8f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strlen(const char *s)
+{
+	int n;
+
+	for (n = 0; *s != '\0'; s++)
+  800a93:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800a97:	8b 45 08             	mov    0x8(%ebp),%eax
+  800a9a:	0f b6 00             	movzbl (%eax),%eax
+  800a9d:	84 c0                	test   %al,%al
+  800a9f:	75 ee                	jne    800a8f <strlen+0xf>
+		n++;
+	return n;
+  800aa1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800aa4:	c9                   	leave  
+  800aa5:	c3                   	ret    
+
+00800aa6 <strnlen>:
+
+int
+strnlen(const char *s, size_t size)
+{
+  800aa6:	55                   	push   %ebp
+  800aa7:	89 e5                	mov    %esp,%ebp
+  800aa9:	83 ec 10             	sub    $0x10,%esp
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800aac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800ab3:	eb 0c                	jmp    800ac1 <strnlen+0x1b>
+		n++;
+  800ab5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+int
+strnlen(const char *s, size_t size)
+{
+	int n;
+
+	for (n = 0; size > 0 && *s != '\0'; s++, size--)
+  800ab9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800abd:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
+  800ac1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800ac5:	74 0a                	je     800ad1 <strnlen+0x2b>
+  800ac7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800aca:	0f b6 00             	movzbl (%eax),%eax
+  800acd:	84 c0                	test   %al,%al
+  800acf:	75 e4                	jne    800ab5 <strnlen+0xf>
+		n++;
+	return n;
+  800ad1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800ad4:	c9                   	leave  
+  800ad5:	c3                   	ret    
+
+00800ad6 <strcpy>:
+
+char *
+strcpy(char *dst, const char *src)
+{
+  800ad6:	55                   	push   %ebp
+  800ad7:	89 e5                	mov    %esp,%ebp
+  800ad9:	83 ec 10             	sub    $0x10,%esp
+	char *ret;
+
+	ret = dst;
+  800adc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800adf:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	while ((*dst++ = *src++) != '\0')
+  800ae2:	90                   	nop
+  800ae3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ae6:	8d 50 01             	lea    0x1(%eax),%edx
+  800ae9:	89 55 08             	mov    %edx,0x8(%ebp)
+  800aec:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800aef:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800af2:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800af5:	0f b6 12             	movzbl (%edx),%edx
+  800af8:	88 10                	mov    %dl,(%eax)
+  800afa:	0f b6 00             	movzbl (%eax),%eax
+  800afd:	84 c0                	test   %al,%al
+  800aff:	75 e2                	jne    800ae3 <strcpy+0xd>
+		/* do nothing */;
+	return ret;
+  800b01:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  800b04:	c9                   	leave  
+  800b05:	c3                   	ret    
+
+00800b06 <strcat>:
+
+char *
+strcat(char *dst, const char *src)
+{
+  800b06:	55                   	push   %ebp
+  800b07:	89 e5                	mov    %esp,%ebp
+  800b09:	83 ec 18             	sub    $0x18,%esp
+	int len = strlen(dst);
+  800b0c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b0f:	89 04 24             	mov    %eax,(%esp)
+  800b12:	e8 69 ff ff ff       	call   800a80 <strlen>
+  800b17:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	strcpy(dst + len, src);
+  800b1a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  800b1d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b20:	01 c2                	add    %eax,%edx
+  800b22:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b25:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800b29:	89 14 24             	mov    %edx,(%esp)
+  800b2c:	e8 a5 ff ff ff       	call   800ad6 <strcpy>
+	return dst;
+  800b31:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800b34:	c9                   	leave  
+  800b35:	c3                   	ret    
+
+00800b36 <strncpy>:
+
+char *
+strncpy(char *dst, const char *src, size_t size) {
+  800b36:	55                   	push   %ebp
+  800b37:	89 e5                	mov    %esp,%ebp
+  800b39:	83 ec 10             	sub    $0x10,%esp
+	size_t i;
+	char *ret;
+
+	ret = dst;
+  800b3c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b3f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+	for (i = 0; i < size; i++) {
+  800b42:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  800b49:	eb 23                	jmp    800b6e <strncpy+0x38>
+		*dst++ = *src;
+  800b4b:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b4e:	8d 50 01             	lea    0x1(%eax),%edx
+  800b51:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b54:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b57:	0f b6 12             	movzbl (%edx),%edx
+  800b5a:	88 10                	mov    %dl,(%eax)
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+  800b5c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800b5f:	0f b6 00             	movzbl (%eax),%eax
+  800b62:	84 c0                	test   %al,%al
+  800b64:	74 04                	je     800b6a <strncpy+0x34>
+			src++;
+  800b66:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+strncpy(char *dst, const char *src, size_t size) {
+	size_t i;
+	char *ret;
+
+	ret = dst;
+	for (i = 0; i < size; i++) {
+  800b6a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800b6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800b71:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800b74:	72 d5                	jb     800b4b <strncpy+0x15>
+		*dst++ = *src;
+		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
+		if (*src != '\0')
+			src++;
+	}
+	return ret;
+  800b76:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  800b79:	c9                   	leave  
+  800b7a:	c3                   	ret    
+
+00800b7b <strlcpy>:
+
+size_t
+strlcpy(char *dst, const char *src, size_t size)
+{
+  800b7b:	55                   	push   %ebp
+  800b7c:	89 e5                	mov    %esp,%ebp
+  800b7e:	83 ec 10             	sub    $0x10,%esp
+	char *dst_in;
+
+	dst_in = dst;
+  800b81:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b84:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	if (size > 0) {
+  800b87:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800b8b:	74 33                	je     800bc0 <strlcpy+0x45>
+		while (--size > 0 && *src != '\0')
+  800b8d:	eb 17                	jmp    800ba6 <strlcpy+0x2b>
+			*dst++ = *src++;
+  800b8f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800b92:	8d 50 01             	lea    0x1(%eax),%edx
+  800b95:	89 55 08             	mov    %edx,0x8(%ebp)
+  800b98:	8b 55 0c             	mov    0xc(%ebp),%edx
+  800b9b:	8d 4a 01             	lea    0x1(%edx),%ecx
+  800b9e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
+  800ba1:	0f b6 12             	movzbl (%edx),%edx
+  800ba4:	88 10                	mov    %dl,(%eax)
+{
+	char *dst_in;
+
+	dst_in = dst;
+	if (size > 0) {
+		while (--size > 0 && *src != '\0')
+  800ba6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800baa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800bae:	74 0a                	je     800bba <strlcpy+0x3f>
+  800bb0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bb3:	0f b6 00             	movzbl (%eax),%eax
+  800bb6:	84 c0                	test   %al,%al
+  800bb8:	75 d5                	jne    800b8f <strlcpy+0x14>
+			*dst++ = *src++;
+		*dst = '\0';
+  800bba:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bbd:	c6 00 00             	movb   $0x0,(%eax)
+	}
+	return dst - dst_in;
+  800bc0:	8b 55 08             	mov    0x8(%ebp),%edx
+  800bc3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800bc6:	29 c2                	sub    %eax,%edx
+  800bc8:	89 d0                	mov    %edx,%eax
+}
+  800bca:	c9                   	leave  
+  800bcb:	c3                   	ret    
+
+00800bcc <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  800bcc:	55                   	push   %ebp
+  800bcd:	89 e5                	mov    %esp,%ebp
+	while (*p && *p == *q)
+  800bcf:	eb 08                	jmp    800bd9 <strcmp+0xd>
+		p++, q++;
+  800bd1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800bd5:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+	while (*p && *p == *q)
+  800bd9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bdc:	0f b6 00             	movzbl (%eax),%eax
+  800bdf:	84 c0                	test   %al,%al
+  800be1:	74 10                	je     800bf3 <strcmp+0x27>
+  800be3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800be6:	0f b6 10             	movzbl (%eax),%edx
+  800be9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bec:	0f b6 00             	movzbl (%eax),%eax
+  800bef:	38 c2                	cmp    %al,%dl
+  800bf1:	74 de                	je     800bd1 <strcmp+0x5>
+		p++, q++;
+	return (int) ((unsigned char) *p - (unsigned char) *q);
+  800bf3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800bf6:	0f b6 00             	movzbl (%eax),%eax
+  800bf9:	0f b6 d0             	movzbl %al,%edx
+  800bfc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800bff:	0f b6 00             	movzbl (%eax),%eax
+  800c02:	0f b6 c0             	movzbl %al,%eax
+  800c05:	29 c2                	sub    %eax,%edx
+  800c07:	89 d0                	mov    %edx,%eax
+}
+  800c09:	5d                   	pop    %ebp
+  800c0a:	c3                   	ret    
+
+00800c0b <strncmp>:
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+  800c0b:	55                   	push   %ebp
+  800c0c:	89 e5                	mov    %esp,%ebp
+	while (n > 0 && *p && *p == *q)
+  800c0e:	eb 0c                	jmp    800c1c <strncmp+0x11>
+		n--, p++, q++;
+  800c10:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  800c14:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c18:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+}
+
+int
+strncmp(const char *p, const char *q, size_t n)
+{
+	while (n > 0 && *p && *p == *q)
+  800c1c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c20:	74 1a                	je     800c3c <strncmp+0x31>
+  800c22:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c25:	0f b6 00             	movzbl (%eax),%eax
+  800c28:	84 c0                	test   %al,%al
+  800c2a:	74 10                	je     800c3c <strncmp+0x31>
+  800c2c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c2f:	0f b6 10             	movzbl (%eax),%edx
+  800c32:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c35:	0f b6 00             	movzbl (%eax),%eax
+  800c38:	38 c2                	cmp    %al,%dl
+  800c3a:	74 d4                	je     800c10 <strncmp+0x5>
+		n--, p++, q++;
+	if (n == 0)
+  800c3c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800c40:	75 07                	jne    800c49 <strncmp+0x3e>
+		return 0;
+  800c42:	b8 00 00 00 00       	mov    $0x0,%eax
+  800c47:	eb 16                	jmp    800c5f <strncmp+0x54>
+	else
+		return (int) ((unsigned char) *p - (unsigned char) *q);
+  800c49:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c4c:	0f b6 00             	movzbl (%eax),%eax
+  800c4f:	0f b6 d0             	movzbl %al,%edx
+  800c52:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c55:	0f b6 00             	movzbl (%eax),%eax
+  800c58:	0f b6 c0             	movzbl %al,%eax
+  800c5b:	29 c2                	sub    %eax,%edx
+  800c5d:	89 d0                	mov    %edx,%eax
+}
+  800c5f:	5d                   	pop    %ebp
+  800c60:	c3                   	ret    
+
+00800c61 <strchr>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+  800c61:	55                   	push   %ebp
+  800c62:	89 e5                	mov    %esp,%ebp
+  800c64:	83 ec 04             	sub    $0x4,%esp
+  800c67:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c6a:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800c6d:	eb 14                	jmp    800c83 <strchr+0x22>
+		if (*s == c)
+  800c6f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c72:	0f b6 00             	movzbl (%eax),%eax
+  800c75:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800c78:	75 05                	jne    800c7f <strchr+0x1e>
+			return (char *) s;
+  800c7a:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c7d:	eb 13                	jmp    800c92 <strchr+0x31>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a null pointer if the string has no 'c'.
+char *
+strchr(const char *s, char c)
+{
+	for (; *s; s++)
+  800c7f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800c83:	8b 45 08             	mov    0x8(%ebp),%eax
+  800c86:	0f b6 00             	movzbl (%eax),%eax
+  800c89:	84 c0                	test   %al,%al
+  800c8b:	75 e2                	jne    800c6f <strchr+0xe>
+		if (*s == c)
+			return (char *) s;
+	return 0;
+  800c8d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800c92:	c9                   	leave  
+  800c93:	c3                   	ret    
+
+00800c94 <strfind>:
+
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+  800c94:	55                   	push   %ebp
+  800c95:	89 e5                	mov    %esp,%ebp
+  800c97:	83 ec 04             	sub    $0x4,%esp
+  800c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800c9d:	88 45 fc             	mov    %al,-0x4(%ebp)
+	for (; *s; s++)
+  800ca0:	eb 11                	jmp    800cb3 <strfind+0x1f>
+		if (*s == c)
+  800ca2:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ca5:	0f b6 00             	movzbl (%eax),%eax
+  800ca8:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  800cab:	75 02                	jne    800caf <strfind+0x1b>
+			break;
+  800cad:	eb 0e                	jmp    800cbd <strfind+0x29>
+// Return a pointer to the first occurrence of 'c' in 's',
+// or a pointer to the string-ending null character if the string has no 'c'.
+char *
+strfind(const char *s, char c)
+{
+	for (; *s; s++)
+  800caf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800cb3:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cb6:	0f b6 00             	movzbl (%eax),%eax
+  800cb9:	84 c0                	test   %al,%al
+  800cbb:	75 e5                	jne    800ca2 <strfind+0xe>
+		if (*s == c)
+			break;
+	return (char *) s;
+  800cbd:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800cc0:	c9                   	leave  
+  800cc1:	c3                   	ret    
+
+00800cc2 <memset>:
+
+#if ASM
+void *
+memset(void *v, int c, size_t n)
+{
+  800cc2:	55                   	push   %ebp
+  800cc3:	89 e5                	mov    %esp,%ebp
+  800cc5:	57                   	push   %edi
+	char *p;
+
+	if (n == 0)
+  800cc6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800cca:	75 05                	jne    800cd1 <memset+0xf>
+		return v;
+  800ccc:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ccf:	eb 5c                	jmp    800d2d <memset+0x6b>
+	if ((int)v%4 == 0 && n%4 == 0) {
+  800cd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800cd4:	83 e0 03             	and    $0x3,%eax
+  800cd7:	85 c0                	test   %eax,%eax
+  800cd9:	75 41                	jne    800d1c <memset+0x5a>
+  800cdb:	8b 45 10             	mov    0x10(%ebp),%eax
+  800cde:	83 e0 03             	and    $0x3,%eax
+  800ce1:	85 c0                	test   %eax,%eax
+  800ce3:	75 37                	jne    800d1c <memset+0x5a>
+		c &= 0xFF;
+  800ce5:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+  800cec:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cef:	c1 e0 18             	shl    $0x18,%eax
+  800cf2:	89 c2                	mov    %eax,%edx
+  800cf4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cf7:	c1 e0 10             	shl    $0x10,%eax
+  800cfa:	09 c2                	or     %eax,%edx
+  800cfc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800cff:	c1 e0 08             	shl    $0x8,%eax
+  800d02:	09 d0                	or     %edx,%eax
+  800d04:	09 45 0c             	or     %eax,0xc(%ebp)
+		asm volatile("cld; rep stosl\n"
+			:: "D" (v), "a" (c), "c" (n/4)
+  800d07:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d0a:	c1 e8 02             	shr    $0x2,%eax
+  800d0d:	89 c1                	mov    %eax,%ecx
+	if (n == 0)
+		return v;
+	if ((int)v%4 == 0 && n%4 == 0) {
+		c &= 0xFF;
+		c = (c<<24)|(c<<16)|(c<<8)|c;
+		asm volatile("cld; rep stosl\n"
+  800d0f:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d12:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d15:	89 d7                	mov    %edx,%edi
+  800d17:	fc                   	cld    
+  800d18:	f3 ab                	rep stos %eax,%es:(%edi)
+  800d1a:	eb 0e                	jmp    800d2a <memset+0x68>
+			:: "D" (v), "a" (c), "c" (n/4)
+			: "cc", "memory");
+	} else
+		asm volatile("cld; rep stosb\n"
+  800d1c:	8b 55 08             	mov    0x8(%ebp),%edx
+  800d1f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d22:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800d25:	89 d7                	mov    %edx,%edi
+  800d27:	fc                   	cld    
+  800d28:	f3 aa                	rep stos %al,%es:(%edi)
+			:: "D" (v), "a" (c), "c" (n)
+			: "cc", "memory");
+	return v;
+  800d2a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800d2d:	5f                   	pop    %edi
+  800d2e:	5d                   	pop    %ebp
+  800d2f:	c3                   	ret    
+
+00800d30 <memmove>:
+
+void *
+memmove(void *dst, const void *src, size_t n)
+{
+  800d30:	55                   	push   %ebp
+  800d31:	89 e5                	mov    %esp,%ebp
+  800d33:	57                   	push   %edi
+  800d34:	56                   	push   %esi
+  800d35:	53                   	push   %ebx
+  800d36:	83 ec 10             	sub    $0x10,%esp
+	const char *s;
+	char *d;
+
+	s = src;
+  800d39:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800d3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	d = dst;
+  800d3f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800d42:	89 45 ec             	mov    %eax,-0x14(%ebp)
+	if (s < d && s + n > d) {
+  800d45:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800d48:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800d4b:	73 6d                	jae    800dba <memmove+0x8a>
+  800d4d:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d50:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800d53:	01 d0                	add    %edx,%eax
+  800d55:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  800d58:	76 60                	jbe    800dba <memmove+0x8a>
+		s += n;
+  800d5a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d5d:	01 45 f0             	add    %eax,-0x10(%ebp)
+		d += n;
+  800d60:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d63:	01 45 ec             	add    %eax,-0x14(%ebp)
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800d66:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800d69:	83 e0 03             	and    $0x3,%eax
+  800d6c:	85 c0                	test   %eax,%eax
+  800d6e:	75 2f                	jne    800d9f <memmove+0x6f>
+  800d70:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d73:	83 e0 03             	and    $0x3,%eax
+  800d76:	85 c0                	test   %eax,%eax
+  800d78:	75 25                	jne    800d9f <memmove+0x6f>
+  800d7a:	8b 45 10             	mov    0x10(%ebp),%eax
+  800d7d:	83 e0 03             	and    $0x3,%eax
+  800d80:	85 c0                	test   %eax,%eax
+  800d82:	75 1b                	jne    800d9f <memmove+0x6f>
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+  800d84:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800d87:	83 e8 04             	sub    $0x4,%eax
+  800d8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800d8d:	83 ea 04             	sub    $0x4,%edx
+  800d90:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800d93:	c1 e9 02             	shr    $0x2,%ecx
+	d = dst;
+	if (s < d && s + n > d) {
+		s += n;
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+  800d96:	89 c7                	mov    %eax,%edi
+  800d98:	89 d6                	mov    %edx,%esi
+  800d9a:	fd                   	std    
+  800d9b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800d9d:	eb 18                	jmp    800db7 <memmove+0x87>
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+  800d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800da2:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800da5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800da8:	8d 58 ff             	lea    -0x1(%eax),%ebx
+		d += n;
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("std; rep movsl\n"
+				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("std; rep movsb\n"
+  800dab:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dae:	89 d7                	mov    %edx,%edi
+  800db0:	89 de                	mov    %ebx,%esi
+  800db2:	89 c1                	mov    %eax,%ecx
+  800db4:	fd                   	std    
+  800db5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+  800db7:	fc                   	cld    
+  800db8:	eb 45                	jmp    800dff <memmove+0xcf>
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+  800dba:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  800dbd:	83 e0 03             	and    $0x3,%eax
+  800dc0:	85 c0                	test   %eax,%eax
+  800dc2:	75 2b                	jne    800def <memmove+0xbf>
+  800dc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800dc7:	83 e0 03             	and    $0x3,%eax
+  800dca:	85 c0                	test   %eax,%eax
+  800dcc:	75 21                	jne    800def <memmove+0xbf>
+  800dce:	8b 45 10             	mov    0x10(%ebp),%eax
+  800dd1:	83 e0 03             	and    $0x3,%eax
+  800dd4:	85 c0                	test   %eax,%eax
+  800dd6:	75 17                	jne    800def <memmove+0xbf>
+			asm volatile("cld; rep movsl\n"
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+  800dd8:	8b 45 10             	mov    0x10(%ebp),%eax
+  800ddb:	c1 e8 02             	shr    $0x2,%eax
+  800dde:	89 c1                	mov    %eax,%ecx
+				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
+		// Some versions of GCC rely on DF being clear
+		asm volatile("cld" ::: "cc");
+	} else {
+		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
+			asm volatile("cld; rep movsl\n"
+  800de0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800de3:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800de6:	89 c7                	mov    %eax,%edi
+  800de8:	89 d6                	mov    %edx,%esi
+  800dea:	fc                   	cld    
+  800deb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  800ded:	eb 10                	jmp    800dff <memmove+0xcf>
+				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
+		else
+			asm volatile("cld; rep movsb\n"
+  800def:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  800df2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  800df5:	8b 4d 10             	mov    0x10(%ebp),%ecx
+  800df8:	89 c7                	mov    %eax,%edi
+  800dfa:	89 d6                	mov    %edx,%esi
+  800dfc:	fc                   	cld    
+  800dfd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
+	}
+	return dst;
+  800dff:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800e02:	83 c4 10             	add    $0x10,%esp
+  800e05:	5b                   	pop    %ebx
+  800e06:	5e                   	pop    %esi
+  800e07:	5f                   	pop    %edi
+  800e08:	5d                   	pop    %ebp
+  800e09:	c3                   	ret    
+
+00800e0a <memcpy>:
+}
+#endif
+
+void *
+memcpy(void *dst, const void *src, size_t n)
+{
+  800e0a:	55                   	push   %ebp
+  800e0b:	89 e5                	mov    %esp,%ebp
+  800e0d:	83 ec 0c             	sub    $0xc,%esp
+	return memmove(dst, src, n);
+  800e10:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e13:	89 44 24 08          	mov    %eax,0x8(%esp)
+  800e17:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800e1a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  800e1e:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e21:	89 04 24             	mov    %eax,(%esp)
+  800e24:	e8 07 ff ff ff       	call   800d30 <memmove>
+}
+  800e29:	c9                   	leave  
+  800e2a:	c3                   	ret    
+
+00800e2b <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, size_t n)
+{
+  800e2b:	55                   	push   %ebp
+  800e2c:	89 e5                	mov    %esp,%ebp
+  800e2e:	83 ec 10             	sub    $0x10,%esp
+	const uint8_t *s1 = (const uint8_t *) v1;
+  800e31:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e34:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	const uint8_t *s2 = (const uint8_t *) v2;
+  800e37:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800e3a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+
+	while (n-- > 0) {
+  800e3d:	eb 30                	jmp    800e6f <memcmp+0x44>
+		if (*s1 != *s2)
+  800e3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800e42:	0f b6 10             	movzbl (%eax),%edx
+  800e45:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800e48:	0f b6 00             	movzbl (%eax),%eax
+  800e4b:	38 c2                	cmp    %al,%dl
+  800e4d:	74 18                	je     800e67 <memcmp+0x3c>
+			return (int) *s1 - (int) *s2;
+  800e4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  800e52:	0f b6 00             	movzbl (%eax),%eax
+  800e55:	0f b6 d0             	movzbl %al,%edx
+  800e58:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800e5b:	0f b6 00             	movzbl (%eax),%eax
+  800e5e:	0f b6 c0             	movzbl %al,%eax
+  800e61:	29 c2                	sub    %eax,%edx
+  800e63:	89 d0                	mov    %edx,%eax
+  800e65:	eb 1a                	jmp    800e81 <memcmp+0x56>
+		s1++, s2++;
+  800e67:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  800e6b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+memcmp(const void *v1, const void *v2, size_t n)
+{
+	const uint8_t *s1 = (const uint8_t *) v1;
+	const uint8_t *s2 = (const uint8_t *) v2;
+
+	while (n-- > 0) {
+  800e6f:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e72:	8d 50 ff             	lea    -0x1(%eax),%edx
+  800e75:	89 55 10             	mov    %edx,0x10(%ebp)
+  800e78:	85 c0                	test   %eax,%eax
+  800e7a:	75 c3                	jne    800e3f <memcmp+0x14>
+		if (*s1 != *s2)
+			return (int) *s1 - (int) *s2;
+		s1++, s2++;
+	}
+
+	return 0;
+  800e7c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  800e81:	c9                   	leave  
+  800e82:	c3                   	ret    
+
+00800e83 <memfind>:
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+  800e83:	55                   	push   %ebp
+  800e84:	89 e5                	mov    %esp,%ebp
+  800e86:	83 ec 10             	sub    $0x10,%esp
+	const void *ends = (const char *) s + n;
+  800e89:	8b 45 10             	mov    0x10(%ebp),%eax
+  800e8c:	8b 55 08             	mov    0x8(%ebp),%edx
+  800e8f:	01 d0                	add    %edx,%eax
+  800e91:	89 45 fc             	mov    %eax,-0x4(%ebp)
+	for (; s < ends; s++)
+  800e94:	eb 13                	jmp    800ea9 <memfind+0x26>
+		if (*(const unsigned char *) s == (unsigned char) c)
+  800e96:	8b 45 08             	mov    0x8(%ebp),%eax
+  800e99:	0f b6 10             	movzbl (%eax),%edx
+  800e9c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800e9f:	38 c2                	cmp    %al,%dl
+  800ea1:	75 02                	jne    800ea5 <memfind+0x22>
+			break;
+  800ea3:	eb 0c                	jmp    800eb1 <memfind+0x2e>
+
+void *
+memfind(const void *s, int c, size_t n)
+{
+	const void *ends = (const char *) s + n;
+	for (; s < ends; s++)
+  800ea5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ea9:	8b 45 08             	mov    0x8(%ebp),%eax
+  800eac:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  800eaf:	72 e5                	jb     800e96 <memfind+0x13>
+		if (*(const unsigned char *) s == (unsigned char) c)
+			break;
+	return (void *) s;
+  800eb1:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  800eb4:	c9                   	leave  
+  800eb5:	c3                   	ret    
+
+00800eb6 <strtol>:
+
+long
+strtol(const char *s, char **endptr, int base)
+{
+  800eb6:	55                   	push   %ebp
+  800eb7:	89 e5                	mov    %esp,%ebp
+  800eb9:	83 ec 10             	sub    $0x10,%esp
+	int neg = 0;
+  800ebc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	long val = 0;
+  800ec3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800eca:	eb 04                	jmp    800ed0 <strtol+0x1a>
+		s++;
+  800ecc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+{
+	int neg = 0;
+	long val = 0;
+
+	// gobble initial whitespace
+	while (*s == ' ' || *s == '\t')
+  800ed0:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ed3:	0f b6 00             	movzbl (%eax),%eax
+  800ed6:	3c 20                	cmp    $0x20,%al
+  800ed8:	74 f2                	je     800ecc <strtol+0x16>
+  800eda:	8b 45 08             	mov    0x8(%ebp),%eax
+  800edd:	0f b6 00             	movzbl (%eax),%eax
+  800ee0:	3c 09                	cmp    $0x9,%al
+  800ee2:	74 e8                	je     800ecc <strtol+0x16>
+		s++;
+
+	// plus/minus sign
+	if (*s == '+')
+  800ee4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ee7:	0f b6 00             	movzbl (%eax),%eax
+  800eea:	3c 2b                	cmp    $0x2b,%al
+  800eec:	75 06                	jne    800ef4 <strtol+0x3e>
+		s++;
+  800eee:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800ef2:	eb 15                	jmp    800f09 <strtol+0x53>
+	else if (*s == '-')
+  800ef4:	8b 45 08             	mov    0x8(%ebp),%eax
+  800ef7:	0f b6 00             	movzbl (%eax),%eax
+  800efa:	3c 2d                	cmp    $0x2d,%al
+  800efc:	75 0b                	jne    800f09 <strtol+0x53>
+		s++, neg = 1;
+  800efe:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f02:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+
+	// hex or octal base prefix
+	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
+  800f09:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f0d:	74 06                	je     800f15 <strtol+0x5f>
+  800f0f:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  800f13:	75 24                	jne    800f39 <strtol+0x83>
+  800f15:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f18:	0f b6 00             	movzbl (%eax),%eax
+  800f1b:	3c 30                	cmp    $0x30,%al
+  800f1d:	75 1a                	jne    800f39 <strtol+0x83>
+  800f1f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f22:	83 c0 01             	add    $0x1,%eax
+  800f25:	0f b6 00             	movzbl (%eax),%eax
+  800f28:	3c 78                	cmp    $0x78,%al
+  800f2a:	75 0d                	jne    800f39 <strtol+0x83>
+		s += 2, base = 16;
+  800f2c:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  800f30:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  800f37:	eb 2a                	jmp    800f63 <strtol+0xad>
+	else if (base == 0 && s[0] == '0')
+  800f39:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f3d:	75 17                	jne    800f56 <strtol+0xa0>
+  800f3f:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f42:	0f b6 00             	movzbl (%eax),%eax
+  800f45:	3c 30                	cmp    $0x30,%al
+  800f47:	75 0d                	jne    800f56 <strtol+0xa0>
+		s++, base = 8;
+  800f49:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800f4d:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  800f54:	eb 0d                	jmp    800f63 <strtol+0xad>
+	else if (base == 0)
+  800f56:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  800f5a:	75 07                	jne    800f63 <strtol+0xad>
+		base = 10;
+  800f5c:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+	// digits
+	while (1) {
+		int dig;
+
+		if (*s >= '0' && *s <= '9')
+  800f63:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f66:	0f b6 00             	movzbl (%eax),%eax
+  800f69:	3c 2f                	cmp    $0x2f,%al
+  800f6b:	7e 1b                	jle    800f88 <strtol+0xd2>
+  800f6d:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f70:	0f b6 00             	movzbl (%eax),%eax
+  800f73:	3c 39                	cmp    $0x39,%al
+  800f75:	7f 11                	jg     800f88 <strtol+0xd2>
+			dig = *s - '0';
+  800f77:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f7a:	0f b6 00             	movzbl (%eax),%eax
+  800f7d:	0f be c0             	movsbl %al,%eax
+  800f80:	83 e8 30             	sub    $0x30,%eax
+  800f83:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800f86:	eb 48                	jmp    800fd0 <strtol+0x11a>
+		else if (*s >= 'a' && *s <= 'z')
+  800f88:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f8b:	0f b6 00             	movzbl (%eax),%eax
+  800f8e:	3c 60                	cmp    $0x60,%al
+  800f90:	7e 1b                	jle    800fad <strtol+0xf7>
+  800f92:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f95:	0f b6 00             	movzbl (%eax),%eax
+  800f98:	3c 7a                	cmp    $0x7a,%al
+  800f9a:	7f 11                	jg     800fad <strtol+0xf7>
+			dig = *s - 'a' + 10;
+  800f9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  800f9f:	0f b6 00             	movzbl (%eax),%eax
+  800fa2:	0f be c0             	movsbl %al,%eax
+  800fa5:	83 e8 57             	sub    $0x57,%eax
+  800fa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  800fab:	eb 23                	jmp    800fd0 <strtol+0x11a>
+		else if (*s >= 'A' && *s <= 'Z')
+  800fad:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fb0:	0f b6 00             	movzbl (%eax),%eax
+  800fb3:	3c 40                	cmp    $0x40,%al
+  800fb5:	7e 3d                	jle    800ff4 <strtol+0x13e>
+  800fb7:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fba:	0f b6 00             	movzbl (%eax),%eax
+  800fbd:	3c 5a                	cmp    $0x5a,%al
+  800fbf:	7f 33                	jg     800ff4 <strtol+0x13e>
+			dig = *s - 'A' + 10;
+  800fc1:	8b 45 08             	mov    0x8(%ebp),%eax
+  800fc4:	0f b6 00             	movzbl (%eax),%eax
+  800fc7:	0f be c0             	movsbl %al,%eax
+  800fca:	83 e8 37             	sub    $0x37,%eax
+  800fcd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		else
+			break;
+		if (dig >= base)
+  800fd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fd3:	3b 45 10             	cmp    0x10(%ebp),%eax
+  800fd6:	7c 02                	jl     800fda <strtol+0x124>
+			break;
+  800fd8:	eb 1a                	jmp    800ff4 <strtol+0x13e>
+		s++, val = (val * base) + dig;
+  800fda:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  800fde:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  800fe1:	0f af 45 10          	imul   0x10(%ebp),%eax
+  800fe5:	89 c2                	mov    %eax,%edx
+  800fe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  800fea:	01 d0                	add    %edx,%eax
+  800fec:	89 45 f8             	mov    %eax,-0x8(%ebp)
+		// we don't properly detect overflow!
+	}
+  800fef:	e9 6f ff ff ff       	jmp    800f63 <strtol+0xad>
+
+	if (endptr)
+  800ff4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  800ff8:	74 08                	je     801002 <strtol+0x14c>
+		*endptr = (char *) s;
+  800ffa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  800ffd:	8b 55 08             	mov    0x8(%ebp),%edx
+  801000:	89 10                	mov    %edx,(%eax)
+	return (neg ? -val : val);
+  801002:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  801006:	74 07                	je     80100f <strtol+0x159>
+  801008:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  80100b:	f7 d8                	neg    %eax
+  80100d:	eb 03                	jmp    801012 <strtol+0x15c>
+  80100f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  801012:	c9                   	leave  
+  801013:	c3                   	ret    
+
+00801014 <syscall>:
+#include <inc/syscall.h>
+#include <inc/lib.h>
+
+static inline int32_t
+syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+{
+  801014:	55                   	push   %ebp
+  801015:	89 e5                	mov    %esp,%ebp
+  801017:	57                   	push   %edi
+  801018:	56                   	push   %esi
+  801019:	53                   	push   %ebx
+  80101a:	83 ec 3c             	sub    $0x3c,%esp
+	//
+	// The last clause tells the assembler that this can
+	// potentially change the condition codes and arbitrary
+	// memory locations.
+
+	asm volatile("int %1\n"
+  80101d:	8b 45 08             	mov    0x8(%ebp),%eax
+  801020:	8b 55 10             	mov    0x10(%ebp),%edx
+  801023:	8b 4d 14             	mov    0x14(%ebp),%ecx
+  801026:	8b 5d 18             	mov    0x18(%ebp),%ebx
+  801029:	8b 7d 1c             	mov    0x1c(%ebp),%edi
+  80102c:	8b 75 20             	mov    0x20(%ebp),%esi
+  80102f:	cd 30                	int    $0x30
+  801031:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		       "b" (a3),
+		       "D" (a4),
+		       "S" (a5)
+		     : "cc", "memory");
+
+	if(check && ret > 0)
+  801034:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  801038:	74 30                	je     80106a <syscall+0x56>
+  80103a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  80103e:	7e 2a                	jle    80106a <syscall+0x56>
+		panic("syscall %d returned %d (> 0)", num, ret);
+  801040:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  801043:	89 44 24 10          	mov    %eax,0x10(%esp)
+  801047:	8b 45 08             	mov    0x8(%ebp),%eax
+  80104a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  80104e:	c7 44 24 08 0c 17 80 	movl   $0x80170c,0x8(%esp)
+  801055:	00 
+  801056:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
+  80105d:	00 
+  80105e:	c7 04 24 29 17 80 00 	movl   $0x801729,(%esp)
+  801065:	e8 23 f1 ff ff       	call   80018d <_panic>
+
+	return ret;
+  80106a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+}
+  80106d:	83 c4 3c             	add    $0x3c,%esp
+  801070:	5b                   	pop    %ebx
+  801071:	5e                   	pop    %esi
+  801072:	5f                   	pop    %edi
+  801073:	5d                   	pop    %ebp
+  801074:	c3                   	ret    
+
+00801075 <sys_cputs>:
+
+void
+sys_cputs(const char *s, size_t len)
+{
+  801075:	55                   	push   %ebp
+  801076:	89 e5                	mov    %esp,%ebp
+  801078:	83 ec 28             	sub    $0x28,%esp
+	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
+  80107b:	8b 45 08             	mov    0x8(%ebp),%eax
+  80107e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  801085:	00 
+  801086:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  80108d:	00 
+  80108e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  801095:	00 
+  801096:	8b 55 0c             	mov    0xc(%ebp),%edx
+  801099:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  80109d:	89 44 24 08          	mov    %eax,0x8(%esp)
+  8010a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  8010a8:	00 
+  8010a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  8010b0:	e8 5f ff ff ff       	call   801014 <syscall>
+}
+  8010b5:	c9                   	leave  
+  8010b6:	c3                   	ret    
+
+008010b7 <sys_cgetc>:
+
+int
+sys_cgetc(void)
+{
+  8010b7:	55                   	push   %ebp
+  8010b8:	89 e5                	mov    %esp,%ebp
+  8010ba:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
+  8010bd:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  8010c4:	00 
+  8010c5:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  8010cc:	00 
+  8010cd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  8010d4:	00 
+  8010d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  8010dc:	00 
+  8010dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  8010e4:	00 
+  8010e5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  8010ec:	00 
+  8010ed:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  8010f4:	e8 1b ff ff ff       	call   801014 <syscall>
+}
+  8010f9:	c9                   	leave  
+  8010fa:	c3                   	ret    
+
+008010fb <sys_env_destroy>:
+
+int
+sys_env_destroy(envid_t envid)
+{
+  8010fb:	55                   	push   %ebp
+  8010fc:	89 e5                	mov    %esp,%ebp
+  8010fe:	83 ec 28             	sub    $0x28,%esp
+	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
+  801101:	8b 45 08             	mov    0x8(%ebp),%eax
+  801104:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80110b:	00 
+  80110c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  801113:	00 
+  801114:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  80111b:	00 
+  80111c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  801123:	00 
+  801124:	89 44 24 08          	mov    %eax,0x8(%esp)
+  801128:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  80112f:	00 
+  801130:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  801137:	e8 d8 fe ff ff       	call   801014 <syscall>
+}
+  80113c:	c9                   	leave  
+  80113d:	c3                   	ret    
+
+0080113e <sys_getenvid>:
+
+envid_t
+sys_getenvid(void)
+{
+  80113e:	55                   	push   %ebp
+  80113f:	89 e5                	mov    %esp,%ebp
+  801141:	83 ec 28             	sub    $0x28,%esp
+	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+  801144:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
+  80114b:	00 
+  80114c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
+  801153:	00 
+  801154:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
+  80115b:	00 
+  80115c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  801163:	00 
+  801164:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  80116b:	00 
+  80116c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  801173:	00 
+  801174:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  80117b:	e8 94 fe ff ff       	call   801014 <syscall>
+}
+  801180:	c9                   	leave  
+  801181:	c3                   	ret    
+  801182:	66 90                	xchg   %ax,%ax
+  801184:	66 90                	xchg   %ax,%ax
+  801186:	66 90                	xchg   %ax,%ax
+  801188:	66 90                	xchg   %ax,%ax
+  80118a:	66 90                	xchg   %ax,%ax
+  80118c:	66 90                	xchg   %ax,%ax
+  80118e:	66 90                	xchg   %ax,%ax
+
+00801190 <__udivdi3>:
+  801190:	55                   	push   %ebp
+  801191:	57                   	push   %edi
+  801192:	56                   	push   %esi
+  801193:	83 ec 0c             	sub    $0xc,%esp
+  801196:	8b 44 24 28          	mov    0x28(%esp),%eax
+  80119a:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
+  80119e:	8b 6c 24 20          	mov    0x20(%esp),%ebp
+  8011a2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8011a6:	85 c0                	test   %eax,%eax
+  8011a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
+  8011ac:	89 ea                	mov    %ebp,%edx
+  8011ae:	89 0c 24             	mov    %ecx,(%esp)
+  8011b1:	75 2d                	jne    8011e0 <__udivdi3+0x50>
+  8011b3:	39 e9                	cmp    %ebp,%ecx
+  8011b5:	77 61                	ja     801218 <__udivdi3+0x88>
+  8011b7:	85 c9                	test   %ecx,%ecx
+  8011b9:	89 ce                	mov    %ecx,%esi
+  8011bb:	75 0b                	jne    8011c8 <__udivdi3+0x38>
+  8011bd:	b8 01 00 00 00       	mov    $0x1,%eax
+  8011c2:	31 d2                	xor    %edx,%edx
+  8011c4:	f7 f1                	div    %ecx
+  8011c6:	89 c6                	mov    %eax,%esi
+  8011c8:	31 d2                	xor    %edx,%edx
+  8011ca:	89 e8                	mov    %ebp,%eax
+  8011cc:	f7 f6                	div    %esi
+  8011ce:	89 c5                	mov    %eax,%ebp
+  8011d0:	89 f8                	mov    %edi,%eax
+  8011d2:	f7 f6                	div    %esi
+  8011d4:	89 ea                	mov    %ebp,%edx
+  8011d6:	83 c4 0c             	add    $0xc,%esp
+  8011d9:	5e                   	pop    %esi
+  8011da:	5f                   	pop    %edi
+  8011db:	5d                   	pop    %ebp
+  8011dc:	c3                   	ret    
+  8011dd:	8d 76 00             	lea    0x0(%esi),%esi
+  8011e0:	39 e8                	cmp    %ebp,%eax
+  8011e2:	77 24                	ja     801208 <__udivdi3+0x78>
+  8011e4:	0f bd e8             	bsr    %eax,%ebp
+  8011e7:	83 f5 1f             	xor    $0x1f,%ebp
+  8011ea:	75 3c                	jne    801228 <__udivdi3+0x98>
+  8011ec:	8b 74 24 04          	mov    0x4(%esp),%esi
+  8011f0:	39 34 24             	cmp    %esi,(%esp)
+  8011f3:	0f 86 9f 00 00 00    	jbe    801298 <__udivdi3+0x108>
+  8011f9:	39 d0                	cmp    %edx,%eax
+  8011fb:	0f 82 97 00 00 00    	jb     801298 <__udivdi3+0x108>
+  801201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
+  801208:	31 d2                	xor    %edx,%edx
+  80120a:	31 c0                	xor    %eax,%eax
+  80120c:	83 c4 0c             	add    $0xc,%esp
+  80120f:	5e                   	pop    %esi
+  801210:	5f                   	pop    %edi
+  801211:	5d                   	pop    %ebp
+  801212:	c3                   	ret    
+  801213:	90                   	nop
+  801214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801218:	89 f8                	mov    %edi,%eax
+  80121a:	f7 f1                	div    %ecx
+  80121c:	31 d2                	xor    %edx,%edx
+  80121e:	83 c4 0c             	add    $0xc,%esp
+  801221:	5e                   	pop    %esi
+  801222:	5f                   	pop    %edi
+  801223:	5d                   	pop    %ebp
+  801224:	c3                   	ret    
+  801225:	8d 76 00             	lea    0x0(%esi),%esi
+  801228:	89 e9                	mov    %ebp,%ecx
+  80122a:	8b 3c 24             	mov    (%esp),%edi
+  80122d:	d3 e0                	shl    %cl,%eax
+  80122f:	89 c6                	mov    %eax,%esi
+  801231:	b8 20 00 00 00       	mov    $0x20,%eax
+  801236:	29 e8                	sub    %ebp,%eax
+  801238:	89 c1                	mov    %eax,%ecx
+  80123a:	d3 ef                	shr    %cl,%edi
+  80123c:	89 e9                	mov    %ebp,%ecx
+  80123e:	89 7c 24 08          	mov    %edi,0x8(%esp)
+  801242:	8b 3c 24             	mov    (%esp),%edi
+  801245:	09 74 24 08          	or     %esi,0x8(%esp)
+  801249:	89 d6                	mov    %edx,%esi
+  80124b:	d3 e7                	shl    %cl,%edi
+  80124d:	89 c1                	mov    %eax,%ecx
+  80124f:	89 3c 24             	mov    %edi,(%esp)
+  801252:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801256:	d3 ee                	shr    %cl,%esi
+  801258:	89 e9                	mov    %ebp,%ecx
+  80125a:	d3 e2                	shl    %cl,%edx
+  80125c:	89 c1                	mov    %eax,%ecx
+  80125e:	d3 ef                	shr    %cl,%edi
+  801260:	09 d7                	or     %edx,%edi
+  801262:	89 f2                	mov    %esi,%edx
+  801264:	89 f8                	mov    %edi,%eax
+  801266:	f7 74 24 08          	divl   0x8(%esp)
+  80126a:	89 d6                	mov    %edx,%esi
+  80126c:	89 c7                	mov    %eax,%edi
+  80126e:	f7 24 24             	mull   (%esp)
+  801271:	39 d6                	cmp    %edx,%esi
+  801273:	89 14 24             	mov    %edx,(%esp)
+  801276:	72 30                	jb     8012a8 <__udivdi3+0x118>
+  801278:	8b 54 24 04          	mov    0x4(%esp),%edx
+  80127c:	89 e9                	mov    %ebp,%ecx
+  80127e:	d3 e2                	shl    %cl,%edx
+  801280:	39 c2                	cmp    %eax,%edx
+  801282:	73 05                	jae    801289 <__udivdi3+0xf9>
+  801284:	3b 34 24             	cmp    (%esp),%esi
+  801287:	74 1f                	je     8012a8 <__udivdi3+0x118>
+  801289:	89 f8                	mov    %edi,%eax
+  80128b:	31 d2                	xor    %edx,%edx
+  80128d:	e9 7a ff ff ff       	jmp    80120c <__udivdi3+0x7c>
+  801292:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
+  801298:	31 d2                	xor    %edx,%edx
+  80129a:	b8 01 00 00 00       	mov    $0x1,%eax
+  80129f:	e9 68 ff ff ff       	jmp    80120c <__udivdi3+0x7c>
+  8012a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  8012a8:	8d 47 ff             	lea    -0x1(%edi),%eax
+  8012ab:	31 d2                	xor    %edx,%edx
+  8012ad:	83 c4 0c             	add    $0xc,%esp
+  8012b0:	5e                   	pop    %esi
+  8012b1:	5f                   	pop    %edi
+  8012b2:	5d                   	pop    %ebp
+  8012b3:	c3                   	ret    
+  8012b4:	66 90                	xchg   %ax,%ax
+  8012b6:	66 90                	xchg   %ax,%ax
+  8012b8:	66 90                	xchg   %ax,%ax
+  8012ba:	66 90                	xchg   %ax,%ax
+  8012bc:	66 90                	xchg   %ax,%ax
+  8012be:	66 90                	xchg   %ax,%ax
+
+008012c0 <__umoddi3>:
+  8012c0:	55                   	push   %ebp
+  8012c1:	57                   	push   %edi
+  8012c2:	56                   	push   %esi
+  8012c3:	83 ec 14             	sub    $0x14,%esp
+  8012c6:	8b 44 24 28          	mov    0x28(%esp),%eax
+  8012ca:	8b 4c 24 24          	mov    0x24(%esp),%ecx
+  8012ce:	8b 74 24 2c          	mov    0x2c(%esp),%esi
+  8012d2:	89 c7                	mov    %eax,%edi
+  8012d4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  8012d8:	8b 44 24 30          	mov    0x30(%esp),%eax
+  8012dc:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  8012e0:	89 34 24             	mov    %esi,(%esp)
+  8012e3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  8012e7:	85 c0                	test   %eax,%eax
+  8012e9:	89 c2                	mov    %eax,%edx
+  8012eb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8012ef:	75 17                	jne    801308 <__umoddi3+0x48>
+  8012f1:	39 fe                	cmp    %edi,%esi
+  8012f3:	76 4b                	jbe    801340 <__umoddi3+0x80>
+  8012f5:	89 c8                	mov    %ecx,%eax
+  8012f7:	89 fa                	mov    %edi,%edx
+  8012f9:	f7 f6                	div    %esi
+  8012fb:	89 d0                	mov    %edx,%eax
+  8012fd:	31 d2                	xor    %edx,%edx
+  8012ff:	83 c4 14             	add    $0x14,%esp
+  801302:	5e                   	pop    %esi
+  801303:	5f                   	pop    %edi
+  801304:	5d                   	pop    %ebp
+  801305:	c3                   	ret    
+  801306:	66 90                	xchg   %ax,%ax
+  801308:	39 f8                	cmp    %edi,%eax
+  80130a:	77 54                	ja     801360 <__umoddi3+0xa0>
+  80130c:	0f bd e8             	bsr    %eax,%ebp
+  80130f:	83 f5 1f             	xor    $0x1f,%ebp
+  801312:	75 5c                	jne    801370 <__umoddi3+0xb0>
+  801314:	8b 7c 24 08          	mov    0x8(%esp),%edi
+  801318:	39 3c 24             	cmp    %edi,(%esp)
+  80131b:	0f 87 e7 00 00 00    	ja     801408 <__umoddi3+0x148>
+  801321:	8b 7c 24 04          	mov    0x4(%esp),%edi
+  801325:	29 f1                	sub    %esi,%ecx
+  801327:	19 c7                	sbb    %eax,%edi
+  801329:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  80132d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  801331:	8b 44 24 08          	mov    0x8(%esp),%eax
+  801335:	8b 54 24 0c          	mov    0xc(%esp),%edx
+  801339:	83 c4 14             	add    $0x14,%esp
+  80133c:	5e                   	pop    %esi
+  80133d:	5f                   	pop    %edi
+  80133e:	5d                   	pop    %ebp
+  80133f:	c3                   	ret    
+  801340:	85 f6                	test   %esi,%esi
+  801342:	89 f5                	mov    %esi,%ebp
+  801344:	75 0b                	jne    801351 <__umoddi3+0x91>
+  801346:	b8 01 00 00 00       	mov    $0x1,%eax
+  80134b:	31 d2                	xor    %edx,%edx
+  80134d:	f7 f6                	div    %esi
+  80134f:	89 c5                	mov    %eax,%ebp
+  801351:	8b 44 24 04          	mov    0x4(%esp),%eax
+  801355:	31 d2                	xor    %edx,%edx
+  801357:	f7 f5                	div    %ebp
+  801359:	89 c8                	mov    %ecx,%eax
+  80135b:	f7 f5                	div    %ebp
+  80135d:	eb 9c                	jmp    8012fb <__umoddi3+0x3b>
+  80135f:	90                   	nop
+  801360:	89 c8                	mov    %ecx,%eax
+  801362:	89 fa                	mov    %edi,%edx
+  801364:	83 c4 14             	add    $0x14,%esp
+  801367:	5e                   	pop    %esi
+  801368:	5f                   	pop    %edi
+  801369:	5d                   	pop    %ebp
+  80136a:	c3                   	ret    
+  80136b:	90                   	nop
+  80136c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801370:	8b 04 24             	mov    (%esp),%eax
+  801373:	be 20 00 00 00       	mov    $0x20,%esi
+  801378:	89 e9                	mov    %ebp,%ecx
+  80137a:	29 ee                	sub    %ebp,%esi
+  80137c:	d3 e2                	shl    %cl,%edx
+  80137e:	89 f1                	mov    %esi,%ecx
+  801380:	d3 e8                	shr    %cl,%eax
+  801382:	89 e9                	mov    %ebp,%ecx
+  801384:	89 44 24 04          	mov    %eax,0x4(%esp)
+  801388:	8b 04 24             	mov    (%esp),%eax
+  80138b:	09 54 24 04          	or     %edx,0x4(%esp)
+  80138f:	89 fa                	mov    %edi,%edx
+  801391:	d3 e0                	shl    %cl,%eax
+  801393:	89 f1                	mov    %esi,%ecx
+  801395:	89 44 24 08          	mov    %eax,0x8(%esp)
+  801399:	8b 44 24 10          	mov    0x10(%esp),%eax
+  80139d:	d3 ea                	shr    %cl,%edx
+  80139f:	89 e9                	mov    %ebp,%ecx
+  8013a1:	d3 e7                	shl    %cl,%edi
+  8013a3:	89 f1                	mov    %esi,%ecx
+  8013a5:	d3 e8                	shr    %cl,%eax
+  8013a7:	89 e9                	mov    %ebp,%ecx
+  8013a9:	09 f8                	or     %edi,%eax
+  8013ab:	8b 7c 24 10          	mov    0x10(%esp),%edi
+  8013af:	f7 74 24 04          	divl   0x4(%esp)
+  8013b3:	d3 e7                	shl    %cl,%edi
+  8013b5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
+  8013b9:	89 d7                	mov    %edx,%edi
+  8013bb:	f7 64 24 08          	mull   0x8(%esp)
+  8013bf:	39 d7                	cmp    %edx,%edi
+  8013c1:	89 c1                	mov    %eax,%ecx
+  8013c3:	89 14 24             	mov    %edx,(%esp)
+  8013c6:	72 2c                	jb     8013f4 <__umoddi3+0x134>
+  8013c8:	39 44 24 0c          	cmp    %eax,0xc(%esp)
+  8013cc:	72 22                	jb     8013f0 <__umoddi3+0x130>
+  8013ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
+  8013d2:	29 c8                	sub    %ecx,%eax
+  8013d4:	19 d7                	sbb    %edx,%edi
+  8013d6:	89 e9                	mov    %ebp,%ecx
+  8013d8:	89 fa                	mov    %edi,%edx
+  8013da:	d3 e8                	shr    %cl,%eax
+  8013dc:	89 f1                	mov    %esi,%ecx
+  8013de:	d3 e2                	shl    %cl,%edx
+  8013e0:	89 e9                	mov    %ebp,%ecx
+  8013e2:	d3 ef                	shr    %cl,%edi
+  8013e4:	09 d0                	or     %edx,%eax
+  8013e6:	89 fa                	mov    %edi,%edx
+  8013e8:	83 c4 14             	add    $0x14,%esp
+  8013eb:	5e                   	pop    %esi
+  8013ec:	5f                   	pop    %edi
+  8013ed:	5d                   	pop    %ebp
+  8013ee:	c3                   	ret    
+  8013ef:	90                   	nop
+  8013f0:	39 d7                	cmp    %edx,%edi
+  8013f2:	75 da                	jne    8013ce <__umoddi3+0x10e>
+  8013f4:	8b 14 24             	mov    (%esp),%edx
+  8013f7:	89 c1                	mov    %eax,%ecx
+  8013f9:	2b 4c 24 08          	sub    0x8(%esp),%ecx
+  8013fd:	1b 54 24 04          	sbb    0x4(%esp),%edx
+  801401:	eb cb                	jmp    8013ce <__umoddi3+0x10e>
+  801403:	90                   	nop
+  801404:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
+  801408:	3b 44 24 0c          	cmp    0xc(%esp),%eax
+  80140c:	0f 82 0f ff ff ff    	jb     801321 <__umoddi3+0x61>
+  801412:	e9 1a ff ff ff       	jmp    801331 <__umoddi3+0x71>
diff --git a/obj/user/testbss.o b/obj/user/testbss.o
new file mode 100644
index 0000000..8767980
Binary files /dev/null and b/obj/user/testbss.o differ
diff --git a/obj/user/testbss.sym b/obj/user/testbss.sym
new file mode 100644
index 0000000..e870b6c
--- /dev/null
+++ b/obj/user/testbss.sym
@@ -0,0 +1,55 @@
+00200010 R __STAB_BEGIN__
+00202b00 R __STAB_END__
+00202b01 R __STABSTR_BEGIN__
+00204205 R __STABSTR_END__
+00800020 T _start
+0080002c t args_exist
+00800033 T umain
+0080012b T libmain
+00800179 T exit
+0080018d T _panic
+008001e8 t putch
+00800244 T vcprintf
+008002a8 T cprintf
+008002ce t printnum
+008003ac t getuint
+008003fb t getint
+00800442 T vprintfmt
+00800989 T printfmt
+008009b7 t sprintputch
+008009ec T vsnprintf
+00800a4c T snprintf
+00800a80 T strlen
+00800aa6 T strnlen
+00800ad6 T strcpy
+00800b06 T strcat
+00800b36 T strncpy
+00800b7b T strlcpy
+00800bcc T strcmp
+00800c0b T strncmp
+00800c61 T strchr
+00800c94 T strfind
+00800cc2 T memset
+00800d30 T memmove
+00800e0a T memcpy
+00800e2b T memcmp
+00800e83 T memfind
+00800eb6 T strtol
+00801014 t syscall
+00801075 T sys_cputs
+008010b7 T sys_cgetc
+008010fb T sys_env_destroy
+0080113e T sys_getenvid
+00801190 T __udivdi3
+008012c0 T __umoddi3
+00801574 r error_string
+00802000 D binaryname
+00802020 B bigarray
+00c02020 B thisenv
+00c02024 B BG_COLOR
+00c02028 B COLOR
+00c0202c B FG_COLOR
+eec00000 A envs
+ef000000 A pages
+ef400000 A uvpt
+ef7bd000 A uvpd
diff --git a/tmp/lab1diff.patch b/tmp/lab1diff.patch
new file mode 100644
index 0000000..5964317
--- /dev/null
+++ b/tmp/lab1diff.patch
@@ -0,0 +1,150 @@
+diff --git a/inc/color.h b/inc/color.h
+new file mode 100644
+index 0000000..ed09ec1
+--- /dev/null
++++ b/inc/color.h
+@@ -0,0 +1,3 @@
++int FG_COLOR;
++int BG_COLOR;
++int COLOR;
+diff --git a/kern/console.c b/kern/console.c
+index 7d312a7..aba428e 100644
+--- a/kern/console.c
++++ b/kern/console.c
+@@ -5,6 +5,7 @@
+ #include <inc/kbdreg.h>
+ #include <inc/string.h>
+ #include <inc/assert.h>
++#include <inc/color.h>
+ 
+ #include <kern/console.h>
+ 
+@@ -164,8 +165,7 @@ cga_putc(int c)
+ {
+ 	// if no attribute given, then use black on white
+ 	if (!(c & ~0xFF))
+-		c |= 0x0700;
+-
++	   	c |= COLOR;
+ 	switch (c & 0xff) {
+ 	case '\b':
+ 		if (crt_pos > 0) {
+diff --git a/kern/kdebug.c b/kern/kdebug.c
+index 9547143..a573a6c 100644
+--- a/kern/kdebug.c
++++ b/kern/kdebug.c
+@@ -179,6 +179,9 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
+ 	//	Look at the STABS documentation and <inc/stab.h> to find
+ 	//	which one.
+ 	// Your code here.
++		stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
++		if (lline <= rline) info->eip_line = lline - lfun;
++		else return -1;
+ 
+ 
+ 	// Search backwards from the line number for the relevant filename
+diff --git a/kern/monitor.c b/kern/monitor.c
+index e137e92..db7917c 100644
+--- a/kern/monitor.c
++++ b/kern/monitor.c
+@@ -57,7 +57,29 @@ mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
+ int
+ mon_backtrace(int argc, char **argv, struct Trapframe *tf)
+ {
+-	// Your code here.
++	int *ebp, eip, *old_ebp;
++	int ary[5]={};
++
++	cprintf("Stack backtrace:\n");
++	
++	ebp=(int *)read_ebp();
++	while((int)ebp!=0)
++	{
++		old_ebp=(int *)*(ebp);
++		eip=*(ebp+1);
++		for(int i=0;i<5;++i)
++		{
++			int j=i+2;
++			ary[i]=*(ebp+j);
++		}
++		struct Eipdebuginfo eip_info;
++		debuginfo_eip((uintptr_t)eip, &eip_info);
++		cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
++		cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
++		cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
++		ebp=old_ebp;
++	}
++	
+ 	return 0;
+ }
+ 
+diff --git a/lib/printfmt.c b/lib/printfmt.c
+index 28e01c9..50b0aa9 100644
+--- a/lib/printfmt.c
++++ b/lib/printfmt.c
+@@ -7,6 +7,7 @@
+ #include <inc/string.h>
+ #include <inc/stdarg.h>
+ #include <inc/error.h>
++#include <inc/color.h>
+ 
+ /*
+  * Space or zero padding and a field width are supported for the numeric
+@@ -92,6 +93,33 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+ 		while ((ch = *(unsigned char *) fmt++) != '%') {
+ 			if (ch == '\0')
+ 				return;
++			else if(ch == '\033'){
++				if((ch = *(unsigned char *) fmt++) != '[') {
++				    putch(ch, putdat);
++				    continue;
++				}
++				BG_COLOR = *(unsigned char *) fmt++;
++				FG_COLOR = *(unsigned char *) fmt++;
++
++				if(BG_COLOR >= '0' && BG_COLOR <= '9')
++				    BG_COLOR -= '0';
++				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
++				    BG_COLOR = BG_COLOR - 'a' + 10;
++				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
++				    BG_COLOR = BG_COLOR - 'A' + 10;
++				else BG_COLOR = 0;
++
++				if(FG_COLOR >= '0' && FG_COLOR <= '9')
++				    FG_COLOR -= '0';
++				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
++				    FG_COLOR = FG_COLOR - 'a' + 10;
++				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
++				    FG_COLOR = FG_COLOR - 'A' + 10;
++				else BG_COLOR = 7;
++
++				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
++				continue;
++			}	
+ 			putch(ch, putdat);
+ 		}
+ 
+@@ -205,11 +233,9 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+ 
+ 		// (unsigned) octal
+ 		case 'o':
+-			// Replace this with your code.
+-			putch('X', putdat);
+-			putch('X', putdat);
+-			putch('X', putdat);
+-			break;
++			num = getuint(&ap,lflag);
++			base = 8;
++			goto number;
+ 
+ 		// pointer
+ 		case 'p':
+@@ -231,7 +257,7 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+ 		// escaped '%' character
+ 		case '%':
+ 			putch(ch, putdat);
+-			break;
++			break;			
+ 
+ 		// unrecognized escape sequence - just print it literally
+ 		default:
diff --git a/user/breakpoint.c b/user/breakpoint.c
index 47e4cb2..f122d6b 100644
--- a/user/breakpoint.c
+++ b/user/breakpoint.c
@@ -2,9 +2,16 @@
 
 #include <inc/lib.h>
 
-void
+    void
 umain(int argc, char **argv)
 {
-	asm volatile("int $3");
+    asm volatile("int $3");
+    asm volatile("movl $0, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+
 }
 
