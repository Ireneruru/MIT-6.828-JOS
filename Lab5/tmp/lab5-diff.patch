diff --git a/COPYRIGHT b/COPYRIGHT
new file mode 100644
index 0000000..6a0270c
--- /dev/null
+++ b/COPYRIGHT
@@ -0,0 +1,155 @@
+Most of the source files in this directory are derived from the Exokernel,
+which is:
+
+/*
+ * Copyright (C) 1997 Massachusetts Institute of Technology 
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ * The name and trademarks of copyright holders may NOT be used in
+ * advertising or publicity pertaining to the software without specific,
+ * written prior permission. Title to copyright in this software and any
+ * associated documentation will at all times remain with copyright
+ * holders. See the file AUTHORS which should have accompanied this software
+ * for a list of all copyright holders.
+ *
+ * This file may be derived from previously copyrighted software. This
+ * copyright applies only to those changes made by the copyright
+ * holders listed in the AUTHORS file. The rest of this file is covered by
+ * the copyright notices, if any, listed below.
+ */
+
+Console.c was created consulting the NetBSD pccons driver which is:
+
+/*-
+ * Copyright (c) 1993, 1994, 1995 Charles Hannum.  All rights reserved.
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * William Jolitz and Don Ahn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+Kclock.h, sched.h, and printf.h are copyright:
+
+/*
+ * Copyright (C) 1998 Exotec, Inc.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ * The name and trademarks of copyright holders may NOT be used in
+ * advertising or publicity pertaining to the software without specific,
+ * written prior permission. Title to copyright in this software and any
+ * associated documentation will at all times remain with Exotec, Inc..
+ *
+ * This file may be derived from previously copyrighted software. This
+ * copyright applies only to those changes made by Exotec, Inc. The rest
+ * of this file is covered by the copyright notices, if any, listed below.
+ */
+
+Printf.c is copyright:
+
+/*-
+ * Copyright (c) 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
+ */
+
diff --git a/GNUmakefile b/GNUmakefile
index 839e8fa..fd8465f 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -84,9 +84,11 @@ PERL	:= perl
 # -fno-builtin is required to avoid refs to undefined functions in the kernel.
 # Only optimize to -O1 to discourage inlining, which complicates backtraces.
 CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MD
+#CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -fno-builtin -I$(TOP) -MD
 CFLAGS += -fno-omit-frame-pointer
 CFLAGS += -std=gnu99
 CFLAGS += -static
+
 CFLAGS += -Wall -Wno-format -Wno-unused -Werror -gstabs -m32
 # -fno-tree-ch prevented gcc from sometimes reordering read_ebp() before
 # mon_backtrace()'s function prologue on gcc version: (Debian 4.7.2-5) 4.7.2
diff --git a/Makefrag b/Makefrag
new file mode 100644
index 0000000..3b2982e
--- /dev/null
+++ b/Makefrag
@@ -0,0 +1,89 @@
+#
+# Makefile fragment for JOS kernel.
+# This is NOT a complete makefile;
+# you must run GNU make in the top-level directory
+# where the GNUmakefile is located.
+#
+
+OBJDIRS += kern
+
+KERN_LDFLAGS := $(LDFLAGS) -T kern/kernel.ld -nostdlib
+
+# entry.S must be first, so that it's the first code in the text segment!!!
+#
+# We also snatch the use of a couple handy source files
+# from the lib directory, to avoid gratuitous code duplication.
+KERN_SRCFILES :=	kern/entry.S \
+			kern/entrypgdir.c \
+			kern/init.c \
+			kern/console.c \
+			kern/monitor.c \
+			kern/pmap.c \
+			kern/env.c \
+			kern/kclock.c \
+			kern/picirq.c \
+			kern/printf.c \
+			kern/trap.c \
+			kern/trapentry.S \
+			kern/sched.c \
+			kern/syscall.c \
+			kern/kdebug.c \
+			lib/printfmt.c \
+			lib/readline.c \
+			lib/string.c
+
+# Only build files if they exist.
+KERN_SRCFILES := $(wildcard $(KERN_SRCFILES))
+
+# Binary program images to embed within the kernel.
+KERN_BINFILES := 
+
+KERN_OBJFILES := $(patsubst %.c, $(OBJDIR)/%.o, $(KERN_SRCFILES))
+KERN_OBJFILES := $(patsubst %.S, $(OBJDIR)/%.o, $(KERN_OBJFILES))
+KERN_OBJFILES := $(patsubst $(OBJDIR)/lib/%, $(OBJDIR)/kern/%, $(KERN_OBJFILES))
+
+KERN_BINFILES := $(patsubst %, $(OBJDIR)/%, $(KERN_BINFILES))
+
+# How to build kernel object files
+$(OBJDIR)/kern/%.o: kern/%.c $(OBJDIR)/.vars.KERN_CFLAGS
+	@echo + cc $<
+	@mkdir -p $(@D)
+	$(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $<
+
+$(OBJDIR)/kern/%.o: kern/%.S $(OBJDIR)/.vars.KERN_CFLAGS
+	@echo + as $<
+	@mkdir -p $(@D)
+	$(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $<
+
+$(OBJDIR)/kern/%.o: lib/%.c $(OBJDIR)/.vars.KERN_CFLAGS
+	@echo + cc $<
+	@mkdir -p $(@D)
+	$(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $<
+
+# Special flags for kern/init
+$(OBJDIR)/kern/init.o: override KERN_CFLAGS+=$(INIT_CFLAGS)
+$(OBJDIR)/kern/init.o: $(OBJDIR)/.vars.INIT_CFLAGS
+
+# How to build the kernel itself
+$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) kern/kernel.ld \
+	  $(OBJDIR)/.vars.KERN_LDFLAGS
+	@echo + ld $@
+	$(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES)
+	$(V)$(OBJDUMP) -S $@ > $@.asm
+	$(V)$(NM) -n $@ > $@.sym
+
+# How to build the kernel disk image
+$(OBJDIR)/kern/kernel.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot
+	@echo + mk $@
+	$(V)dd if=/dev/zero of=$(OBJDIR)/kern/kernel.img~ count=10000 2>/dev/null
+	$(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/kernel.img~ conv=notrunc 2>/dev/null
+	$(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/kernel.img~ seek=1 conv=notrunc 2>/dev/null
+	$(V)mv $(OBJDIR)/kern/kernel.img~ $(OBJDIR)/kern/kernel.img
+
+all: $(OBJDIR)/kern/kernel.img
+
+grub: $(OBJDIR)/jos-grub
+
+$(OBJDIR)/jos-grub: $(OBJDIR)/kern/kernel
+	@echo + oc $@
+	$(V)$(OBJCOPY) --adjust-vma=0x10000000 $^ $@
diff --git a/boot/boot.S b/boot/boot.S
index 7a91ab1..5cde8a3 100644
--- a/boot/boot.S
+++ b/boot/boot.S
@@ -72,7 +72,7 @@ protcseg:
 spin:
   jmp spin
 
-# Bootstrap GDT
+# Bootstrap GDT 
 .p2align 2                                # force 4 byte alignment
 gdt:
   SEG_NULL				# null seg
diff --git a/boot/boot.S~ b/boot/boot.S~
new file mode 100644
index 0000000..7a91ab1
--- /dev/null
+++ b/boot/boot.S~
@@ -0,0 +1,85 @@
+#include <inc/mmu.h>
+
+# Start the CPU: switch to 32-bit protected mode, jump into C.
+# The BIOS loads this code from the first sector of the hard disk into
+# memory at physical address 0x7c00 and starts executing in real mode
+# with %cs=0 %ip=7c00.
+
+.set PROT_MODE_CSEG, 0x8         # kernel code segment selector
+.set PROT_MODE_DSEG, 0x10        # kernel data segment selector
+.set CR0_PE_ON,      0x1         # protected mode enable flag
+
+.globl start
+start:
+  .code16                     # Assemble for 16-bit mode
+  cli                         # Disable interrupts
+  cld                         # String operations increment
+
+  # Set up the important data segment registers (DS, ES, SS).
+  xorw    %ax,%ax             # Segment number zero
+  movw    %ax,%ds             # -> Data Segment
+  movw    %ax,%es             # -> Extra Segment
+  movw    %ax,%ss             # -> Stack Segment
+
+  # Enable A20:
+  #   For backwards compatibility with the earliest PCs, physical
+  #   address line 20 is tied low, so that addresses higher than
+  #   1MB wrap around to zero by default.  This code undoes this.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+  testb   $0x2,%al
+  jnz     seta20.1
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+  outb    %al,$0x64
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+  testb   $0x2,%al
+  jnz     seta20.2
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+  outb    %al,$0x60
+
+  # Switch from real to protected mode, using a bootstrap GDT
+  # and segment translation that makes virtual addresses 
+  # identical to their physical addresses, so that the 
+  # effective memory map does not change during the switch.
+  lgdt    gdtdesc
+  movl    %cr0, %eax
+  orl     $CR0_PE_ON, %eax
+  movl    %eax, %cr0
+  
+  # Jump to next instruction, but in 32-bit code segment.
+  # Switches processor into 32-bit mode.
+  ljmp    $PROT_MODE_CSEG, $protcseg
+
+  .code32                     # Assemble for 32-bit mode
+protcseg:
+  # Set up the protected-mode data segment registers
+  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
+  movw    %ax, %ds                # -> DS: Data Segment
+  movw    %ax, %es                # -> ES: Extra Segment
+  movw    %ax, %fs                # -> FS
+  movw    %ax, %gs                # -> GS
+  movw    %ax, %ss                # -> SS: Stack Segment
+  
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+  call bootmain
+
+  # If bootmain returns (it shouldn't), loop.
+spin:
+  jmp spin
+
+# Bootstrap GDT
+.p2align 2                                # force 4 byte alignment
+gdt:
+  SEG_NULL				# null seg
+  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg
+  SEG(STA_W, 0x0, 0xffffffff)	        # data seg
+
+gdtdesc:
+  .word   0x17                            # sizeof(gdt) - 1
+  .long   gdt                             # address gdt
+
diff --git a/fs/bc.c b/fs/bc.c
index 1825555..4f69c6a 100644
--- a/fs/bc.c
+++ b/fs/bc.c
@@ -2,63 +2,67 @@
 #include "fs.h"
 
 // Return the virtual address of this disk block.
-void*
+    void*
 diskaddr(uint32_t blockno)
 {
-	if (blockno == 0 || (super && blockno >= super->s_nblocks))
-		panic("bad block number %08x in diskaddr", blockno);
-	return (char*) (DISKMAP + blockno * BLKSIZE);
+    if (blockno == 0 || (super && blockno >= super->s_nblocks))
+	panic("bad block number %08x in diskaddr", blockno);
+    return (char*) (DISKMAP + blockno * BLKSIZE);
 }
 
 // Is this virtual address mapped?
-bool
+    bool
 va_is_mapped(void *va)
 {
-	return (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P);
+    return (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P);
 }
 
 // Is this virtual address dirty?
-bool
+    bool
 va_is_dirty(void *va)
 {
-	return (uvpt[PGNUM(va)] & PTE_D) != 0;
+    return (uvpt[PGNUM(va)] & PTE_D) != 0;
 }
 
 // Fault any disk block that is read in to memory by
 // loading it from disk.
-static void
+    static void
 bc_pgfault(struct UTrapframe *utf)
 {
-	void *addr = (void *) utf->utf_fault_va;
-	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
-	int r;
-
-	// Check that the fault was within the block cache region
-	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
-		panic("page fault in FS: eip %08x, va %08x, err %04x",
-		      utf->utf_eip, addr, utf->utf_err);
-
-	// Sanity check the block number.
-	if (super && blockno >= super->s_nblocks)
-		panic("reading non-existent block %08x\n", blockno);
-
-	// Allocate a page in the disk map region, read the contents
-	// of the block from the disk into that page.
-	// Hint: first round addr to page boundary. fs/ide.c has code to read
-	// the disk.
-	//
-	// LAB 5: you code here:
-
-	// Clear the dirty bit for the disk block page since we just read the
-	// block from disk
-	if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
-		panic("in bc_pgfault, sys_page_map: %e", r);
-
-	// Check that the block we read was allocated. (exercise for
-	// the reader: why do we do this *after* reading the block
-	// in?)
-	if (bitmap && block_is_free(blockno))
-		panic("reading free block %08x\n", blockno);
+    void *addr = (void *) utf->utf_fault_va;
+    uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
+    int r;
+
+    // Check that the fault was within the block cache region
+    if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
+	panic("page fault in FS: eip %08x, va %08x, err %04x",
+		utf->utf_eip, addr, utf->utf_err);
+
+    // Sanity check the block number.
+    if (super && blockno >= super->s_nblocks)
+	panic("reading non-existent block %08x\n", blockno);
+
+    // Allocate a page in the disk map region, read the contents
+    // of the block from the disk into that page.
+    // Hint: first round addr to page boundary. fs/ide.c has code to read
+    // the disk.
+    //
+    // LAB 5: you code here:
+
+    addr = (void*)ROUNDDOWN((uintptr_t)addr, PGSIZE);
+    sys_page_alloc(0, addr, PTE_P | PTE_U | PTE_W);
+    ide_read(blockno << 3, addr, 8);
+
+    // Clear the dirty bit for the disk block page since we just read the
+    // block from disk
+    if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
+	panic("in bc_pgfault, sys_page_map: %e", r);
+
+    // Check that the block we read was allocated. (exercise for
+    // the reader: why do we do this *after* reading the block
+    // in?)
+    if (bitmap && block_is_free(blockno))
+	panic("reading free block %08x\n", blockno);
 }
 
 // Flush the contents of the block containing VA out to disk if
@@ -68,56 +72,66 @@ bc_pgfault(struct UTrapframe *utf)
 // Hint: Use va_is_mapped, va_is_dirty, and ide_write.
 // Hint: Use the PTE_SYSCALL constant when calling sys_page_map.
 // Hint: Don't forget to round addr down.
-void
+    void
 flush_block(void *addr)
 {
-	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
+    uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
+
+    if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
+	panic("flush_block of bad va %08x", addr);
 
-	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
-		panic("flush_block of bad va %08x", addr);
+    // LAB 5: Your code here.
+   addr = ROUNDDOWN(addr, PGSIZE);
+    
+   int r;
 
-	// LAB 5: Your code here.
-	panic("flush_block not implemented");
+    if(va_is_dirty(addr)&&va_is_mapped(addr))  
+    {
+	ide_write(blockno*BLKSECTS, addr, BLKSECTS);
+
+	if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
+	    panic("flush_block, sys_page_map: %e", r);
+    }
 }
 
 // Test that the block cache works, by smashing the superblock and
 // reading it back.
-static void
+    static void
 check_bc(void)
 {
-	struct Super backup;
+    struct Super backup;
 
-	// back up super block
-	memmove(&backup, diskaddr(1), sizeof backup);
+    // back up super block
+    memmove(&backup, diskaddr(1), sizeof backup);
 
-	// smash it
-	strcpy(diskaddr(1), "OOPS!\n");
-	flush_block(diskaddr(1));
-	assert(va_is_mapped(diskaddr(1)));
-	assert(!va_is_dirty(diskaddr(1)));
+    // smash it
+    strcpy(diskaddr(1), "OOPS!\n");
+    flush_block(diskaddr(1));
+    assert(va_is_mapped(diskaddr(1)));
+    assert(!va_is_dirty(diskaddr(1)));
 
-	// clear it out
-	sys_page_unmap(0, diskaddr(1));
-	assert(!va_is_mapped(diskaddr(1)));
+    // clear it out
+    sys_page_unmap(0, diskaddr(1));
+    assert(!va_is_mapped(diskaddr(1)));
 
-	// read it back in
-	assert(strcmp(diskaddr(1), "OOPS!\n") == 0);
+    // read it back in
+    assert(strcmp(diskaddr(1), "OOPS!\n") == 0);
 
-	// fix it
-	memmove(diskaddr(1), &backup, sizeof backup);
-	flush_block(diskaddr(1));
+    // fix it
+    memmove(diskaddr(1), &backup, sizeof backup);
+    flush_block(diskaddr(1));
 
-	cprintf("block cache is good\n");
+    cprintf("block cache is good\n");
 }
 
-void
+    void
 bc_init(void)
 {
-	struct Super super;
-	set_pgfault_handler(bc_pgfault);
-	check_bc();
+    struct Super super;
+    set_pgfault_handler(bc_pgfault);
+    check_bc();
 
-	// cache the super block by reading it once
-	memmove(&super, diskaddr(1), sizeof super);
+    // cache the super block by reading it once
+    memmove(&super, diskaddr(1), sizeof super);
 }
 
diff --git a/fs/fs.c b/fs/fs.c
index 45ecaf8..4905b42 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -8,16 +8,16 @@
 // --------------------------------------------------------------
 
 // Validate the file system super-block.
-void
+    void
 check_super(void)
 {
-	if (super->s_magic != FS_MAGIC)
-		panic("bad file system magic number");
+    if (super->s_magic != FS_MAGIC)
+	panic("bad file system magic number");
 
-	if (super->s_nblocks > DISKSIZE/BLKSIZE)
-		panic("file system is too large");
+    if (super->s_nblocks > DISKSIZE/BLKSIZE)
+	panic("file system is too large");
 
-	cprintf("superblock is good\n");
+    cprintf("superblock is good\n");
 }
 
 // --------------------------------------------------------------
@@ -26,24 +26,24 @@ check_super(void)
 
 // Check to see if the block bitmap indicates that block 'blockno' is free.
 // Return 1 if the block is free, 0 if not.
-bool
+    bool
 block_is_free(uint32_t blockno)
 {
-	if (super == 0 || blockno >= super->s_nblocks)
-		return 0;
-	if (bitmap[blockno / 32] & (1 << (blockno % 32)))
-		return 1;
+    if (super == 0 || blockno >= super->s_nblocks)
 	return 0;
+    if (bitmap[blockno / 32] & (1 << (blockno % 32)))
+	return 1;
+    return 0;
 }
 
 // Mark a block free in the bitmap
-void
+    void
 free_block(uint32_t blockno)
 {
-	// Blockno zero is the null pointer of block numbers.
-	if (blockno == 0)
-		panic("attempt to free zero block");
-	bitmap[blockno/32] |= 1<<(blockno%32);
+    // Blockno zero is the null pointer of block numbers.
+    if (blockno == 0)
+	panic("attempt to free zero block");
+    bitmap[blockno/32] |= 1<<(blockno%32);
 }
 
 // Search the bitmap for a free block and allocate it.  When you
@@ -54,36 +54,47 @@ free_block(uint32_t blockno)
 // -E_NO_DISK if we are out of blocks.
 //
 // Hint: use free_block as an example for manipulating the bitmap.
-int
+    int
 alloc_block(void)
 {
-	// The bitmap consists of one or more blocks.  A single bitmap block
-	// contains the in-use bits for BLKBITSIZE blocks.  There are
-	// super->s_nblocks blocks in the disk altogether.
+    // The bitmap consists of one or more blocks.  A single bitmap block
+    // contains the in-use bits for BLKBITSIZE blocks.  There are
+    // super->s_nblocks blocks in the disk altogether.
+
+    // LAB 5: Your code here.
+    int blockno;
+
+    for(blockno = 0; blockno < super->s_nblocks; blockno++)
+    {
+	if(block_is_free(blockno))
+	{
+	    bitmap[blockno/32] ^= 1<<(blockno%32);
+	    flush_block(bitmap+blockno/8);
+	    return blockno;
+	}
+    }
 
-	// LAB 5: Your code here.
-	panic("alloc_block not implemented");
-	return -E_NO_DISK;
+    return -E_NO_DISK;
 }
 
 // Validate the file system bitmap.
 //
 // Check that all reserved blocks -- 0, 1, and the bitmap blocks themselves --
 // are all marked as in-use.
-void
+    void
 check_bitmap(void)
 {
-	uint32_t i;
+    uint32_t i;
 
-	// Make sure all bitmap blocks are marked in-use
-	for (i = 0; i * BLKBITSIZE < super->s_nblocks; i++)
-		assert(!block_is_free(2+i));
+    // Make sure all bitmap blocks are marked in-use
+    for (i = 0; i * BLKBITSIZE < super->s_nblocks; i++)
+	assert(!block_is_free(2+i));
 
-	// Make sure the reserved and root blocks are marked in-use.
-	assert(!block_is_free(0));
-	assert(!block_is_free(1));
+    // Make sure the reserved and root blocks are marked in-use.
+    assert(!block_is_free(0));
+    assert(!block_is_free(1));
 
-	cprintf("bitmap is good\n");
+    cprintf("bitmap is good\n");
 }
 
 // --------------------------------------------------------------
@@ -93,26 +104,26 @@ check_bitmap(void)
 
 
 // Initialize the file system
-void
+    void
 fs_init(void)
 {
-	static_assert(sizeof(struct File) == 256);
-
-	// Find a JOS disk.  Use the second IDE disk (number 1) if available
-	if (ide_probe_disk1())
-		ide_set_disk(1);
-	else
-		ide_set_disk(0);
-	bc_init();
-
-	// Set "super" to point to the super block.
-	super = diskaddr(1);
-	check_super();
-
-	// Set "bitmap" to the beginning of the first bitmap block.
-	bitmap = diskaddr(2);
-	check_bitmap();
-	
+    static_assert(sizeof(struct File) == 256);
+
+    // Find a JOS disk.  Use the second IDE disk (number 1) if available
+    if (ide_probe_disk1())
+	ide_set_disk(1);
+    else
+	ide_set_disk(0);
+    bc_init();
+
+    // Set "super" to point to the super block.
+    super = diskaddr(1);
+    check_super();
+
+    // Set "bitmap" to the beginning of the first bitmap block.
+    bitmap = diskaddr(2);
+    check_bitmap();
+
 }
 
 // Find the disk block number slot for the 'filebno'th block in file 'f'.
@@ -131,11 +142,35 @@ fs_init(void)
 //
 // Analogy: This is like pgdir_walk for files.
 // Hint: Don't forget to clear any block you allocate.
-static int
+    static int
 file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
 {
-       // LAB 5: Your code here.
-       panic("file_block_walk not implemented");
+    int r;
+    uint32_t *ptr;
+    char *blk;
+
+    if(filebno < NDIRECT)
+    {
+	ptr = &f->f_direct[filebno];
+    }else if(filebno < NDIRECT + NINDIRECT)
+    {
+	if(f->f_indirect == 0 && alloc == 0)
+	    return -E_NOT_FOUND;
+	else if(f->f_indirect==0)
+	{
+	    if((r = alloc_block()) < 0)
+		return -E_NO_DISK;
+	    f->f_indirect = r;
+	    memset(diskaddr(r), 0, BLKSIZE);
+	    flush_block(diskaddr(r));
+	}
+	ptr = (uint32_t*)diskaddr(f->f_indirect) + filebno - NDIRECT;
+    }else
+    {
+	return -E_INVAL;
+    }
+    *ppdiskbno = ptr;
+    return 0;
 }
 
 // Set *blk to the address in memory where the filebno'th
@@ -146,80 +181,93 @@ file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool all
 //	-E_INVAL if filebno is out of range.
 //
 // Hint: Use file_block_walk and alloc_block.
-int
+    int
 file_get_block(struct File *f, uint32_t filebno, char **blk)
 {
-       // LAB 5: Your code here.
-       panic("file_get_block not implemented");
+    // LAB 5: Your code here.
+    int r;
+    uint32_t *ptr;
+
+    if ((r = file_block_walk(f, filebno, &ptr, 1)) < 0)
+	return r;
+    if (*ptr == 0) {
+	if((r = alloc_block())<0)
+	    return -E_NO_DISK;
+
+	*ptr = r;
+	memset(diskaddr(r), 0, BLKSIZE);
+	flush_block(diskaddr(r));
+    }   
+    *blk = diskaddr(*ptr);
+    return 0;
 }
-
 // Try to find a file named "name" in dir.  If so, set *file to it.
 //
 // Returns 0 and sets *file on success, < 0 on error.  Errors are:
 //	-E_NOT_FOUND if the file is not found
-static int
+    static int
 dir_lookup(struct File *dir, const char *name, struct File **file)
 {
-	int r;
-	uint32_t i, j, nblock;
-	char *blk;
-	struct File *f;
-
-	// Search dir for name.
-	// We maintain the invariant that the size of a directory-file
-	// is always a multiple of the file system's block size.
-	assert((dir->f_size % BLKSIZE) == 0);
-	nblock = dir->f_size / BLKSIZE;
-	for (i = 0; i < nblock; i++) {
-		if ((r = file_get_block(dir, i, &blk)) < 0)
-			return r;
-		f = (struct File*) blk;
-		for (j = 0; j < BLKFILES; j++)
-			if (strcmp(f[j].f_name, name) == 0) {
-				*file = &f[j];
-				return 0;
-			}
-	}
-	return -E_NOT_FOUND;
+    int r;
+    uint32_t i, j, nblock;
+    char *blk;
+    struct File *f;
+
+    // Search dir for name.
+    // We maintain the invariant that the size of a directory-file
+    // is always a multiple of the file system's block size.
+    assert((dir->f_size % BLKSIZE) == 0);
+    nblock = dir->f_size / BLKSIZE;
+    for (i = 0; i < nblock; i++) {
+	if ((r = file_get_block(dir, i, &blk)) < 0)
+	    return r;
+	f = (struct File*) blk;
+	for (j = 0; j < BLKFILES; j++)
+	    if (strcmp(f[j].f_name, name) == 0) {
+		*file = &f[j];
+		return 0;
+	    }
+    }
+    return -E_NOT_FOUND;
 }
 
 // Set *file to point at a free File structure in dir.  The caller is
 // responsible for filling in the File fields.
-static int
+    static int
 dir_alloc_file(struct File *dir, struct File **file)
 {
-	int r;
-	uint32_t nblock, i, j;
-	char *blk;
-	struct File *f;
-
-	assert((dir->f_size % BLKSIZE) == 0);
-	nblock = dir->f_size / BLKSIZE;
-	for (i = 0; i < nblock; i++) {
-		if ((r = file_get_block(dir, i, &blk)) < 0)
-			return r;
-		f = (struct File*) blk;
-		for (j = 0; j < BLKFILES; j++)
-			if (f[j].f_name[0] == '\0') {
-				*file = &f[j];
-				return 0;
-			}
-	}
-	dir->f_size += BLKSIZE;
+    int r;
+    uint32_t nblock, i, j;
+    char *blk;
+    struct File *f;
+
+    assert((dir->f_size % BLKSIZE) == 0);
+    nblock = dir->f_size / BLKSIZE;
+    for (i = 0; i < nblock; i++) {
 	if ((r = file_get_block(dir, i, &blk)) < 0)
-		return r;
+	    return r;
 	f = (struct File*) blk;
-	*file = &f[0];
-	return 0;
+	for (j = 0; j < BLKFILES; j++)
+	    if (f[j].f_name[0] == '\0') {
+		*file = &f[j];
+		return 0;
+	    }
+    }
+    dir->f_size += BLKSIZE;
+    if ((r = file_get_block(dir, i, &blk)) < 0)
+	return r;
+    f = (struct File*) blk;
+    *file = &f[0];
+    return 0;
 }
 
 // Skip over slashes.
-static const char*
+    static const char*
 skip_slash(const char *p)
 {
-	while (*p == '/')
-		p++;
-	return p;
+    while (*p == '/')
+	p++;
+    return p;
 }
 
 // Evaluate a path name, starting at the root.
@@ -228,54 +276,54 @@ skip_slash(const char *p)
 // If we cannot find the file but find the directory
 // it should be in, set *pdir and copy the final path
 // element into lastelem.
-static int
+    static int
 walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)
 {
-	const char *p;
-	char name[MAXNAMELEN];
-	struct File *dir, *f;
-	int r;
-
-	// if (*path != '/')
-	//	return -E_BAD_PATH;
+    const char *p;
+    char name[MAXNAMELEN];
+    struct File *dir, *f;
+    int r;
+
+    // if (*path != '/')
+    //	return -E_BAD_PATH;
+    path = skip_slash(path);
+    f = &super->s_root;
+    dir = 0;
+    name[0] = 0;
+
+    if (pdir)
+	*pdir = 0;
+    *pf = 0;
+    while (*path != '\0') {
+	dir = f;
+	p = path;
+	while (*path != '/' && *path != '\0')
+	    path++;
+	if (path - p >= MAXNAMELEN)
+	    return -E_BAD_PATH;
+	memmove(name, p, path - p);
+	name[path - p] = '\0';
 	path = skip_slash(path);
-	f = &super->s_root;
-	dir = 0;
-	name[0] = 0;
-
-	if (pdir)
-		*pdir = 0;
-	*pf = 0;
-	while (*path != '\0') {
-		dir = f;
-		p = path;
-		while (*path != '/' && *path != '\0')
-			path++;
-		if (path - p >= MAXNAMELEN)
-			return -E_BAD_PATH;
-		memmove(name, p, path - p);
-		name[path - p] = '\0';
-		path = skip_slash(path);
-
-		if (dir->f_type != FTYPE_DIR)
-			return -E_NOT_FOUND;
-
-		if ((r = dir_lookup(dir, name, &f)) < 0) {
-			if (r == -E_NOT_FOUND && *path == '\0') {
-				if (pdir)
-					*pdir = dir;
-				if (lastelem)
-					strcpy(lastelem, name);
-				*pf = 0;
-			}
-			return r;
-		}
+
+	if (dir->f_type != FTYPE_DIR)
+	    return -E_NOT_FOUND;
+
+	if ((r = dir_lookup(dir, name, &f)) < 0) {
+	    if (r == -E_NOT_FOUND && *path == '\0') {
+		if (pdir)
+		    *pdir = dir;
+		if (lastelem)
+		    strcpy(lastelem, name);
+		*pf = 0;
+	    }
+	    return r;
 	}
+    }
 
-	if (pdir)
-		*pdir = dir;
-	*pf = f;
-	return 0;
+    if (pdir)
+	*pdir = dir;
+    *pf = f;
+    return 0;
 }
 
 // --------------------------------------------------------------
@@ -284,59 +332,59 @@ walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem
 
 // Create "path".  On success set *pf to point at the file and return 0.
 // On error return < 0.
-int
+    int
 file_create(const char *path, struct File **pf)
 {
-	char name[MAXNAMELEN];
-	int r;
-	struct File *dir, *f;
-
-	if ((r = walk_path(path, &dir, &f, name)) == 0)
-		return -E_FILE_EXISTS;
-	if (r != -E_NOT_FOUND || dir == 0)
-		return r;
-	if ((r = dir_alloc_file(dir, &f)) < 0)
-		return r;
-
-	strcpy(f->f_name, name);
-	*pf = f;
-	file_flush(dir);
-	return 0;
+    char name[MAXNAMELEN];
+    int r;
+    struct File *dir, *f;
+
+    if ((r = walk_path(path, &dir, &f, name)) == 0)
+	return -E_FILE_EXISTS;
+    if (r != -E_NOT_FOUND || dir == 0)
+	return r;
+    if ((r = dir_alloc_file(dir, &f)) < 0)
+	return r;
+
+    strcpy(f->f_name, name);
+    *pf = f;
+    file_flush(dir);
+    return 0;
 }
 
 // Open "path".  On success set *pf to point at the file and return 0.
 // On error return < 0.
-int
+    int
 file_open(const char *path, struct File **pf)
 {
-	return walk_path(path, 0, pf, 0);
+    return walk_path(path, 0, pf, 0);
 }
 
 // Read count bytes from f into buf, starting from seek position
 // offset.  This meant to mimic the standard pread function.
 // Returns the number of bytes read, < 0 on error.
-ssize_t
+    ssize_t
 file_read(struct File *f, void *buf, size_t count, off_t offset)
 {
-	int r, bn;
-	off_t pos;
-	char *blk;
+    int r, bn;
+    off_t pos;
+    char *blk;
 
-	if (offset >= f->f_size)
-		return 0;
+    if (offset >= f->f_size)
+	return 0;
 
-	count = MIN(count, f->f_size - offset);
+    count = MIN(count, f->f_size - offset);
 
-	for (pos = offset; pos < offset + count; ) {
-		if ((r = file_get_block(f, pos / BLKSIZE, &blk)) < 0)
-			return r;
-		bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);
-		memmove(buf, blk + pos % BLKSIZE, bn);
-		pos += bn;
-		buf += bn;
-	}
+    for (pos = offset; pos < offset + count; ) {
+	if ((r = file_get_block(f, pos / BLKSIZE, &blk)) < 0)
+	    return r;
+	bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);
+	memmove(buf, blk + pos % BLKSIZE, bn);
+	pos += bn;
+	buf += bn;
+    }
 
-	return count;
+    return count;
 }
 
 
@@ -344,45 +392,45 @@ file_read(struct File *f, void *buf, size_t count, off_t offset)
 // offset.  This is meant to mimic the standard pwrite function.
 // Extends the file if necessary.
 // Returns the number of bytes written, < 0 on error.
-int
+    int
 file_write(struct File *f, const void *buf, size_t count, off_t offset)
 {
-	int r, bn;
-	off_t pos;
-	char *blk;
-
-	// Extend file if necessary
-	if (offset + count > f->f_size)
-		if ((r = file_set_size(f, offset + count)) < 0)
-			return r;
-
-	for (pos = offset; pos < offset + count; ) {
-		if ((r = file_get_block(f, pos / BLKSIZE, &blk)) < 0)
-			return r;
-		bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);
-		memmove(blk + pos % BLKSIZE, buf, bn);
-		pos += bn;
-		buf += bn;
-	}
-
-	return count;
+    int r, bn;
+    off_t pos;
+    char *blk;
+
+    // Extend file if necessary
+    if (offset + count > f->f_size)
+	if ((r = file_set_size(f, offset + count)) < 0)
+	    return r;
+
+    for (pos = offset; pos < offset + count; ) {
+	if ((r = file_get_block(f, pos / BLKSIZE, &blk)) < 0)
+	    return r;
+	bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);
+	memmove(blk + pos % BLKSIZE, buf, bn);
+	pos += bn;
+	buf += bn;
+    }
+
+    return count;
 }
 
 // Remove a block from file f.  If it's not there, just silently succeed.
 // Returns 0 on success, < 0 on error.
-static int
+    static int
 file_free_block(struct File *f, uint32_t filebno)
 {
-	int r;
-	uint32_t *ptr;
-
-	if ((r = file_block_walk(f, filebno, &ptr, 0)) < 0)
-		return r;
-	if (*ptr) {
-		free_block(*ptr);
-		*ptr = 0;
-	}
-	return 0;
+    int r;
+    uint32_t *ptr;
+
+    if ((r = file_block_walk(f, filebno, &ptr, 0)) < 0)
+	return r;
+    if (*ptr) {
+	free_block(*ptr);
+	*ptr = 0;
+    }
+    return 0;
 }
 
 // Remove any blocks currently used by file 'f',
@@ -394,63 +442,63 @@ file_free_block(struct File *f, uint32_t filebno)
 // (Remember to clear the f->f_indirect pointer so you'll know
 // whether it's valid!)
 // Do not change f->f_size.
-static void
+    static void
 file_truncate_blocks(struct File *f, off_t newsize)
 {
-	int r;
-	uint32_t bno, old_nblocks, new_nblocks;
-
-	old_nblocks = (f->f_size + BLKSIZE - 1) / BLKSIZE;
-	new_nblocks = (newsize + BLKSIZE - 1) / BLKSIZE;
-	for (bno = new_nblocks; bno < old_nblocks; bno++)
-		if ((r = file_free_block(f, bno)) < 0)
-			cprintf("warning: file_free_block: %e", r);
-
-	if (new_nblocks <= NDIRECT && f->f_indirect) {
-		free_block(f->f_indirect);
-		f->f_indirect = 0;
-	}
+    int r;
+    uint32_t bno, old_nblocks, new_nblocks;
+
+    old_nblocks = (f->f_size + BLKSIZE - 1) / BLKSIZE;
+    new_nblocks = (newsize + BLKSIZE - 1) / BLKSIZE;
+    for (bno = new_nblocks; bno < old_nblocks; bno++)
+	if ((r = file_free_block(f, bno)) < 0)
+	    cprintf("warning: file_free_block: %e", r);
+
+    if (new_nblocks <= NDIRECT && f->f_indirect) {
+	free_block(f->f_indirect);
+	f->f_indirect = 0;
+    }
 }
 
 // Set the size of file f, truncating or extending as necessary.
-int
+    int
 file_set_size(struct File *f, off_t newsize)
 {
-	if (f->f_size > newsize)
-		file_truncate_blocks(f, newsize);
-	f->f_size = newsize;
-	flush_block(f);
-	return 0;
+    if (f->f_size > newsize)
+	file_truncate_blocks(f, newsize);
+    f->f_size = newsize;
+    flush_block(f);
+    return 0;
 }
 
 // Flush the contents and metadata of file f out to disk.
 // Loop over all the blocks in file.
 // Translate the file block number into a disk block number
 // and then check whether that disk block is dirty.  If so, write it out.
-void
+    void
 file_flush(struct File *f)
 {
-	int i;
-	uint32_t *pdiskbno;
-
-	for (i = 0; i < (f->f_size + BLKSIZE - 1) / BLKSIZE; i++) {
-		if (file_block_walk(f, i, &pdiskbno, 0) < 0 ||
-		    pdiskbno == NULL || *pdiskbno == 0)
-			continue;
-		flush_block(diskaddr(*pdiskbno));
-	}
-	flush_block(f);
-	if (f->f_indirect)
-		flush_block(diskaddr(f->f_indirect));
+    int i;
+    uint32_t *pdiskbno;
+
+    for (i = 0; i < (f->f_size + BLKSIZE - 1) / BLKSIZE; i++) {
+	if (file_block_walk(f, i, &pdiskbno, 0) < 0 ||
+		pdiskbno == NULL || *pdiskbno == 0)
+	    continue;
+	flush_block(diskaddr(*pdiskbno));
+    }
+    flush_block(f);
+    if (f->f_indirect)
+	flush_block(diskaddr(f->f_indirect));
 }
 
 
 // Sync the entire file system.  A big hammer.
-void
+    void
 fs_sync(void)
 {
-	int i;
-	for (i = 1; i < super->s_nblocks; i++)
-		flush_block(diskaddr(i));
+    int i;
+    for (i = 1; i < super->s_nblocks; i++)
+	flush_block(diskaddr(i));
 }
 
diff --git a/fs/serv.c b/fs/serv.c
index 76c1d99..88f98d9 100644
--- a/fs/serv.c
+++ b/fs/serv.c
@@ -30,10 +30,10 @@
 //    file IDs to struct OpenFile.
 
 struct OpenFile {
-	uint32_t o_fileid;	// file id
-	struct File *o_file;	// mapped descriptor for open file
-	int o_mode;		// open mode
-	struct Fd *o_fd;	// Fd page
+    uint32_t o_fileid;	// file id
+    struct File *o_file;	// mapped descriptor for open file
+    int o_mode;		// open mode
+    struct Fd *o_fd;	// Fd page
 };
 
 // Max number of open files in the file system at once
@@ -42,179 +42,191 @@ struct OpenFile {
 
 // initialize to force into data section
 struct OpenFile opentab[MAXOPEN] = {
-	{ 0, 0, 1, 0 }
+    { 0, 0, 1, 0 }
 };
 
 // Virtual address at which to receive page mappings containing client requests.
 union Fsipc *fsreq = (union Fsipc *)0x0ffff000;
 
-void
+    void
 serve_init(void)
 {
-	int i;
-	uintptr_t va = FILEVA;
-	for (i = 0; i < MAXOPEN; i++) {
-		opentab[i].o_fileid = i;
-		opentab[i].o_fd = (struct Fd*) va;
-		va += PGSIZE;
-	}
+    int i;
+    uintptr_t va = FILEVA;
+    for (i = 0; i < MAXOPEN; i++) {
+	opentab[i].o_fileid = i;
+	opentab[i].o_fd = (struct Fd*) va;
+	va += PGSIZE;
+    }
 }
 
 // Allocate an open file.
-int
+    int
 openfile_alloc(struct OpenFile **o)
 {
-	int i, r;
-
-	// Find an available open-file table entry
-	for (i = 0; i < MAXOPEN; i++) {
-		switch (pageref(opentab[i].o_fd)) {
-		case 0:
-			if ((r = sys_page_alloc(0, opentab[i].o_fd, PTE_P|PTE_U|PTE_W)) < 0)
-				return r;
-			/* fall through */
-		case 1:
-			opentab[i].o_fileid += MAXOPEN;
-			*o = &opentab[i];
-			memset(opentab[i].o_fd, 0, PGSIZE);
-			return (*o)->o_fileid;
-		}
+    int i, r;
+
+    // Find an available open-file table entry
+    for (i = 0; i < MAXOPEN; i++) {
+	switch (pageref(opentab[i].o_fd)) {
+	    case 0:
+		if ((r = sys_page_alloc(0, opentab[i].o_fd, PTE_P|PTE_U|PTE_W)) < 0)
+		    return r;
+		/* fall through */
+	    case 1:
+		opentab[i].o_fileid += MAXOPEN;
+		*o = &opentab[i];
+		memset(opentab[i].o_fd, 0, PGSIZE);
+		return (*o)->o_fileid;
 	}
-	return -E_MAX_OPEN;
+    }
+    return -E_MAX_OPEN;
 }
 
 // Look up an open file for envid.
-int
+    int
 openfile_lookup(envid_t envid, uint32_t fileid, struct OpenFile **po)
 {
-	struct OpenFile *o;
+    struct OpenFile *o;
 
-	o = &opentab[fileid % MAXOPEN];
-	if (pageref(o->o_fd) <= 1 || o->o_fileid != fileid)
-		return -E_INVAL;
-	*po = o;
-	return 0;
+    o = &opentab[fileid % MAXOPEN];
+    if (pageref(o->o_fd) <= 1 || o->o_fileid != fileid)
+	return -E_INVAL;
+    *po = o;
+    return 0;
 }
 
 // Open req->req_path in mode req->req_omode, storing the Fd page and
 // permissions to return to the calling environment in *pg_store and
 // *perm_store respectively.
-int
+    int
 serve_open(envid_t envid, struct Fsreq_open *req,
-	   void **pg_store, int *perm_store)
+	void **pg_store, int *perm_store)
 {
-	char path[MAXPATHLEN];
-	struct File *f;
-	int fileid;
-	int r;
-	struct OpenFile *o;
+    char path[MAXPATHLEN];
+    struct File *f;
+    int fileid;
+    int r;
+    struct OpenFile *o;
 
-	if (debug)
-		cprintf("serve_open %08x %s 0x%x\n", envid, req->req_path, req->req_omode);
+    if (debug)
+	cprintf("serve_open %08x %s 0x%x\n", envid, req->req_path, req->req_omode);
 
-	// Copy in the path, making sure it's null-terminated
-	memmove(path, req->req_path, MAXPATHLEN);
-	path[MAXPATHLEN-1] = 0;
+    // Copy in the path, making sure it's null-terminated
+    memmove(path, req->req_path, MAXPATHLEN);
+    path[MAXPATHLEN-1] = 0;
 
-	// Find an open file ID
-	if ((r = openfile_alloc(&o)) < 0) {
-		if (debug)
-			cprintf("openfile_alloc failed: %e", r);
-		return r;
+    // Find an open file ID
+    if ((r = openfile_alloc(&o)) < 0) {
+	if (debug)
+	    cprintf("openfile_alloc failed: %e", r);
+	return r;
+    }
+    fileid = r;
+
+    // Open the file
+    if (req->req_omode & O_CREAT) {
+	if ((r = file_create(path, &f)) < 0) {
+	    if (!(req->req_omode & O_EXCL) && r == -E_FILE_EXISTS)
+		goto try_open;
+	    if (debug)
+		cprintf("file_create failed: %e", r);
+	    return r;
 	}
-	fileid = r;
-
-	// Open the file
-	if (req->req_omode & O_CREAT) {
-		if ((r = file_create(path, &f)) < 0) {
-			if (!(req->req_omode & O_EXCL) && r == -E_FILE_EXISTS)
-				goto try_open;
-			if (debug)
-				cprintf("file_create failed: %e", r);
-			return r;
-		}
-	} else {
+    } else {
 try_open:
-		if ((r = file_open(path, &f)) < 0) {
-			if (debug)
-				cprintf("file_open failed: %e", r);
-			return r;
-		}
-	}
-
-	// Truncate
-	if (req->req_omode & O_TRUNC) {
-		if ((r = file_set_size(f, 0)) < 0) {
-			if (debug)
-				cprintf("file_set_size failed: %e", r);
-			return r;
-		}
-	}
 	if ((r = file_open(path, &f)) < 0) {
-		if (debug)
-			cprintf("file_open failed: %e", r);
-		return r;
+	    if (debug)
+		cprintf("file_open failed: %e", r);
+	    return r;
 	}
+    }
+
+    // Truncate
+    if (req->req_omode & O_TRUNC) {
+	if ((r = file_set_size(f, 0)) < 0) {
+	    if (debug)
+		cprintf("file_set_size failed: %e", r);
+	    return r;
+	}
+    }
+    if ((r = file_open(path, &f)) < 0) {
+	if (debug)
+	    cprintf("file_open failed: %e", r);
+	return r;
+    }
 
-	// Save the file pointer
-	o->o_file = f;
+    // Save the file pointer
+    o->o_file = f;
 
-	// Fill out the Fd structure
-	o->o_fd->fd_file.id = o->o_fileid;
-	o->o_fd->fd_omode = req->req_omode & O_ACCMODE;
-	o->o_fd->fd_dev_id = devfile.dev_id;
-	o->o_mode = req->req_omode;
+    // Fill out the Fd structure
+    o->o_fd->fd_file.id = o->o_fileid;
+    o->o_fd->fd_omode = req->req_omode & O_ACCMODE;
+    o->o_fd->fd_dev_id = devfile.dev_id;
+    o->o_mode = req->req_omode;
 
-	if (debug)
-		cprintf("sending success, page %08x\n", (uintptr_t) o->o_fd);
+    if (debug)
+	cprintf("sending success, page %08x\n", (uintptr_t) o->o_fd);
 
-	// Share the FD page with the caller by setting *pg_store,
-	// store its permission in *perm_store
-	*pg_store = o->o_fd;
-	*perm_store = PTE_P|PTE_U|PTE_W|PTE_SHARE;
+    // Share the FD page with the caller by setting *pg_store,
+    // store its permission in *perm_store
+    *pg_store = o->o_fd;
+    *perm_store = PTE_P|PTE_U|PTE_W|PTE_SHARE;
 
-	return 0;
+    return 0;
 }
 
 // Set the size of req->req_fileid to req->req_size bytes, truncating
 // or extending the file as necessary.
-int
+    int
 serve_set_size(envid_t envid, struct Fsreq_set_size *req)
 {
-	struct OpenFile *o;
-	int r;
+    struct OpenFile *o;
+    int r;
 
-	if (debug)
-		cprintf("serve_set_size %08x %08x %08x\n", envid, req->req_fileid, req->req_size);
+    if (debug)
+	cprintf("serve_set_size %08x %08x %08x\n", envid, req->req_fileid, req->req_size);
 
-	// Every file system IPC call has the same general structure.
-	// Here's how it goes.
+    // Every file system IPC call has the same general structure.
+    // Here's how it goes.
 
-	// First, use openfile_lookup to find the relevant open file.
-	// On failure, return the error code to the client with ipc_send.
-	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
-		return r;
+    // First, use openfile_lookup to find the relevant open file.
+    // On failure, return the error code to the client with ipc_send.
+    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
+	return r;
 
-	// Second, call the relevant file system function (from fs/fs.c).
-	// On failure, return the error code to the client.
-	return file_set_size(o->o_file, req->req_size);
+    // Second, call the relevant file system function (from fs/fs.c).
+    // On failure, return the error code to the client.
+    return file_set_size(o->o_file, req->req_size);
 }
 
 // Read at most ipc->read.req_n bytes from the current seek position
 // in ipc->read.req_fileid.  Return the bytes read from the file to
 // the caller in ipc->readRet, then update the seek position.  Returns
 // the number of bytes successfully read, or < 0 on error.
-int
+    int
 serve_read(envid_t envid, union Fsipc *ipc)
 {
-	struct Fsreq_read *req = &ipc->read;
-	struct Fsret_read *ret = &ipc->readRet;
+    struct Fsreq_read *req = &ipc->read;
+    struct Fsret_read *ret = &ipc->readRet;
 
-	if (debug)
-		cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
+    if (debug)
+	cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
+
+    // Lab 5: Your code here:
+    // First, use openfile_lookup to find the relevant open file.
+    // On failure, return the error code to the client with ipc_send.
+    struct OpenFile *o;
+    int r;
+
+    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
+	return r;
 
-	// Lab 5: Your code here:
-	return 0;
+    if ((r = file_read(o->o_file, ret->ret_buf, MIN(req->req_n, sizeof ret->ret_buf),o->o_fd->fd_offset)) < 0)
+	return r;
+
+    o->o_fd->fd_offset += r;
+    return r;
 }
 
 
@@ -222,124 +234,136 @@ serve_read(envid_t envid, union Fsipc *ipc)
 // the current seek position, and update the seek position
 // accordingly.  Extend the file if necessary.  Returns the number of
 // bytes written, or < 0 on error.
-int
+    int
 serve_write(envid_t envid, struct Fsreq_write *req)
 {
-	if (debug)
-		cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
+    if (debug)
+	cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
+
+    // LAB 5: Your code here.
+    struct OpenFile *o;
+    int r;
+
+    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0) {
+	return r;
+    }
+
+    int req_n = req->req_n > sizeof(req->req_buf) ? sizeof(req->req_buf): req->req_n;
+    if ((r = file_write(o->o_file, req->req_buf, req_n, o->o_fd->fd_offset)) < 0)
+	return r;
+
+    o->o_fd->fd_offset += r;
+    return r;
 
-	// LAB 5: Your code here.
-	panic("serve_write not implemented");
 }
 
 // Stat ipc->stat.req_fileid.  Return the file's struct Stat to the
 // caller in ipc->statRet.
-int
+    int
 serve_stat(envid_t envid, union Fsipc *ipc)
 {
-	struct Fsreq_stat *req = &ipc->stat;
-	struct Fsret_stat *ret = &ipc->statRet;
-	struct OpenFile *o;
-	int r;
+    struct Fsreq_stat *req = &ipc->stat;
+    struct Fsret_stat *ret = &ipc->statRet;
+    struct OpenFile *o;
+    int r;
 
-	if (debug)
-		cprintf("serve_stat %08x %08x\n", envid, req->req_fileid);
+    if (debug)
+	cprintf("serve_stat %08x %08x\n", envid, req->req_fileid);
 
-	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
-		return r;
+    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
+	return r;
 
-	strcpy(ret->ret_name, o->o_file->f_name);
-	ret->ret_size = o->o_file->f_size;
-	ret->ret_isdir = (o->o_file->f_type == FTYPE_DIR);
-	return 0;
+    strcpy(ret->ret_name, o->o_file->f_name);
+    ret->ret_size = o->o_file->f_size;
+    ret->ret_isdir = (o->o_file->f_type == FTYPE_DIR);
+    return 0;
 }
 
 // Flush all data and metadata of req->req_fileid to disk.
-int
+    int
 serve_flush(envid_t envid, struct Fsreq_flush *req)
 {
-	struct OpenFile *o;
-	int r;
+    struct OpenFile *o;
+    int r;
 
-	if (debug)
-		cprintf("serve_flush %08x %08x\n", envid, req->req_fileid);
+    if (debug)
+	cprintf("serve_flush %08x %08x\n", envid, req->req_fileid);
 
-	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
-		return r;
-	file_flush(o->o_file);
-	return 0;
+    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
+	return r;
+    file_flush(o->o_file);
+    return 0;
 }
 
 
-int
+    int
 serve_sync(envid_t envid, union Fsipc *req)
 {
-	fs_sync();
-	return 0;
+    fs_sync();
+    return 0;
 }
 
 typedef int (*fshandler)(envid_t envid, union Fsipc *req);
 
 fshandler handlers[] = {
-	// Open is handled specially because it passes pages
-	/* [FSREQ_OPEN] =	(fshandler)serve_open, */
-	[FSREQ_READ] =		serve_read,
-	[FSREQ_STAT] =		serve_stat,
-	[FSREQ_FLUSH] =		(fshandler)serve_flush,
-	[FSREQ_WRITE] =		(fshandler)serve_write,
-	[FSREQ_SET_SIZE] =	(fshandler)serve_set_size,
-	[FSREQ_SYNC] =		serve_sync
+    // Open is handled specially because it passes pages
+    [FSREQ_OPEN] =   (fshandler)serve_open,
+    [FSREQ_READ] =      serve_read,
+    [FSREQ_STAT] =      serve_stat,
+    [FSREQ_FLUSH] =     (fshandler)serve_flush,
+    [FSREQ_WRITE] =	(fshandler)serve_write,
 };
+#define NHANDLERS (sizeof(handlers)/sizeof(handlers[0]))
 
-void
+    void
 serve(void)
 {
-	uint32_t req, whom;
-	int perm, r;
-	void *pg;
-
-	while (1) {
-		perm = 0;
-		req = ipc_recv((int32_t *) &whom, fsreq, &perm);
-		if (debug)
-			cprintf("fs req %d from %08x [page %08x: %s]\n",
-				req, whom, uvpt[PGNUM(fsreq)], fsreq);
-
-		// All requests must contain an argument page
-		if (!(perm & PTE_P)) {
-			cprintf("Invalid request from %08x: no argument page\n",
-				whom);
-			continue; // just leave it hanging...
-		}
-
-		pg = NULL;
-		if (req == FSREQ_OPEN) {
-			r = serve_open(whom, (struct Fsreq_open*)fsreq, &pg, &perm);
-		} else if (req < ARRAY_SIZE(handlers) && handlers[req]) {
-			r = handlers[req](whom, fsreq);
-		} else {
-			cprintf("Invalid request code %d from %08x\n", req, whom);
-			r = -E_INVAL;
-		}
-		ipc_send(whom, r, pg, perm);
-		sys_page_unmap(0, fsreq);
+    uint32_t req, whom;
+    int perm, r;
+    void *pg;
+
+    while (1) {
+	perm = 0;
+	req = ipc_recv((int32_t *) &whom, fsreq, &perm);
+	if (debug)
+	    cprintf("fs req %d from %08x [page %08x: %s]\n",
+		    req, whom, uvpt[PGNUM(fsreq)], fsreq);
+
+	// All requests must contain an argument page
+	if (!(perm & PTE_P)) {
+	    cprintf("Invalid request from %08x: no argument page\n",
+		    whom);
+	    continue; // just leave it hanging...
+	}
+
+	pg = NULL;
+	if (req == FSREQ_OPEN) {
+	    r = serve_open(whom, (struct Fsreq_open*)fsreq, &pg, &perm);
+	} else if (req < ARRAY_SIZE(handlers) && handlers[req]) {
+	    r = handlers[req](whom, fsreq);
+	} else {
+	    cprintf("Invalid request code %d from %08x\n", req, whom);
+	    r = -E_INVAL;
 	}
+	ipc_send(whom, r, pg, perm);
+	sys_page_unmap(0, fsreq);
+    }
 }
 
-void
+    void
 umain(int argc, char **argv)
 {
-	static_assert(sizeof(struct File) == 256);
-	binaryname = "fs";
-	cprintf("FS is running\n");
-
-	// Check that we are able to do I/O
-	outw(0x8A00, 0x8A00);
-	cprintf("FS can do I/O\n");
-
-	serve_init();
-	fs_init();
-        fs_test();
-	serve();
+    static_assert(sizeof(struct File) == 256);
+    binaryname = "fs";
+    cprintf("FS is running\n");
+
+    // Check that we are able to do I/O
+    outw(0x8A00, 0x8A00);
+    cprintf("FS can do I/O\n");
+
+    serve_init();
+    fs_init();
+    fs_test();
+    serve();
 }
 
diff --git a/gradelib.pyc b/gradelib.pyc
new file mode 100644
index 0000000..f31811f
Binary files /dev/null and b/gradelib.pyc differ
diff --git a/inc/color.h b/inc/color.h
new file mode 100644
index 0000000..ed09ec1
--- /dev/null
+++ b/inc/color.h
@@ -0,0 +1,3 @@
+int FG_COLOR;
+int BG_COLOR;
+int COLOR;
diff --git a/inc/fs.c b/inc/fs.c
new file mode 100644
index 0000000..e69de29
diff --git a/inc/memlayout.h b/inc/memlayout.h
index 9b4f3c4..e74835d 100644
--- a/inc/memlayout.h
+++ b/inc/memlayout.h
@@ -47,7 +47,7 @@
  *                     |       Memory-mapped I/O      | RW/--  PTSIZE
  * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
  *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
- *    UVPT      ---->  +------------------------------+ 0xef400000
+ *    UVPT      ---->  +------------------------------+ show
  *                     |          RO PAGES            | R-/R-  PTSIZE
  *    UPAGES    ---->  +------------------------------+ 0xef000000
  *                     |           RO ENVS            | R-/R-  PTSIZE
@@ -56,7 +56,7 @@
  *                     +------------------------------+ 0xeebff000
  *                     |       Empty Memory (*)       | --/--  PGSIZE
  *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
- *                     |      Normal User Stack       | RW/RW  PGSIZE
+ *                     |      Normal x Stack       | RW/RW  PGSIZE
  *                     +------------------------------+ 0xeebfd000
  *                     |                              |
  *                     |                              |
diff --git a/inc/memlayout.h~ b/inc/memlayout.h~
new file mode 100644
index 0000000..a90a638
--- /dev/null
+++ b/inc/memlayout.h~
@@ -0,0 +1,188 @@
+#ifndef JOS_INC_MEMLAYOUT_H
+#define JOS_INC_MEMLAYOUT_H
+
+#ifndef __ASSEMBLER__
+#include <inc/types.h>
+#include <inc/mmu.h>
+#endif /* not __ASSEMBLER__ */
+
+/*
+ * This file contains definitions for memory management in our OS,
+ * which are relevant to both the kernel and user-mode software.
+ */
+
+// Global descriptor numbers
+#define GD_KT     0x08     // kernel text
+#define GD_KD     0x10     // kernel data
+#define GD_UT     0x18     // user text
+#define GD_UD     0x20     // user data
+#define GD_TSS0   0x28     // Task segment selector for CPU 0
+
+/*
+ * Virtual memory map:                                Permissions
+ *                                                    kernel/user
+ *
+ *    4 Gig -------->  +------------------------------+
+ *                     |                              | RW/--
+ *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                     :              .               :
+ *                     :              .               :
+ *                     :              .               :
+ *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
+ *                     |                              | RW/--
+ *                     |   Remapped Physical Memory   | RW/--
+ *                     |                              | RW/--
+ *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
+ *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
+ *                     | - - - - - - - - - - - - - - -|                   |
+ *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
+ *                     +------------------------------+                   |
+ *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
+ *                     | - - - - - - - - - - - - - - -|                 PTSIZE
+ *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
+ *                     +------------------------------+                   |
+ *                     :              .               :                   |
+ *                     :              .               :                   |
+ *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
+ *                     |       Memory-mapped I/O      | RW/--  PTSIZE
+ * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
+ *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
+ *    UVPT      ---->  +------------------------------+ show
+ *                     |          RO PAGES            | R-/R-  PTSIZE
+ *    UPAGES    ---->  +------------------------------+ 0xef000000
+ *                     |           RO ENVS            | R-/R-  PTSIZE
+ * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
+ * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
+ *                     +------------------------------+ 0xeebff000
+ *                     |       Empty Memory (*)       | --/--  PGSIZE
+ *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
+ *                     |      Normal User Stack       | RW/RW  PGSIZE
+ *                     +------------------------------+ 0xeebfd000
+ *                     |                              |
+ *                     |                              |
+ *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                     .                              .
+ *                     .                              .
+ *                     .                              .
+ *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
+ *                     |     Program Data & Heap      |
+ *    UTEXT -------->  +------------------------------+ 0x00800000
+ *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
+ *                     |                              |
+ *    UTEMP -------->  +------------------------------+ 0x00400000      --+
+ *                     |       Empty Memory (*)       |                   |
+ *                     | - - - - - - - - - - - - - - -|                   |
+ *                     |  User STAB Data (optional)   |                 PTSIZE
+ *    USTABDATA ---->  +------------------------------+ 0x00200000        |
+ *                     |       Empty Memory (*)       |                   |
+ *    0 ------------>  +------------------------------+                 --+
+ *
+ * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
+ *     "Empty Memory" is normally unmapped, but user programs may map pages
+ *     there if desired.  JOS user programs map pages temporarily at UTEMP.
+ */
+
+
+// All physical memory mapped at this address
+#define	KERNBASE	0xF0000000
+
+// At IOPHYSMEM (640K) there is a 384K hole for I/O.  From the kernel,
+// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM.  The hole ends
+// at physical address EXTPHYSMEM.
+#define IOPHYSMEM	0x0A0000
+#define EXTPHYSMEM	0x100000
+
+// Kernel stack.
+#define KSTACKTOP	KERNBASE
+#define KSTKSIZE	(8*PGSIZE)   		// size of a kernel stack
+#define KSTKGAP		(8*PGSIZE)   		// size of a kernel stack guard
+
+// Memory-mapped IO.
+#define MMIOLIM		(KSTACKTOP - PTSIZE)
+#define MMIOBASE	(MMIOLIM - PTSIZE)
+
+#define ULIM		(MMIOBASE)
+
+/*
+ * User read-only mappings! Anything below here til UTOP are readonly to user.
+ * They are global pages mapped in at env allocation time.
+ */
+
+// User read-only virtual page table (see 'uvpt' below)
+#define UVPT		(ULIM - PTSIZE)
+// Read-only copies of the Page structures
+#define UPAGES		(UVPT - PTSIZE)
+// Read-only copies of the global env structures
+#define UENVS		(UPAGES - PTSIZE)
+
+/*
+ * Top of user VM. User can manipulate VA from UTOP-1 and down!
+ */
+
+// Top of user-accessible VM
+#define UTOP		UENVS
+// Top of one-page user exception stack
+#define UXSTACKTOP	UTOP
+// Next page left invalid to guard against exception stack overflow; then:
+// Top of normal user stack
+#define USTACKTOP	(UTOP - 2*PGSIZE)
+
+// Where user programs generally begin
+#define UTEXT		(2*PTSIZE)
+
+// Used for temporary page mappings.  Typed 'void*' for convenience
+#define UTEMP		((void*) PTSIZE)
+// Used for temporary page mappings for the user page-fault handler
+// (should not conflict with other temporary page mappings)
+#define PFTEMP		(UTEMP + PTSIZE - PGSIZE)
+// The location of the user-level STABS data structure
+#define USTABDATA	(PTSIZE / 2)
+
+#ifndef __ASSEMBLER__
+
+typedef uint32_t pte_t;
+typedef uint32_t pde_t;
+
+#if JOS_USER
+/*
+ * The page directory entry corresponding to the virtual address range
+ * [UVPT, UVPT + PTSIZE) points to the page directory itself.  Thus, the page
+ * directory is treated as a page table as well as a page directory.
+ *
+ * One result of treating the page directory as a page table is that all PTEs
+ * can be accessed through a "virtual page table" at virtual address UVPT (to
+ * which uvpt is set in lib/entry.S).  The PTE for page number N is stored in
+ * uvpt[N].  (It's worth drawing a diagram of this!)
+ *
+ * A second consequence is that the contents of the current page directory
+ * will always be available at virtual address (UVPT + (UVPT >> PGSHIFT)), to
+ * which uvpd is set in lib/entry.S.
+ */
+extern volatile pte_t uvpt[];     // VA of "virtual page table"
+extern volatile pde_t uvpd[];     // VA of current page directory
+#endif
+
+/*
+ * Page descriptor structures, mapped at UPAGES.
+ * Read/write to the kernel, read-only to user programs.
+ *
+ * Each struct PageInfo stores metadata for one physical page.
+ * Is it NOT the physical page itself, but there is a one-to-one
+ * correspondence between physical pages and struct PageInfo's.
+ * You can map a struct PageInfo * to the corresponding physical address
+ * with page2pa() in kern/pmap.h.
+ */
+struct PageInfo {
+	// Next page on the free list.
+	struct PageInfo *pp_link;
+
+	// pp_ref is the count of pointers (usually in page table entries)
+	// to this page, for pages allocated using page_alloc.
+	// Pages allocated at boot time using pmap.c's
+	// boot_alloc do not have valid reference count fields.
+
+	uint16_t pp_ref;
+};
+
+#endif /* !__ASSEMBLER__ */
+#endif /* !JOS_INC_MEMLAYOUT_H */
diff --git a/inc/stab.h~ b/inc/stab.h~
new file mode 100644
index 0000000..8153cec
--- /dev/null
+++ b/inc/stab.h~
@@ -0,0 +1,51 @@
+#ifndef JOS_STAB_H
+#define JOS_STAB_H
+#include <inc/types.h>
+
+// <inc/stab.h>
+// STABS debugging info
+
+// The JOS kernel debugger can understand some debugging information
+// in the STABS format.  For more information on this format, see
+// http://sourceware.org/gdb/onlinedocs/stabs.html
+
+// The constants below define some symbol types used by various debuggers
+// and compilers.  JOS uses the N_SO, N_SOL, N_FUN, and N_SLINE types.
+
+#define	N_GSYM		0x20	// global symbol
+#define	N_FNAME		0x22	// F77 function name
+#define	N_FUN		0x24	// procedure name
+#define	N_STSYM		0x26	// data segment variable
+#define	N_LCSYM		0x28	// bss segment variable
+#define	N_MAIN		0x2a	// main function name
+#define	N_PC		0x30	// global Pascal symbol
+#define	N_RSYM		0x40	// register variable
+#define	N_SLINE		0x44	// text segment line number
+#define	N_DSLINE	0x46	// data segment line number
+#define	N_BSLINE	0x48	// bss segment line number
+#define	N_SSYM		0x60	// structure/union element
+#define	N_SO		0x64	// main source file name
+#define	N_LSYM		0x80	// stack variable
+#define	N_BINCL		0x82	// include file beginning
+#define	N_SOL		0x84	// included source file name
+#define	N_PSYM		0xa0	// parameter variable
+#define	N_EINCL		0xa2	// include file end
+#define	N_ENTRY		0xa4	// alternate entry point
+#define	N_LBRAC		0xc0	// left bracket
+#define	N_EXCL		0xc2	// deleted include file
+#define	N_RBRAC		0xe0	// right bracket
+#define	N_BCOMM		0xe2	// begin common
+#define	N_ECOMM		0xe4	// end common
+#define	N_ECOML		0xe8	// end common (local name)
+#define	N_LENG		0xfe	// length of preceding entry
+
+// Entries in the STABS table are formatted as follows.
+struct Stab {
+	uint32_t n_strx;	// index into string table of name
+	uint8_t n_type;         // type of symbol
+	uint8_t n_other;        // misc info (usually empty)
+	uint16_t n_desc;        // description field
+	uintptr_t n_value;	// value of symbol
+};
+
+#endif /* !JOS_STAB_H */
diff --git a/inc/trap.h b/inc/trap.h
index b36aae3..58c1af7 100644
--- a/inc/trap.h
+++ b/inc/trap.h
@@ -88,4 +88,4 @@ struct UTrapframe {
 
 #endif /* !__ASSEMBLER__ */
 
-#endif /* !JOS_INC_TRAP_H */
+#endif /* !JOS_INC_TRAP_f */
diff --git a/inc/trap.h~ b/inc/trap.h~
new file mode 100644
index 0000000..c3437af
--- /dev/null
+++ b/inc/trap.h~
@@ -0,0 +1,80 @@
+#ifndef JOS_INC_TRAP_H
+#define JOS_INC_TRAP_H
+
+// Trap numbers
+// These are processor defined:
+#define T_DIVIDE     0		// divide error
+#define T_DEBUG      1		// debug exception
+#define T_NMI        2		// non-maskable interrupt
+#define T_BRKPT      3		// breakpoint
+#define T_OFLOW      4		// overflow
+#define T_BOUND      5		// bounds check
+#define T_ILLOP      6		// illegal opcode
+#define T_DEVICE     7		// device not available
+#define T_DBLFLT     8		// double fault
+/* #define T_COPROC  9 */	// reserved (not generated by recent processors)
+#define T_TSS       10		// invalid task switch segment
+#define T_SEGNP     11		// segment not present
+#define T_STACK     12		// stack exception
+#define T_GPFLT     13		// general protection fault
+#define T_PGFLT     14		// page fault
+/* #define T_RES    15 */	// reserved
+#define T_FPERR     16		// floating point error
+#define T_ALIGN     17		// aligment check
+#define T_MCHK      18		// machine check
+#define T_SIMDERR   19		// SIMD floating point error
+
+// These are arbitrarily chosen, but with care not to overlap
+// processor defined exceptions or interrupt vectors.
+#define T_SYSCALL   48		// system call
+#define T_DEFAULT   500		// catchall
+
+#define IRQ_OFFSET	32	// IRQ 0 corresponds to int IRQ_OFFSET
+
+// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)
+#define IRQ_TIMER        0
+#define IRQ_KBD          1
+#define IRQ_SERIAL       4
+#define IRQ_SPURIOUS     7
+#define IRQ_IDE         14
+#define IRQ_ERROR       19
+
+#ifndef __ASSEMBLER__
+
+#include <inc/types.h>
+
+struct PushRegs {
+	/* registers as pushed by pusha */
+	uint32_t reg_edi;
+	uint32_t reg_esi;
+	uint32_t reg_ebp;
+	uint32_t reg_oesp;		/* Useless */
+	uint32_t reg_ebx;
+	uint32_t reg_edx;
+	uint32_t reg_ecx;
+	uint32_t reg_eax;
+} __attribute__((packed));
+
+struct Trapframe {
+	struct PushRegs tf_regs;
+	uint16_t tf_es;
+	uint16_t tf_padding1;
+	uint16_t tf_ds;
+	uint16_t tf_padding2;
+	uint32_t tf_trapno;
+	/* below here defined by x86 hardware */
+	uint32_t tf_err;
+	uintptr_t tf_eip;
+	uint16_t tf_cs;
+	uint16_t tf_padding3;
+	uint32_t tf_eflags;
+	/* below here only when crossing rings, such as from user to kernel */
+	uintptr_t tf_esp;
+	uint16_t tf_ss;
+	uint16_t tf_padding4;
+} __attribute__((packed));
+
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* !JOS_INC_TRAP_H */
diff --git a/inc/x86.h b/inc/x86.h
index cc15ff4..d56bdee 100644
--- a/inc/x86.h
+++ b/inc/x86.h
@@ -1,6 +1,6 @@
 #ifndef JOS_INC_X86_H
 #define JOS_INC_X86_H
-
+#include <inc/stdio.h>
 #include <inc/types.h>
 
 static inline void
@@ -63,7 +63,7 @@ insl(int port, void *addr, int cnt)
 static inline void
 outb(int port, uint8_t data)
 {
-	asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
+    asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
 }
 
 static inline void
diff --git a/jos.out b/jos.out
new file mode 100644
index 0000000..644d54e
--- /dev/null
+++ b/jos.out
@@ -0,0 +1,365 @@
++ ld obj/kern/kernel
++ mk obj/kern/kernel.img
+6828 decimal is 15254 octal!
+Physical memory: 131072K available, base = 640K, extended = 130432K
+check_page_free_list() succeeded!
+check_page_alloc() succeeded!
+check_page() succeeded!
+check_kern_pgdir() succeeded!
+check_page_free_list() succeeded!
+check_page_installed_pgdir() succeeded!
+SMP: CPU 0 found 1 CPU(s)
+enabled interrupts: 1 2 4
+[00000000] new env 00001000
+[00000000] new env 00001001
+FS is running
+FS can do I/O
+Device 1 presence: 1
+[00001001] new env 00001002
+2
+[00001002] new env 00001003
+3
+[00001003] new env 00001004
+5
+[00001004] new env 00001005
+7
+[00001005] new env 00001006
+11
+[00001006] new env 00001007
+13
+[00001007] new env 00001008
+17
+block cache is good
+superblock is good
+bitmap is good
+alloc_block is good
+[00001008] new env 00001009
+19
+[00001009] new env 0000100a
+file_open is good
+23
+[0000100a] new env 0000100b
+29
+[0000100b] new env 0000100c
+31
+[0000100c] new env 0000100d
+37
+[0000100d] new env 0000100e
+41
+[0000100e] new env 0000100f
+file_get_block is good
+file_flush is good
+43
+[0000100f] new env 00001010
+47
+[00001010] new env 00001011
+file_truncate is good
+53
+[00001011] new env 00001012
+59
+[00001012] new env 00001013
+61
+[00001013] new env 00001014
+file rewrite is good
+67
+[00001014] new env 00001015
+71
+[00001015] new env 00001016
+73
+[00001016] new env 00001017
+79
+[00001017] new env 00001018
+83
+[00001018] new env 00001019
+89
+[00001019] new env 0000101a
+97
+[0000101a] new env 0000101b
+101
+[0000101b] new env 0000101c
+103
+[0000101c] new env 0000101d
+107
+[0000101d] new env 0000101e
+109
+[0000101e] new env 0000101f
+113
+[0000101f] new env 00001020
+127
+[00001020] new env 00001021
+131
+[00001021] new env 00001022
+137
+[00001022] new env 00001023
+139
+[00001023] new env 00001024
+149
+[00001024] new env 00001025
+151
+[00001025] new env 00001026
+157
+[00001026] new env 00001027
+163
+[00001027] new env 00001028
+167
+[00001028] new env 00001029
+173
+[00001029] new env 0000102a
+179
+[0000102a] new env 0000102b
+181
+[0000102b] new env 0000102c
+191
+[0000102c] new env 0000102d
+193
+[0000102d] new env 0000102e
+197
+[0000102e] new env 0000102f
+199
+[0000102f] new env 00001030
+211
+[00001030] new env 00001031
+223
+[00001031] new env 00001032
+227
+[00001032] new env 00001033
+229
+[00001033] new env 00001034
+233
+[00001034] new env 00001035
+239
+[00001035] new env 00001036
+241
+[00001036] new env 00001037
+251
+[00001037] new env 00001038
+257
+[00001038] new env 00001039
+263
+[00001039] new env 0000103a
+269
+[0000103a] new env 0000103b
+271
+[0000103b] new env 0000103c
+277
+[0000103c] new env 0000103d
+281
+[0000103d] new env 0000103e
+283
+[0000103e] new env 0000103f
+293
+[0000103f] new env 00001040
+307
+[00001040] new env 00001041
+311
+[00001041] new env 00001042
+313
+[00001042] new env 00001043
+317
+[00001043] new env 00001044
+331
+[00001044] new env 00001045
+337
+[00001045] new env 00001046
+347
+[00001046] new env 00001047
+349
+[00001047] new env 00001048
+353
+[00001048] new env 00001049
+359
+[00001049] new env 0000104a
+367
+[0000104a] new env 0000104b
+373
+[0000104b] new env 0000104c
+379
+[0000104c] new env 0000104d
+383
+[0000104d] new env 0000104e
+389
+[0000104e] new env 0000104f
+397
+[0000104f] new env 00001050
+401
+[00001050] new env 00001051
+409
+[00001051] new env 00001052
+419
+[00001052] new env 00001053
+421
+[00001053] new env 00001054
+431
+[00001054] new env 00001055
+433
+[00001055] new env 00001056
+439
+[00001056] new env 00001057
+443
+[00001057] new env 00001058
+449
+[00001058] new env 00001059
+457
+[00001059] new env 0000105a
+461
+[0000105a] new env 0000105b
+463
+[0000105b] new env 0000105c
+467
+[0000105c] new env 0000105d
+479
+[0000105d] new env 0000105e
+487
+[0000105e] new env 0000105f
+491
+[0000105f] new env 00001060
+499
+[00001060] new env 00001061
+503
+[00001061] new env 00001062
+509
+[00001062] new env 00001063
+521
+[00001063] new env 00001064
+523
+[00001064] new env 00001065
+541
+[00001065] new env 00001066
+547
+[00001066] new env 00001067
+557
+[00001067] new env 00001068
+563
+[00001068] new env 00001069
+569
+[00001069] new env 0000106a
+571
+[0000106a] new env 0000106b
+577
+[0000106b] new env 0000106c
+587
+[0000106c] new env 0000106d
+593
+[0000106d] new env 0000106e
+599
+[0000106e] new env 0000106f
+601
+[0000106f] new env 00001070
+607
+[00001070] new env 00001071
+613
+[00001071] new env 00001072
+617
+[00001072] new env 00001073
+619
+[00001073] new env 00001074
+631
+[00001074] new env 00001075
+641
+[00001075] new env 00001076
+643
+[00001076] new env 00001077
+647
+[00001077] new env 00001078
+653
+[00001078] new env 00001079
+659
+[00001079] new env 0000107a
+661
+[0000107a] new env 0000107b
+673
+[0000107b] new env 0000107c
+677
+[0000107c] new env 0000107d
+683
+[0000107d] new env 0000107e
+691
+[0000107e] new env 0000107f
+701
+[0000107f] new env 00001080
+709
+[00001080] new env 00001081
+719
+[00001081] new env 00001082
+727
+[00001082] new env 00001083
+733
+[00001083] new env 00001084
+739
+[00001084] new env 00001085
+743
+[00001085] new env 00001086
+751
+[00001086] new env 00001087
+757
+[00001087] new env 00001088
+761
+[00001088] new env 00001089
+769
+[00001089] new env 0000108a
+773
+[0000108a] new env 0000108b
+787
+[0000108b] new env 0000108c
+797
+[0000108c] new env 0000108d
+809
+[0000108d] new env 0000108e
+811
+[0000108e] new env 0000108f
+821
+[0000108f] new env 00001090
+823
+[00001090] new env 00001091
+827
+[00001091] new env 00001092
+829
+[00001092] new env 00001093
+839
+[00001093] new env 00001094
+853
+[00001094] new env 00001095
+857
+[00001095] new env 00001096
+859
+[00001096] new env 00001097
+863
+[00001097] new env 00001098
+877
+[00001098] new env 00001099
+881
+[00001099] new env 0000109a
+883
+[0000109a] new env 0000109b
+887
+[0000109b] new env 0000109c
+907
+[0000109c] new env 0000109d
+911
+[0000109d] new env 0000109e
+919
+[0000109e] new env 0000109f
+929
+[0000109f] new env 000010a0
+937
+[000010a0] new env 000010a1
+941
+[000010a1] new env 000010a2
+947
+[000010a2] new env 000010a3
+953
+[000010a3] new env 000010a4
+967
+[000010a4] new env 000010a5
+971
+[000010a5] new env 000010a6
+977
+[000010a6] new env 000010a7
+983
+[000010a7] new env 000010a8
+991
+[000010a8] new env 000010a9
+997
+[000010a9] new env 000010aa
+1009
+qemu: terminating on signal 15 from pid 24975
diff --git a/kern/.pmap.c.swp b/kern/.pmap.c.swp
new file mode 100644
index 0000000..efcbb66
Binary files /dev/null and b/kern/.pmap.c.swp differ
diff --git a/kern/console.c b/kern/console.c
index dad94fd..513b271 100644
--- a/kern/console.c
+++ b/kern/console.c
@@ -5,6 +5,7 @@
 #include <inc/kbdreg.h>
 #include <inc/string.h>
 #include <inc/assert.h>
+#include <inc/color.h>
 
 #include <kern/console.h>
 #include <kern/trap.h>
@@ -169,8 +170,7 @@ cga_putc(int c)
 {
 	// if no attribute given, then use black on white
 	if (!(c & ~0xFF))
-		c |= 0x0700;
-
+	   	c |= COLOR;
 	switch (c & 0xff) {
 	case '\b':
 		if (crt_pos > 0) {
@@ -196,7 +196,7 @@ cga_putc(int c)
 		break;
 	}
 
-	// What is the purpose of this?
+	// What is the purpose of this? sol: lab 1 report P15
 	if (crt_pos >= CRT_SIZE) {
 		int i;
 
diff --git a/kern/console.c~ b/kern/console.c~
new file mode 100644
index 0000000..ff1ffad
--- /dev/null
+++ b/kern/console.c~
@@ -0,0 +1,476 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/x86.h>
+#include <inc/memlayout.h>
+#include <inc/kbdreg.h>
+#include <inc/string.h>
+#include <inc/assert.h>
+#include <inc/color.h>
+
+#include <kern/console.h>
+
+static void cons_intr(int (*proc)(void));
+static void cons_putc(int c);
+
+// Stupid I/O delay routine necessitated by historical PC design flaws
+static void
+delay(void)
+{
+	inb(0x84);
+	inb(0x84);
+	inb(0x84);
+	inb(0x84);
+}
+
+/***** Serial I/O code *****/
+
+#define COM1		0x3F8
+
+#define COM_RX		0	// In:	Receive buffer (DLAB=0)
+#define COM_TX		0	// Out: Transmit buffer (DLAB=0)
+#define COM_DLL		0	// Out: Divisor Latch Low (DLAB=1)
+#define COM_DLM		1	// Out: Divisor Latch High (DLAB=1)
+#define COM_IER		1	// Out: Interrupt Enable Register
+#define   COM_IER_RDI	0x01	//   Enable receiver data interrupt
+#define COM_IIR		2	// In:	Interrupt ID Register
+#define COM_FCR		2	// Out: FIFO Control Register
+#define COM_LCR		3	// Out: Line Control Register
+#define	  COM_LCR_DLAB	0x80	//   Divisor latch access bit
+#define	  COM_LCR_WLEN8	0x03	//   Wordlength: 8 bits
+#define COM_MCR		4	// Out: Modem Control Register
+#define	  COM_MCR_RTS	0x02	// RTS complement
+#define	  COM_MCR_DTR	0x01	// DTR complement
+#define	  COM_MCR_OUT2	0x08	// Out2 complement
+#define COM_LSR		5	// In:	Line Status Register
+#define   COM_LSR_DATA	0x01	//   Data available
+#define   COM_LSR_TXRDY	0x20	//   Transmit buffer avail
+#define   COM_LSR_TSRE	0x40	//   Transmitter off
+
+static bool serial_exists;
+
+static int
+serial_proc_data(void)
+{
+	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
+		return -1;
+	return inb(COM1+COM_RX);
+}
+
+void
+serial_intr(void)
+{
+	if (serial_exists)
+		cons_intr(serial_proc_data);
+}
+
+static void
+serial_putc(int c)
+{
+	int i;
+
+	for (i = 0;
+	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
+	     i++)
+		delay();
+
+	outb(COM1 + COM_TX, c);
+}
+
+static void
+serial_init(void)
+{
+	// Turn off the FIFO
+	outb(COM1+COM_FCR, 0);
+
+	// Set speed; requires DLAB latch
+	outb(COM1+COM_LCR, COM_LCR_DLAB);
+	outb(COM1+COM_DLL, (uint8_t) (115200 / 9600));
+	outb(COM1+COM_DLM, 0);
+
+	// 8 data bits, 1 stop bit, parity off; turn off DLAB latch
+	outb(COM1+COM_LCR, COM_LCR_WLEN8 & ~COM_LCR_DLAB);
+
+	// No modem controls
+	outb(COM1+COM_MCR, 0);
+	// Enable rcv interrupts
+	outb(COM1+COM_IER, COM_IER_RDI);
+
+	// Clear any preexisting overrun indications and interrupts
+	// Serial port doesn't exist if COM_LSR returns 0xFF
+	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
+	(void) inb(COM1+COM_IIR);
+	(void) inb(COM1+COM_RX);
+
+}
+
+
+
+/***** Parallel port output code *****/
+// For information on PC parallel port programming, see the class References
+// page.
+
+static void
+lpt_putc(int c)
+{
+	int i;
+
+	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
+		delay();
+	outb(0x378+0, c);
+	outb(0x378+2, 0x08|0x04|0x01);
+	outb(0x378+2, 0x08);
+}
+
+
+
+
+/***** Text-mode CGA/VGA display output *****/
+
+static unsigned addr_6845;
+static uint16_t *crt_buf;
+static uint16_t crt_pos;
+
+static void
+cga_init(void)
+{
+	volatile uint16_t *cp;
+	uint16_t was;
+	unsigned pos;
+
+	cp = (uint16_t*) (KERNBASE + CGA_BUF);
+	was = *cp;
+	*cp = (uint16_t) 0xA55A;
+	if (*cp != 0xA55A) {
+		cp = (uint16_t*) (KERNBASE + MONO_BUF);
+		addr_6845 = MONO_BASE;
+	} else {
+		*cp = was;
+		addr_6845 = CGA_BASE;
+	}
+
+	/* Extract cursor location */
+	outb(addr_6845, 14);
+	pos = inb(addr_6845 + 1) << 8;
+	outb(addr_6845, 15);
+	pos |= inb(addr_6845 + 1);
+
+	crt_buf = (uint16_t*) cp;
+	crt_pos = pos;
+}
+
+
+
+static void
+cga_putc(int c)
+{
+	// if no attribute given, then use black on white
+	if (!(c & ~0xFF))
+	   	c |= COLOR;
+	switch (c & 0xff) {
+	case '\b':
+		if (crt_pos > 0) {
+			crt_pos--;
+			crt_buf[crt_pos] = (c & ~0xff) | ' ';
+		}
+		break;
+	case '\n':
+		crt_pos += CRT_COLS;
+		/* fallthru */
+	case '\r':
+		crt_pos -= (crt_pos % CRT_COLS);
+		break;
+	case '\t':
+		cons_putc(' ');
+		cons_putc(' ');
+		cons_putc(' ');
+		cons_putc(' ');
+		cons_putc(' ');
+		break;
+	default:
+		crt_buf[crt_pos++] = c;		/* write the character */
+		break;
+	}
+
+	// What is the purpose of this? sol: lab 1 report P15
+	if (crt_pos >= CRT_SIZE) {
+		int i;
+
+		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
+			crt_buf[i] = 0x0700 | ' ';
+		crt_pos -= CRT_COLS;
+	}
+
+	/* move that little blinky thing */
+	outb(addr_6845, 14);
+	outb(addr_6845 + 1, crt_pos >> 8);
+	outb(addr_6845, 15);
+	outb(addr_6845 + 1, crt_pos);
+}
+
+
+/***** Keyboard input code *****/
+
+#define NO		0
+
+#define SHIFT		(1<<0)
+#define CTL		(1<<1)
+#define ALT		(1<<2)
+
+#define CAPSLOCK	(1<<3)
+#define NUMLOCK		(1<<4)
+#define SCROLLLOCK	(1<<5)
+
+#define E0ESC		(1<<6)
+
+static uint8_t shiftcode[256] =
+{
+	[0x1D] = CTL,
+	[0x2A] = SHIFT,
+	[0x36] = SHIFT,
+	[0x38] = ALT,
+	[0x9D] = CTL,
+	[0xB8] = ALT
+};
+
+static uint8_t togglecode[256] =
+{
+	[0x3A] = CAPSLOCK,
+	[0x45] = NUMLOCK,
+	[0x46] = SCROLLLOCK
+};
+
+static uint8_t normalmap[256] =
+{
+	NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',	// 0x00
+	'7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+	'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',	// 0x10
+	'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+	'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',	// 0x20
+	'\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+	'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',	// 0x30
+	NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+	NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',	// 0x40
+	'8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+	'2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,	// 0x50
+	[0xC7] = KEY_HOME,	      [0x9C] = '\n' /*KP_Enter*/,
+	[0xB5] = '/' /*KP_Div*/,      [0xC8] = KEY_UP,
+	[0xC9] = KEY_PGUP,	      [0xCB] = KEY_LF,
+	[0xCD] = KEY_RT,	      [0xCF] = KEY_END,
+	[0xD0] = KEY_DN,	      [0xD1] = KEY_PGDN,
+	[0xD2] = KEY_INS,	      [0xD3] = KEY_DEL
+};
+
+static uint8_t shiftmap[256] =
+{
+	NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',	// 0x00
+	'&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+	'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',	// 0x10
+	'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+	'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',	// 0x20
+	'"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+	'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',	// 0x30
+	NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+	NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',	// 0x40
+	'8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+	'2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,	// 0x50
+	[0xC7] = KEY_HOME,	      [0x9C] = '\n' /*KP_Enter*/,
+	[0xB5] = '/' /*KP_Div*/,      [0xC8] = KEY_UP,
+	[0xC9] = KEY_PGUP,	      [0xCB] = KEY_LF,
+	[0xCD] = KEY_RT,	      [0xCF] = KEY_END,
+	[0xD0] = KEY_DN,	      [0xD1] = KEY_PGDN,
+	[0xD2] = KEY_INS,	      [0xD3] = KEY_DEL
+};
+
+#define C(x) (x - '@')
+
+static uint8_t ctlmap[256] =
+{
+	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+	C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+	C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+	C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+	NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+	C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+	[0x97] = KEY_HOME,
+	[0xB5] = C('/'),		[0xC8] = KEY_UP,
+	[0xC9] = KEY_PGUP,		[0xCB] = KEY_LF,
+	[0xCD] = KEY_RT,		[0xCF] = KEY_END,
+	[0xD0] = KEY_DN,		[0xD1] = KEY_PGDN,
+	[0xD2] = KEY_INS,		[0xD3] = KEY_DEL
+};
+
+static uint8_t *charcode[4] = {
+	normalmap,
+	shiftmap,
+	ctlmap,
+	ctlmap
+};
+
+/*
+ * Get data from the keyboard.  If we finish a character, return it.  Else 0.
+ * Return -1 if no data.
+ */
+static int
+kbd_proc_data(void)
+{
+	int c;
+	uint8_t stat, data;
+	static uint32_t shift;
+
+	stat = inb(KBSTATP);
+	if ((stat & KBS_DIB) == 0)
+		return -1;
+	// Ignore data from mouse.
+	if (stat & KBS_TERR)
+		return -1;
+
+	data = inb(KBDATAP);
+
+	if (data == 0xE0) {
+		// E0 escape character
+		shift |= E0ESC;
+		return 0;
+	} else if (data & 0x80) {
+		// Key released
+		data = (shift & E0ESC ? data : data & 0x7F);
+		shift &= ~(shiftcode[data] | E0ESC);
+		return 0;
+	} else if (shift & E0ESC) {
+		// Last character was an E0 escape; or with 0x80
+		data |= 0x80;
+		shift &= ~E0ESC;
+	}
+
+	shift |= shiftcode[data];
+	shift ^= togglecode[data];
+
+	c = charcode[shift & (CTL | SHIFT)][data];
+	if (shift & CAPSLOCK) {
+		if ('a' <= c && c <= 'z')
+			c += 'A' - 'a';
+		else if ('A' <= c && c <= 'Z')
+			c += 'a' - 'A';
+	}
+
+	// Process special keys
+	// Ctrl-Alt-Del: reboot
+	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+		cprintf("Rebooting!\n");
+		outb(0x92, 0x3); // courtesy of Chris Frost
+	}
+
+	return c;
+}
+
+void
+kbd_intr(void)
+{
+	cons_intr(kbd_proc_data);
+}
+
+static void
+kbd_init(void)
+{
+}
+
+
+
+/***** General device-independent console code *****/
+// Here we manage the console input buffer,
+// where we stash characters received from the keyboard or serial port
+// whenever the corresponding interrupt occurs.
+
+#define CONSBUFSIZE 512
+
+static struct {
+	uint8_t buf[CONSBUFSIZE];
+	uint32_t rpos;
+	uint32_t wpos;
+} cons;
+
+// called by device interrupt routines to feed input characters
+// into the circular console input buffer.
+static void
+cons_intr(int (*proc)(void))
+{
+	int c;
+
+	while ((c = (*proc)()) != -1) {
+		if (c == 0)
+			continue;
+		cons.buf[cons.wpos++] = c;
+		if (cons.wpos == CONSBUFSIZE)
+			cons.wpos = 0;
+	}
+}
+
+// return the next input character from the console, or 0 if none waiting
+int
+cons_getc(void)
+{
+	int c;
+
+	// poll for any pending input characters,
+	// so that this function works even when interrupts are disabled
+	// (e.g., when called from the kernel monitor).
+	serial_intr();
+	kbd_intr();
+
+	// grab the next character from the input buffer.
+	if (cons.rpos != cons.wpos) {
+		c = cons.buf[cons.rpos++];
+		if (cons.rpos == CONSBUFSIZE)
+			cons.rpos = 0;
+		return c;
+	}
+	return 0;
+}
+
+// output a character to the console
+static void
+cons_putc(int c)
+{
+	serial_putc(c);
+	lpt_putc(c);
+	cga_putc(c);
+}
+
+// initialize the console devices
+void
+cons_init(void)
+{
+	cga_init();
+	kbd_init();
+	serial_init();
+
+	if (!serial_exists)
+		cprintf("Serial port does not exist!\n");
+}
+
+
+// `High'-level console I/O.  Used by readline and cprintf.
+
+void
+cputchar(int c)
+{
+	cons_putc(c);
+}
+
+int
+getchar(void)
+{
+	int c;
+
+	while ((c = cons_getc()) == 0)
+		/* do nothing */;
+	return c;
+}
+
+int
+iscons(int fdnum)
+{
+	// used by readline
+	return 1;
+}
diff --git a/kern/env.c b/kern/env.c
index 5771aa5..3447d24 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -17,7 +17,7 @@
 
 struct Env *envs = NULL;		// All environments
 static struct Env *env_free_list;	// Free environment list
-					// (linked by Env->env_link)
+// (linked by Env->env_link)
 
 #define ENVGENSHIFT	12		// >= LOGNENV
 
@@ -38,28 +38,28 @@ static struct Env *env_free_list;	// Free environment list
 //
 struct Segdesc gdt[NCPU + 5] =
 {
-	// 0x0 - unused (always faults -- for trapping NULL far pointers)
-	SEG_NULL,
+    // 0x0 - unused (always faults -- for trapping NULL far pointers)
+    SEG_NULL,
 
-	// 0x8 - kernel code segment
-	[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),
+    // 0x8 - kernel code segment
+    [GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),
 
-	// 0x10 - kernel data segment
-	[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),
+    // 0x10 - kernel data segment
+    [GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),
 
-	// 0x18 - user code segment
-	[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),
+    // 0x18 - user code segment
+    [GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),
 
-	// 0x20 - user data segment
-	[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),
+    // 0x20 - user data segment
+    [GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),
 
-	// Per-CPU TSS descriptors (starting from GD_TSS0) are initialized
-	// in trap_init_percpu()
-	[GD_TSS0 >> 3] = SEG_NULL
+    // Per-CPU TSS descriptors (starting from GD_TSS0) are initialized
+    // in trap_init_percpu()
+    [GD_TSS0 >> 3] = SEG_NULL
 };
 
 struct Pseudodesc gdt_pd = {
-	sizeof(gdt) - 1, (unsigned long) gdt
+    sizeof(gdt) - 1, (unsigned long) gdt
 };
 
 //
@@ -72,40 +72,40 @@ struct Pseudodesc gdt_pd = {
 //   On success, sets *env_store to the environment.
 //   On error, sets *env_store to NULL.
 //
-int
+    int
 envid2env(envid_t envid, struct Env **env_store, bool checkperm)
 {
-	struct Env *e;
+    struct Env *e;
 
-	// If envid is zero, return the current environment.
-	if (envid == 0) {
-		*env_store = curenv;
-		return 0;
-	}
-
-	// Look up the Env structure via the index part of the envid,
-	// then check the env_id field in that struct Env
-	// to ensure that the envid is not stale
-	// (i.e., does not refer to a _previous_ environment
-	// that used the same slot in the envs[] array).
-	e = &envs[ENVX(envid)];
-	if (e->env_status == ENV_FREE || e->env_id != envid) {
-		*env_store = 0;
-		return -E_BAD_ENV;
-	}
-
-	// Check that the calling environment has legitimate permission
-	// to manipulate the specified environment.
-	// If checkperm is set, the specified environment
-	// must be either the current environment
-	// or an immediate child of the current environment.
-	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
-		*env_store = 0;
-		return -E_BAD_ENV;
-	}
-
-	*env_store = e;
+    // If envid is zero, return the current environment.
+    if (envid == 0) {
+	*env_store = curenv;
 	return 0;
+    }
+
+    // Look up the Env structure via the index part of the envid,
+    // then check the env_id field in that struct Env
+    // to ensure that the envid is not stale
+    // (i.e., does not refer to a _previous_ environment
+    // that used the same slot in the envs[] array).
+    e = &envs[ENVX(envid)];
+    if (e->env_status == ENV_FREE || e->env_id != envid) {
+	*env_store = 0;
+	return -E_BAD_ENV;
+    }
+
+    // Check that the calling environment has legitimate permission
+    // to manipulate the specified environment.
+    // If checkperm is set, the specified environment
+    // must be either the current environment
+    // or an immediate child of the current environment.
+    if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
+	*env_store = 0;
+	return -E_BAD_ENV;
+    }
+
+    *env_store = e;
+    return 0;
 }
 
 // Mark all environments in 'envs' as free, set their env_ids to 0,
@@ -114,37 +114,57 @@ envid2env(envid_t envid, struct Env **env_store, bool checkperm)
 // they are in the envs array (i.e., so that the first call to
 // env_alloc() returns envs[0]).
 //
-void
+    void
 env_init(void)
 {
-	// Set up envs array
-	// LAB 3: Your code here.
-
-	// Per-CPU part of the initialization
-	env_init_percpu();
+    // Set up envs array
+    // LAB 3: Your code here.
+    int i;
+    env_free_list = NULL;
+    for (i = NENV - 1; i >= 0; i--) {
+	envs[i].env_id = 0;
+	envs[i].env_link = env_free_list;
+	env_free_list = &(envs[i]);
+    }
+
+    // Per-CPU part of the initialization
+    env_init_percpu();
 }
 
 // Load GDT and segment descriptors.
-void
+    void
 env_init_percpu(void)
 {
-	lgdt(&gdt_pd);
-	// The kernel never uses GS or FS, so we leave those set to
-	// the user data segment.
-	asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
-	asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
-	// The kernel does use ES, DS, and SS.  We'll change between
-	// the kernel and user data segments as needed.
-	asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
-	asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
-	asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
-	// Load the kernel text segment into CS.
-	asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
-	// For good measure, clear the local descriptor table (LDT),
-	// since we don't use it.
-	lldt(0);
+    lgdt(&gdt_pd);
+    // The kernel never uses GS or FS, so we leave those set to
+    // the user data segment.
+    asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
+    asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
+    // The kernel does use ES, DS, and SS.  We'll change between
+    // the kernel and user data segments as needed.
+    asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
+    asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
+    asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
+    // Load the kernel text segment into CS.
+    asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
+    // For good measure, clear the local descriptor table (LDT),
+    // since we don't use it.
+    lldt(0);
+}
+
+
+
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
 }
 
+
 //
 // Initialize the kernel virtual memory layout for environment e.
 // Allocate a page directory, set e->env_pgdir accordingly,
@@ -155,39 +175,44 @@ env_init_percpu(void)
 // Returns 0 on success, < 0 on error.  Errors include:
 //	-E_NO_MEM if page directory or table could not be allocated.
 //
-static int
+    static int
 env_setup_vm(struct Env *e)
 {
-	int i;
-	struct PageInfo *p = NULL;
-
-	// Allocate a page for the page directory
-	if (!(p = page_alloc(ALLOC_ZERO)))
-		return -E_NO_MEM;
-
-	// Now, set e->env_pgdir and initialize the page directory.
-	//
-	// Hint:
-	//    - The VA space of all envs is identical above UTOP
-	//	(except at UVPT, which we've set below).
-	//	See inc/memlayout.h for permissions and layout.
-	//	Can you use kern_pgdir as a template?  Hint: Yes.
-	//	(Make sure you got the permissions right in Lab 2.)
-	//    - The initial VA below UTOP is empty.
-	//    - You do not need to make any more calls to page_alloc.
-	//    - Note: In general, pp_ref is not maintained for
-	//	physical pages mapped only above UTOP, but env_pgdir
-	//	is an exception -- you need to increment env_pgdir's
-	//	pp_ref for env_free to work correctly.
-	//    - The functions in kern/pmap.h are handy.
-
-	// LAB 3: Your code here.
-
-	// UVPT maps the env's own page table read-only.
-	// Permissions: kernel R, user R
-	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
-
-	return 0;
+    int i;
+    struct PageInfo *p = NULL;
+
+    // Allocate a page for the page directory
+    if (!(p = page_alloc(ALLOC_ZERO)))
+	return -E_NO_MEM;
+
+    // Now, set e->env_pgdir and initialize the page directory.
+    //
+    // Hint:
+    //    - The VA space of all envs is identical above UTOP
+    //	(except at UVPT, which we've set below).
+    //	See inc/memlayout.h for permissions and layout.
+    //	Can you use kern_pgdir as a template?  Hint: Yes.
+    //	(Make sure you got the permissions right in Lab 2.)
+    //    - The initial VA below UTOP is empty.
+    //    - You do not need to make any more calls to page_alloc.
+    //    - Note: In general, pp_ref is not maintained for
+    //	physical pages mapped only above UTOP, but env_pgdir
+    //	is an exception -- you need to increment env_pgdir's
+    //	pp_ref for env_free to work correctly.
+    //    - The functions in kern/pmap.h are handy.
+
+    // LAB 3: Your code here.
+    e->env_pgdir = (pde_t*)page2kva(p);
+    memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
+    memset(e->env_pgdir, 0, PDX(UTOP) * sizeof(pte_t));
+    p->pp_ref++;
+
+
+    // UVPT maps the env's own page table read-only.
+    // Permissions: kernel R, user R
+    e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+
+    return 0;
 }
 
 //
@@ -198,68 +223,70 @@ env_setup_vm(struct Env *e)
 //	-E_NO_FREE_ENV if all NENVS environments are allocated
 //	-E_NO_MEM on memory exhaustion
 //
-int
+    int
 env_alloc(struct Env **newenv_store, envid_t parent_id)
 {
-	int32_t generation;
-	int r;
-	struct Env *e;
-
-	if (!(e = env_free_list))
-		return -E_NO_FREE_ENV;
-
-	// Allocate and set up the page directory for this environment.
-	if ((r = env_setup_vm(e)) < 0)
-		return r;
-
-	// Generate an env_id for this environment.
-	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
-	if (generation <= 0)	// Don't create a negative env_id.
-		generation = 1 << ENVGENSHIFT;
-	e->env_id = generation | (e - envs);
-
-	// Set the basic status variables.
-	e->env_parent_id = parent_id;
-	e->env_type = ENV_TYPE_USER;
-	e->env_status = ENV_RUNNABLE;
-	e->env_runs = 0;
-
-	// Clear out all the saved register state,
-	// to prevent the register values
-	// of a prior environment inhabiting this Env structure
-	// from "leaking" into our new environment.
-	memset(&e->env_tf, 0, sizeof(e->env_tf));
-
-	// Set up appropriate initial values for the segment registers.
-	// GD_UD is the user data segment selector in the GDT, and
-	// GD_UT is the user text segment selector (see inc/memlayout.h).
-	// The low 2 bits of each segment register contains the
-	// Requestor Privilege Level (RPL); 3 means user mode.  When
-	// we switch privilege levels, the hardware does various
-	// checks involving the RPL and the Descriptor Privilege Level
-	// (DPL) stored in the descriptors themselves.
-	e->env_tf.tf_ds = GD_UD | 3;
-	e->env_tf.tf_es = GD_UD | 3;
-	e->env_tf.tf_ss = GD_UD | 3;
-	e->env_tf.tf_esp = USTACKTOP;
-	e->env_tf.tf_cs = GD_UT | 3;
-	// You will set e->env_tf.tf_eip later.
-
-	// Enable interrupts while in user mode.
-	// LAB 4: Your code here.
-
-	// Clear the page fault handler until user installs one.
-	e->env_pgfault_upcall = 0;
-
-	// Also clear the IPC receiving flag.
-	e->env_ipc_recving = 0;
-
-	// commit the allocation
-	env_free_list = e->env_link;
-	*newenv_store = e;
-
-	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
-	return 0;
+    int32_t generation;
+    int r;
+    struct Env *e;
+
+    if (!(e = env_free_list))
+	return -E_NO_FREE_ENV;
+
+    // Allocate and set up the page directory for this environment.
+    if ((r = env_setup_vm(e)) < 0)
+	return r;
+
+    // Generate an env_id for this environment.
+    generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+    if (generation <= 0)	// Don't create a negative env_id.
+	generation = 1 << ENVGENSHIFT;
+    e->env_id = generation | (e - envs);
+
+    // Set the basic status variables.
+    e->env_parent_id = parent_id;
+    e->env_type = ENV_TYPE_USER;
+    e->env_status = ENV_RUNNABLE;
+    e->env_runs = 0;
+
+    // Clear out all the saved register state,
+    // to prevent the register values
+    // of a prior environment inhabiting this Env structure
+    // from "leaking" into our new environment.
+    memset(&e->env_tf, 0, sizeof(e->env_tf));
+
+    // Set up appropriate initial values for the segment registers.
+    // GD_UD is the user data segment selector in the GDT, and
+    // GD_UT is the user text segment selector (see inc/memlayout.h).
+    // The low 2 bits of each segment register contains the
+    // Requestor Privilege Level (RPL); 3 means user mode.  When
+    // we switch privilege levels, the hardware does various
+    // checks involving the RPL and the Descriptor Privilege Level
+    // (DPL) stored in the descriptors themselves.
+    e->env_tf.tf_ds = GD_UD | 3;
+    e->env_tf.tf_es = GD_UD | 3;
+    e->env_tf.tf_ss = GD_UD | 3;
+    e->env_tf.tf_esp = USTACKTOP;
+    e->env_tf.tf_cs = GD_UT | 3;
+    // You will set e->env_tf.tf_eip later.
+
+    // Enable interrupts while in user mode.
+    // LAB 4: Your code here.
+    e->env_tf.tf_eflags |= FL_IF;
+
+
+    // Clear the page fault handler until user installs one.
+    e->env_pgfault_upcall = 0;
+
+    // Also clear the IPC receiving flag.
+    e->env_ipc_recving = 0;
+
+    // commit the allocation
+    env_free_list = e->env_link;
+    *newenv_store = e;
+
+    cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+    return 0;
 }
 
 //
@@ -269,16 +296,26 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 // Pages should be writable by user and kernel.
 // Panic if any allocation attempt fails.
 //
-static void
+    static void
 region_alloc(struct Env *e, void *va, size_t len)
 {
-	// LAB 3: Your code here.
-	// (But only if you need it for load_icode.)
-	//
-	// Hint: It is easier to use region_alloc if the caller can pass
-	//   'va' and 'len' values that are not page-aligned.
-	//   You should round va down, and round (va + len) up.
-	//   (Watch out for corner-cases!)
+    // LAB 3: Your code here.
+    // (But only if you need it for load_icode.)
+    //
+    // Hint: It is easier to use region_alloc if the caller can pass
+    //   'va' and 'len' values that are not page-aligned.
+    //   You should round va down, and round (va + len) up.
+    //   (Watch out for corner-cases!)
+    int l = 0, va_ = (uintptr_t)va;
+    struct PageInfo *p;
+    va = (void*)ROUNDDOWN(va_, PGSIZE);
+    len = ROUNDUP(va_ + len, PGSIZE) - (uintptr_t)va;
+    for (; l < len; l += PGSIZE) {
+	p = page_alloc(0);
+	if (!p) panic("Panic: region_alloc()\n");
+	if (page_insert(e->env_pgdir, p, va + l, PTE_U | PTE_W))
+	    panic("Panic: region_alloc()\n");
+    }
 }
 
 //
@@ -303,43 +340,62 @@ region_alloc(struct Env *e, void *va, size_t len)
 // load_icode panics if it encounters problems.
 //  - How might load_icode fail?  What might be wrong with the given input?
 //
-static void
+    static void
 load_icode(struct Env *e, uint8_t *binary)
 {
-	// Hints:
-	//  Load each program segment into virtual memory
-	//  at the address specified in the ELF segment header.
-	//  You should only load segments with ph->p_type == ELF_PROG_LOAD.
-	//  Each segment's virtual address can be found in ph->p_va
-	//  and its size in memory can be found in ph->p_memsz.
-	//  The ph->p_filesz bytes from the ELF binary, starting at
-	//  'binary + ph->p_offset', should be copied to virtual address
-	//  ph->p_va.  Any remaining memory bytes should be cleared to zero.
-	//  (The ELF header should have ph->p_filesz <= ph->p_memsz.)
-	//  Use functions from the previous lab to allocate and map pages.
-	//
-	//  All page protection bits should be user read/write for now.
-	//  ELF segments are not necessarily page-aligned, but you can
-	//  assume for this function that no two segments will touch
-	//  the same virtual page.
-	//
-	//  You may find a function like region_alloc useful.
-	//
-	//  Loading the segments is much simpler if you can move data
-	//  directly into the virtual addresses stored in the ELF binary.
-	//  So which page directory should be in force during
-	//  this function?
-	//
-	//  You must also do something with the program's entry point,
-	//  to make sure that the environment starts executing there.
-	//  What?  (See env_run() and env_pop_tf() below.)
-
-	// LAB 3: Your code here.
-
-	// Now map one page for the program's initial stack
-	// at virtual address USTACKTOP - PGSIZE.
-
-	// LAB 3: Your code here.
+    // Hints:
+    //  Load each program segment into virtual memory
+    //  at the address specified in the ELF section header.
+    //  You should only load segments with ph->p_type == ELF_PROG_LOAD.
+    //  Each segment's virtual address can be found in ph->p_va
+    //  and its size in memory can be found in ph->p_memsz.
+    //  The ph->p_filesz bytes from the ELF binary, starting at
+    //  'binary + ph->p_offset', should be copied to virtual address
+    //  ph->p_va.  Any remaining memory bytes should be cleared to zero.
+    //  (The ELF header should have ph->p_filesz <= ph->p_memsz.)
+    //  Use functions from the previous lab to allocate and map pages.
+    //
+    //  All page protection bits should be user read/write for now.
+    //  ELF segments are not necessarily page-aligned, but you can
+    //  assume for this function that no two segments will touch
+    //  the same virtual page.
+    //
+    //  You may find a function like region_alloc useful.
+    //
+    //  Loading the segments is much simpler if you can move data
+    //  directly into the virtual addresses stored in the ELF binary.
+    //  So which page directory should be in force during
+    //  this function?
+    //
+    //  You must also do something with the program's entry point,
+    //  to make sure that the environment starts executing there.
+    //  What?  (See env_run() and env_pop_tf() below.)
+
+    // LAB 3: Your code here.
+    struct Elf *elf = (struct Elf*)binary;
+    struct Proghdr *ph, *eph;
+    struct PageInfo *pp;
+    unsigned i, va, sz, delta;
+
+    if (elf->e_magic != ELF_MAGIC) 
+	panic("Panic: load_icode() ELF_MAGIC\n");
+    ph = (struct Proghdr*)(binary + elf->e_phoff);
+    eph = ph + elf->e_phnum;
+    lcr3(PADDR(e->env_pgdir));
+    for (; ph < eph; ph++) {
+	if (ph->p_type != ELF_PROG_LOAD) continue;
+	region_alloc(e, (void*)ph->p_va, ph->p_memsz);
+	memset((void*)ph->p_va, 0, ph->p_memsz);
+	memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+    }
+    lcr3(PADDR(kern_pgdir));
+    e->env_tf.tf_eip = elf->e_entry;
+
+    // Now map one page for the program's initial stack
+    // at virtual address USTACKTOP - PGSIZE.
+
+    // LAB 3: Your code here.
+    region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
 }
 
 //
@@ -349,66 +405,74 @@ load_icode(struct Env *e, uint8_t *binary)
 // before running the first user-mode environment.
 // The new env's parent ID is set to 0.
 //
-void
+    void
 env_create(uint8_t *binary, enum EnvType type)
 {
-	// LAB 3: Your code here.
-
-	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
-	// LAB 5: Your code here.
+    // LAB 3: Your code here.
+    struct Env *e;
+    env_alloc(&e, 0);
+    load_icode(e, binary);
+    e->env_type = type;
+
+    // If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
+    // LAB 5: Your code here.
+    e->env_tf.tf_eflags &= ~FL_IOPL_MASK;
+    if (type == ENV_TYPE_FS)
+	e->env_tf.tf_eflags |= FL_IOPL_3;
+    else
+	e->env_tf.tf_eflags |= FL_IOPL_0;
 }
-
 //
 // Frees env e and all memory it uses.
 //
-void
+    void
 env_free(struct Env *e)
 {
-	pte_t *pt;
-	uint32_t pdeno, pteno;
-	physaddr_t pa;
-
-	// If freeing the current environment, switch to kern_pgdir
-	// before freeing the page directory, just in case the page
-	// gets reused.
-	if (e == curenv)
-		lcr3(PADDR(kern_pgdir));
-
-	// Note the environment's demise.
-	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
-
-	// Flush all mapped pages in the user portion of the address space
-	static_assert(UTOP % PTSIZE == 0);
-	for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
-
-		// only look at mapped page tables
-		if (!(e->env_pgdir[pdeno] & PTE_P))
-			continue;
-
-		// find the pa and va of the page table
-		pa = PTE_ADDR(e->env_pgdir[pdeno]);
-		pt = (pte_t*) KADDR(pa);
-
-		// unmap all PTEs in this page table
-		for (pteno = 0; pteno <= PTX(~0); pteno++) {
-			if (pt[pteno] & PTE_P)
-				page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
-		}
-
-		// free the page table itself
-		e->env_pgdir[pdeno] = 0;
-		page_decref(pa2page(pa));
+    pte_t *pt;
+    uint32_t pdeno, pteno;
+    physaddr_t pa;
+
+    // If freeing the current environment, switch to kern_pgdir
+    // before freeing the page directory, just in case the page
+    // gets reused.
+    if (e == curenv)
+	lcr3(PADDR(kern_pgdir));
+
+    // Note the environment's demise.
+    cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+
+    // Flush all mapped pages in the user portion of the address space
+    static_assert(UTOP % PTSIZE == 0);
+    for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
+
+	// only look at mapped page tables
+	if (!(e->env_pgdir[pdeno] & PTE_P))
+	    continue;
+
+	// find the pa and va of the page table
+	pa = PTE_ADDR(e->env_pgdir[pdeno]);
+	pt = (pte_t*) KADDR(pa);
+
+	// unmap all PTEs in this page table
+	for (pteno = 0; pteno <= PTX(~0); pteno++) {
+	    if (pt[pteno] & PTE_P)
+		page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
 	}
 
-	// free the page directory
-	pa = PADDR(e->env_pgdir);
-	e->env_pgdir = 0;
+	// free the page table itself
+	e->env_pgdir[pdeno] = 0;
 	page_decref(pa2page(pa));
+    }
 
-	// return the environment to the free list
-	e->env_status = ENV_FREE;
-	e->env_link = env_free_list;
-	env_free_list = e;
+    // free the page directory
+    pa = PADDR(e->env_pgdir);
+    e->env_pgdir = 0;
+    page_decref(pa2page(pa));
+
+    // return the environment to the free list
+    e->env_status = ENV_FREE;
+    e->env_link = env_free_list;
+    env_free_list = e;
 }
 
 //
@@ -416,23 +480,23 @@ env_free(struct Env *e)
 // If e was the current env, then runs a new environment (and does not return
 // to the caller).
 //
-void
+    void
 env_destroy(struct Env *e)
 {
-	// If e is currently running on other CPUs, we change its state to
-	// ENV_DYING. A zombie environment will be freed the next time
-	// it traps to the kernel.
-	if (e->env_status == ENV_RUNNING && curenv != e) {
-		e->env_status = ENV_DYING;
-		return;
-	}
-
-	env_free(e);
-
-	if (curenv == e) {
-		curenv = NULL;
-		sched_yield();
-	}
+    // If e is currently running on other CPUs, we change its state to
+    // ENV_DYING. A zombie environment will be freed the next time
+    // it traps to the kernel.
+    if (e->env_status == ENV_RUNNING && curenv != e) {
+	e->env_status = ENV_DYING;
+	return;
+    }
+
+    env_free(e);
+
+    if (curenv == e) {
+	curenv = NULL;
+	sched_yield();
+    }
 }
 
 
@@ -442,21 +506,23 @@ env_destroy(struct Env *e)
 //
 // This function does not return.
 //
-void
+    void
 env_pop_tf(struct Trapframe *tf)
 {
-	// Record the CPU we are running on for user-space debugging
-	curenv->env_cpunum = cpunum();
-
-	asm volatile(
-		"\tmovl %0,%%esp\n"
-		"\tpopal\n"
-		"\tpopl %%es\n"
-		"\tpopl %%ds\n"
-		"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
-		"\tiret\n"
-		: : "g" (tf) : "memory");
-	panic("iret failed");  /* mostly to placate the compiler */
+    // Record the CPU we are running on for user-space debugging
+    curenv->env_cpunum = cpunum();
+    unlock_kernel();
+
+
+    asm volatile(
+	    "\tmovl %0,%%esp\n"
+	    "\tpopal\n"
+	    "\tpopl %%es\n"
+	    "\tpopl %%ds\n"
+	    "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
+	    "\tiret\n"
+	    : : "g" (tf) : "memory");
+    panic("iret failed");  /* mostly to placate the compiler */
 }
 
 //
@@ -465,28 +531,36 @@ env_pop_tf(struct Trapframe *tf)
 //
 // This function does not return.
 //
-void
+    void
 env_run(struct Env *e)
 {
-	// Step 1: If this is a context switch (a new environment is running):
-	//	   1. Set the current environment (if any) back to
-	//	      ENV_RUNNABLE if it is ENV_RUNNING (think about
-	//	      what other states it can be in),
-	//	   2. Set 'curenv' to the new environment,
-	//	   3. Set its status to ENV_RUNNING,
-	//	   4. Update its 'env_runs' counter,
-	//	   5. Use lcr3() to switch to its address space.
-	// Step 2: Use env_pop_tf() to restore the environment's
-	//	   registers and drop into user mode in the
-	//	   environment.
-
-	// Hint: This function loads the new environment's state from
-	//	e->env_tf.  Go back through the code you wrote above
-	//	and make sure you have set the relevant parts of
-	//	e->env_tf to sensible values.
-
-	// LAB 3: Your code here.
-
-	panic("env_run not yet implemented");
+    // Step 1: If this is a context switch (a new environment is running):
+    //	   1. Set the current environment (if any) back to
+    //	      ENV_RUNNABLE if it is ENV_RUNNING (think about
+    //	      what other states it can be in),
+    //	   2. Set 'curenv' to the new environment,
+    //	   3. Set its status to ENV_RUNNING,
+    //	   4. Update its 'env_runs' counter,
+    //	   5. Use lcr3() to switch to its address space.
+    // Step 2: Use env_pop_tf() to restore the environment's
+    //	   registers and drop into user mode in the
+    //	   environment.
+
+    // Hint: This function loads the new environment's state from
+    //	e->env_tf.  Go back through the code you wrote above
+    //	and make sure you have set the relevant parts of
+    //	e->env_tf to sensible values.
+
+    // LAB 3: Your code here.
+    if (curenv) {
+	if (curenv->env_status == ENV_RUNNING)
+	    curenv->env_status = ENV_RUNNABLE;
+    }
+    curenv = e;
+    curenv->env_status = ENV_RUNNING;
+    curenv->env_runs++;
+    lcr3(PADDR(e->env_pgdir));
+
+    env_pop_tf(&e->env_tf);
 }
 
diff --git a/kern/env.c~ b/kern/env.c~
new file mode 100644
index 0000000..1e454ab
--- /dev/null
+++ b/kern/env.c~
@@ -0,0 +1,530 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/x86.h>
+#include <inc/mmu.h>
+#include <inc/error.h>
+#include <inc/string.h>
+#include <inc/assert.h>
+#include <inc/elf.h>
+
+#include <kern/env.h>
+#include <kern/pmap.h>
+#include <kern/trap.h>
+#include <kern/monitor.h>
+
+struct Env *envs = NULL;		// All environments
+struct Env *curenv = NULL;		// The current env
+static struct Env *env_free_list;	// Free environment list
+					// (linked by Env->env_link)
+
+#define ENVGENSHIFT	12		// >= LOGNENV
+
+// Global descriptor table.
+//
+// Set up global descriptor table (GDT) with separate segments for
+// kernel mode and user mode.  Segments serve many purposes on the x86.
+// We don't use any of their memory-mapping capabilities, but we need
+// them to switch privilege levels. 
+//
+// The kernel and user segments are identical except for the DPL.
+// To load the SS register, the CPL must equal the DPL.  Thus,
+// we must duplicate the segments for the user and the kernel.
+//
+// In particular, the last argument to the SEG macro used in the
+// definition of gdt specifies the Descriptor Privilege Level (DPL)
+// of that descriptor: 0 for kernel and 3 for user.
+//
+struct Segdesc gdt[] =
+{
+	// 0x0 - unused (always faults -- for trapping NULL far pointers)
+	SEG_NULL,
+
+	// 0x8 - kernel code segment
+	[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),
+
+	// 0x10 - kernel data segment
+	[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),
+
+	// 0x18 - user code segment
+	[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),
+
+	// 0x20 - user data segment
+	[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),
+
+	// 0x28 - tss, initialized in trap_init_percpu()
+	[GD_TSS0 >> 3] = SEG_NULL
+};
+
+struct Pseudodesc gdt_pd = {
+	sizeof(gdt) - 1, (unsigned long) gdt
+};
+
+//
+// Converts an envid to an env pointer.
+// If checkperm is set, the specified environment must be either the
+// current environment or an immediate child of the current environment.
+//
+// RETURNS
+//   0 on success, -E_BAD_ENV on error.
+//   On success, sets *env_store to the environment.
+//   On error, sets *env_store to NULL.
+//
+int
+envid2env(envid_t envid, struct Env **env_store, bool checkperm)
+{
+	struct Env *e;
+
+	// If envid is zero, return the current environment.
+	if (envid == 0) {
+		*env_store = curenv;
+		return 0;
+	}
+
+	// Look up the Env structure via the index part of the envid,
+	// then check the env_id field in that struct Env
+	// to ensure that the envid is not stale
+	// (i.e., does not refer to a _previous_ environment
+	// that used the same slot in the envs[] array).
+	e = &envs[ENVX(envid)];
+	if (e->env_status == ENV_FREE || e->env_id != envid) {
+		*env_store = 0;
+		return -E_BAD_ENV;
+	}
+
+	// Check that the calling environment has legitimate permission
+	// to manipulate the specified environment.
+	// If checkperm is set, the specified environment
+	// must be either the current environment
+	// or an immediate child of the current environment.
+	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
+		*env_store = 0;
+		return -E_BAD_ENV;
+	}
+
+	*env_store = e;
+	return 0;
+}
+
+// Mark all environments in 'envs' as free, set their env_ids to 0,
+// and insert them into the env_free_list.
+// Make sure the environments are in the free list in the same order
+// they are in the envs array (i.e., so that the first call to
+// env_alloc() returns envs[0]).
+//
+void
+env_init(void)
+{
+	// Set up envs array
+	// LAB 3: Your code here.
+	int i;
+    env_free_list = NULL;
+    for (i = NENV - 1; i >= 0; i--) {
+	envs[i].env_id = 0;
+	envs[i].env_link = env_free_list;
+	env_free_list = &(envs[i]);
+    }
+
+	// Per-CPU part of the initialization
+	env_init_percpu();
+}
+
+// Load GDT and segment descriptors.
+void
+env_init_percpu(void)
+{
+	lgdt(&gdt_pd);
+	// The kernel never uses GS or FS, so we leave those set to
+	// the user data segment.
+	asm volatile("movw %%ax,%%gs" : : "a" (GD_UD|3));
+	asm volatile("movw %%ax,%%fs" : : "a" (GD_UD|3));
+	// The kernel does use ES, DS, and SS.  We'll change between
+	// the kernel and user data segments as needed.
+	asm volatile("movw %%ax,%%es" : : "a" (GD_KD));
+	asm volatile("movw %%ax,%%ds" : : "a" (GD_KD));
+	asm volatile("movw %%ax,%%ss" : : "a" (GD_KD));
+	// Load the kernel text segment into CS.
+	asm volatile("ljmp %0,$1f\n 1:\n" : : "i" (GD_KT));
+	// For good measure, clear the local descriptor table (LDT),
+	// since we don't use it.
+	lldt(0);
+}
+
+
+
+    static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+
+
+//
+// Initialize the kernel virtual memory layout for environment e.
+// Allocate a page directory, set e->env_pgdir accordingly,
+// and initialize the kernel portion of the new environment's address space.
+// Do NOT (yet) map anything into the user portion
+// of the environment's virtual address space.
+//
+// Returns 0 on success, < 0 on error.  Errors include:
+//	-E_NO_MEM if page directory or table could not be allocated.
+//
+static int
+env_setup_vm(struct Env *e)
+{
+	int i;
+	struct PageInfo *p = NULL;
+
+	// Allocate a page for the page directory
+	if (!(p = page_alloc(ALLOC_ZERO)))
+		return -E_NO_MEM;
+
+	// Now, set e->env_pgdir and initialize the page directory.
+	//
+	// Hint:
+	//    - The VA space of all envs is identical above UTOP
+	//	(except at UVPT, which we've set below).
+	//	See inc/memlayout.h for permissions and layout.
+	//	Can you use kern_pgdir as a template?  Hint: Yes.
+	//	(Make sure you got the permissions right in Lab 2.)
+	//    - The initial VA below UTOP is empty.
+	//    - You do not need to make any more calls to page_alloc.
+	//    - Note: In general, pp_ref is not maintained for
+	//	physical pages mapped only above UTOP, but env_pgdir
+	//	is an exception -- you need to increment env_pgdir's
+	//	pp_ref for env_free to work correctly.
+	//    - The functions in kern/pmap.h are handy.
+
+	// LAB 3: Your code here.
+	p->pp_ref++;
+    e->env_pgdir = (pde_t*)page2kva(p);
+    boot_map_region(e->env_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo) * npages, PGSIZE), PADDR(pages), PTE_U);
+    boot_map_region(e->env_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);
+    boot_map_region(e->env_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+    boot_map_region(e->env_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+	// UVPT maps the env's own page table read-only.
+	// Permissions: kernel R, user R
+	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
+
+	return 0;
+}
+
+//
+// Allocates and initializes a new environment.
+// On success, the new environment is stored in *newenv_store.
+//
+// Returns 0 on success, < 0 on failure.  Errors include:
+//	-E_NO_FREE_ENV if all NENVS environments are allocated
+//	-E_NO_MEM on memory exhaustion
+//
+int
+env_alloc(struct Env **newenv_store, envid_t parent_id)
+{
+	int32_t generation;
+	int r;
+	struct Env *e;
+
+	if (!(e = env_free_list))
+		return -E_NO_FREE_ENV;
+
+	// Allocate and set up the page directory for this environment.
+	if ((r = env_setup_vm(e)) < 0)
+		return r;
+
+	// Generate an env_id for this environment.
+	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
+	if (generation <= 0)	// Don't create a negative env_id.
+		generation = 1 << ENVGENSHIFT;
+	e->env_id = generation | (e - envs);
+
+	// Set the basic status variables.
+	e->env_parent_id = parent_id;
+	e->env_type = ENV_TYPE_USER;
+	e->env_status = ENV_RUNNABLE;
+	e->env_runs = 0;
+
+	// Clear out all the saved register state,
+	// to prevent the register values
+	// of a prior environment inhabiting this Env structure
+	// from "leaking" into our new environment.
+	memset(&e->env_tf, 0, sizeof(e->env_tf));
+
+	// Set up appropriate initial values for the segment registers.
+	// GD_UD is the user data segment selector in the GDT, and
+	// GD_UT is the user text segment selector (see inc/memlayout.h).
+	// The low 2 bits of each segment register contains the
+	// Requestor Privilege Level (RPL); 3 means user mode.  When
+	// we switch privilege levels, the hardware does various
+	// checks involving the RPL and the Descriptor Privilege Level
+	// (DPL) stored in the descriptors themselves.
+	e->env_tf.tf_ds = GD_UD | 3;
+	e->env_tf.tf_es = GD_UD | 3;
+	e->env_tf.tf_ss = GD_UD | 3;
+	e->env_tf.tf_esp = USTACKTOP;
+	e->env_tf.tf_cs = GD_UT | 3;
+	// You will set e->env_tf.tf_eip later.
+
+	// commit the allocation
+	env_free_list = e->env_link;
+	*newenv_store = e;
+
+	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+	return 0;
+}
+
+//
+// Allocate len bytes of physical memory for environment env,
+// and map it at virtual address va in the environment's address space.
+// Does not zero or otherwise initialize the mapped pages in any way.
+// Pages should be writable by user and kernel.
+// Panic if any allocation attempt fails.
+//
+static void
+region_alloc(struct Env *e, void *va, size_t len)
+{
+	// LAB 3: Your code here.
+	// (But only if you need it for load_icode.)
+	//
+	// Hint: It is easier to use region_alloc if the caller can pass
+	//   'va' and 'len' values that are not page-aligned.
+	//   You should round va down, and round (va + len) up.
+	//   (Watch out for corner-cases!)
+	 int l = 0, va_ = (uintptr_t)va;
+    struct PageInfo *p;
+    va = (void*)ROUNDDOWN(va_, PGSIZE);
+    len = ROUNDUP(va_ + len, PGSIZE) - (uintptr_t)va;
+    for (; l < len; l += PGSIZE) {
+		p = page_alloc(0);
+		if (!p) panic("Panic: region_alloc()\n");
+		if (page_insert(e->env_pgdir, p, va + l, PTE_U | PTE_W))
+			panic("Panic: region_alloc()\n");
+	}
+}
+
+//
+// Set up the initial program binary, stack, and processor flags
+// for a user process.
+// This function is ONLY called during kernel initialization,
+// before running the first user-mode environment.
+//
+// This function loads all loadable segments from the ELF binary image
+// into the environment's user memory, starting at the appropriate
+// virtual addresses indicated in the ELF program header.
+// At the same time it clears to zero any portions of these segments
+// that are marked in the program header as being mapped
+// but not actually present in the ELF file - i.e., the program's bss section.
+//
+// All this is very similar to what our boot loader does, except the boot
+// loader also needs to read the code from disk.  Take a look at
+// boot/main.c to get ideas.
+//
+// Finally, this function maps one page for the program's initial stack.
+//
+// load_icode panics if it encounters problems.
+//  - How might load_icode fail?  What might be wrong with the given input?
+//
+static void
+load_icode(struct Env *e, uint8_t *binary)
+{
+	// Hints:
+	//  Load each program segment into virtual memory
+	//  at the address specified in the ELF section header.
+	//  You should only load segments with ph->p_type == ELF_PROG_LOAD.
+	//  Each segment's virtual address can be found in ph->p_va
+	//  and its size in memory can be found in ph->p_memsz.
+	//  The ph->p_filesz bytes from the ELF binary, starting at
+	//  'binary + ph->p_offset', should be copied to virtual address
+	//  ph->p_va.  Any remaining memory bytes should be cleared to zero.
+	//  (The ELF header should have ph->p_filesz <= ph->p_memsz.)
+	//  Use functions from the previous lab to allocate and map pages.
+	//
+	//  All page protection bits should be user read/write for now.
+	//  ELF segments are not necessarily page-aligned, but you can
+	//  assume for this function that no two segments will touch
+	//  the same virtual page.
+	//
+	//  You may find a function like region_alloc useful.
+	//
+	//  Loading the segments is much simpler if you can move data
+	//  directly into the virtual addresses stored in the ELF binary.
+	//  So which page directory should be in force during
+	//  this function?
+	//
+	//  You must also do something with the program's entry point,
+	//  to make sure that the environment starts executing there.
+	//  What?  (See env_run() and env_pop_tf() below.)
+
+	// LAB 3: Your code here.
+	struct Elf *elf = (struct Elf*)binary;
+    struct Proghdr *ph, *eph;
+    struct PageInfo *pp;
+    unsigned i, va, sz, delta;
+
+    if (elf->e_magic != ELF_MAGIC) 
+	panic("Panic: load_icode() ELF_MAGIC\n");
+    ph = (struct Proghdr*)(binary + elf->e_phoff);
+    eph = ph + elf->e_phnum;
+    lcr3(PADDR(e->env_pgdir));
+    for (; ph < eph; ph++) {
+	if (ph->p_type != ELF_PROG_LOAD) continue;
+	region_alloc(e, (void*)ph->p_va, ph->p_memsz);
+	memset((void*)ph->p_va, 0, ph->p_memsz);
+	memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz); 
+	    }
+    lcr3(PADDR(kern_pgdir));
+    e->env_tf.tf_eip = elf->e_entry;
+
+	// Now map one page for the program's initial stack
+	// at virtual address USTACKTOP - PGSIZE.
+
+	// LAB 3: Your code here.
+    region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
+}
+
+//
+// Allocates a new env with env_alloc, loads the named elf
+// binary into it with load_icode, and sets its env_type.
+// This function is ONLY called during kernel initialization,
+// before running the first user-mode environment.
+// The new env's parent ID is set to 0.
+//
+void
+env_create(uint8_t *binary, enum EnvType type)
+{
+	// LAB 3: Your code here.
+	 struct Env *e;
+    env_alloc(&e, 0);
+    load_icode(e, binary, size);
+    e->env_type = type;
+}
+
+//
+// Frees env e and all memory it uses.
+//
+void
+env_free(struct Env *e)
+{
+	pte_t *pt;
+	uint32_t pdeno, pteno;
+	physaddr_t pa;
+
+	// If freeing the current environment, switch to kern_pgdir
+	// before freeing the page directory, just in case the page
+	// gets reused.
+	if (e == curenv)
+		lcr3(PADDR(kern_pgdir));
+
+	// Note the environment's demise.
+	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+
+	// Flush all mapped pages in the user portion of the address space
+	static_assert(UTOP % PTSIZE == 0);
+	for (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {
+
+		// only look at mapped page tables
+		if (!(e->env_pgdir[pdeno] & PTE_P))
+			continue;
+
+		// find the pa and va of the page table
+		pa = PTE_ADDR(e->env_pgdir[pdeno]);
+		pt = (pte_t*) KADDR(pa);
+
+		// unmap all PTEs in this page table
+		for (pteno = 0; pteno <= PTX(~0); pteno++) {
+			if (pt[pteno] & PTE_P)
+				page_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));
+		}
+
+		// free the page table itself
+		e->env_pgdir[pdeno] = 0;
+		page_decref(pa2page(pa));
+	}
+
+	// free the page directory
+	pa = PADDR(e->env_pgdir);
+	e->env_pgdir = 0;
+	page_decref(pa2page(pa));
+
+	// return the environment to the free list
+	e->env_status = ENV_FREE;
+	e->env_link = env_free_list;
+	env_free_list = e;
+}
+
+//
+// Frees environment e.
+//
+void
+env_destroy(struct Env *e)
+{
+	env_free(e);
+
+	cprintf("Destroyed the only environment - nothing more to do!\n");
+	while (1)
+		monitor(NULL);
+}
+
+
+//
+// Restores the register values in the Trapframe with the 'iret' instruction.
+// This exits the kernel and starts executing some environment's code.
+//
+// This function does not return.
+//
+void
+env_pop_tf(struct Trapframe *tf)
+{
+	asm volatile(
+		"\tmovl %0,%%esp\n"
+		"\tpopal\n"
+		"\tpopl %%es\n"
+		"\tpopl %%ds\n"
+		"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
+		"\tiret\n"
+		: : "g" (tf) : "memory");
+	panic("iret failed");  /* mostly to placate the compiler */
+}
+
+//
+// Context switch from curenv to env e.
+// Note: if this is the first call to env_run, curenv is NULL.
+//
+// This function does not return.
+//
+void
+env_run(struct Env *e)
+{
+	// Step 1: If this is a context switch (a new environment is running):
+	//	   1. Set the current environment (if any) back to
+	//	      ENV_RUNNABLE if it is ENV_RUNNING (think about
+	//	      what other states it can be in),
+	//	   2. Set 'curenv' to the new environment,
+	//	   3. Set its status to ENV_RUNNING,
+	//	   4. Update its 'env_runs' counter,
+	//	   5. Use lcr3() to switch to its address space.
+	// Step 2: Use env_pop_tf() to restore the environment's
+	//	   registers and drop into user mode in the
+	//	   environment.
+
+	// Hint: This function loads the new environment's state from
+	//	e->env_tf.  Go back through the code you wrote above
+	//	and make sure you have set the relevant parts of
+	//	e->env_tf to sensible values.
+
+	// LAB 3: Your code here.
+	if (curenv) {
+		if (curenv->env_status == ENV_RUNNING)
+			curenv->env_status = ENV_RUNNABLE;
+    }
+    curenv = e;
+    curenv->env_status = ENV_RUNNING;
+    curenv->env_runs++;
+    lcr3(PADDR(e->env_pgdir));
+	
+    env_pop_tf(&e->env_tf);
+}
+
diff --git a/kern/env.v b/kern/env.v
new file mode 100644
index 0000000..e69de29
diff --git a/kern/grade-lab1 b/kern/grade-lab1
new file mode 100755
index 0000000..94bcb0f
--- /dev/null
+++ b/kern/grade-lab1
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+
+import re
+from gradelib import *
+
+r = Runner(save("jos.out"),
+           stop_breakpoint("readline"))
+
+@test(0, "running JOS")
+def test_jos():
+    r.run_qemu()
+
+@test(20, parent=test_jos)
+def test_printf():
+    r.match("6828 decimal is 15254 octal!")
+
+BACKTRACE_RE = r"^ *ebp +f01[0-9a-z]{5} +eip +f0100[0-9a-z]{3} +args +([0-9a-z]+)"
+
+@test(10, parent=test_jos)
+def test_backtrace_count():
+    matches = re.findall(BACKTRACE_RE, r.qemu.output, re.MULTILINE)
+    assert_equal(len(matches), 8)
+
+@test(10, parent=test_jos)
+def test_backtrace_arguments():
+    matches = re.findall(BACKTRACE_RE, r.qemu.output, re.MULTILINE)
+    assert_equal("\n".join(matches[:7]),
+                 "\n".join("%08x" % n for n in [0,0,1,2,3,4,5]))
+
+@test(5, parent=test_jos)
+def test_backtrace_symbols():
+    matches = re.findall(r"kern/init.c:[0-9]+: +([^+]*)\+", r.qemu.output)
+    assert_equal("\n".join(matches[:7]),
+                 "\n".join(["test_backtrace"] * 6 + ["i386_init"]))
+
+@test(5, parent=test_jos)
+def test_backtrace_lines():
+    matches = re.findall(r"([^ ]*init.c:([0-9]+):) +test_backtrace\+", r.qemu.output)
+    assert matches, "No line numbers"
+    if any(int(m[1]) < 5 or int(m[1]) > 50 for m in matches):
+        assert_equal("\n".join(m[0] for m in matches),
+                     "Line numbers between 5 and 50")
+
+run_tests()
diff --git a/kern/init.c b/kern/init.c
index f00fd99..38d1cd3 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -18,58 +18,62 @@
 static void boot_aps(void);
 
 
-void
+    void
 i386_init(void)
 {
-	extern char edata[], end[];
+    extern char edata[], end[];
 
-	// Before doing anything else, complete the ELF loading process.
-	// Clear the uninitialized global data (BSS) section of our program.
-	// This ensures that all static/global variables start out zero.
-	memset(edata, 0, end - edata);
+    // Before doing anything else, complete the ELF loading process.
+    // Clear the uninitialized global data (BSS) section of our program.
+    // This ensures that all static/global variables start out zero.
+    memset(edata, 0, end - edata);
 
-	// Initialize the console.
-	// Can't call cprintf until after we do this!
-	cons_init();
+    // Initialize the console.
+    // Can't call cprintf until after we do this!
+    cons_init();
 
-	cprintf("6828 decimal is %o octal!\n", 6828);
+    cprintf("6828 decimal is %o octal!\n", 6828);
 
-	// Lab 2 memory management initialization functions
-	mem_init();
+    // Lab 2 memory management initialization functions
+    mem_init();
 
-	// Lab 3 user environment initialization functions
-	env_init();
-	trap_init();
+    // Lab 3 user environment initialization functions
+    env_init();
+    trap_init();
 
-	// Lab 4 multiprocessor initialization functions
-	mp_init();
-	lapic_init();
+    // Lab 4 multiprocessor initialization functions
+    mp_init();
+    lapic_init();
 
-	// Lab 4 multitasking initialization functions
-	pic_init();
+    // Lab 4 multitasking initialization functions
+    pic_init();
 
-	// Acquire the big kernel lock before waking up APs
-	// Your code here:
+    // Acquire the big kernel lock before waking up APs
+    // Your code here:
+    spin_initlock(&kernel_lock);
+    lock_kernel();
 
-	// Starting non-boot CPUs
-	boot_aps();
+    // Starting non-boot CPUs
+    boot_aps();
 
-	// Start fs.
-	ENV_CREATE(fs_fs, ENV_TYPE_FS);
+
+
+    // Start fs.
+    ENV_CREATE(fs_fs, ENV_TYPE_FS);
 
 #if defined(TEST)
-	// Don't touch -- used by grading script!
-	ENV_CREATE(TEST, ENV_TYPE_USER);
+    // Don't touch -- used by grading script!
+    ENV_CREATE(TEST, ENV_TYPE_USER);
 #else
-	// Touch all you want.
-	ENV_CREATE(user_icode, ENV_TYPE_USER);
+    // Touch all you want.
+    ENV_CREATE(user_icode, ENV_TYPE_USER);
 #endif // TEST*
 
-	// Should not be necessary - drains keyboard because interrupt has given up.
-	kbd_intr();
+    // Should not be necessary - drains keyboard because interrupt has given up.
+    kbd_intr();
 
-	// Schedule and run the first user environment!
-	sched_yield();
+    // Schedule and run the first user environment!
+    sched_yield();
 }
 
 // While boot_aps is booting a given CPU, it communicates the per-core
@@ -78,53 +82,53 @@ i386_init(void)
 void *mpentry_kstack;
 
 // Start the non-boot (AP) processors.
-static void
+    static void
 boot_aps(void)
 {
-	extern unsigned char mpentry_start[], mpentry_end[];
-	void *code;
-	struct CpuInfo *c;
-
-	// Write entry code to unused memory at MPENTRY_PADDR
-	code = KADDR(MPENTRY_PADDR);
-	memmove(code, mpentry_start, mpentry_end - mpentry_start);
-
-	// Boot each AP one at a time
-	for (c = cpus; c < cpus + ncpu; c++) {
-		if (c == cpus + cpunum())  // We've started already.
-			continue;
-
-		// Tell mpentry.S what stack to use 
-		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
-		// Start the CPU at mpentry_start
-		lapic_startap(c->cpu_id, PADDR(code));
-		// Wait for the CPU to finish some basic setup in mp_main()
-		while(c->cpu_status != CPU_STARTED)
-			;
-	}
+    extern unsigned char mpentry_start[], mpentry_end[];
+    void *code;
+    struct CpuInfo *c;
+
+    // Write entry code to unused memory at MPENTRY_PADDR
+    code = KADDR(MPENTRY_PADDR);
+    memmove(code, mpentry_start, mpentry_end - mpentry_start);
+
+    // Boot each AP one at a time
+    for (c = cpus; c < cpus + ncpu; c++) {
+	if (c == cpus + cpunum())  // We've started already.
+	    continue;
+
+	// Tell mpentry.S what stack to use 
+	mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
+	// Start the CPU at mpentry_start
+	lapic_startap(c->cpu_id, PADDR(code));
+	// Wait for the CPU to finish some basic setup in mp_main()
+	while(c->cpu_status != CPU_STARTED)
+	    ;
+    }
 }
 
 // Setup code for APs
-void
+    void
 mp_main(void)
 {
-	// We are in high EIP now, safe to switch to kern_pgdir 
-	lcr3(PADDR(kern_pgdir));
-	cprintf("SMP: CPU %d starting\n", cpunum());
-
-	lapic_init();
-	env_init_percpu();
-	trap_init_percpu();
-	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
-
-	// Now that we have finished some basic setup, call sched_yield()
-	// to start running processes on this CPU.  But make sure that
-	// only one CPU can enter the scheduler at a time!
-	//
-	// Your code here:
-
-	// Remove this after you finish Exercise 4
-	for (;;);
+    // We are in high EIP now, safe to switch to kern_pgdir 
+    lcr3(PADDR(kern_pgdir));
+    cprintf("SMP: CPU %d starting\n", cpunum());
+
+    lapic_init();
+    env_init_percpu();
+    trap_init_percpu();
+    xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
+
+    // Now that we have finished some basic setup, call sched_yield()
+    // to start running processes on this CPU.  But make sure that
+    // only one CPU can enter the scheduler at a time!
+    //
+    // Your code here:
+    lock_kernel();
+
+    sched_yield();
 }
 
 /*
@@ -137,39 +141,39 @@ const char *panicstr;
  * Panic is called on unresolvable fatal errors.
  * It prints "panic: mesg", and then enters the kernel monitor.
  */
-void
+    void
 _panic(const char *file, int line, const char *fmt,...)
 {
-	va_list ap;
+    va_list ap;
 
-	if (panicstr)
-		goto dead;
-	panicstr = fmt;
+    if (panicstr)
+	goto dead;
+    panicstr = fmt;
 
-	// Be extra sure that the machine is in as reasonable state
-	asm volatile("cli; cld");
+    // Be extra sure that the machine is in as reasonable state
+    asm volatile("cli; cld");
 
-	va_start(ap, fmt);
-	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
-	vcprintf(fmt, ap);
-	cprintf("\n");
-	va_end(ap);
+    va_start(ap, fmt);
+    cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
 
 dead:
-	/* break into the kernel monitor */
-	while (1)
-		monitor(NULL);
+    /* break into the kernel monitor */
+    while (1)
+	monitor(NULL);
 }
 
 /* like panic, but don't */
-void
+    void
 _warn(const char *file, int line, const char *fmt,...)
 {
-	va_list ap;
+    va_list ap;
 
-	va_start(ap, fmt);
-	cprintf("kernel warning at %s:%d: ", file, line);
-	vcprintf(fmt, ap);
-	cprintf("\n");
-	va_end(ap);
+    va_start(ap, fmt);
+    cprintf("kernel warning at %s:%d: ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
 }
diff --git a/kern/kdebug.c b/kern/kdebug.c
index f4ee8ee..b721c0b 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -13,10 +13,10 @@ extern const char __STABSTR_BEGIN__[];		// Beginning of string table
 extern const char __STABSTR_END__[];		// End of string table
 
 struct UserStabData {
-	const struct Stab *stabs;
-	const struct Stab *stab_end;
-	const char *stabstr;
-	const char *stabstr_end;
+    const struct Stab *stabs;
+    const struct Stab *stab_end;
+    const char *stabstr;
+    const char *stabstr_end;
 };
 
 
@@ -56,50 +56,50 @@ struct UserStabData {
 //		stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
 //	will exit setting left = 118, right = 554.
 //
-static void
+    static void
 stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
-	       int type, uintptr_t addr)
+	int type, uintptr_t addr)
 {
-	int l = *region_left, r = *region_right, any_matches = 0;
-
-	while (l <= r) {
-		int true_m = (l + r) / 2, m = true_m;
-
-		// search for earliest stab with right type
-		while (m >= l && stabs[m].n_type != type)
-			m--;
-		if (m < l) {	// no match in [l, m]
-			l = true_m + 1;
-			continue;
-		}
-
-		// actual binary search
-		any_matches = 1;
-		if (stabs[m].n_value < addr) {
-			*region_left = m;
-			l = true_m + 1;
-		} else if (stabs[m].n_value > addr) {
-			*region_right = m - 1;
-			r = m - 1;
-		} else {
-			// exact match for 'addr', but continue loop to find
-			// *region_right
-			*region_left = m;
-			l = m;
-			addr++;
-		}
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+	int true_m = (l + r) / 2, m = true_m;
+
+	// search for earliest stab with right type
+	while (m >= l && stabs[m].n_type != type)
+	    m--;
+	if (m < l) {	// no match in [l, m]
+	    l = true_m + 1;
+	    continue;
 	}
 
-	if (!any_matches)
-		*region_right = *region_left - 1;
-	else {
-		// find rightmost region containing 'addr'
-		for (l = *region_right;
-		     l > *region_left && stabs[l].n_type != type;
-		     l--)
-			/* do nothing */;
-		*region_left = l;
+	// actual binary search
+	any_matches = 1;
+	if (stabs[m].n_value < addr) {
+	    *region_left = m;
+	    l = true_m + 1;
+	} else if (stabs[m].n_value > addr) {
+	    *region_right = m - 1;
+	    r = m - 1;
+	} else {
+	    // exact match for 'addr', but continue loop to find
+	    // *region_right
+	    *region_left = m;
+	    l = m;
+	    addr++;
 	}
+    }
+
+    if (!any_matches)
+	*region_right = *region_left - 1;
+    else {
+	// find rightmost region containing 'addr'
+	for (l = *region_right;
+		l > *region_left && stabs[l].n_type != type;
+		l--)
+	    /* do nothing */;
+	*region_left = l;
+    }
 }
 
 
@@ -110,122 +110,129 @@ stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
 //	negative if not.  But even if it returns negative it has stored some
 //	information into '*info'.
 //
-int
+    int
 debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 {
-	const struct Stab *stabs, *stab_end;
-	const char *stabstr, *stabstr_end;
-	int lfile, rfile, lfun, rfun, lline, rline;
-
-	// Initialize *info
-	info->eip_file = "<unknown>";
-	info->eip_line = 0;
-	info->eip_fn_name = "<unknown>";
-	info->eip_fn_namelen = 9;
+    const struct Stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+    int lfile, rfile, lfun, rfun, lline, rline;
+
+    // Initialize *info
+    info->eip_file = "<unknown>";
+    info->eip_line = 0;
+    info->eip_fn_name = "<unknown>";
+    info->eip_fn_namelen = 9;
+    info->eip_fn_addr = addr;
+    info->eip_fn_narg = 0;
+
+    // Find the relevant set of stabs
+    if (addr >= ULIM) {
+	stabs = __STAB_BEGIN__;
+	stab_end = __STAB_END__;
+	stabstr = __STABSTR_BEGIN__;
+	stabstr_end = __STABSTR_END__;
+    } else {
+	// The user-application linker script, user/user.ld,
+	// puts information about the application's stabs (equivalent
+	// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
+	// __STABSTR_END__) in a structure located at virtual address
+	// USTABDATA.
+	const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
+
+	// Make sure this memory is valid.
+	// Return -1 if it is not.  Hint: Call user_mem_check.
+	// LAB 3: Your code here.
+	if (user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U) < 0)
+	    return -1;
+
+	stabs = usd->stabs;
+	stab_end = usd->stab_end;
+	stabstr = usd->stabstr;
+	stabstr_end = usd->stabstr_end;
+
+	// Make sure the STABS and string table memory is valid.
+	// LAB 3: Your code here.
+	if (user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) < 0) return -1;
+	if (user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) < 0) return -1;
+    }
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
+	return -1;
+
+    // Now we find the right stabs that define the function containing
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    lfile = 0;
+    rfile = (stab_end - stabs) - 1;
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+    if (lfile == 0)
+	return -1;
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    lfun = lfile;
+    rfun = rfile;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+
+    if (lfun <= rfun) {
+	// stabs[lfun] points to the function name
+	// in the string table, but check bounds just in case.
+	if (stabs[lfun].n_strx < stabstr_end - stabstr)
+	    info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+	info->eip_fn_addr = stabs[lfun].n_value;
+	addr -= info->eip_fn_addr;
+	// Search within the function definition for the line number.
+	lline = lfun;
+	rline = rfun;
+    } else {
+	// Couldn't find function stab!  Maybe we're in an assembly
+	// file.  Search the whole file for the line number.
 	info->eip_fn_addr = addr;
-	info->eip_fn_narg = 0;
-
-	// Find the relevant set of stabs
-	if (addr >= ULIM) {
-		stabs = __STAB_BEGIN__;
-		stab_end = __STAB_END__;
-		stabstr = __STABSTR_BEGIN__;
-		stabstr_end = __STABSTR_END__;
-	} else {
-		// The user-application linker script, user/user.ld,
-		// puts information about the application's stabs (equivalent
-		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
-		// __STABSTR_END__) in a structure located at virtual address
-		// USTABDATA.
-		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
-
-		// Make sure this memory is valid.
-		// Return -1 if it is not.  Hint: Call user_mem_check.
-		// LAB 3: Your code here.
-
-		stabs = usd->stabs;
-		stab_end = usd->stab_end;
-		stabstr = usd->stabstr;
-		stabstr_end = usd->stabstr_end;
-
-		// Make sure the STABS and string table memory is valid.
-		// LAB 3: Your code here.
-	}
-
-	// String table validity checks
-	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
-		return -1;
-
-	// Now we find the right stabs that define the function containing
-	// 'eip'.  First, we find the basic source file containing 'eip'.
-	// Then, we look in that source file for the function.  Then we look
-	// for the line number.
-
-	// Search the entire set of stabs for the source file (type N_SO).
-	lfile = 0;
-	rfile = (stab_end - stabs) - 1;
-	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
-	if (lfile == 0)
-		return -1;
-
-	// Search within that file's stabs for the function definition
-	// (N_FUN).
-	lfun = lfile;
-	rfun = rfile;
-	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
-
-	if (lfun <= rfun) {
-		// stabs[lfun] points to the function name
-		// in the string table, but check bounds just in case.
-		if (stabs[lfun].n_strx < stabstr_end - stabstr)
-			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
-		info->eip_fn_addr = stabs[lfun].n_value;
-		addr -= info->eip_fn_addr;
-		// Search within the function definition for the line number.
-		lline = lfun;
-		rline = rfun;
-	} else {
-		// Couldn't find function stab!  Maybe we're in an assembly
-		// file.  Search the whole file for the line number.
-		info->eip_fn_addr = addr;
-		lline = lfile;
-		rline = rfile;
-	}
-	// Ignore stuff after the colon.
-	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
-
-
-	// Search within [lline, rline] for the line number stab.
-	// If found, set info->eip_line to the right line number.
-	// If not found, return -1.
-	//
-	// Hint:
-	//	There's a particular stabs type used for line numbers.
-	//	Look at the STABS documentation and <inc/stab.h> to find
-	//	which one.
-	// Your code here.
-
-
-	// Search backwards from the line number for the relevant filename
-	// stab.
-	// We can't just use the "lfile" stab because inlined functions
-	// can interpolate code from a different file!
-	// Such included source files use the N_SOL stab type.
-	while (lline >= lfile
-	       && stabs[lline].n_type != N_SOL
-	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
-		lline--;
-	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
-		info->eip_file = stabstr + stabs[lline].n_strx;
-
-
-	// Set eip_fn_narg to the number of arguments taken by the function,
-	// or 0 if there was no containing function.
-	if (lfun < rfun)
-		for (lline = lfun + 1;
-		     lline < rfun && stabs[lline].n_type == N_PSYM;
-		     lline++)
-			info->eip_fn_narg++;
-
-	return 0;
+	lline = lfile;
+	rline = rfile;
+    }
+    // Ignore stuff after the colon.
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    //
+    // Hint:
+    //	There's a particular stabs type used for line numbers.
+    //	Look at the STABS documentation and <inc/stab.h> to find
+    //	which one.
+    // Your code here.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) info->eip_line = lline - lfun;
+    else return -1;
+
+
+    // Search backwards from the line number for the relevant filename
+    // stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+	    && stabs[lline].n_type != N_SOL
+	    && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
+	lline--;
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
+	info->eip_file = stabstr + stabs[lline].n_strx;
+
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun)
+	for (lline = lfun + 1;
+		lline < rfun && stabs[lline].n_type == N_PSYM;
+		lline++)
+	    info->eip_fn_narg++;
+
+    return 0;
 }
diff --git a/kern/mergedep.pl b/kern/mergedep.pl
new file mode 100644
index 0000000..1730d53
--- /dev/null
+++ b/kern/mergedep.pl
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+# Copyright 2003 Bryan Ford
+# Distributed under the GNU General Public License.
+#
+# Usage: mergedep <main-depfile> [<new-depfiles> ...]
+#
+# This script merges the contents of all <new-depfiles> specified
+# on the command line into the single file <main-depfile>,
+# which may or may not previously exist.
+# Dependencies in the <new-depfiles> will override
+# any existing dependencies for the same targets in <main-depfile>.
+# The <new-depfiles> are deleted after <main-depfile> is updated.
+#
+# The <new-depfiles> are typically generated by GCC with the -MD option,
+# and the <main-depfile> is typically included from a Makefile,
+# as shown here for GNU 'make':
+#
+#	.deps: $(wildcard *.d)
+#		perl mergedep $@ $^
+#	-include .deps
+#
+# This script properly handles multiple dependencies per <new-depfile>,
+# including dependencies having no target,
+# so it is compatible with GCC3's -MP option.
+#
+
+sub readdeps {
+	my $filename = shift;
+
+	open(DEPFILE, $filename) or return 0;
+	while (<DEPFILE>) {
+		if (/([^:]*):([^\\:]*)([\\]?)$/) {
+			my $target = $1;
+			my $deplines = $2;
+			my $slash = $3;
+			while ($slash ne '') {
+				$_ = <DEPFILE>;
+				defined($_) or die
+					"Unterminated dependency in $filename";
+				/(^[ \t][^\\]*)([\\]?)$/ or die
+					"Bad continuation line in $filename";
+				$deplines = "$deplines\\\n$1";
+				$slash = $2;
+			}
+			#print "DEPENDENCY [[$target]]: [[$deplines]]\n";
+			$dephash{$target} = $deplines;
+		} elsif (/^[#]?[ \t]*$/) {
+			# ignore blank lines and comments
+		} else {
+			die "Bad dependency line in $filename: $_";
+		}
+	}
+	close DEPFILE;
+	return 1;
+}
+
+
+if ($#ARGV < 0) {
+	print "Usage: mergedep <main-depfile> [<new-depfiles> ..]\n";
+	exit(1);
+}
+
+%dephash = ();
+
+# Read the main dependency file
+$maindeps = $ARGV[0];
+readdeps($maindeps);
+
+# Read and merge in the new dependency files
+foreach $i (1 .. $#ARGV) {
+	readdeps($ARGV[$i]) or die "Can't open $ARGV[$i]";
+}
+
+# Update the main dependency file
+open(DEPFILE, ">$maindeps.tmp") or die "Can't open output file $maindeps.tmp";
+foreach $target (keys %dephash) {
+	print DEPFILE "$target:$dephash{$target}";
+}
+close DEPFILE;
+rename("$maindeps.tmp", "$maindeps") or die "Can't overwrite $maindeps";
+
+# Finally, delete the new dependency files
+foreach $i (1 .. $#ARGV) {
+	unlink($ARGV[$i]) or print "Error removing $ARGV[$i]\n";
+}
+
diff --git a/kern/monitor.c b/kern/monitor.c
index 4e00796..4f6b18b 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -11,57 +11,183 @@
 #include <kern/monitor.h>
 #include <kern/kdebug.h>
 #include <kern/trap.h>
+#include <kern/pmap.h>
+
 
 #define CMDBUF_SIZE	80	// enough for one VGA text line
 
+int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf);
+int
+mon_memdump(int argc, char **argv, struct Trapframe *tf);
+int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf);
+int
+mon_continue(int argc, char **argv, struct Trapframe *tf);
+int
+mon_stepins(int argc, char **argv, struct Trapframe *tf);
+
+
 
 struct Command {
-	const char *name;
-	const char *desc;
-	// return -1 to force monitor to exit
-	int (*func)(int argc, char** argv, struct Trapframe* tf);
+    const char *name;
+    const char *desc;
+    // return -1 to force monitor to exit
+    int (*func)(int argc, char** argv, struct Trapframe* tf);
 };
 
 static struct Command commands[] = {
-	{ "help", "Display this list of commands", mon_help },
-	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
+    { "help", "Display this list of commands", mon_help },
+    { "kerninfo", "Display information about the kernel", mon_kerninfo },
+    { "pgmap", "Display the physical page mappings", mon_pgmap },
+    { "pgperm", "set, clear, or change the permissions", mon_pgperm },
+    { "memdump", "Dump the contents of a range of memory", mon_memdump },
+    { "backtrace", "Backtrace", mon_backtrace },
+    { "si", "single-step one instruction at a time", mon_stepins },
+    { "c", "continue", mon_continue },
 };
 
+
 /***** Implementations of basic kernel monitor commands *****/
 
-int
+    int
 mon_help(int argc, char **argv, struct Trapframe *tf)
 {
-	int i;
+    int i;
 
-	for (i = 0; i < ARRAY_SIZE(commands); i++)
-		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
-	return 0;
+    for (i = 0; i < ARRAY_SIZE(commands); i++)
+	cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    return 0;
 }
 
-int
+    int
 mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
 {
-	extern char _start[], entry[], etext[], edata[], end[];
-
-	cprintf("Special kernel symbols:\n");
-	cprintf("  _start                  %08x (phys)\n", _start);
-	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
-	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
-	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
-	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
-	cprintf("Kernel executable memory footprint: %dKB\n",
-		ROUNDUP(end - entry, 1024) / 1024);
-	return 0;
+    extern char _start[], entry[], etext[], edata[], end[];
+
+    cprintf("Special kernel symbols:\n");
+    cprintf("  _start                  %08x (phys)\n", _start);
+    cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+    cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+    cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+    cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+    cprintf("Kernel executable memory footprint: %dKB\n",
+	    ROUNDUP(end - entry, 1024) / 1024);
+    return 0;
 }
 
-int
+    int
 mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 {
-	// Your code here.
+    int *ebp, eip, *old_ebp;
+    int ary[5]={};
+
+    cprintf("Stack backtrace:\n");
+
+    ebp=(int *)read_ebp();
+    while((int)ebp!=0)
+    {
+	old_ebp=(int *)*(ebp);
+	eip=*(ebp+1);
+	for(int i=0;i<5;++i)
+	{
+	    int j=i+2;
+	    ary[i]=*(ebp+j);
+	}
+	struct Eipdebuginfo eip_info;
+	debuginfo_eip((uintptr_t)eip, &eip_info);
+	cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
+	cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
+	cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
+	ebp=old_ebp;
+    }
+
+    return 0;
+}
+
+
+
+
+    int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va1, va2, va;
+    struct PageInfo *pg;
+    pte_t *pte;
+    if (argc != 3) {
+	cprintf("Usage: pgmap va1 va2\n Display physical memory mapping from virtual memory va1 to va2\nva1 and va2 are hex\n");
+	return 0;
+    }
+    else {
+	for (va1 = strtol(argv[1], 0, 16), va2 = strtol(argv[2], 0, 16); va1 < va2; va1 += PGSIZE) {
+	    va = va1 & ~0xfff;
+	    pg = page_lookup(kern_pgdir, (void*)va, 0);
+	    pte = pgdir_walk(kern_pgdir, (void* )va,0);
+	    if (pg){
+		cprintf("[%x, %x) ---> [%x, %x)    ", va, va + PGSIZE, page2pa(pg), page2pa(pg) + PGSIZE);
+		if(*pte & PTE_U)
+		    cprintf("user: ");
+		else 
+		    cprintf("kernel: ");
+
+		if(*pte &PTE_W)
+		    cprintf("read/write ");
+		else 
+		    cprintf("read only ");
+	    }else
+		cprintf("[%x, %x) ---> NULL    ", va, va + PGSIZE);
+
+	    cprintf("\n");                                                                                       
+	}
+    }
+    return 0;
+}
+
+
+    int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va, perm;
+    if (argc != 4) {
+	cprintf("Usage: pgperm +/-/= perm va\nset perm of page which contains va, va is hex\n");
 	return 0;
+    }
+    else {
+	va = strtol(argv[3], 0, 16);
+	perm = strtol(argv[2], 0, 16);
+	pte_t *pte = pgdir_walk(kern_pgdir, (void*)va, 0);
+	if (!pte) {
+	    cprintf("0x%x is not mapped\n", va);
+	}
+	else {
+	    if (argv[1][0] == '+') *pte |= perm;
+	    if (argv[1][0] == '0') *pte &= ~perm;
+	    if (argv[1][0] == '=') *pte = PTE_ADDR(*pte) | perm;
+	}
+    }
+    return 0;
 }
 
+    int
+mon_memdump(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t a1, a2, a;
+    struct PageInfo *pg;
+    if (argc != 4) {
+	cprintf("Usage: memdump p/v a1 a2\n Dump memory content via virtual or physical address\na1 and a2 are hex\n");
+	return 0;
+    }
+    else {
+	a1 = strtol(argv[2], 0, 16), a2 = strtol(argv[3], 0, 16);
+	if (argv[1][0] == 'p') a1 = (int)KADDR(a1), a2 = (int)KADDR(a2);
+	for (a = a1; a < a2 && a >= KERNBASE; a += 4) {
+	    if (!((a - a1) & 0xf)) cprintf("\n%x:\t", a);
+	    cprintf(" %x", *(int*)(a));
+	}
+	cprintf("\n");
+    }
+    return 0;
+}
 
 
 /***** Kernel monitor command interpreter *****/
@@ -69,60 +195,83 @@ mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 #define WHITESPACE "\t\r\n "
 #define MAXARGS 16
 
-static int
+    static int
 runcmd(char *buf, struct Trapframe *tf)
 {
-	int argc;
-	char *argv[MAXARGS];
-	int i;
-
-	// Parse the command buffer into whitespace-separated arguments
-	argc = 0;
-	argv[argc] = 0;
-	while (1) {
-		// gobble whitespace
-		while (*buf && strchr(WHITESPACE, *buf))
-			*buf++ = 0;
-		if (*buf == 0)
-			break;
-
-		// save and scan past next arg
-		if (argc == MAXARGS-1) {
-			cprintf("Too many arguments (max %d)\n", MAXARGS);
-			return 0;
-		}
-		argv[argc++] = buf;
-		while (*buf && !strchr(WHITESPACE, *buf))
-			buf++;
-	}
-	argv[argc] = 0;
-
-	// Lookup and invoke the command
-	if (argc == 0)
-		return 0;
-	for (i = 0; i < ARRAY_SIZE(commands); i++) {
-		if (strcmp(argv[0], commands[i].name) == 0)
-			return commands[i].func(argc, argv, tf);
+    int argc;
+    char *argv[MAXARGS];
+    int i;
+
+    // Parse the command buffer into whitespace-separated arguments
+    argc = 0;
+    argv[argc] = 0;
+    while (1) {
+	// gobble whitespace
+	while (*buf && strchr(WHITESPACE, *buf))
+	    *buf++ = 0;
+	if (*buf == 0)
+	    break;
+
+	// save and scan past next arg
+	if (argc == MAXARGS-1) {
+	    cprintf("Too many arguments (max %d)\n", MAXARGS);
+	    return 0;
 	}
-	cprintf("Unknown command '%s'\n", argv[0]);
+	argv[argc++] = buf;
+	while (*buf && !strchr(WHITESPACE, *buf))
+	    buf++;
+    }
+    argv[argc] = 0;
+
+    // Lookup and invoke the command
+    if (argc == 0)
 	return 0;
+    for (i = 0; i < ARRAY_SIZE(commands); i++) {
+	if (strcmp(argv[0], commands[i].name) == 0)
+	    return commands[i].func(argc, argv, tf);
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+    return 0;
 }
 
-void
+    void
 monitor(struct Trapframe *tf)
 {
-	char *buf;
+    char *buf;
 
-	cprintf("Welcome to the JOS kernel monitor!\n");
-	cprintf("Type 'help' for a list of commands.\n");
+    cprintf("Welcome to the JOS kernel monitor!\n");
+    cprintf("Type 'help' for a list of commands.\n");
 
-	if (tf != NULL)
-		print_trapframe(tf);
+    if (tf != NULL)
+	print_trapframe(tf);
 
-	while (1) {
-		buf = readline("K> ");
-		if (buf != NULL)
-			if (runcmd(buf, tf) < 0)
-				break;
-	}
+    while (1) {
+	buf = readline("K> ");
+	if (buf != NULL)
+	    if (runcmd(buf, tf) < 0)
+		break;
+    }
 }
+
+extern void env_pop_tf(struct Trapframe *tf);
+    int
+mon_continue(int argc, char **argv, struct Trapframe *tf)
+{
+    if (tf->tf_trapno == T_BRKPT || tf->tf_trapno == T_DEBUG) {
+	tf->tf_eflags &= ~FL_TF;
+	env_pop_tf(tf);
+    }
+    return 0;
+}
+
+    int
+mon_stepins(int argc, char **argv, struct Trapframe *tf)
+{
+    if (tf->tf_trapno == T_BRKPT || tf->tf_trapno == T_DEBUG) {
+	tf->tf_eflags |= FL_TF;
+	env_pop_tf(tf);
+    }
+    return 0;
+}
+
+
diff --git a/kern/monitor.c~ b/kern/monitor.c~
new file mode 100644
index 0000000..2c6f8fb
--- /dev/null
+++ b/kern/monitor.c~
@@ -0,0 +1,240 @@
+// Simple command-line kernel monitor useful for
+// controlling the kernel and exploring the system interactively.
+
+#include <inc/stdio.h>
+#include <inc/string.h>
+#include <inc/memlayout.h>
+#include <inc/assert.h>
+#include <inc/x86.h>
+
+#include <kern/console.h>
+#include <kern/monitor.h>
+#include <kern/kdebug.h>
+#include <kern/pmap.h>
+
+
+#define CMDBUF_SIZE	80	// enough for one VGA text line
+
+int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf);
+ int
+mon_memdump(int argc, char **argv, struct Trapframe *tf);
+ int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf);
+struct Command {
+	const char *name;
+	const char *desc;
+	// return -1 to force monitor to exit
+	int (*func)(int argc, char** argv, struct Trapframe* tf);
+};
+
+static struct Command commands[] = {
+	{ "help", "Display this list of commands", mon_help },
+	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
+	{ "pgmap", "Display the physical page mappings", mon_pgmap },
+	{ "pgperm", "set, clear, or change the permissions", mon_pgperm },
+	{ "memdump", "Dump the contents of a range of memory", mon_memdump },
+};
+
+/***** Implementations of basic kernel monitor commands *****/
+
+int
+mon_help(int argc, char **argv, struct Trapframe *tf)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(commands); i++)
+		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+	return 0;
+}
+
+int
+mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
+{
+	extern char _start[], entry[], etext[], edata[], end[];
+
+	cprintf("Special kernel symbols:\n");
+	cprintf("  _start                  %08x (phys)\n", _start);
+	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+	cprintf("Kernel executable memory footprint: %dKB\n",
+		ROUNDUP(end - entry, 1024) / 1024);
+	return 0;
+}
+
+int
+mon_backtrace(int argc, char **argv, struct Trapframe *tf)
+{
+	int *ebp, eip, *old_ebp;
+	int ary[5]={};
+
+	cprintf("Stack backtrace:\n");
+	
+	ebp=(int *)read_ebp();
+	while((int)ebp!=0)
+	{
+		old_ebp=(int *)*(ebp);
+		eip=*(ebp+1);
+		for(int i=0;i<5;++i)
+		{
+			int j=i+2;
+			ary[i]=*(ebp+j);
+		}
+		struct Eipdebuginfo eip_info;
+		debuginfo_eip((uintptr_t)eip, &eip_info);
+		cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
+		cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
+		cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
+		ebp=old_ebp;
+	}
+	
+	return 0;
+}
+
+
+
+
+    int
+mon_pgmap(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va1, va2, va;
+    struct PageInfo *pg;
+	pte_t *pte;
+    if (argc != 3) {
+	cprintf("Usage: pgmap va1 va2\n Display physical memory mapping from virtual memory va1 to va2\nva1 and va2 are hex\n");
+	return 0;
+    }
+    else {
+	for (va1 = strtol(argv[1], 0, 16), va2 = strtol(argv[2], 0, 16); va1 < va2; va1 += PGSIZE) {
+	    va = va1 & ~0xfff;
+	    pg = page_lookup(kern_pgdir, (void*)va, 0);
+		pte = pgdir_walk(kern_pgdir, (void* )va,0);
+	    if (pg){
+		cprintf("[%x, %x) ---> [%x, %x)    ", va, va + PGSIZE, page2pa(pg), page2pa(pg) + PGSIZE);
+		    if(*pte & PTE_U)
+			cprintf("user: ");
+		   else 
+			cprintf("kernel: ");
+
+		   if(*pte &PTE_W)
+			cprintf("read/write ");
+		   else 
+			cprintf("read only ");
+		}else
+		cprintf("[%x, %x) ---> NULL    ", va, va + PGSIZE);
+
+		cprintf("\n");                                                                                       
+	}
+    }
+    return 0;
+}
+
+
+    int
+mon_pgperm(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t va, perm;
+    if (argc != 4) {
+		cprintf("Usage: pgperm +/-/= perm va\nset perm of page which contains va, va is hex\n");
+		return 0;
+    }
+    else {
+		va = strtol(argv[3], 0, 16);
+		perm = strtol(argv[2], 0, 16);
+		pte_t *pte = pgdir_walk(kern_pgdir, (void*)va, 0);
+		if (!pte) {
+			cprintf("0x%x is not mapped\n", va);
+		}
+		else {
+			if (argv[1][0] == '+') *pte |= perm;
+			if (argv[1][0] == '0') *pte &= ~perm;
+			if (argv[1][0] == '=') *pte = PTE_ADDR(*pte) | perm;
+		}
+    }
+    return 0;
+}
+
+    int
+mon_memdump(int argc, char **argv, struct Trapframe *tf)
+{
+    uintptr_t a1, a2, a;
+    struct PageInfo *pg;
+    if (argc != 4) {
+	cprintf("Usage: memdump p/v a1 a2\n Dump memory content via virtual or physical address\na1 and a2 are hex\n");
+	return 0;
+    }
+    else {
+	a1 = strtol(argv[2], 0, 16), a2 = strtol(argv[3], 0, 16);
+	if (argv[1][0] == 'p') a1 = (int)KADDR(a1), a2 = (int)KADDR(a2);
+	for (a = a1; a < a2 && a >= KERNBASE; a += 4) {
+	    if (!((a - a1) & 0xf)) cprintf("\n%x:\t", a);
+	    cprintf(" %x", *(int*)(a));
+	}
+	cprintf("\n");
+    }
+    return 0;
+}
+
+
+/***** Kernel monitor command interpreter *****/
+
+#define WHITESPACE "\t\r\n "
+#define MAXARGS 16
+
+static int
+runcmd(char *buf, struct Trapframe *tf)
+{
+	int argc;
+	char *argv[MAXARGS];
+	int i;
+
+	// Parse the command buffer into whitespace-separated arguments
+	argc = 0;
+	argv[argc] = 0;
+	while (1) {
+		// gobble whitespace
+		while (*buf && strchr(WHITESPACE, *buf))
+			*buf++ = 0;
+		if (*buf == 0)
+			break;
+
+		// save and scan past next arg
+		if (argc == MAXARGS-1) {
+			cprintf("Too many arguments (max %d)\n", MAXARGS);
+			return 0;
+		}
+		argv[argc++] = buf;
+		while (*buf && !strchr(WHITESPACE, *buf))
+			buf++;
+	}
+	argv[argc] = 0;
+
+	// Lookup and invoke the command
+	if (argc == 0)
+		return 0;
+	for (i = 0; i < ARRAY_SIZE(commands); i++) {
+		if (strcmp(argv[0], commands[i].name) == 0)
+			return commands[i].func(argc, argv, tf);
+	}
+	cprintf("Unknown command '%s'\n", argv[0]);
+	return 0;
+}
+
+void
+monitor(struct Trapframe *tf)
+{
+	char *buf;
+
+	cprintf("Welcome to the JOS kernel monitor!\n");
+	cprintf("Type 'help' for a list of commands.\n");
+
+
+	while (1) {
+		buf = readline("K> ");
+		if (buf != NULL)
+			if (runcmd(buf, tf) < 0)
+				break;
+	}
+}
diff --git a/kern/pmap.c b/kern/pmap.c
index c04d014..19b5a6f 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -20,42 +20,41 @@ pde_t *kern_pgdir;		// Kernel's initial page directory
 struct PageInfo *pages;		// Physical page state array
 static struct PageInfo *page_free_list;	// Free list of physical pages
 
-
 // --------------------------------------------------------------
 // Detect machine's physical memory setup.
 // --------------------------------------------------------------
 
-static int
+    static int
 nvram_read(int r)
 {
-	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
+    return mc146818_read(r) | (mc146818_read(r + 1) << 8);
 }
 
-static void
+    static void
 i386_detect_memory(void)
 {
-	size_t basemem, extmem, ext16mem, totalmem;
-
-	// Use CMOS calls to measure available base & extended memory.
-	// (CMOS calls return results in kilobytes.)
-	basemem = nvram_read(NVRAM_BASELO);
-	extmem = nvram_read(NVRAM_EXTLO);
-	ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
-
-	// Calculate the number of physical pages available in both base
-	// and extended memory.
-	if (ext16mem)
-		totalmem = 16 * 1024 + ext16mem;
-	else if (extmem)
-		totalmem = 1 * 1024 + extmem;
-	else
-		totalmem = basemem;
-
-	npages = totalmem / (PGSIZE / 1024);
-	npages_basemem = basemem / (PGSIZE / 1024);
-
-	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
-		totalmem, basemem, totalmem - basemem);
+    size_t basemem, extmem, ext16mem, totalmem;
+
+    // Use CMOS calls to measure available base & extended memory.
+    // (CMOS calls return results in kilobytes.)
+    basemem = nvram_read(NVRAM_BASELO);
+    extmem = nvram_read(NVRAM_EXTLO);
+    ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
+
+    // Calculate the number of physical pages available in both base
+    // and extended memory.
+    if (ext16mem)
+	totalmem = 16 * 1024 + ext16mem;
+    else if (extmem)
+	totalmem = 1 * 1024 + extmem;
+    else
+	totalmem = basemem;
+
+    npages = totalmem / (PGSIZE / 1024);
+    npages_basemem = basemem / (PGSIZE / 1024);
+
+    cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
+	    totalmem, basemem, totalmem - basemem);
 }
 
 
@@ -84,29 +83,36 @@ static void check_page_installed_pgdir(void);
 // If we're out of memory, boot_alloc should panic.
 // This function may ONLY be used during initialization,
 // before the page_free_list list has been set up.
-static void *
+    static void *
 boot_alloc(uint32_t n)
 {
-	static char *nextfree;	// virtual address of next byte of free memory
-	char *result;
-
-	// Initialize nextfree if this is the first time.
-	// 'end' is a magic symbol automatically generated by the linker,
-	// which points to the end of the kernel's bss segment:
-	// the first virtual address that the linker did *not* assign
-	// to any kernel code or global variables.
-	if (!nextfree) {
-		extern char end[];
-		nextfree = ROUNDUP((char *) end, PGSIZE);
-	}
-
-	// Allocate a chunk large enough to hold 'n' bytes, then update
-	// nextfree.  Make sure nextfree is kept aligned
-	// to a multiple of PGSIZE.
-	//
-	// LAB 2: Your code here.
-
+    static char *nextfree;	// virtual address of next byte of free memory
+    char *result;
+
+    // Initialize nextfree if this is the first time.
+    // 'end' is a magic symbol automatically generated by the linker,
+    // which points to the end of the kernel's bss segment:
+    // the first virtual address that the linker did *not* assign
+    // to any kernel code or global variables.
+    if (!nextfree) {
+	extern char end[];
+	nextfree = ROUNDUP((char *) end, PGSIZE);
+    }
+
+    // Allocate a chunk large enough to hold 'n' bytes, then update
+    // nextfree.  Make sure nextfree is kept aligned
+    // to a multiple of PGSIZE.
+    // LAB 2: Your code here.
+    if (n == 0) return (void*)nextfree;
+    n = ROUNDUP(n, PGSIZE);
+    if (PADDR(nextfree + n) > npages * PGSIZE)
+    {
+	panic("kern/pmap.c: boot_alloc()");
 	return NULL;
+    }
+    result = nextfree;
+    nextfree += n;
+    return result;
 }
 
 // Set up a two-level page table:
@@ -118,147 +124,159 @@ boot_alloc(uint32_t n)
 //
 // From UTOP to ULIM, the user is allowed to read but not write.
 // Above ULIM the user cannot read or write.
-void
+    void
 mem_init(void)
 {
-	uint32_t cr0;
-	size_t n;
-
-	// Find out how much memory the machine has (npages & npages_basemem).
-	i386_detect_memory();
-
-	// Remove this line when you're ready to test this function.
-	panic("mem_init: This function is not finished\n");
-
-	//////////////////////////////////////////////////////////////////////
-	// create initial page directory.
-	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
-	memset(kern_pgdir, 0, PGSIZE);
-
-	//////////////////////////////////////////////////////////////////////
-	// Recursively insert PD in itself as a page table, to form
-	// a virtual page table at virtual address UVPT.
-	// (For now, you don't have understand the greater purpose of the
-	// following line.)
-
-	// Permissions: kernel R, user R
-	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
-
-	//////////////////////////////////////////////////////////////////////
-	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
-	// The kernel uses this array to keep track of physical pages: for
-	// each physical page, there is a corresponding struct PageInfo in this
-	// array.  'npages' is the number of physical pages in memory.  Use memset
-	// to initialize all fields of each struct PageInfo to 0.
-	// Your code goes here:
-
-
-	//////////////////////////////////////////////////////////////////////
-	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
-	// LAB 3: Your code here.
-
-	//////////////////////////////////////////////////////////////////////
-	// Now that we've allocated the initial kernel data structures, we set
-	// up the list of free physical pages. Once we've done so, all further
-	// memory management will go through the page_* functions. In
-	// particular, we can now map memory using boot_map_region
-	// or page_insert
-	page_init();
-
-	check_page_free_list(1);
-	check_page_alloc();
-	check_page();
-
-	//////////////////////////////////////////////////////////////////////
-	// Now we set up virtual memory
-
-	//////////////////////////////////////////////////////////////////////
-	// Map 'pages' read-only by the user at linear address UPAGES
-	// Permissions:
-	//    - the new image at UPAGES -- kernel R, user R
-	//      (ie. perm = PTE_U | PTE_P)
-	//    - pages itself -- kernel RW, user NONE
-	// Your code goes here:
-
-	//////////////////////////////////////////////////////////////////////
-	// Map the 'envs' array read-only by the user at linear address UENVS
-	// (ie. perm = PTE_U | PTE_P).
-	// Permissions:
-	//    - the new image at UENVS  -- kernel R, user R
-	//    - envs itself -- kernel RW, user NONE
-	// LAB 3: Your code here.
-
-	//////////////////////////////////////////////////////////////////////
-	// Use the physical memory that 'bootstack' refers to as the kernel
-	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
-	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
-	// to be the kernel stack, but break this into two pieces:
-	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
-	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
-	//       the kernel overflows its stack, it will fault rather than
-	//       overwrite memory.  Known as a "guard page".
-	//     Permissions: kernel RW, user NONE
-	// Your code goes here:
-
-	//////////////////////////////////////////////////////////////////////
-	// Map all of physical memory at KERNBASE.
-	// Ie.  the VA range [KERNBASE, 2^32) should map to
-	//      the PA range [0, 2^32 - KERNBASE)
-	// We might not have 2^32 - KERNBASE bytes of physical memory, but
-	// we just set up the mapping anyway.
-	// Permissions: kernel RW, user NONE
-	// Your code goes here:
-
-	// Initialize the SMP-related parts of the memory map
-	mem_init_mp();
-
-	// Check that the initial page directory has been set up correctly.
-	check_kern_pgdir();
-
-	// Switch from the minimal entry page directory to the full kern_pgdir
-	// page table we just created.	Our instruction pointer should be
-	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
-	// mapped the same way by both page tables.
-	//
-	// If the machine reboots at this point, you've probably set up your
-	// kern_pgdir wrong.
-	lcr3(PADDR(kern_pgdir));
-
-	check_page_free_list(0);
-
-	// entry.S set the really important flags in cr0 (including enabling
-	// paging).  Here we configure the rest of the flags that we care about.
-	cr0 = rcr0();
-	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
-	cr0 &= ~(CR0_TS|CR0_EM);
-	lcr0(cr0);
-
-	// Some more checks, only possible after kern_pgdir is installed.
-	check_page_installed_pgdir();
+    uint32_t cr0;
+    size_t n;
+
+    // Find out how much memory the machine has (npages & npages_basemem).
+    i386_detect_memory();
+
+    // Remove this line when you're ready to test this function.
+    //panic("mem_init: This function is not finished\n");
+
+    //////////////////////////////////////////////////////////////////////
+    // create initial page directory.
+    kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
+    memset(kern_pgdir, 0, PGSIZE);
+
+    //////////////////////////////////////////////////////////////////////
+    // Recursively insert PD in itself as a page table, to form
+    // a virtual page table at virtual address UVPT.
+    // (For now, you don't have understand the greater purpose of the
+    // following line.)
+
+    // Permissions: kernel R, user R
+    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
+
+    //////////////////////////////////////////////////////////////////////
+    // Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
+    // The kernel uses this array to keep track of physical pages: for
+    // each physical page, there is a corresponding struct PageInfo in this
+    // array.  'npages' is the number of physical pages in memory.  Use memset
+    // to initialize all fields of each struct PageInfo to 0.
+    // Your code goes here:
+    pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
+    memset(pages, 0, npages * sizeof(struct PageInfo));
+
+    //////////////////////////////////////////////////////////////////////
+    // Make 'envs' point to an array of size 'NENV' of 'struct Env'.
+    // LAB 3: Your code here.
+    envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
+
+    //////////////////////////////////////////////////////////////////////
+    // Now that we've allocated the initial kernel data structures, we set
+    // up the list of free physical pages. Once we've done so, all further
+    // memory management will go through the page_* functions. In
+    // particular, we can now map memory using boot_map_region
+    // or page_insert
+    page_init();
+
+    check_page_free_list(1);
+    check_page_alloc();
+    check_page();
+
+    //////////////////////////////////////////////////////////////////////
+    // Now we set up virtual memory
+
+    //////////////////////////////////////////////////////////////////////
+    // Map 'pages' read-only by the user at linear address UPAGES
+    // Permissions:
+    //    - the new image at UPAGES -- kernel R, user R
+    //      (ie. perm = PTE_U | PTE_P)
+    //    - pages itself -- kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo)* npages, PGSIZE), PADDR(pages), PTE_U);
+
+    //////////////////////////////////////////////////////////////////////
+    // Map the 'envs' array read-only by the user at linear address UENVS
+    // (ie. perm = PTE_U | PTE_P).
+    // Permissions:
+    //    - the new image at UENVS  -- kernel R, user R
+    //    - envs itself -- kernel RW, user NONE
+    // LAB 3: Your code here.
+    boot_map_region(kern_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);	
+
+    //////////////////////////////////////////////////////////////////////
+    // Use the physical memory that 'bootstack' refers to as the kernel
+    // stack.  The kernel stack grows down from virtual address KSTACKTOP.
+    // We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
+    // to be the kernel stack, but break this into two pieces:
+    //     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
+    //     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
+    //       the kernel overflows its stack, it will fault rather than
+    //       overwrite memory.  Known as a "guard page".
+    //     Permissions: kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+
+    //////////////////////////////////////////////////////////////////////
+    // Map all of physical memory at KERNBASE.
+    // Ie.  the VA range [KERNBASE, 2^32) should map to
+    //      the PA range [0, 2^32 - KERNBASE)
+    // We might not have 2^32 - KERNBASE bytes of physical memory, but
+    // we just set up the mapping anyway.
+    // Permissions: kernel RW, user NONE
+    // Your code goes here:
+    boot_map_region(kern_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+
+    // Initialize the SMP-related parts of the memory map
+    mem_init_mp();
+
+    // Check that the initial page directory has been set up correctly.
+    check_kern_pgdir();
+
+    // Switch from the minimal entry page directory to the full kern_pgdir
+    // page table we just created.	Our instruction pointer should be
+    // somewhere between KERNBASE and KERNBASE+4MB right now, which is
+    // mapped the same way by both page tables.
+    //
+    // If the machine reboots at this point, you've probably set up your
+    // kern_pgdir wrong.
+    lcr3(PADDR(kern_pgdir));
+
+    check_page_free_list(0);
+
+    // entry.S set the really important flags in cr0 (including enabling
+    // paging).  Here we configure the rest of the flags that we care about.
+    cr0 = rcr0();
+    cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
+    cr0 &= ~(CR0_TS|CR0_EM);
+    lcr0(cr0);
+
+    // Some more checks, only possible after kern_pgdir is installed.
+    check_page_installed_pgdir();
 }
 
 // Modify mappings in kern_pgdir to support SMP
 //   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
 //
-static void
+    static void
 mem_init_mp(void)
 {
-	// Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.
-	//
-	// For CPU i, use the physical memory that 'percpu_kstacks[i]' refers
-	// to as its kernel stack. CPU i's kernel stack grows down from virtual
-	// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is
-	// divided into two pieces, just like the single stack you set up in
-	// mem_init:
-	//     * [kstacktop_i - KSTKSIZE, kstacktop_i)
-	//          -- backed by physical memory
-	//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)
-	//          -- not backed; so if the kernel overflows its stack,
-	//             it will fault rather than overwrite another CPU's stack.
-	//             Known as a "guard page".
-	//     Permissions: kernel RW, user NONE
-	//
-	// LAB 4: Your code here:
+    // Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.
+    //
+    // For CPU i, use the physical memory that 'percpu_kstacks[i]' refers
+    // to as its kernel stack. CPU i's kernel stack grows down from virtual
+    // address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is
+    // divided into two pieces, just like the single stack you set up in
+    // mem_init:
+    //     * [kstacktop_i - KSTKSIZE, kstacktop_i)
+    //          -- backed by physical memory
+    //     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)
+    //          -- not backed; so if the kernel overflows its stack,
+    //             it will fault rather than overwrite another CPU's stack.
+    //             Known as a "guard page".
+    //     Permissions: kernel RW, user NONE
+    //
+    // LAB 4: Your code here:
+    int c;
+    for (c = 0; c < NCPU; ++c) {
+	boot_map_region(kern_pgdir, KSTACKTOP - c * (KSTKSIZE + KSTKGAP) - KSTKSIZE,
+		ROUNDUP(KSTKSIZE, PGSIZE), PADDR(percpu_kstacks[c]), PTE_W);
+    }
 
 }
 
@@ -274,36 +292,40 @@ mem_init_mp(void)
 // allocator functions below to allocate and deallocate physical
 // memory via the page_free_list.
 //
-void
+    void
 page_init(void)
 {
-	// LAB 4:
-	// Change your code to mark the physical page at MPENTRY_PADDR
-	// as in use
-
-	// The example code here marks all physical pages as free.
-	// However this is not truly the case.  What memory is free?
-	//  1) Mark physical page 0 as in use.
-	//     This way we preserve the real-mode IDT and BIOS structures
-	//     in case we ever need them.  (Currently we don't, but...)
-	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
-	//     is free.
-	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
-	//     never be allocated.
-	//  4) Then extended memory [EXTPHYSMEM, ...).
-	//     Some of it is in use, some is free. Where is the kernel
-	//     in physical memory?  Which pages are already in use for
-	//     page tables and other data structures?
-	//
-	// Change the code to reflect this.
-	// NB: DO NOT actually touch the physical memory corresponding to
-	// free pages!
-	size_t i;
-	for (i = 0; i < npages; i++) {
-		pages[i].pp_ref = 0;
-		pages[i].pp_link = page_free_list;
-		page_free_list = &pages[i];
-	}
+    // LAB 4:
+    // Change your code to mark the physical page at MPENTRY_PADDR
+    // as in use
+
+    // The example code here marks all physical pages as free.
+    // However this is not truly the case.  What memory is free?
+    //  1) Mark physical page 0 as in use.
+    //     This way we preserve the real-mode IDT and BIOS structures
+    //     in case we ever need them.  (Currently we don't, but...)
+    //  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
+    //     is free.
+    //  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
+    //     never be allocated.
+    //  4) Then extended memory [EXTPHYSMEM, ...).
+    //     Some of it is in use, some is free. Where is the kernel
+    //     in physical memory?  Which pages are already in use for
+    //     page tables and other data structures?
+    //
+    // Change the code to reflect this.
+    // NB: DO NOT actually touch the physical memory corresponding to
+    // free pages!
+    size_t i;
+    assert(page_free_list == 0);
+    unsigned used_top = PADDR(boot_alloc(0));
+    for (i = 0; i < npages; i++) {
+	if (i == 0 || (page2pa(&pages[i]) >= IOPHYSMEM && page2pa(&pages[i]) < used_top)||(page2pa(&pages[i]) == MPENTRY_PADDR))
+	    continue;
+	pages[i].pp_ref = 0;
+	pages[i].pp_link = page_free_list;
+	page_free_list = &pages[i];
+    }
 }
 
 //
@@ -318,34 +340,49 @@ page_init(void)
 // Returns NULL if out of free memory.
 //
 // Hint: use page2kva and memset
-struct PageInfo *
+    struct PageInfo *
 page_alloc(int alloc_flags)
 {
-	// Fill this function in
-	return 0;
+    // Fill this function in
+    if (page_free_list == NULL) return NULL;
+    struct PageInfo* ret = page_free_list;
+    page_free_list = ret->pp_link;
+    if (alloc_flags & ALLOC_ZERO) 
+	memset(page2kva(ret), 0, PGSIZE);
+    ret->pp_link = NULL;
+    return ret;
 }
 
 //
 // Return a page to the free list.
 // (This function should only be called when pp->pp_ref reaches 0.)
 //
-void
+    void
 page_free(struct PageInfo *pp)
 {
-	// Fill this function in
-	// Hint: You may want to panic if pp->pp_ref is nonzero or
-	// pp->pp_link is not NULL.
+    // Fill this function in
+    // Hint: You may want to panic if pp->pp_ref is nonzero or
+    // pp->pp_link is not NULL.
+    if(pp->pp_ref == 0){
+	pp->pp_link = page_free_list;
+	page_free_list = pp;
+    }
+    else
+    {
+	panic("pp->pp_ref is not zero. Wrong call of the page_free!!!");
+    }
 }
 
+
 //
 // Decrement the reference count on a page,
 // freeing it if there are no more refs.
 //
-void
+    void
 page_decref(struct PageInfo* pp)
 {
-	if (--pp->pp_ref == 0)
-		page_free(pp);
+    if (--pp->pp_ref == 0)
+	page_free(pp);
 }
 
 // Given 'pgdir', a pointer to a page directory, pgdir_walk returns
@@ -370,11 +407,18 @@ page_decref(struct PageInfo* pp)
 // Hint 3: look at inc/mmu.h for useful macros that mainipulate page
 // table and page directory entries.
 //
-pte_t *
+    pte_t *
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
-	// Fill this function in
-	return NULL;
+    // Fill this function in
+    if (!(pgdir[PDX(va)] & PTE_P)) {
+	if (!create) return NULL;
+	struct PageInfo *page = page_alloc(ALLOC_ZERO);
+	if (!page) return NULL;
+	page->pp_ref = 1;
+	pgdir[PDX(va)] = page2pa(page) | PTE_P | PTE_U | PTE_W;
+    }
+    return KADDR(PTE_ADDR(pgdir[PDX(va)])) + PTX(va) * sizeof(pte_t*);
 }
 
 //
@@ -388,12 +432,18 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 // mapped pages.
 //
 // Hint: the TA solution uses pgdir_walk
-static void
+    static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
-	// Fill this function in
+    // Fill this function in
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
 }
 
+
 //
 // Map the physical page 'pp' at virtual address 'va'.
 // The permissions (the low 12 bits) of the page table entry
@@ -419,11 +469,24 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 // Hint: The TA solution is implemented using pgdir_walk, page_remove,
 // and page2pa.
 //
-int
+    int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
-	// Fill this function in
-	return 0;
+    // Fill this function in
+    pte_t *pte = pgdir_walk(pgdir, va, 1);
+    if (pte == NULL) return -E_NO_MEM;
+    if (*pte & PTE_P) {
+	if (PTE_ADDR(*pte) == page2pa(pp)) {
+	    pp->pp_ref--;
+	    tlb_invalidate(pgdir, va);
+	}
+	else {
+	    page_remove(pgdir, va);
+	}
+    }
+    *pte = page2pa(pp) | perm | PTE_P;
+    pp->pp_ref++;
+    return 0;
 }
 
 //
@@ -437,17 +500,20 @@ page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 //
 // Hint: the TA solution uses pgdir_walk and pa2page.
 //
-struct PageInfo *
+    struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 {
-	// Fill this function in
-	return NULL;
+    // Fill this function in
+    pte_t *pte = pgdir_walk(pgdir, va, 0);
+    if (pte_store != NULL) *pte_store = pte;
+    if (pte == NULL || !(*pte & PTE_P)) return NULL;
+    return pa2page(PTE_ADDR(*pte));
 }
 
 //
 // Unmaps the physical page at virtual address 'va'.
 // If there is no physical page at that address, silently does nothing.
-//
+// 
 // Details:
 //   - The ref count on the physical page should decrement.
 //   - The physical page should be freed if the refcount reaches 0.
@@ -459,22 +525,29 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 // Hint: The TA solution is implemented using page_lookup,
 // 	tlb_invalidate, and page_decref.
 //
-void
+    void
 page_remove(pde_t *pgdir, void *va)
 {
-	// Fill this function in
+    // Fill this function in
+    struct PageInfo *page = page_lookup(pgdir, va, 0);
+    pte_t *pte = pgdir_walk(pgdir, va, 0);
+    if (page != NULL) page_decref(page);
+    if (pte != NULL) {
+	*pte = 0;
+	tlb_invalidate(pgdir, va);
+    }
 }
 
 //
 // Invalidate a TLB entry, but only if the page tables being
 // edited are the ones currently in use by the processor.
 //
-void
+    void
 tlb_invalidate(pde_t *pgdir, void *va)
 {
-	// Flush the entry only if we're modifying the current address space.
-	if (!curenv || curenv->env_pgdir == pgdir)
-		invlpg(va);
+    // Flush the entry only if we're modifying the current address space.
+    if (!curenv || curenv->env_pgdir == pgdir)
+	invlpg(va);
 }
 
 //
@@ -482,34 +555,40 @@ tlb_invalidate(pde_t *pgdir, void *va)
 // location.  Return the base of the reserved region.  size does *not*
 // have to be multiple of PGSIZE.
 //
-void *
+    void *
 mmio_map_region(physaddr_t pa, size_t size)
 {
-	// Where to start the next region.  Initially, this is the
-	// beginning of the MMIO region.  Because this is static, its
-	// value will be preserved between calls to mmio_map_region
-	// (just like nextfree in boot_alloc).
-	static uintptr_t base = MMIOBASE;
-
-	// Reserve size bytes of virtual memory starting at base and
-	// map physical pages [pa,pa+size) to virtual addresses
-	// [base,base+size).  Since this is device memory and not
-	// regular DRAM, you'll have to tell the CPU that it isn't
-	// safe to cache access to this memory.  Luckily, the page
-	// tables provide bits for this purpose; simply create the
-	// mapping with PTE_PCD|PTE_PWT (cache-disable and
-	// write-through) in addition to PTE_W.  (If you're interested
-	// in more details on this, see section 10.5 of IA32 volume
-	// 3A.)
-	//
-	// Be sure to round size up to a multiple of PGSIZE and to
-	// handle if this reservation would overflow MMIOLIM (it's
-	// okay to simply panic if this happens).
-	//
-	// Hint: The staff solution uses boot_map_region.
-	//
-	// Your code here:
-	panic("mmio_map_region not implemented");
+    // Where to start the next region.  Initially, this is the
+    // beginning of the MMIO region.  Because this is static, its
+    // value will be preserved between calls to mmio_map_region
+    // (just like nextfree in boot_alloc).
+    static uintptr_t base = MMIOBASE;
+
+    // Reserve size bytes of virtual memory starting at base and
+    // map physical pages [pa,pa+size) to virtual addresses
+    // [base,base+size).  Since this is device memory and not
+    // regular DRAM, you'll have to tell the CPU that it isn't
+    // safe to cache access to this memory.  Luckily, the page
+    // tables provide bits for this purpose; simply create the
+    // mapping with PTE_PCD|PTE_PWT (cache-disable and
+    // write-through) in addition to PTE_W.  (If you're interested
+    // in more details on this, see section 10.5 of IA32 volume
+    // 3A.)
+    //
+    // Be sure to round size up to a multiple of PGSIZE and to
+    // handle if this reservation would overflow MMIOLIM (it's
+    // okay to simply panic if this happens).
+    //
+    // Hint: The staff solution uses boot_map_region.
+    //
+    // Your code here:
+    size = ROUNDUP(size, PGSIZE);
+    if (base + size > MMIOLIM)
+	panic("mmio_map_region(): out of memory\n");
+    boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
+    base += size;
+    return (void*)(base - size);
+    panic("mmio_map_region not implemented");
 }
 
 static uintptr_t user_mem_check_addr;
@@ -532,12 +611,25 @@ static uintptr_t user_mem_check_addr;
 // Returns 0 if the user program can access this range of addresses,
 // and -E_FAULT otherwise.
 //
-int
+    int
 user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 {
-	// LAB 3: Your code here.
-
-	return 0;
+    // LAB 3: Your code here.
+
+    uintptr_t va1 = (uintptr_t)va, va2 = va1 + len;
+    pte_t *pte;
+    for (; va1 < va2; va1 = ROUNDDOWN(va1 + PGSIZE, PGSIZE)) {
+	if (va1 >= ULIM) {
+	    user_mem_check_addr = va1;
+	    return -E_FAULT;
+	}
+	pte = pgdir_walk(env->env_pgdir, (void*)va1, 0);
+	if (pte == NULL||(*pte & (perm | PTE_P)) != (perm | PTE_P)) {
+	    user_mem_check_addr = va1;
+	    return -E_FAULT;
+	}
+    }
+    return 0;
 }
 
 //
@@ -547,14 +639,14 @@ user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 // If it cannot, 'env' is destroyed and, if env is the current
 // environment, this function will not return.
 //
-void
+    void
 user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
 {
-	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
-		cprintf("[%08x] user_mem_check assertion failure for "
-			"va %08x\n", env->env_id, user_mem_check_addr);
-		env_destroy(env);	// may not return
-	}
+    if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
+	cprintf("[%08x] user_mem_check assertion failure for "
+		"va %08x\n", env->env_id, user_mem_check_addr);
+	env_destroy(env);	// may not return
+    }
 }
 
 
@@ -565,142 +657,141 @@ user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
 //
 // Check that the pages on the page_free_list are reasonable.
 //
-static void
+    static void
 check_page_free_list(bool only_low_memory)
 {
-	struct PageInfo *pp;
-	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
-	int nfree_basemem = 0, nfree_extmem = 0;
-	char *first_free_page;
-
-	if (!page_free_list)
-		panic("'page_free_list' is a null pointer!");
-
-	if (only_low_memory) {
-		// Move pages with lower addresses first in the free
-		// list, since entry_pgdir does not map all pages.
-		struct PageInfo *pp1, *pp2;
-		struct PageInfo **tp[2] = { &pp1, &pp2 };
-		for (pp = page_free_list; pp; pp = pp->pp_link) {
-			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
-			*tp[pagetype] = pp;
-			tp[pagetype] = &pp->pp_link;
-		}
-		*tp[1] = 0;
-		*tp[0] = pp2;
-		page_free_list = pp1;
-	}
-
-	// if there's a page that shouldn't be on the free list,
-	// try to make sure it eventually causes trouble.
-	for (pp = page_free_list; pp; pp = pp->pp_link)
-		if (PDX(page2pa(pp)) < pdx_limit)
-			memset(page2kva(pp), 0x97, 128);
-
-	first_free_page = (char *) boot_alloc(0);
+    struct PageInfo *pp;
+    unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
+    int nfree_basemem = 0, nfree_extmem = 0;
+    char *first_free_page;
+
+    if (!page_free_list)
+	panic("'page_free_list' is a null pointer!");
+
+    if (only_low_memory) {
+	// Move pages with lower addresses first in the free
+	// list, since entry_pgdir does not map all pages.
+	struct PageInfo *pp1, *pp2;
+	struct PageInfo **tp[2] = { &pp1, &pp2 };
 	for (pp = page_free_list; pp; pp = pp->pp_link) {
-		// check that we didn't corrupt the free list itself
-		assert(pp >= pages);
-		assert(pp < pages + npages);
-		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
-
-		// check a few pages that shouldn't be on the free list
-		assert(page2pa(pp) != 0);
-		assert(page2pa(pp) != IOPHYSMEM);
-		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
-		assert(page2pa(pp) != EXTPHYSMEM);
-		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
-		// (new test for lab 4)
-		assert(page2pa(pp) != MPENTRY_PADDR);
-
-		if (page2pa(pp) < EXTPHYSMEM)
-			++nfree_basemem;
-		else
-			++nfree_extmem;
+	    int pagetype = PDX(page2pa(pp)) >= pdx_limit;
+	    *tp[pagetype] = pp;
+	    tp[pagetype] = &pp->pp_link;
 	}
+	*tp[1] = 0;
+	*tp[0] = pp2;
+	page_free_list = pp1;
+    }
+
+    // if there's a page that shouldn't be on the free list,
+    // try to make sure it eventually causes trouble.
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+	if (PDX(page2pa(pp)) < pdx_limit)
+	    memset(page2kva(pp), 0x97, 128);
+
+    first_free_page = (char *) boot_alloc(0);
+    for (pp = page_free_list; pp; pp = pp->pp_link) {
+	// check that we didn't corrupt the free list itself
+	assert(pp >= pages);
+	assert(pp < pages + npages);
+	assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
+
+	// check a few pages that shouldn't be on the free list
+	assert(page2pa(pp) != 0);
+	assert(page2pa(pp) != IOPHYSMEM);
+	assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
+	assert(page2pa(pp) != EXTPHYSMEM);
+	assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
+	// (new test for lab 4)
+	assert(page2pa(pp) != MPENTRY_PADDR);
+
+	if (page2pa(pp) < EXTPHYSMEM)
+	    ++nfree_basemem;
+	else
+	    ++nfree_extmem;
+    }
+    assert(nfree_basemem > 0);
+    assert(nfree_extmem > 0);
 
-	assert(nfree_basemem > 0);
-	assert(nfree_extmem > 0);
-
-	cprintf("check_page_free_list() succeeded!\n");
+    cprintf("check_page_free_list() succeeded!\n");
 }
 
 //
 // Check the physical page allocator (page_alloc(), page_free(),
 // and page_init()).
 //
-static void
+    static void
 check_page_alloc(void)
 {
-	struct PageInfo *pp, *pp0, *pp1, *pp2;
-	int nfree;
-	struct PageInfo *fl;
-	char *c;
-	int i;
-
-	if (!pages)
-		panic("'pages' is a null pointer!");
-
-	// check number of free pages
-	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
-		++nfree;
-
-	// should be able to allocate three pages
-	pp0 = pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-
-	assert(pp0);
-	assert(pp1 && pp1 != pp0);
-	assert(pp2 && pp2 != pp1 && pp2 != pp0);
-	assert(page2pa(pp0) < npages*PGSIZE);
-	assert(page2pa(pp1) < npages*PGSIZE);
-	assert(page2pa(pp2) < npages*PGSIZE);
-
-	// temporarily steal the rest of the free pages
-	fl = page_free_list;
-	page_free_list = 0;
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// free and re-allocate?
-	page_free(pp0);
-	page_free(pp1);
-	page_free(pp2);
-	pp0 = pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-	assert(pp0);
-	assert(pp1 && pp1 != pp0);
-	assert(pp2 && pp2 != pp1 && pp2 != pp0);
-	assert(!page_alloc(0));
-
-	// test flags
-	memset(page2kva(pp0), 1, PGSIZE);
-	page_free(pp0);
-	assert((pp = page_alloc(ALLOC_ZERO)));
-	assert(pp && pp0 == pp);
-	c = page2kva(pp);
-	for (i = 0; i < PGSIZE; i++)
-		assert(c[i] == 0);
-
-	// give free list back
-	page_free_list = fl;
-
-	// free the pages we took
-	page_free(pp0);
-	page_free(pp1);
-	page_free(pp2);
-
-	// number of free pages should be the same
-	for (pp = page_free_list; pp; pp = pp->pp_link)
-		--nfree;
-	assert(nfree == 0);
-
-	cprintf("check_page_alloc() succeeded!\n");
+    struct PageInfo *pp, *pp0, *pp1, *pp2;
+    int nfree;
+    struct PageInfo *fl;
+    char *c;
+    int i;
+
+    if (!pages)
+	panic("'pages' is a null pointer!");
+
+    // check number of free pages
+    for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
+	++nfree;
+
+    // should be able to allocate three pages
+    pp0 = pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+
+    assert(pp0);
+    assert(pp1 && pp1 != pp0);
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+    assert(page2pa(pp0) < npages*PGSIZE);
+    assert(page2pa(pp1) < npages*PGSIZE);
+    assert(page2pa(pp2) < npages*PGSIZE);
+
+    // temporarily steal the rest of the free pages
+    fl = page_free_list;
+    page_free_list = 0;
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // free and re-allocate?
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+    pp0 = pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+    assert(pp0);
+    assert(pp1 && pp1 != pp0);
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+    assert(!page_alloc(0));
+
+    // test flags
+    memset(page2kva(pp0), 1, PGSIZE);
+    page_free(pp0);
+    assert((pp = page_alloc(ALLOC_ZERO)));
+    assert(pp && pp0 == pp);
+    c = page2kva(pp);
+    for (i = 0; i < PGSIZE; i++)
+	assert(c[i] == 0);
+
+    // give free list back
+    page_free_list = fl;
+
+    // free the pages we took
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+
+    // number of free pages should be the same
+    for (pp = page_free_list; pp; pp = pp->pp_link)
+	--nfree;
+    assert(nfree == 0);
+
+    cprintf("check_page_alloc() succeeded!\n");
 }
 
 //
@@ -711,59 +802,59 @@ check_page_alloc(void)
 // but it is a pretty good sanity check.
 //
 
-static void
+    static void
 check_kern_pgdir(void)
 {
-	uint32_t i, n;
-	pde_t *pgdir;
-
-	pgdir = kern_pgdir;
-
-	// check pages array
-	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
-	for (i = 0; i < n; i += PGSIZE)
-		assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
-
-	// check envs array (new test for lab 3)
-	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
-	for (i = 0; i < n; i += PGSIZE)
-		assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
-
-	// check phys mem
-	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
-		assert(check_va2pa(pgdir, KERNBASE + i) == i);
-
-	// check kernel stack
-	// (updated in lab 4 to check per-CPU kernel stacks)
-	for (n = 0; n < NCPU; n++) {
-		uint32_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
-		for (i = 0; i < KSTKSIZE; i += PGSIZE)
-			assert(check_va2pa(pgdir, base + KSTKGAP + i)
-				== PADDR(percpu_kstacks[n]) + i);
-		for (i = 0; i < KSTKGAP; i += PGSIZE)
-			assert(check_va2pa(pgdir, base + i) == ~0);
-	}
-
-	// check PDE permissions
-	for (i = 0; i < NPDENTRIES; i++) {
-		switch (i) {
-		case PDX(UVPT):
-		case PDX(KSTACKTOP-1):
-		case PDX(UPAGES):
-		case PDX(UENVS):
-		case PDX(MMIOBASE):
-			assert(pgdir[i] & PTE_P);
-			break;
-		default:
-			if (i >= PDX(KERNBASE)) {
-				assert(pgdir[i] & PTE_P);
-				assert(pgdir[i] & PTE_W);
-			} else
-				assert(pgdir[i] == 0);
-			break;
-		}
+    uint32_t i, n;
+    pde_t *pgdir;
+
+    pgdir = kern_pgdir;
+
+    // check pages array
+    n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+	assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+
+    // check envs array (new test for lab 3)
+    n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+    for (i = 0; i < n; i += PGSIZE)
+	assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+
+    // check phys mem
+    for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+	assert(check_va2pa(pgdir, KERNBASE + i) == i);
+
+    // check kernel stack
+    // (updated in lab 4 to check per-CPU kernel stacks)
+    for (n = 0; n < NCPU; n++) {
+	uint32_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
+	for (i = 0; i < KSTKSIZE; i += PGSIZE)
+	    assert(check_va2pa(pgdir, base + KSTKGAP + i)
+		    == PADDR(percpu_kstacks[n]) + i);
+	for (i = 0; i < KSTKGAP; i += PGSIZE)
+	    assert(check_va2pa(pgdir, base + i) == ~0);
+    }
+
+    // check PDE permissions
+    for (i = 0; i < NPDENTRIES; i++) {
+	switch (i) {
+	    case PDX(UVPT):
+	    case PDX(KSTACKTOP-1):
+	    case PDX(UPAGES):
+	    case PDX(UENVS):
+	    case PDX(MMIOBASE):
+		assert(pgdir[i] & PTE_P);
+		break;
+	    default:
+		if (i >= PDX(KERNBASE)) {
+		    assert(pgdir[i] & PTE_P);
+		    assert(pgdir[i] & PTE_W);
+		} else
+		    assert(pgdir[i] == 0);
+		break;
 	}
-	cprintf("check_kern_pgdir() succeeded!\n");
+    }
+    cprintf("check_kern_pgdir() succeeded!\n");
 }
 
 // This function returns the physical address of the page containing 'va',
@@ -771,236 +862,236 @@ check_kern_pgdir(void)
 // this functionality for us!  We define our own version to help check
 // the check_kern_pgdir() function; it shouldn't be used elsewhere.
 
-static physaddr_t
+    static physaddr_t
 check_va2pa(pde_t *pgdir, uintptr_t va)
 {
-	pte_t *p;
-
-	pgdir = &pgdir[PDX(va)];
-	if (!(*pgdir & PTE_P))
-		return ~0;
-	p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
-	if (!(p[PTX(va)] & PTE_P))
-		return ~0;
-	return PTE_ADDR(p[PTX(va)]);
+    pte_t *p;
+
+    pgdir = &pgdir[PDX(va)];
+    if (!(*pgdir & PTE_P))
+	return ~0;
+    p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
+    if (!(p[PTX(va)] & PTE_P))
+	return ~0;
+    return PTE_ADDR(p[PTX(va)]);
 }
 
 
 // check page_insert, page_remove, &c
-static void
+    static void
 check_page(void)
 {
-	struct PageInfo *pp, *pp0, *pp1, *pp2;
-	struct PageInfo *fl;
-	pte_t *ptep, *ptep1;
-	void *va;
-	uintptr_t mm1, mm2;
-	int i;
-	extern pde_t entry_pgdir[];
-
-	// should be able to allocate three pages
-	pp0 = pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-
-	assert(pp0);
-	assert(pp1 && pp1 != pp0);
-	assert(pp2 && pp2 != pp1 && pp2 != pp0);
-
-	// temporarily steal the rest of the free pages
-	fl = page_free_list;
-	page_free_list = 0;
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// there is no page allocated at address 0
-	assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
-
-	// there is no free memory, so we can't allocate a page table
-	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
-
-	// free pp0 and try again: pp0 should be used for page table
-	page_free(pp0);
-	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
-	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
-	assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
-	assert(pp1->pp_ref == 1);
-	assert(pp0->pp_ref == 1);
-
-	// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
-	assert(pp2->pp_ref == 1);
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// should be able to map pp2 at PGSIZE because it's already there
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
-	assert(pp2->pp_ref == 1);
-
-	// pp2 should NOT be on the free list
-	// could happen in ref counts are handled sloppily in page_insert
-	assert(!page_alloc(0));
-
-	// check that pgdir_walk returns a pointer to the pte
-	ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
-	assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
-
-	// should be able to change permissions too.
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
-	assert(pp2->pp_ref == 1);
-	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
-	assert(kern_pgdir[0] & PTE_U);
-
-	// should be able to remap with fewer permissions
-	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
-	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
-	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
-
-	// should not be able to map at PTSIZE because need free page for page table
-	assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
-
-	// insert pp1 at PGSIZE (replacing pp2)
-	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
-	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
-
-	// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
-	assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
-	// ... and ref counts should reflect this
-	assert(pp1->pp_ref == 2);
-	assert(pp2->pp_ref == 0);
-
-	// pp2 should be returned by page_alloc
-	assert((pp = page_alloc(0)) && pp == pp2);
-
-	// unmapping pp1 at 0 should keep pp1 at PGSIZE
-	page_remove(kern_pgdir, 0x0);
-	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
-	assert(pp1->pp_ref == 1);
-	assert(pp2->pp_ref == 0);
-
-	// test re-inserting pp1 at PGSIZE
-	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
-	assert(pp1->pp_ref);
-	assert(pp1->pp_link == NULL);
-
-	// unmapping pp1 at PGSIZE should free it
-	page_remove(kern_pgdir, (void*) PGSIZE);
-	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
-	assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
-	assert(pp1->pp_ref == 0);
-	assert(pp2->pp_ref == 0);
-
-	// so it should be returned by page_alloc
-	assert((pp = page_alloc(0)) && pp == pp1);
-
-	// should be no free memory
-	assert(!page_alloc(0));
-
-	// forcibly take pp0 back
-	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
-	kern_pgdir[0] = 0;
-	assert(pp0->pp_ref == 1);
-	pp0->pp_ref = 0;
-
-	// check pointer arithmetic in pgdir_walk
-	page_free(pp0);
-	va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
-	ptep = pgdir_walk(kern_pgdir, va, 1);
-	ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
-	assert(ptep == ptep1 + PTX(va));
-	kern_pgdir[PDX(va)] = 0;
-	pp0->pp_ref = 0;
-
-	// check that new page tables get cleared
-	memset(page2kva(pp0), 0xFF, PGSIZE);
-	page_free(pp0);
-	pgdir_walk(kern_pgdir, 0x0, 1);
-	ptep = (pte_t *) page2kva(pp0);
-	for(i=0; i<NPTENTRIES; i++)
-		assert((ptep[i] & PTE_P) == 0);
-	kern_pgdir[0] = 0;
-	pp0->pp_ref = 0;
-
-	// give free list back
-	page_free_list = fl;
-
-	// free the pages we took
-	page_free(pp0);
-	page_free(pp1);
-	page_free(pp2);
-
-	// test mmio_map_region
-	mm1 = (uintptr_t) mmio_map_region(0, 4097);
-	mm2 = (uintptr_t) mmio_map_region(0, 4096);
-	// check that they're in the right region
-	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
-	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
-	// check that they're page-aligned
-	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
-	// check that they don't overlap
-	assert(mm1 + 8096 <= mm2);
-	// check page mappings
-	assert(check_va2pa(kern_pgdir, mm1) == 0);
-	assert(check_va2pa(kern_pgdir, mm1+PGSIZE) == PGSIZE);
-	assert(check_va2pa(kern_pgdir, mm2) == 0);
-	assert(check_va2pa(kern_pgdir, mm2+PGSIZE) == ~0);
-	// check permissions
-	assert(*pgdir_walk(kern_pgdir, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
-	assert(!(*pgdir_walk(kern_pgdir, (void*) mm1, 0) & PTE_U));
-	// clear the mappings
-	*pgdir_walk(kern_pgdir, (void*) mm1, 0) = 0;
-	*pgdir_walk(kern_pgdir, (void*) mm1 + PGSIZE, 0) = 0;
-	*pgdir_walk(kern_pgdir, (void*) mm2, 0) = 0;
-
-	cprintf("check_page() succeeded!\n");
+    struct PageInfo *pp, *pp0, *pp1, *pp2;
+    struct PageInfo *fl;
+    pte_t *ptep, *ptep1;
+    void *va;
+    uintptr_t mm1, mm2;
+    int i;
+    extern pde_t entry_pgdir[];
+
+    // should be able to allocate three pages
+    pp0 = pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+
+    assert(pp0);
+    assert(pp1 && pp1 != pp0);
+    assert(pp2 && pp2 != pp1 && pp2 != pp0);
+
+    // temporarily steal the rest of the free pages
+    fl = page_free_list;
+    page_free_list = 0;
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // there is no page allocated at address 0
+    assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
+
+    // there is no free memory, so we can't allocate a page table
+    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
+
+    // free pp0 and try again: pp0 should be used for page table
+    page_free(pp0);
+    assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+    assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
+    assert(pp1->pp_ref == 1);
+    assert(pp0->pp_ref == 1);
+
+    // should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+    assert(pp2->pp_ref == 1);
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // should be able to map pp2 at PGSIZE because it's already there
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+    assert(pp2->pp_ref == 1);
+
+    // pp2 should NOT be on the free list
+    // could happen in ref counts are handled sloppily in page_insert
+    assert(!page_alloc(0));
+
+    // check that pgdir_walk returns a pointer to the pte
+    ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
+    assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
+
+    // should be able to change permissions too.
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+    assert(pp2->pp_ref == 1);
+    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
+    assert(kern_pgdir[0] & PTE_U);
+
+    // should be able to remap with fewer permissions
+    assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+    assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
+    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+    // should not be able to map at PTSIZE because need free page for page table
+    assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
+
+    // insert pp1 at PGSIZE (replacing pp2)
+    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
+    assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+    // should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
+    assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+    // ... and ref counts should reflect this
+    assert(pp1->pp_ref == 2);
+    assert(pp2->pp_ref == 0);
+
+    // pp2 should be returned by page_alloc
+    assert((pp = page_alloc(0)) && pp == pp2);
+
+    // unmapping pp1 at 0 should keep pp1 at PGSIZE
+    page_remove(kern_pgdir, 0x0);
+    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+    assert(pp1->pp_ref == 1);
+    assert(pp2->pp_ref == 0);
+
+    // test re-inserting pp1 at PGSIZE
+    assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
+    assert(pp1->pp_ref);
+    assert(pp1->pp_link == NULL);
+
+    // unmapping pp1 at PGSIZE should free it
+    page_remove(kern_pgdir, (void*) PGSIZE);
+    assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+    assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
+    assert(pp1->pp_ref == 0);
+    assert(pp2->pp_ref == 0);
+
+    // so it should be returned by page_alloc
+    assert((pp = page_alloc(0)) && pp == pp1);
+
+    // should be no free memory
+    assert(!page_alloc(0));
+
+    // forcibly take pp0 back
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+    kern_pgdir[0] = 0;
+    assert(pp0->pp_ref == 1);
+    pp0->pp_ref = 0;
+
+    // check pointer arithmetic in pgdir_walk
+    page_free(pp0);
+    va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
+    ptep = pgdir_walk(kern_pgdir, va, 1);
+    ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
+    assert(ptep == ptep1 + PTX(va));
+    kern_pgdir[PDX(va)] = 0;
+    pp0->pp_ref = 0;
+
+    // check that new page tables get cleared
+    memset(page2kva(pp0), 0xFF, PGSIZE);
+    page_free(pp0);
+    pgdir_walk(kern_pgdir, 0x0, 1);
+    ptep = (pte_t *) page2kva(pp0);
+    for(i=0; i<NPTENTRIES; i++)
+	assert((ptep[i] & PTE_P) == 0);
+    kern_pgdir[0] = 0;
+    pp0->pp_ref = 0;
+
+    // give free list back
+    page_free_list = fl;
+
+    // free the pages we took
+    page_free(pp0);
+    page_free(pp1);
+    page_free(pp2);
+
+    // test mmio_map_region
+    mm1 = (uintptr_t) mmio_map_region(0, 4097);
+    mm2 = (uintptr_t) mmio_map_region(0, 4096);
+    // check that they're in the right region
+    assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
+    assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
+    // check that they're page-aligned
+    assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
+    // check that they don't overlap
+    assert(mm1 + 8096 <= mm2);
+    // check page mappings
+    assert(check_va2pa(kern_pgdir, mm1) == 0);
+    assert(check_va2pa(kern_pgdir, mm1+PGSIZE) == PGSIZE);
+    assert(check_va2pa(kern_pgdir, mm2) == 0);
+    assert(check_va2pa(kern_pgdir, mm2+PGSIZE) == ~0);
+    // check permissions
+    assert(*pgdir_walk(kern_pgdir, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
+    assert(!(*pgdir_walk(kern_pgdir, (void*) mm1, 0) & PTE_U));
+    // clear the mappings
+    *pgdir_walk(kern_pgdir, (void*) mm1, 0) = 0;
+    *pgdir_walk(kern_pgdir, (void*) mm1 + PGSIZE, 0) = 0;
+    *pgdir_walk(kern_pgdir, (void*) mm2, 0) = 0;
+
+    cprintf("check_page() succeeded!\n");
 }
 
 // check page_insert, page_remove, &c, with an installed kern_pgdir
-static void
+    static void
 check_page_installed_pgdir(void)
 {
-	struct PageInfo *pp, *pp0, *pp1, *pp2;
-	struct PageInfo *fl;
-	pte_t *ptep, *ptep1;
-	uintptr_t va;
-	int i;
-
-	// check that we can read and write installed pages
-	pp1 = pp2 = 0;
-	assert((pp0 = page_alloc(0)));
-	assert((pp1 = page_alloc(0)));
-	assert((pp2 = page_alloc(0)));
-	page_free(pp0);
-	memset(page2kva(pp1), 1, PGSIZE);
-	memset(page2kva(pp2), 2, PGSIZE);
-	page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
-	assert(pp1->pp_ref == 1);
-	assert(*(uint32_t *)PGSIZE == 0x01010101U);
-	page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
-	assert(*(uint32_t *)PGSIZE == 0x02020202U);
-	assert(pp2->pp_ref == 1);
-	assert(pp1->pp_ref == 0);
-	*(uint32_t *)PGSIZE = 0x03030303U;
-	assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
-	page_remove(kern_pgdir, (void*) PGSIZE);
-	assert(pp2->pp_ref == 0);
-
-	// forcibly take pp0 back
-	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
-	kern_pgdir[0] = 0;
-	assert(pp0->pp_ref == 1);
-	pp0->pp_ref = 0;
-
-	// free the pages we took
-	page_free(pp0);
-
-	cprintf("check_page_installed_pgdir() succeeded!\n");
+    struct PageInfo *pp, *pp0, *pp1, *pp2;
+    struct PageInfo *fl;
+    pte_t *ptep, *ptep1;
+    uintptr_t va;
+    int i;
+
+    // check that we can read and write installed pages
+    pp1 = pp2 = 0;
+    assert((pp0 = page_alloc(0)));
+    assert((pp1 = page_alloc(0)));
+    assert((pp2 = page_alloc(0)));
+    page_free(pp0);
+    memset(page2kva(pp1), 1, PGSIZE);
+    memset(page2kva(pp2), 2, PGSIZE);
+    page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
+    assert(pp1->pp_ref == 1);
+    assert(*(uint32_t *)PGSIZE == 0x01010101U);
+    page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
+    assert(*(uint32_t *)PGSIZE == 0x02020202U);
+    assert(pp2->pp_ref == 1);
+    assert(pp1->pp_ref == 0);
+    *(uint32_t *)PGSIZE = 0x03030303U;
+    assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
+    page_remove(kern_pgdir, (void*) PGSIZE);
+    assert(pp2->pp_ref == 0);
+
+    // forcibly take pp0 back
+    assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+    kern_pgdir[0] = 0;
+    assert(pp0->pp_ref == 1);
+    pp0->pp_ref = 0;
+
+    // free the pages we took
+    page_free(pp0);
+
+    cprintf("check_page_installed_pgdir() succeeded!\n");
 }
diff --git a/kern/pmap.c~ b/kern/pmap.c~
new file mode 100644
index 0000000..180c733
--- /dev/null
+++ b/kern/pmap.c~
@@ -0,0 +1,973 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/x86.h>
+#include <inc/mmu.h>
+#include <inc/error.h>
+#include <inc/string.h>
+#include <inc/assert.h>
+
+#include <kern/pmap.h>
+#include <kern/kclock.h>
+#include <kern/env.h>
+
+// These variables are set by i386_detect_memory()
+size_t npages;			// Amount of physical memory (in pages)
+static size_t npages_basemem;	// Amount of base memory (in pages)
+
+// These variables are set in mem_init()
+pde_t *kern_pgdir;		// Kernel's initial page directory
+struct PageInfo *pages;		// Physical page state array
+static struct PageInfo *page_free_list;	// Free list of physical pages
+
+// --------------------------------------------------------------
+// Detect machine's physical memory setup.
+// --------------------------------------------------------------
+
+static int
+nvram_read(int r)
+{
+	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
+}
+
+static void
+i386_detect_memory(void)
+{
+	size_t basemem, extmem, ext16mem, totalmem;
+
+	// Use CMOS calls to measure available base & extended memory.
+	// (CMOS calls return results in kilobytes.)
+	basemem = nvram_read(NVRAM_BASELO);
+	extmem = nvram_read(NVRAM_EXTLO);
+	ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
+
+	// Calculate the number of physical pages available in both base
+	// and extended memory.
+	if (ext16mem)
+		totalmem = 16 * 1024 + ext16mem;
+	else if (extmem)
+		totalmem = 1 * 1024 + extmem;
+	else
+		totalmem = basemem;
+
+	npages = totalmem / (PGSIZE / 1024);
+	npages_basemem = basemem / (PGSIZE / 1024);
+
+	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
+		totalmem, basemem, totalmem - basemem);
+}
+
+
+// --------------------------------------------------------------
+// Set up memory mappings above UTOP.
+// --------------------------------------------------------------
+
+static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);
+static void check_page_free_list(bool only_low_memory);
+static void check_page_alloc(void);
+static void check_kern_pgdir(void);
+static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
+static void check_page(void);
+static void check_page_installed_pgdir(void);
+
+// This simple physical memory allocator is used only while JOS is setting
+// up its virtual memory system.  page_alloc() is the real allocator.
+//
+// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
+// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
+//
+// If n==0, returns the address of the next free page without allocating
+// anything.
+//
+// If we're out of memory, boot_alloc should panic.
+// This function may ONLY be used during initialization,
+// before the page_free_list list has been set up.
+static void *
+boot_alloc(uint32_t n)
+{
+	static char *nextfree;	// virtual address of next byte of free memory
+	char *result;
+	// Initialize nextfree if this is the first time.
+	// 'end' is a magic symbol automatically generated by the linker,
+	// which points to the end of the kernel's bss segment:
+	// the first virtual address that the linker did *not* assign
+	// to any kernel code or global variables.
+	if (!nextfree) {
+		extern char end[];
+		nextfree = ROUNDUP((char *) end, PGSIZE);
+	}
+
+	// Allocate a chunk large enough to hold 'n' bytes, then update
+	// nextfree.  Make sure nextfree is kept aligned
+	// to a multiple of PGSIZE.
+	// LAB 2: Your code here.
+	if (n == 0) return (void*)nextfree;
+	n = ROUNDUP(n, PGSIZE);
+	if (PADDR(nextfree + n) > npages * PGSIZE)
+	{
+		panic("kern/pmap.c: boot_alloc()");
+		return NULL;
+	}
+	result = nextfree;
+	nextfree += n;
+	return result;
+}
+
+// Set up a two-level page table:
+//    kern_pgdir is its linear (virtual) address of the root
+//
+// This function only sets up the kernel part of the address space
+// (ie. addresses >= UTOP).  The user part of the address space
+// will be setup later.
+//
+// From UTOP to ULIM, the user is allowed to read but not write.
+// Above ULIM the user cannot read or write.
+void
+mem_init(void)
+{
+	uint32_t cr0;
+	size_t n;
+
+	// Find out how much memory the machine has (npages & npages_basemem).
+	i386_detect_memory();
+
+	// Remove this line when you're ready to test this function.
+	//panic("mem_init: This function is not finished\n");
+
+	//////////////////////////////////////////////////////////////////////
+	// create initial page directory.
+	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
+	memset(kern_pgdir, 0, PGSIZE);
+
+	//////////////////////////////////////////////////////////////////////
+	// Recursively insert PD in itself as a page table, to form
+	// a virtual page table at virtual address UVPT.
+	// (For now, you don't have understand the greater purpose of the
+	// following line.)
+
+	// Permissions: kernel R, user R
+	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
+
+	//////////////////////////////////////////////////////////////////////
+	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
+	// The kernel uses this array to keep track of physical pages: for
+	// each physical page, there is a corresponding struct PageInfo in this
+	// array.  'npages' is the number of physical pages in memory.  Use memset
+	// to initialize all fields of each struct PageInfo to 0.
+	// Your code goes here:
+	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
+	memset(pages, 0, npages * sizeof(struct PageInfo));
+
+	//////////////////////////////////////////////////////////////////////
+	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
+	// LAB 3: Your code here.
+	 envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
+
+	//////////////////////////////////////////////////////////////////////
+	// Now that we've allocated the initial kernel data structures, we set
+	// up the list of free physical pages. Once we've done so, all further
+	// memory management will go through the page_* functions. In
+	// particular, we can now map memory using boot_map_region
+	// or page_insert
+	page_init();
+	
+
+	check_page_free_list(1);
+	check_page_alloc();
+	check_page();
+
+	//////////////////////////////////////////////////////////////////////
+	// Now we set up virtual memory
+
+	//////////////////////////////////////////////////////////////////////
+	// Map 'pages' read-only by the user at linear address UPAGES
+	// Permissions:
+	//    - the new image at UPAGES -- kernel R, user R
+	//      (ie. perm = PTE_U | PTE_P)
+	//    - pages itself -- kernel RW, user NONE
+	// Your code goes here:
+    	boot_map_region(kern_pgdir, UPAGES, ROUNDUP(sizeof(struct PageInfo)* npages, PGSIZE), PADDR(pages), PTE_U);
+
+	//////////////////////////////////////////////////////////////////////
+	// Map the 'envs' array read-only by the user at linear address UENVS
+	// (ie. perm = PTE_U | PTE_P).
+	// Permissions:
+	//    - the new image at UENVS  -- kernel R, user R
+	//    - envs itself -- kernel RW, user NONE
+	// LAB 3: Your code here.
+ 	//boot_map_region(kern_pgdir, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_U);	
+
+	//////////////////////////////////////////////////////////////////////
+	// Use the physical memory that 'bootstack' refers to as the kernel
+	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
+	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
+	// to be the kernel stack, but break this into two pieces:
+	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
+	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
+	//       the kernel overflows its stack, it will fault rather than
+	//       overwrite memory.  Known as a "guard page".
+	//     Permissions: kernel RW, user NONE
+	// Your code goes here:
+	 boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, ROUNDUP(KSTKSIZE, PGSIZE), PADDR(bootstack), PTE_W);
+
+	//////////////////////////////////////////////////////////////////////
+	// Map all of physical memory at KERNBASE.
+	// Ie.  the VA range [KERNBASE, 2^32) should map to
+	//      the PA range [0, 2^32 - KERNBASE)
+	// We might not have 2^32 - KERNBASE bytes of physical memory, but
+	// we just set up the mapping anyway.
+	// Permissions: kernel RW, user NONE
+	// Your code goes here:
+    boot_map_region(kern_pgdir, (uintptr_t)KERNBASE , -KERNBASE, (physaddr_t)0, PTE_W);
+
+
+	// Check that the initial page directory has been set up correctly.
+	check_kern_pgdir();
+
+	// Switch from the minimal entry page directory to the full kern_pgdir
+	// page table we just created.	Our instruction pointer should be
+	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
+	// mapped the same way by both page tables.
+	//
+	// If the machine reboots at this point, you've probably set up your
+	// kern_pgdir wrong.
+	lcr3(PADDR(kern_pgdir));
+
+	check_page_free_list(0);
+
+	// entry.S set the really important flags in cr0 (including enabling
+	// paging).  Here we configure the rest of the flags that we care about.
+	cr0 = rcr0();
+	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
+	cr0 &= ~(CR0_TS|CR0_EM);
+	lcr0(cr0);
+
+	// Some more checks, only possible after kern_pgdir is installed.
+	check_page_installed_pgdir();
+}
+
+// --------------------------------------------------------------
+// Tracking of physical pages.
+// The 'pages' array has one 'struct PageInfo' entry per physical page.
+// Pages are reference counted, and free pages are kept on a linked list.
+// --------------------------------------------------------------
+
+//
+// Initialize page structure and memory free list.
+// After this is done, NEVER use boot_alloc again.  ONLY use the page
+// allocator functions below to allocate and deallocate physical
+// memory via the page_free_list.
+//
+void
+page_init(void)
+{
+	// The example code here marks all physical pages as free.
+	// However this is not truly the case.  What memory is free?
+	//  1) Mark physical page 0 as in use.
+	//     This way we preserve the real-mode IDT and BIOS structures
+	//     in case we ever need them.  (Currently we don't, but...)
+	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
+	//     is free.
+	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
+	//     never be allocated.
+	//  4) Then extended memory [EXTPHYSMEM, ...).
+	//     Some of it is in use, some is free. Where is the kernel
+	//     in physical memory?  Which pages are already in use for
+	//     page tables and other data structures?
+	//
+	// Change the code to reflect this.
+	// NB: DO NOT actually touch the physical memory corresponding to
+	// free pages!
+	size_t i;
+    	assert(page_free_list == 0);
+    	unsigned used_top = PADDR(boot_alloc(0));
+    	for (i = 0; i < npages; i++) {
+		if (i == 0 || (page2pa(&pages[i]) >= IOPHYSMEM && page2pa(&pages[i]) < used_top))
+	   	continue;
+	pages[i].pp_ref = 0;
+	pages[i].pp_link = page_free_list;
+	page_free_list = &pages[i];
+    	}
+}
+
+//
+// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
+// returned physical page with '\0' bytes.  Does NOT increment the reference
+// count of the page - the caller must do these if necessary (either explicitly
+// or via page_insert).
+//
+// Be sure to set the pp_link field of the allocated page to NULL so
+// page_free can check for double-free bugs.
+//
+// Returns NULL if out of free memory.
+//
+// Hint: use page2kva and memset
+struct PageInfo *
+page_alloc(int alloc_flags)
+{
+	// Fill this function in
+	if (page_free_list == NULL) return NULL;
+    	struct PageInfo* ret = page_free_list;
+   	page_free_list = ret->pp_link;
+    	if (alloc_flags & ALLOC_ZERO) 
+		memset(page2kva(ret), 0, PGSIZE);
+	ret->pp_link = NULL;
+    	return ret;
+
+}
+
+//
+// Return a page to the free list.
+// (This function should only be called when pp->pp_ref reaches 0.)
+//
+void
+page_free(struct PageInfo *pp)
+{
+	// Fill this function in
+	// Hint: You may want to panic if pp->pp_ref is nonzero or
+	// pp->pp_link is not NULL.
+		
+	if(pp->pp_ref == 0){
+    		pp->pp_link = page_free_list;
+	    	page_free_list = pp;
+	}
+	else
+	{
+		panic("pp->pp_ref is not zero. Wrong call of the page_free!!!");
+	}
+}
+
+
+//
+// Decrement the reference count on a page,
+// freeing it if there are no more refs.
+//
+void
+page_decref(struct PageInfo* pp)
+{
+	if (--pp->pp_ref == 0)
+		page_free(pp);
+}
+
+// Given 'pgdir', a pointer to a page directory, pgdir_walk returns
+// a pointer to the page table entry (PTE) for linear address 'va'.
+// This requires walking the two-level page table structure.
+//
+// The relevant page table page might not exist yet.
+// If this is true, and create == false, then pgdir_walk returns NULL.
+// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
+//    - If the allocation fails, pgdir_walk returns NULL.
+//    - Otherwise, the new page's reference count is incremented,
+//	the page is cleared,
+//	and pgdir_walk returns a pointer into the new page table page.
+//
+// Hint 1: you can turn a PageInfo * into the physical address of the
+// page it refers to with page2pa() from kern/pmap.h.
+//
+// Hint 2: the x86 MMU checks permission bits in both the page directory
+// and the page table, so it's safe to leave permissions in the page
+// directory more permissive than strictly necessary.
+//
+// Hint 3: look at inc/mmu.h for useful macros that mainipulate page
+// table and page directory entries.
+//
+pte_t *
+pgdir_walk(pde_t *pgdir, const void *va, int create)
+{
+    // Fill this function in
+      if (!(pgdir[PDX(va)] & PTE_P)) {
+	if (!create) return NULL;
+	struct PageInfo *page = page_alloc(ALLOC_ZERO);
+	if (!page) return NULL;
+	page->pp_ref = 1;
+	pgdir[PDX(va)] = page2pa(page) | PTE_P | PTE_U | PTE_W;
+    }
+    return KADDR(PTE_ADDR(pgdir[PDX(va)])) + PTX(va) * sizeof(pte_t*);
+}
+
+//
+// Map [va, va+size) of virtual address space to physical [pa, pa+size)
+// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
+// va and pa are both page-aligned.
+// Use permission bits perm|PTE_P for the entries.
+//
+// This function is only intended to set up the ``static'' mappings
+// above UTOP. As such, it should *not* change the pp_ref field on the
+// mapped pages.
+//
+// Hint: the TA solution uses pgdir_walk
+//
+static void
+boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
+{
+    // Fill this function in
+    int i;
+    for (i = 0; i < size; i += PGSIZE) {
+	pte_t *pte = pgdir_walk(pgdir, (void*)(va + i), 1);
+	if (pte) *pte = (pa + i) | perm | PTE_P;
+    }
+}
+
+
+//
+// Map the physical page 'pp' at virtual address 'va'.
+// The permissions (the low 12 bits) of the page table entry
+// should be set to 'perm|PTE_P'.
+//
+// Requirements
+//   - If there is already a page mapped at 'va', it should be page_remove()d.
+//   - If necessary, on demand, a page table should be allocated and inserted
+//     into 'pgdir'.
+//   - pp->pp_ref should be incremented if the insertion succeeds.
+//   - The TLB must be invalidated if a page was formerly present at 'va'.
+//
+// Corner-case hint: Make sure to consider what happens when the same
+// pp is re-inserted at the same virtual address in the same pgdir.
+// However, try not to distinguish this case in your code, as this
+// frequently leads to subtle bugs; there's an elegant way to handle
+// everything in one code path.
+//
+// RETURNS:
+//   0 on success
+//   -E_NO_MEM, if page table couldn't be allocated
+//
+// Hint: The TA solution is implemented using pgdir_walk, page_remove,
+// and page2pa.
+//
+int
+page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
+{
+	// Fill this function in
+	pte_t *pte = pgdir_walk(pgdir, va, 1);
+    	if (pte == NULL) return -E_NO_MEM;
+    	if (*pte & PTE_P) {
+		if (PTE_ADDR(*pte) == page2pa(pp)) {
+		    pp->pp_ref--;
+		    tlb_invalidate(pgdir, va);
+		}
+		else {
+		    page_remove(pgdir, va);
+		}
+    	}
+    	*pte = page2pa(pp) | perm | PTE_P;
+    	pp->pp_ref++;
+    	return 0;
+}
+
+//
+// Return the page mapped at virtual address 'va'.
+// If pte_store is not zero, then we store in it the address
+// of the pte for this page.  This is used by page_remove and
+// can be used to verify page permissions for syscall arguments,
+// but should not be used by most callers.
+//
+// Return NULL if there is no page mapped at va.
+//
+// Hint: the TA solution uses pgdir_walk and pa2page.
+//
+struct PageInfo *
+page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
+{
+	// Fill this function in
+    	pte_t *pte = pgdir_walk(pgdir, va, 0);
+   	if (pte_store != NULL) *pte_store = pte;
+    	if (pte == NULL || !(*pte & PTE_P)) return NULL;
+    	return pa2page(PTE_ADDR(*pte));
+}
+
+//
+// Unmaps the physical page at virtual address 'va'.
+// If there is no physical page at that address, silently does nothing.
+// 
+// Details:
+//   - The ref count on the physical page should decrement.
+//   - The physical page should be freed if the refcount reaches 0.
+//   - The pg table entry corresponding to 'va' should be set to 0.
+//     (if such a PTE exists)
+//   - The TLB must be invalidated if you remove an entry from
+//     the page table.
+//
+// Hint: The TA solution is implemented using page_lookup,
+// 	tlb_invalidate, and page_decref.
+//
+void
+page_remove(pde_t *pgdir, void *va)
+{
+   	// Fill this function in
+    	struct PageInfo *page = page_lookup(pgdir, va, 0);
+    	pte_t *pte = pgdir_walk(pgdir, va, 0);
+    	if (page != NULL) page_decref(page);
+    	if (pte != NULL) {
+		*pte = 0;
+		tlb_invalidate(pgdir, va);
+    	}
+}
+
+//
+// Invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+//
+void
+tlb_invalidate(pde_t *pgdir, void *va)
+{
+	// Flush the entry only if we're modifying the current address space.
+	// For now, there is only one address space, so always invalidate.
+	invlpg(va);
+}
+
+static uintptr_t user_mem_check_addr;
+
+//
+// Check that an environment is allowed to access the range of memory
+// [va, va+len) with permissions 'perm | PTE_P'.
+// Normally 'perm' will contain PTE_U at least, but this is not required.
+// 'va' and 'len' need not be page-aligned; you must test every page that
+// contains any of that range.  You will test either 'len/PGSIZE',
+// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.
+//
+// A user program can access a virtual address if (1) the address is below
+// ULIM, and (2) the page table gives it permission.  These are exactly
+// the tests you should implement here.
+//
+// If there is an error, set the 'user_mem_check_addr' variable to the first
+// erroneous virtual address.
+//
+// Returns 0 if the user program can access this range of addresses,
+// and -E_FAULT otherwise.
+//
+int
+user_mem_check(struct Env *env, const void *va, size_t len, int perm)
+{
+	// LAB 3: Your code here.
+
+	return 0;
+}
+
+//
+// Checks that environment 'env' is allowed to access the range
+// of memory [va, va+len) with permissions 'perm | PTE_U | PTE_P'.
+// If it can, then the function simply returns.
+// If it cannot, 'env' is destroyed and, if env is the current
+// environment, this function will not return.
+//
+void
+user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
+{
+	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
+		cprintf("[%08x] user_mem_check assertion failure for "
+			"va %08x\n", env->env_id, user_mem_check_addr);
+		env_destroy(env);	// may not return
+	}
+}
+
+
+// --------------------------------------------------------------
+// Checking functions.
+// --------------------------------------------------------------
+
+//
+// Check that the pages on the page_free_list are reasonable.
+//
+static void
+check_page_free_list(bool only_low_memory)
+{
+	struct PageInfo *pp;
+	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
+	int nfree_basemem = 0, nfree_extmem = 0;
+	char *first_free_page;
+
+	if (!page_free_list)
+		panic("'page_free_list' is a null pointer!");
+
+	if (only_low_memory) {
+		// Move pages with lower addresses first in the free
+		// list, since entry_pgdir does not map all pages.
+		struct PageInfo *pp1, *pp2;
+		struct PageInfo **tp[2] = { &pp1, &pp2 };
+		for (pp = page_free_list; pp; pp = pp->pp_link) {
+			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
+			*tp[pagetype] = pp;
+			tp[pagetype] = &pp->pp_link;
+		}
+		*tp[1] = 0;
+		*tp[0] = pp2;
+		page_free_list = pp1;
+	}
+
+	// if there's a page that shouldn't be on the free list,
+	// try to make sure it eventually causes trouble.
+	for (pp = page_free_list; pp; pp = pp->pp_link)
+		if (PDX(page2pa(pp)) < pdx_limit)
+			memset(page2kva(pp), 0x97, 128);
+
+	first_free_page = (char *) boot_alloc(0);
+	for (pp = page_free_list; pp; pp = pp->pp_link) {
+		// check that we didn't corrupt the free list itself
+		assert(pp >= pages);
+		assert(pp < pages + npages);
+		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
+
+		// check a few pages that shouldn't be on the free list
+		assert(page2pa(pp) != 0);
+		assert(page2pa(pp) != IOPHYSMEM);
+		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
+		assert(page2pa(pp) != EXTPHYSMEM);
+		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
+
+		if (page2pa(pp) < EXTPHYSMEM)
+			++nfree_basemem;
+		else
+			++nfree_extmem;
+	}
+
+	assert(nfree_basemem > 0);
+	assert(nfree_extmem > 0);
+}
+
+//
+// Check the physical page allocator (page_alloc(), page_free(),
+// and page_init()).
+//
+static void
+check_page_alloc(void)
+{
+	struct PageInfo *pp, *pp0, *pp1, *pp2;
+	int nfree;
+	struct PageInfo *fl;
+	char *c;
+	int i;
+
+	if (!pages)
+		panic("'pages' is a null pointer!");
+
+	// check number of free pages
+	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
+		++nfree;
+
+	// should be able to allocate three pages
+	pp0 = pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+
+	assert(pp0);
+	assert(pp1 && pp1 != pp0);
+	assert(pp2 && pp2 != pp1 && pp2 != pp0);
+	assert(page2pa(pp0) < npages*PGSIZE);
+	assert(page2pa(pp1) < npages*PGSIZE);
+	assert(page2pa(pp2) < npages*PGSIZE);
+
+	// temporarily steal the rest of the free pages
+	fl = page_free_list;
+	page_free_list = 0;
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// free and re-allocate?
+	page_free(pp0);
+	page_free(pp1);
+	page_free(pp2);
+	pp0 = pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+	assert(pp0);
+	assert(pp1 && pp1 != pp0);
+	assert(pp2 && pp2 != pp1 && pp2 != pp0);
+	assert(!page_alloc(0));
+
+	// test flags
+	memset(page2kva(pp0), 1, PGSIZE);
+	page_free(pp0);
+	assert((pp = page_alloc(ALLOC_ZERO)));
+	assert(pp && pp0 == pp);
+	c = page2kva(pp);
+	for (i = 0; i < PGSIZE; i++)
+		assert(c[i] == 0);
+
+	// give free list back
+	page_free_list = fl;
+
+	// free the pages we took
+	page_free(pp0);
+	page_free(pp1);
+	page_free(pp2);
+
+	// number of free pages should be the same
+	for (pp = page_free_list; pp; pp = pp->pp_link)
+		--nfree;
+	assert(nfree == 0);
+
+	cprintf("check_page_alloc() succeeded!\n");
+}
+
+//
+// Checks that the kernel part of virtual address space
+// has been setup roughly correctly (by mem_init()).
+//
+// This function doesn't test every corner case,
+// but it is a pretty good sanity check.
+//
+
+static void
+check_kern_pgdir(void)
+{
+	uint32_t i, n;
+	pde_t *pgdir;
+
+	pgdir = kern_pgdir;
+
+	// check pages array
+	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
+	for (i = 0; i < n; i += PGSIZE)
+		assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
+
+	// check envs array (new test for lab 3)
+	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
+	for (i = 0; i < n; i += PGSIZE)
+		assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);
+
+	// check phys mem
+	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
+		assert(check_va2pa(pgdir, KERNBASE + i) == i);
+
+	// check kernel stack
+	for (i = 0; i < KSTKSIZE; i += PGSIZE)
+		assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
+	assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);
+
+	// check PDE permissions
+	for (i = 0; i < NPDENTRIES; i++) {
+		switch (i) {
+		case PDX(UVPT):
+		case PDX(KSTACKTOP-1):
+		case PDX(UPAGES):
+		case PDX(UENVS):
+			assert(pgdir[i] & PTE_P);
+			break;
+		default:
+			if (i >= PDX(KERNBASE)) {
+				assert(pgdir[i] & PTE_P);
+				assert(pgdir[i] & PTE_W);
+			} else
+				assert(pgdir[i] == 0);
+			break;
+		}
+	}
+	cprintf("check_kern_pgdir() succeeded!\n");
+}
+
+// This function returns the physical address of the page containing 'va',
+// defined by the page directory 'pgdir'.  The hardware normally performs
+// this functionality for us!  We define our own version to help check
+// the check_kern_pgdir() function; it shouldn't be used elsewhere.
+
+static physaddr_t
+check_va2pa(pde_t *pgdir, uintptr_t va)
+{
+	pte_t *p;
+
+	pgdir = &pgdir[PDX(va)];
+	if (!(*pgdir & PTE_P))
+		return ~0;
+	p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
+	if (!(p[PTX(va)] & PTE_P))
+		return ~0;
+	return PTE_ADDR(p[PTX(va)]);
+}
+
+
+// check page_insert, page_remove, &c
+static void
+check_page(void)
+{
+	struct PageInfo *pp, *pp0, *pp1, *pp2;
+	struct PageInfo *fl;
+	pte_t *ptep, *ptep1;
+	void *va;
+	int i;
+	extern pde_t entry_pgdir[];
+
+	// should be able to allocate three pages
+	pp0 = pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+
+	assert(pp0);
+	assert(pp1 && pp1 != pp0);
+	assert(pp2 && pp2 != pp1 && pp2 != pp0);
+
+	// temporarily steal the rest of the free pages
+	fl = page_free_list;
+	page_free_list = 0;
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// there is no page allocated at address 0
+	assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);
+
+	// there is no free memory, so we can't allocate a page table
+	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);
+
+	// free pp0 and try again: pp0 should be used for page table
+	page_free(pp0);
+	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
+	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+	assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
+	assert(pp1->pp_ref == 1);
+	assert(pp0->pp_ref == 1);
+
+	// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+	assert(pp2->pp_ref == 1);
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// should be able to map pp2 at PGSIZE because it's already there
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+	assert(pp2->pp_ref == 1);
+
+	// pp2 should NOT be on the free list
+	// could happen in ref counts are handled sloppily in page_insert
+	assert(!page_alloc(0));
+
+	// check that pgdir_walk returns a pointer to the pte
+	ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
+	assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
+
+	// should be able to change permissions too.
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
+	assert(pp2->pp_ref == 1);
+	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
+	assert(kern_pgdir[0] & PTE_U);
+
+	// should be able to remap with fewer permissions
+	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
+	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
+	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+	// should not be able to map at PTSIZE because need free page for page table
+	assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);
+
+	// insert pp1 at PGSIZE (replacing pp2)
+	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
+	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));
+
+	// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
+	assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+	// ... and ref counts should reflect this
+	assert(pp1->pp_ref == 2);
+	assert(pp2->pp_ref == 0);
+
+	// pp2 should be returned by page_alloc
+	assert((pp = page_alloc(0)) && pp == pp2);
+
+	// unmapping pp1 at 0 should keep pp1 at PGSIZE
+	page_remove(kern_pgdir, 0x0);
+	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
+	assert(pp1->pp_ref == 1);
+	assert(pp2->pp_ref == 0);
+
+	// test re-inserting pp1 at PGSIZE
+	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
+	assert(pp1->pp_ref);
+	assert(pp1->pp_link == NULL);
+
+	// unmapping pp1 at PGSIZE should free it
+	page_remove(kern_pgdir, (void*) PGSIZE);
+	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
+	assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
+	assert(pp1->pp_ref == 0);
+	assert(pp2->pp_ref == 0);
+
+	// so it should be returned by page_alloc
+	assert((pp = page_alloc(0)) && pp == pp1);
+
+	// should be no free memory
+	assert(!page_alloc(0));
+
+	// forcibly take pp0 back
+	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+	kern_pgdir[0] = 0;
+	assert(pp0->pp_ref == 1);
+	pp0->pp_ref = 0;
+
+	// check pointer arithmetic in pgdir_walk
+	page_free(pp0);
+	va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
+	ptep = pgdir_walk(kern_pgdir, va, 1);
+	ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
+	assert(ptep == ptep1 + PTX(va));
+	kern_pgdir[PDX(va)] = 0;
+	pp0->pp_ref = 0;
+
+	// check that new page tables get cleared
+	memset(page2kva(pp0), 0xFF, PGSIZE);
+	page_free(pp0);
+	pgdir_walk(kern_pgdir, 0x0, 1);
+	ptep = (pte_t *) page2kva(pp0);
+	for(i=0; i<NPTENTRIES; i++)
+		assert((ptep[i] & PTE_P) == 0);
+	kern_pgdir[0] = 0;
+	pp0->pp_ref = 0;
+
+	// give free list back
+	page_free_list = fl;
+
+	// free the pages we took
+	page_free(pp0);
+	page_free(pp1);
+	page_free(pp2);
+
+	cprintf("check_page() succeeded!\n");
+}
+
+// check page_insert, page_remove, &c, with an installed kern_pgdir
+static void
+check_page_installed_pgdir(void)
+{
+	struct PageInfo *pp, *pp0, *pp1, *pp2;
+	struct PageInfo *fl;
+	pte_t *ptep, *ptep1;
+	uintptr_t va;
+	int i;
+
+	// check that we can read and write installed pages
+	pp1 = pp2 = 0;
+	assert((pp0 = page_alloc(0)));
+	assert((pp1 = page_alloc(0)));
+	assert((pp2 = page_alloc(0)));
+	page_free(pp0);
+	memset(page2kva(pp1), 1, PGSIZE);
+	memset(page2kva(pp2), 2, PGSIZE);
+	page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
+	assert(pp1->pp_ref == 1);
+	assert(*(uint32_t *)PGSIZE == 0x01010101U);
+	page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
+	assert(*(uint32_t *)PGSIZE == 0x02020202U);
+	assert(pp2->pp_ref == 1);
+	assert(pp1->pp_ref == 0);
+	*(uint32_t *)PGSIZE = 0x03030303U;
+	assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
+	page_remove(kern_pgdir, (void*) PGSIZE);
+	assert(pp2->pp_ref == 0);
+
+	// forcibly take pp0 back
+	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
+	kern_pgdir[0] = 0;
+	assert(pp0->pp_ref == 1);
+	pp0->pp_ref = 0;
+
+	// free the pages we took
+	page_free(pp0);
+
+	cprintf("check_page_installed_pgdir() succeeded!\n");
+}
diff --git a/kern/pmap.h~ b/kern/pmap.h~
new file mode 100644
index 0000000..950cca1
--- /dev/null
+++ b/kern/pmap.h~
@@ -0,0 +1,87 @@
+/* See COPYRIGHT for copyright information. */
+
+#ifndef JOS_KERN_PMAP_H
+#define JOS_KERN_PMAP_H
+#ifndef JOS_KERNEL
+# error "This is a JOS kernel header; user programs should not #include it"
+#endif
+
+#include <inc/memlayout.h>
+#include <inc/assert.h>
+
+extern char bootstacktop[], bootstack[];
+
+extern struct PageInfo *pages;
+extern size_t npages;
+
+extern pde_t *kern_pgdir;
+
+
+/* This macro takes a kernel virtual address -- an address that points above
+ * KERNBASE, where the machine's maximum 256MB of physical memory is mapped --
+ * and returns the corresponding physical address.  It panics if you pass it a
+ * non-kernel virtual address.
+ */
+#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)
+
+static inline physaddr_t
+_paddr(const char *file, int line, void *kva)
+{
+	if ((uint32_t)kva < KERNBASE)
+		_panic(file, line, "PADDR called with invalid kva %08lx", kva);
+	return (physaddr_t)kva - KERNBASE;
+}
+
+/* This macro takes a physical address and returns the corresponding kernel
+ * virtual address.  It panics if you pass an invalid physical address. */
+#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)
+
+static inline void*
+_kaddr(const char *file, int line, physaddr_t pa)
+{
+	if (PGNUM(pa) >= npages)
+		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
+	return (void *)(pa + KERNBASE);
+}
+
+
+enum {
+	// For page_alloc, zero the returned physical page.
+	ALLOC_ZERO = 1<<0,
+};
+
+void	mem_init(void);
+
+void	page_init(void);
+struct PageInfo *page_alloc(int alloc_flags);
+void	page_free(struct PageInfo *pp);
+int	page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);
+void	page_remove(pde_t *pgdir, void *va);
+struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);
+void	page_decref(struct PageInfo *pp);
+
+void	tlb_invalidate(pde_t *pgdir, void *va);
+
+static inline physaddr_t
+page2pa(struct PageInfo *pp)
+{
+	return (pp - pages) << PGSHIFT;
+}
+
+static inline struct PageInfo*
+pa2page(physaddr_t pa)
+{
+	if (PGNUM(pa) >= npages)
+		panic("pa2page called with invalid pa");
+	return &pages[PGNUM(pa)];
+}
+
+static inline void*
+page2kva(struct PageInfo *pp)
+{
+	return KADDR(page2pa(pp));
+}
+
+pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);
+
+#endif /* !JOS_KERN_PMAP_H */
diff --git a/kern/sched.c b/kern/sched.c
index fbd2790..da94fb7 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -8,76 +8,86 @@
 void sched_halt(void);
 
 // Choose a user environment to run and run it.
-void
+    void
 sched_yield(void)
 {
-	struct Env *idle;
+    struct Env *idle;
 
-	// Implement simple round-robin scheduling.
-	//
-	// Search through 'envs' for an ENV_RUNNABLE environment in
-	// circular fashion starting just after the env this CPU was
-	// last running.  Switch to the first such environment found.
-	//
-	// If no envs are runnable, but the environment previously
-	// running on this CPU is still ENV_RUNNING, it's okay to
-	// choose that environment.
-	//
-	// Never choose an environment that's currently running on
-	// another CPU (env_status == ENV_RUNNING). If there are
-	// no runnable environments, simply drop through to the code
-	// below to halt the cpu.
+    // Implement simple round-robin scheduling.
+    //
+    // Search through 'envs' for an ENV_RUNNABLE environment in
+    // circular fashion starting just after the env this CPU was
+    // last running.  Switch to the first such environment found.
+    //
+    // If no envs are runnable, but the environment previously
+    // running on this CPU is still ENV_RUNNING, it's okay to
+    // choose that environment.
+    //
+    // Never choose an environment that's currently running on
+    // another CPU (env_status == ENV_RUNNING). If there are
+    // no runnable environments, simply drop through to the code
+    // below to halt the cpu.
+    // LAB 4: Your code here.
+    int i;
+    if (curenv!=NULL) idle = curenv + 1;
+    else
+	idle =envs;
 
-	// LAB 4: Your code here.
-
-	// sched_halt never returns
-	sched_halt();
+    for(i=0;i<NENV; i++,idle++)
+    {
+	if(idle >= envs+NENV) idle = envs;
+	if(idle->env_status== ENV_RUNNABLE) env_run(idle);
+    }
+    if(thiscpu->cpu_env!=NULL&& thiscpu->cpu_env->env_status==ENV_RUNNING)
+	env_run(curenv);
+    // sched_halt never returns
+    sched_halt();
 }
 
 // Halt this CPU when there is nothing to do. Wait until the
 // timer interrupt wakes it up. This function never returns.
 //
-void
+    void
 sched_halt(void)
 {
-	int i;
+    int i;
 
-	// For debugging and testing purposes, if there are no runnable
-	// environments in the system, then drop into the kernel monitor.
-	for (i = 0; i < NENV; i++) {
-		if ((envs[i].env_status == ENV_RUNNABLE ||
-		     envs[i].env_status == ENV_RUNNING ||
-		     envs[i].env_status == ENV_DYING))
-			break;
-	}
-	if (i == NENV) {
-		cprintf("No runnable environments in the system!\n");
-		while (1)
-			monitor(NULL);
-	}
+    // For debugging and testing purposes, if there are no runnable
+    // environments in the system, then drop into the kernel monitor.
+    for (i = 0; i < NENV; i++) {
+	if ((envs[i].env_status == ENV_RUNNABLE ||
+		    envs[i].env_status == ENV_RUNNING ||
+		    envs[i].env_status == ENV_DYING))
+	    break;
+    }
+    if (i == NENV) {
+	cprintf("No runnable environments in the system!\n");
+	while (1)
+	    monitor(NULL);
+    }
 
-	// Mark that no environment is running on this CPU
-	curenv = NULL;
-	lcr3(PADDR(kern_pgdir));
+    // Mark that no environment is running on this CPU
+    curenv = NULL;
+    lcr3(PADDR(kern_pgdir));
 
-	// Mark that this CPU is in the HALT state, so that when
-	// timer interupts come in, we know we should re-acquire the
-	// big kernel lock
-	xchg(&thiscpu->cpu_status, CPU_HALTED);
+    // Mark that this CPU is in the HALT state, so that when
+    // timer interupts come in, we know we should re-acquire the
+    // big kernel lock
+    xchg(&thiscpu->cpu_status, CPU_HALTED);
 
-	// Release the big kernel lock as if we were "leaving" the kernel
-	unlock_kernel();
+    // Release the big kernel lock as if we were "leaving" the kernel
+    unlock_kernel();
 
-	// Reset stack pointer, enable interrupts and then halt.
-	asm volatile (
-		"movl $0, %%ebp\n"
-		"movl %0, %%esp\n"
-		"pushl $0\n"
-		"pushl $0\n"
-		"sti\n"
-		"1:\n"
-		"hlt\n"
-		"jmp 1b\n"
-	: : "a" (thiscpu->cpu_ts.ts_esp0));
+    // Reset stack pointer, enable interrupts and then halt.
+    asm volatile (
+	    "movl $0, %%ebp\n"
+	    "movl %0, %%esp\n"
+	    "pushl $0\n"
+	    "pushl $0\n"
+	    "sti\n"
+	    "1:\n"
+	    "hlt\n"
+	    "jmp 1b\n"
+	    : : "a" (thiscpu->cpu_ts.ts_esp0));
 }
 
diff --git a/kern/syscall. b/kern/syscall.
new file mode 100644
index 0000000..e69de29
diff --git a/kern/syscall.c b/kern/syscall.c
index 85759fe..ab75871 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -15,31 +15,33 @@
 // Print a string to the system console.
 // The string is exactly 'len' characters long.
 // Destroys the environment on memory errors.
-static void
+    static void
 sys_cputs(const char *s, size_t len)
 {
-	// Check that the user has permission to read memory [s, s+len).
-	// Destroy the environment if not.
+    // Check that the user has permission to read memory [s, s+len).
+    // Destroy the environment if not.
 
-	// LAB 3: Your code here.
+    // LAB 3: Your code here.
+    if (curenv->env_tf.tf_cs & 3)
+	user_mem_assert(curenv, s, len, 0);
 
-	// Print the string supplied by the user.
-	cprintf("%.*s", len, s);
+    // Print the string supplied by the user.
+    cprintf("%.*s", len, s);
 }
 
 // Read a character from the system console without blocking.
 // Returns the character, or 0 if there is no input waiting.
-static int
+    static int
 sys_cgetc(void)
 {
-	return cons_getc();
+    return cons_getc();
 }
 
 // Returns the current environment's envid.
-static envid_t
+    static envid_t
 sys_getenvid(void)
 {
-	return curenv->env_id;
+    return curenv->env_id;
 }
 
 // Destroy a given environment (possibly the currently running environment).
@@ -47,40 +49,49 @@ sys_getenvid(void)
 // Returns 0 on success, < 0 on error.  Errors are:
 //	-E_BAD_ENV if environment envid doesn't currently exist,
 //		or the caller doesn't have permission to change envid.
-static int
+    static int
 sys_env_destroy(envid_t envid)
 {
-	int r;
-	struct Env *e;
+    int r;
+    struct Env *e;
 
-	if ((r = envid2env(envid, &e, 1)) < 0)
-		return r;
-	env_destroy(e);
-	return 0;
+    if ((r = envid2env(envid, &e, 1)) < 0)
+	return r;
+    if (e == curenv)
+	cprintf("[%08x] exiting gracefully\n", curenv->env_id);
+    else
+	cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
+    env_destroy(e);
+    return 0;
 }
 
 // Deschedule current environment and pick a different one to run.
-static void
+    static void
 sys_yield(void)
 {
-	sched_yield();
+    sched_yield();
 }
 
 // Allocate a new environment.
 // Returns envid of new environment, or < 0 on error.  Errors are:
 //	-E_NO_FREE_ENV if no free environment is available.
 //	-E_NO_MEM on memory exhaustion.
-static envid_t
+    envid_t
 sys_exofork(void)
 {
-	// Create the new environment with env_alloc(), from kern/env.c.
-	// It should be left as env_alloc created it, except that
-	// status is set to ENV_NOT_RUNNABLE, and the register set is copied
-	// from the current environment -- but tweaked so sys_exofork
-	// will appear to return 0.
+    // Create the new environment with env_alloc(), from kern/env.c.
+    // It should be left as env_alloc created it, except that
+    // status is set to ENV_NOT_RUNNABLE, and the register set is copied
+    // from the current environment -- but tweaked so sys_exofork
+    // will appear to return 0.
 
-	// LAB 4: Your code here.
-	panic("sys_exofork not implemented");
+    // LAB 4: Your code here.
+    struct Env *e = NULL;
+    if (env_alloc(&e, curenv->env_id) == -E_NO_FREE_ENV) return -E_NO_FREE_ENV;
+    memcpy(&e->env_tf, &curenv->env_tf, sizeof(e->env_tf));
+    e->env_tf.tf_regs.reg_eax = 0;
+    e->env_status = ENV_NOT_RUNNABLE;
+    return e->env_id;
 }
 
 // Set envid's env_status to status, which must be ENV_RUNNABLE
@@ -90,17 +101,22 @@ sys_exofork(void)
 //	-E_BAD_ENV if environment envid doesn't currently exist,
 //		or the caller doesn't have permission to change envid.
 //	-E_INVAL if status is not a valid status for an environment.
-static int
+    static int
 sys_env_set_status(envid_t envid, int status)
 {
-	// Hint: Use the 'envid2env' function from kern/env.c to translate an
-	// envid to a struct Env.
-	// You should set envid2env's third argument to 1, which will
-	// check whether the current environment has permission to set
-	// envid's status.
+    // Hint: Use the 'envid2env' function from kern/env.c to translate an
+    // envid to a struct Env.
+    // You should set envid2env's third argument to 1, which will
+    // check whether the current environment has permission to set
+    // envid's status.
+
+    // LAB 4: Your code here.
+    struct Env *e;
+    if (envid2env(envid, &e, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE) return -E_INVAL;
+    e->env_status = status;
+    return 0;
 
-	// LAB 4: Your code here.
-	panic("sys_env_set_status not implemented");
 }
 
 // Set envid's trap frame to 'tf'.
@@ -110,13 +126,20 @@ sys_env_set_status(envid_t envid, int status)
 // Returns 0 on success, < 0 on error.  Errors are:
 //	-E_BAD_ENV if environment envid doesn't currently exist,
 //		or the caller doesn't have permission to change envid.
-static int
+    static int
 sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 {
-	// LAB 5: Your code here.
-	// Remember to check whether the user has supplied us with a good
-	// address!
-	panic("sys_env_set_trapframe not implemented");
+    // LAB 5: Your code here.
+    // Remember to check whether the user has supplied us with a good
+    // address!
+    struct Env *e;
+    if (envid2env(envid, &e, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    if ((uintptr_t)tf >= UTOP || !page_lookup(curenv->env_pgdir, tf, 0)) return -E_INVAL;
+    tf->tf_cs = GD_UT |  3;
+    tf->tf_eflags |= FL_IF;
+    tf->tf_eflags &= ~FL_IOPL_MASK;
+    e->env_tf = *tf;
+    return 0;
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -127,11 +150,14 @@ sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 // Returns 0 on success, < 0 on error.  Errors are:
 //	-E_BAD_ENV if environment envid doesn't currently exist,
 //		or the caller doesn't have permission to change envid.
-static int
+    static int
 sys_env_set_pgfault_upcall(envid_t envid, void *func)
 {
-	// LAB 4: Your code here.
-	panic("sys_env_set_pgfault_upcall not implemented");
+    // LAB 4: Your code here.
+    struct Env *e;
+    if (envid2env(envid, &e, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    e->env_pgfault_upcall = func;
+    return 0;
 }
 
 // Allocate a page of memory and map it at 'va' with permission
@@ -150,18 +176,29 @@ sys_env_set_pgfault_upcall(envid_t envid, void *func)
 //	-E_INVAL if perm is inappropriate (see above).
 //	-E_NO_MEM if there's no memory to allocate the new page,
 //		or to allocate any necessary page tables.
-static int
+    static int
 sys_page_alloc(envid_t envid, void *va, int perm)
 {
-	// Hint: This function is a wrapper around page_alloc() and
-	//   page_insert() from kern/pmap.c.
-	//   Most of the new code you write should be to check the
-	//   parameters for correctness.
-	//   If page_insert() fails, remember to free the page you
-	//   allocated!
+    // Hint: This function is a wrapper around page_alloc() and
+    //   page_insert() from kern/pmap.c.
+    //   Most of the new code you write should be to check the
+    //   parameters for correctness.
+    //   If page_insert() fails, remember to free the page you
+    //   allocated!
 
-	// LAB 4: Your code here.
-	panic("sys_page_alloc not implemented");
+    // LAB 4: Your code here.
+    struct Env *e;
+    struct PageInfo *p;
+    perm &= PTE_SYSCALL;
+    if (envid2env(envid, &e, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    if ((uintptr_t)va >= UTOP || (uintptr_t)va % PGSIZE != 0) return -E_INVAL;
+    if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P)) return -E_INVAL;
+    if (!(p = page_alloc(ALLOC_ZERO))) return -E_NO_MEM;
+    if (page_insert(e->env_pgdir, p, va, perm) == -E_NO_MEM) {
+	page_free(p);
+	return -E_NO_MEM;
+    }
+    return 0;
 }
 
 // Map the page of memory at 'srcva' in srcenvid's address space
@@ -180,19 +217,34 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 //	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
 //		address space.
 //	-E_NO_MEM if there's no memory to allocate any necessary page tables.
-static int
+    static int
 sys_page_map(envid_t srcenvid, void *srcva,
-	     envid_t dstenvid, void *dstva, int perm)
+	envid_t dstenvid, void *dstva, int perm)
 {
-	// Hint: This function is a wrapper around page_lookup() and
-	//   page_insert() from kern/pmap.c.
-	//   Again, most of the new code you write should be to check the
-	//   parameters for correctness.
-	//   Use the third argument to page_lookup() to
-	//   check the current permissions on the page.
+    // Hint: This function is a wrapper around page_lookup() and
+    //   page_insert() from kern/pmap.c.
+    //   Again, most of the new code you write should be to check the
+    //   parameters for correctness.
+    //   Use the third argument to page_lookup() to
+    //   check the current permissions on the page.
 
-	// LAB 4: Your code here.
-	panic("sys_page_map not implemented");
+    // LAB 4: Your code here.
+    struct Env *esrc, *edst;
+    struct PageInfo *p;
+    pte_t *pte;
+    perm &= PTE_SYSCALL;
+    if (envid2env(srcenvid, &esrc, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    if (envid2env(dstenvid, &edst, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    if ((uintptr_t)srcva >= UTOP || (uintptr_t)srcva % PGSIZE != 0) return -E_INVAL;
+    if ((uintptr_t)dstva >= UTOP || (uintptr_t)dstva % PGSIZE != 0) return -E_INVAL;
+    if (!(p = page_lookup(esrc->env_pgdir, srcva, &pte))) return -E_INVAL;
+    if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P)) return -E_INVAL;
+    if (perm & PTE_W & ~*pte) return -E_INVAL;
+    if (page_insert(edst->env_pgdir, p, dstva, perm) == -E_NO_MEM){
+	page_free(p);
+	return -E_NO_MEM;
+    }
+    return 0;
 }
 
 // Unmap the page of memory at 'va' in the address space of 'envid'.
@@ -202,13 +254,17 @@ sys_page_map(envid_t srcenvid, void *srcva,
 //	-E_BAD_ENV if environment envid doesn't currently exist,
 //		or the caller doesn't have permission to change envid.
 //	-E_INVAL if va >= UTOP, or va is not page-aligned.
-static int
+    static int
 sys_page_unmap(envid_t envid, void *va)
 {
-	// Hint: This function is a wrapper around page_remove().
+    // Hint: This function is a wrapper around page_remove().
 
-	// LAB 4: Your code here.
-	panic("sys_page_unmap not implemented");
+    // LAB 4: Your code here.
+    struct Env *e;
+    if (envid2env(envid, &e, 1) == -E_BAD_ENV) return -E_BAD_ENV;
+    if ((uintptr_t)va >= UTOP || (uintptr_t)va % PGSIZE != 0) return -E_INVAL;
+    page_remove(e->env_pgdir, va);
+    return 0;
 }
 
 // Try to send 'value' to the target env 'envid'.
@@ -249,11 +305,34 @@ sys_page_unmap(envid_t envid, void *va)
 //		current environment's address space.
 //	-E_NO_MEM if there's not enough memory to map srcva in envid's
 //		address space.
-static int
+    static int
 sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 {
-	// LAB 4: Your code here.
-	panic("sys_ipc_try_send not implemented");
+    // LAB 4: Your code here.
+    struct Env *e;
+    struct PageInfo *p;
+    pte_t *pte;
+    perm &= PTE_SYSCALL;
+    if (envid2env(envid, &e, 0) == -E_BAD_ENV) return -E_BAD_ENV;
+    if (!e->env_ipc_recving) return -E_IPC_NOT_RECV;
+    if ((uintptr_t)srcva < UTOP) {
+	if ((uintptr_t)srcva % PGSIZE) return -E_INVAL;
+	if ((perm & (PTE_P | PTE_U)) != (PTE_P | PTE_U)) return -E_INVAL;
+	if (!(p = page_lookup(curenv->env_pgdir, srcva, &pte))) return -E_INVAL;
+	if (perm & PTE_W & ~*pte) return -E_INVAL;
+    }
+    e->env_ipc_recving = 0;
+    e->env_ipc_from = curenv->env_id;
+    e->env_ipc_value = value;
+    if ((uintptr_t)e->env_ipc_dstva < UTOP && (uintptr_t)srcva < UTOP) {
+	if (page_insert(e->env_pgdir, p, e->env_ipc_dstva, perm) == -E_NO_MEM) {
+	    return -E_NO_MEM;
+	}
+	e->env_ipc_perm = perm;
+    }
+    e->env_status = ENV_RUNNABLE;
+    e->env_tf.tf_regs.reg_eax = 0;
+    return 0;
 }
 
 // Block until a value is ready.  Record that you want to receive
@@ -267,27 +346,58 @@ sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 // return 0 on success.
 // Return < 0 on error.  Errors are:
 //	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
-static int
+    static int
 sys_ipc_recv(void *dstva)
 {
-	// LAB 4: Your code here.
-	panic("sys_ipc_recv not implemented");
-	return 0;
+    // LAB 4: Your code here.
+    if ((uintptr_t)dstva < UTOP && (uintptr_t)dstva % PGSIZE) return -E_INVAL;
+    struct Env *e = curenv;
+    e->env_ipc_recving = 1;
+    e->env_ipc_dstva = dstva;
+    e->env_ipc_perm = 0;
+    e->env_status = ENV_NOT_RUNNABLE;
+    return 0;
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
-int32_t
+    int32_t
 syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
 {
-	// Call the function corresponding to the 'syscallno' parameter.
-	// Return any appropriate return value.
-	// LAB 3: Your code here.
-
-	panic("syscall not implemented");
-
-	switch (syscallno) {
+    // Call the function corresponding to the 'syscallno' parameter.
+    // Return any appropriate return value.
+    // LAB 3: Your code here.
+    switch (syscallno) {
+	case SYS_cputs:
+	    sys_cputs((const char*)a1, (size_t)a2);
+	    return 0;
+	case SYS_cgetc:
+	    return sys_cgetc();
+	case SYS_getenvid:
+	    return sys_getenvid();
+	case SYS_env_destroy:
+	    return sys_env_destroy((envid_t)a1);
+	case SYS_yield:
+	    sys_yield();
+	case SYS_exofork:
+	    return sys_exofork();
+	case SYS_env_set_status:
+	    return sys_env_set_status((envid_t)a1, (int)a2);
+	case SYS_page_alloc:
+	    return sys_page_alloc((envid_t)a1, (void*)a2, (int)a3);
+	case SYS_page_map:
+	    return sys_page_map((envid_t)a1, (void*)a2, (envid_t)a3, (void*)a4, (int)a5);
+	case SYS_page_unmap:
+	    return sys_page_unmap((envid_t)a1, (void*)a2);
+	case SYS_env_set_pgfault_upcall:
+	    return sys_env_set_pgfault_upcall((envid_t)a1, (void*)a2);
+	case SYS_ipc_try_send:
+	    return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void*)a3, (unsigned)a4);
+	case SYS_ipc_recv:
+	    return sys_ipc_recv((void*)a1);
+	case SYS_env_set_trapframe:
+	    return sys_env_set_trapframe((envid_t) a1, (struct Trapframe *)a2);
 	default:
-		return -E_INVAL;
-	}
+	    return -E_INVAL;
+    }
 }
 
diff --git a/kern/trap.c b/kern/trap.c
index 25694ef..a3337c5 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -14,6 +14,7 @@
 #include <kern/cpu.h>
 #include <kern/spinlock.h>
 
+
 static struct Taskstate ts;
 
 /* For debugging, so print_trapframe can distinguish between printing
@@ -27,290 +28,347 @@ static struct Trapframe *last_tf;
  */
 struct Gatedesc idt[256] = { { 0 } };
 struct Pseudodesc idt_pd = {
-	sizeof(idt) - 1, (uint32_t) idt
+    sizeof(idt) - 1, (uint32_t) idt
 };
 
 
 static const char *trapname(int trapno)
 {
-	static const char * const excnames[] = {
-		"Divide error",
-		"Debug",
-		"Non-Maskable Interrupt",
-		"Breakpoint",
-		"Overflow",
-		"BOUND Range Exceeded",
-		"Invalid Opcode",
-		"Device Not Available",
-		"Double Fault",
-		"Coprocessor Segment Overrun",
-		"Invalid TSS",
-		"Segment Not Present",
-		"Stack Fault",
-		"General Protection",
-		"Page Fault",
-		"(unknown trap)",
-		"x87 FPU Floating-Point Error",
-		"Alignment Check",
-		"Machine-Check",
-		"SIMD Floating-Point Exception"
-	};
-
-	if (trapno < ARRAY_SIZE(excnames))
-		return excnames[trapno];
-	if (trapno == T_SYSCALL)
-		return "System call";
-	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
-		return "Hardware Interrupt";
-	return "(unknown trap)";
+    static const char * const excnames[] = {
+	"Divide error",
+	"Debug",
+	"Non-Maskable Interrupt",
+	"Breakpoint",
+	"Overflow",
+	"BOUND Range Exceeded",
+	"Invalid Opcode",
+	"Device Not Available",
+	"Double Fault",
+	"Coprocessor Segment Overrun",
+	"Invalid TSS",
+	"Segment Not Present",
+	"Stack Fault",
+	"General Protection",
+	"Page Fault",
+	"(unknown trap)",
+	"x87 FPU Floating-Point Error",
+	"Alignment Check",
+	"Machine-Check",
+	"SIMD Floating-Point Exception"
+    };
+
+    if (trapno < ARRAY_SIZE(excnames))
+	return excnames[trapno];
+    if (trapno == T_SYSCALL)
+	return "System call";
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
+	return "Hardware Interrupt";
+    return "(unknown trap)";
 }
 
 
-void
+    void
 trap_init(void)
 {
-	extern struct Segdesc gdt[];
-
-	// LAB 3: Your code here.
-
-	// Per-CPU setup 
-	trap_init_percpu();
+    extern struct Segdesc gdt[];
+    extern long vectors[];
+    int i;
+
+    // LAB 3: Your code here.
+    for (i = 0; i <= 0x30; ++i) {
+	switch (i) {
+	    case T_BRKPT:
+	    case T_SYSCALL:
+	    case IRQ_OFFSET + IRQ_TIMER:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 3);
+		break;
+	    default:
+		SETGATE(idt[i], 0, GD_KT, vectors[i], 0);
+	}
+    }
+    // Per-CPU setup 
+    trap_init_percpu();
 }
 
 // Initialize and load the per-CPU TSS and IDT
-void
+    void
 trap_init_percpu(void)
 {
-	// The example code here sets up the Task State Segment (TSS) and
-	// the TSS descriptor for CPU 0. But it is incorrect if we are
-	// running on other CPUs because each CPU has its own kernel stack.
-	// Fix the code so that it works for all CPUs.
-	//
-	// Hints:
-	//   - The macro "thiscpu" always refers to the current CPU's
-	//     struct CpuInfo;
-	//   - The ID of the current CPU is given by cpunum() or
-	//     thiscpu->cpu_id;
-	//   - Use "thiscpu->cpu_ts" as the TSS for the current CPU,
-	//     rather than the global "ts" variable;
-	//   - Use gdt[(GD_TSS0 >> 3) + i] for CPU i's TSS descriptor;
-	//   - You mapped the per-CPU kernel stacks in mem_init_mp()
-	//
-	// ltr sets a 'busy' flag in the TSS selector, so if you
-	// accidentally load the same TSS on more than one CPU, you'll
-	// get a triple fault.  If you set up an individual CPU's TSS
-	// wrong, you may not get a fault until you try to return from
-	// user space on that CPU.
-	//
-	// LAB 4: Your code here:
-
-	// Setup a TSS so that we get the right stack
-	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-	ts.ts_iomb = sizeof(struct Taskstate);
-
-	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
-					sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
-
-	// Load the TSS selector (like other segment selectors, the
-	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
-
-	// Load the IDT
-	lidt(&idt_pd);
+    // The example code here sets up the Task State Segment (TSS) and
+    // the TSS descriptor for CPU 0. But it is incorrect if we are
+    // running on other CPUs because each CPU has its own kernel stack.
+    // Fix the code so that it works for all CPUs.
+    //
+    // Hints:
+    //   - The macro "thiscpu" always refers to the current CPU's
+    //     struct CpuInfo;
+    //   - The ID of the current CPU is given by cpunum() or
+    //     thiscpu->cpu_id;
+    //   - Use "thiscpu->cpu_ts" as the TSS for the current CPU,
+    //     rather than the global "ts" variable;
+    //   - Use gdt[(GD_TSS0 >> 3) + i] for CPU i's TSS descriptor;
+    //   - You mapped the per-CPU kernel stacks in mem_init_mp()
+    //
+    // ltr sets a 'busy' flag in the TSS selector, so if you
+    // accidentally load the same TSS on more than one CPU, you'll
+    // get a triple fault.  If you set up an individual CPU's TSS
+    // wrong, you may not get a fault until you try to return from
+    // user space on that CPU.
+    //
+    // LAB 4: Your code here:
+    int i = thiscpu->cpu_id;
+
+    thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
+    thiscpu->cpu_ts.ts_ss0 = GD_KD;
+    thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);
+
+    // Initialize the TSS slot of the gdt.
+    gdt[(GD_TSS0 >> 3) + i] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts), sizeof(struct Taskstate), 0); 
+
+    gdt[(GD_TSS0 >> 3) + i].sd_s = 0;
+
+    // Load the TSS selector (like other segment selectors, the
+    // bottom three bits are special; we leave them 0)
+    ltr(GD_TSS0+ (i<<3));
+
+    // Load the IDT
+    lidt(&idt_pd);
 }
 
-void
+    void
 print_trapframe(struct Trapframe *tf)
 {
-	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
-	print_regs(&tf->tf_regs);
-	cprintf("  es   0x----%04x\n", tf->tf_es);
-	cprintf("  ds   0x----%04x\n", tf->tf_ds);
-	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
-	// If this trap was a page fault that just happened
-	// (so %cr2 is meaningful), print the faulting linear address.
-	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
-		cprintf("  cr2  0x%08x\n", rcr2());
-	cprintf("  err  0x%08x", tf->tf_err);
-	// For page faults, print decoded fault error code:
-	// U/K=fault occurred in user/kernel mode
-	// W/R=a write/read caused the fault
-	// PR=a protection violation caused the fault (NP=page not present).
-	if (tf->tf_trapno == T_PGFLT)
-		cprintf(" [%s, %s, %s]\n",
-			tf->tf_err & 4 ? "user" : "kernel",
-			tf->tf_err & 2 ? "write" : "read",
-			tf->tf_err & 1 ? "protection" : "not-present");
-	else
-		cprintf("\n");
-	cprintf("  eip  0x%08x\n", tf->tf_eip);
-	cprintf("  cs   0x----%04x\n", tf->tf_cs);
-	cprintf("  flag 0x%08x\n", tf->tf_eflags);
-	if ((tf->tf_cs & 3) != 0) {
-		cprintf("  esp  0x%08x\n", tf->tf_esp);
-		cprintf("  ss   0x----%04x\n", tf->tf_ss);
-	}
+    cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
+    print_regs(&tf->tf_regs);
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+    // If this trap was a page fault that just happened
+    // (so %cr2 is meaningful), print the faulting linear address.
+    if (tf == last_tf && tf->tf_trapno == T_PGFLT)
+	cprintf("  cr2  0x%08x\n", rcr2());
+    cprintf("  err  0x%08x", tf->tf_err);
+    // For page faults, print decoded fault error code:
+    // U/K=fault occurred in user/kernel mode
+    // W/R=a write/read caused the fault
+    // PR=a protection violation caused the fault (NP=page not present).
+    if (tf->tf_trapno == T_PGFLT)
+	cprintf(" [%s, %s, %s]\n",
+		tf->tf_err & 4 ? "user" : "kernel",
+		tf->tf_err & 2 ? "write" : "read",
+		tf->tf_err & 1 ? "protection" : "not-present");
+    else
+	cprintf("\n");
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x\n", tf->tf_eflags);
+    if ((tf->tf_cs & 3) != 0) {
+	cprintf("  esp  0x%08x\n", tf->tf_esp);
+	cprintf("  ss   0x----%04x\n", tf->tf_ss);
+    }
 }
 
-void
+    void
 print_regs(struct PushRegs *regs)
 {
-	cprintf("  edi  0x%08x\n", regs->reg_edi);
-	cprintf("  esi  0x%08x\n", regs->reg_esi);
-	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
-	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
-	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
-	cprintf("  edx  0x%08x\n", regs->reg_edx);
-	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
-	cprintf("  eax  0x%08x\n", regs->reg_eax);
+
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
 }
 
-static void
+    static void
 trap_dispatch(struct Trapframe *tf)
 {
-	// Handle processor exceptions.
-	// LAB 3: Your code here.
-
-	// Handle spurious interrupts
-	// The hardware sometimes raises these because of noise on the
-	// IRQ line or other reasons. We don't care.
-	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
-		cprintf("Spurious interrupt on irq 7\n");
-		print_trapframe(tf);
-		return;
-	}
-
-	// Handle clock interrupts. Don't forget to acknowledge the
-	// interrupt using lapic_eoi() before calling the scheduler!
-	// LAB 4: Your code here.
-
-	// Handle keyboard and serial interrupts.
-	// LAB 5: Your code here.
-
-	// Unexpected trap: The user process or the kernel has a bug.
+    // Handle processor exceptions.
+    // LAB 3: Your code here.
+    switch (tf->tf_trapno) {
+	case T_DEBUG:
+	case T_BRKPT:
+	    monitor(tf);
+	    return;
+	case T_PGFLT:
+	    page_fault_handler(tf);
+	    return;
+	case T_SYSCALL:
+	    tf->tf_regs.reg_eax = 
+		syscall(tf->tf_regs.reg_eax, tf->tf_regs.reg_edx, tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi, tf->tf_regs.reg_esi);
+	    return;
+    }
+
+    // Handle spurious interrupts
+    // The hardware sometimes raises these because of noise on the
+    // IRQ line or other reasons. We don't care.
+    if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
+	cprintf("Spurious interrupt on irq 7\n");
 	print_trapframe(tf);
-	if (tf->tf_cs == GD_KT)
-		panic("unhandled trap in kernel");
-	else {
-		env_destroy(curenv);
-		return;
-	}
+	return;
+    }
+
+    // Handle clock interrupts. Don't forget to acknowledge the
+    // interrupt using lapic_eoi() before calling the scheduler!
+    // LAB 4: Your code here.
+    if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
+	lapic_eoi();
+	sched_yield();
+	return;
+    }
+
+    // Handle keyboard and serial interrupts.
+    // LAB 5: Your code here.
+    if (tf->tf_trapno == IRQ_OFFSET+IRQ_KBD) {
+	kbd_intr();
+	return;
+    }
+
+    if (tf->tf_trapno == IRQ_OFFSET+IRQ_SERIAL) {
+	serial_intr();
+	return;
+    }
+    // Unexpected trap: The user process or the kernel has a bug.
+    print_trapframe(tf);
+    if (tf->tf_cs == GD_KT)
+	panic("unhandled trap in kernel");
+    else {
+	env_destroy(curenv);
+	return;
+    }
 }
-
-void
+    void
 trap(struct Trapframe *tf)
 {
-	// The environment may have set DF and some versions
-	// of GCC rely on DF being clear
-	asm volatile("cld" ::: "cc");
-
-	// Halt the CPU if some other CPU has called panic()
-	extern char *panicstr;
-	if (panicstr)
-		asm volatile("hlt");
-
-	// Re-acqurie the big kernel lock if we were halted in
-	// sched_yield()
-	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
-		lock_kernel();
-	// Check that interrupts are disabled.  If this assertion
-	// fails, DO NOT be tempted to fix it by inserting a "cli" in
-	// the interrupt path.
-	assert(!(read_eflags() & FL_IF));
-
-	if ((tf->tf_cs & 3) == 3) {
-		// Trapped from user mode.
-		// Acquire the big kernel lock before doing any
-		// serious kernel work.
-		// LAB 4: Your code here.
-		assert(curenv);
-
-		// Garbage collect if current enviroment is a zombie
-		if (curenv->env_status == ENV_DYING) {
-			env_free(curenv);
-			curenv = NULL;
-			sched_yield();
-		}
-
-		// Copy trap frame (which is currently on the stack)
-		// into 'curenv->env_tf', so that running the environment
-		// will restart at the trap point.
-		curenv->env_tf = *tf;
-		// The trapframe on the stack should be ignored from here on.
-		tf = &curenv->env_tf;
-	}
+    // The environment may have set DF and some versions
+    // of GCC rely on DF being clear
+    asm volatile("cld" ::: "cc");
+
+    // Halt the CPU if some other CPU has called panic()
+    extern char *panicstr;
+    if (panicstr)
+	asm volatile("hlt");
+
+    // Re-acqurie the big kernel lock if we were halted in
+    // sched_yield()
+    if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
+	lock_kernel();
+    // Check that interrupts are disabled.  If this assertion
+    // fails, DO NOT be tempted to fix it by inserting a "cli" in
+    // the interrupt path.
+    assert(!(read_eflags() & FL_IF));
+
+    if ((tf->tf_cs & 3) == 3) {
+	// Trapped from user mode.
+	// Acquire the big kernel lock before doing any
+	// serious kernel work.
+	// LAB 4: Your code here.
+	assert(curenv);
+	lock_kernel();
 
-	// Record that tf is the last real trapframe so
-	// print_trapframe can print some additional information.
-	last_tf = tf;
 
-	// Dispatch based on what type of trap occurred
-	trap_dispatch(tf);
+	// Garbage collect if current enviroment is a zombie
+	if (curenv->env_status == ENV_DYING) {
+	    env_free(curenv);
+	    curenv = NULL;
+	    sched_yield();
+	}
 
-	// If we made it to this point, then no other environment was
-	// scheduled, so we should return to the current environment
-	// if doing so makes sense.
-	if (curenv && curenv->env_status == ENV_RUNNING)
-		env_run(curenv);
-	else
-		sched_yield();
+	// Copy trap frame (which is currently on the stack)
+	// into 'curenv->env_tf', so that running the environment
+	// will restart at the trap point.
+	curenv->env_tf = *tf;
+	// The trapframe on the stack should be ignored from here on.
+	tf = &curenv->env_tf;
+    }
+
+    // Record that tf is the last real trapframe so
+    // print_trapframe can print some additional information.
+    last_tf = tf;
+
+    // Dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+
+    // If we made it to this point, then no other environment was
+    // scheduled, so we should return to the current environment
+    // if doing so makes sense.
+    if (curenv && curenv->env_status == ENV_RUNNING)
+	env_run(curenv);
+    else
+	sched_yield();
 }
 
 
-void
+    void
 page_fault_handler(struct Trapframe *tf)
 {
-	uint32_t fault_va;
-
-	// Read processor's CR2 register to find the faulting address
-	fault_va = rcr2();
-
-	// Handle kernel-mode page faults.
-
-	// LAB 3: Your code here.
-
-	// We've already handled kernel-mode exceptions, so if we get here,
-	// the page fault happened in user mode.
-
-	// Call the environment's page fault upcall, if one exists.  Set up a
-	// page fault stack frame on the user exception stack (below
-	// UXSTACKTOP), then branch to curenv->env_pgfault_upcall.
-	//
-	// The page fault upcall might cause another page fault, in which case
-	// we branch to the page fault upcall recursively, pushing another
-	// page fault stack frame on top of the user exception stack.
-	//
-	// It is convenient for our code which returns from a page fault
-	// (lib/pfentry.S) to have one word of scratch space at the top of the
-	// trap-time stack; it allows us to more easily restore the eip/esp. In
-	// the non-recursive case, we don't have to worry about this because
-	// the top of the regular user stack is free.  In the recursive case,
-	// this means we have to leave an extra word between the current top of
-	// the exception stack and the new stack frame because the exception
-	// stack _is_ the trap-time stack.
-	//
-	// If there's no page fault upcall, the environment didn't allocate a
-	// page for its exception stack or can't write to it, or the exception
-	// stack overflows, then destroy the environment that caused the fault.
-	// Note that the grade script assumes you will first check for the page
-	// fault upcall and print the "user fault va" message below if there is
-	// none.  The remaining three checks can be combined into a single test.
-	//
-	// Hints:
-	//   user_mem_assert() and env_run() are useful here.
-	//   To change what the user environment runs, modify 'curenv->env_tf'
-	//   (the 'tf' variable points at 'curenv->env_tf').
-
-	// LAB 4: Your code here.
-
-	// Destroy the environment that caused the fault.
-	cprintf("[%08x] user fault va %08x ip %08x\n",
-		curenv->env_id, fault_va, tf->tf_eip);
-	print_trapframe(tf);
-	env_destroy(curenv);
+    uint32_t fault_va;
+
+    // Read processor's CR2 register to find the faulting address
+    fault_va = rcr2();
+
+    // Handle kernel-mode page faults.
+
+    // LAB 3: Your code here.
+    if (!(tf->tf_cs & 3))
+	panic("a page fault happens in kernel mode\n");
+
+    // We've already handled kernel-mode exceptions, so if we get here,
+    // the page fault happened in user mode.
+
+    // Call the environment's page fault upcall, if one exists.  Set up a
+    // page fault stack frame on the user exception stack (below
+    // UXSTACKTOP), then branch to curenv->env_pgfault_upcall.
+    //
+    // The page fault upcall might cause another page fault, in which case
+    // we branch to the page fault upcall recursively, pushing another
+    // page fault stack frame on top of the user exception stack.
+    //
+    // The trap handler needs one word of scratch space at the top of the
+    // trap-time stack in order to return.  In the non-recursive case, we
+    // don't have to worry about this because the top of the regular user
+    // stack is free.  In the recursive case, this means we have to leave
+    // an extra word between the current top of the exception stack and
+    // the new stack frame because the exception stack _is_ the trap-time
+    // stack.
+    //
+    // If there's no page fault upcall, the environment didn't allocate a
+    // page for its exception stack or can't write to it, or the exception
+    // stack overflows, then destroy the environment that caused the fault.
+    // Note that the grade script assumes you will first check for the page
+    // fault upcall and print the "user fault va" message below if there is
+    // none.  The remaining three checks can be combined into a single test.
+    //
+    // Hints:
+    //   user_mem_assert() and env_run() are useful here.
+    //   To change what the user environment runs, modify 'curenv->env_tf'
+    //   (the 'tf' variable points at 'curenv->env_tf').
+
+    // LAB 4: Your code here.
+    struct UTrapframe *utf;
+    uint32_t esp = tf->tf_esp;
+
+    if (curenv->env_pgfault_upcall) {
+	if (esp < UXSTACKTOP - PGSIZE || esp >= UXSTACKTOP) tf->tf_esp = UXSTACKTOP+4; 
+	utf = (struct UTrapframe*)(tf->tf_esp - 4 - sizeof(struct UTrapframe));
+	user_mem_assert(curenv, (const void*)utf, 1, PTE_W|PTE_U);
+	lcr3(PADDR(curenv->env_pgdir));
+	utf->utf_fault_va = fault_va;
+	utf->utf_err = tf->tf_err;
+	utf->utf_regs = tf->tf_regs;
+	utf->utf_eip = tf->tf_eip;
+	utf->utf_eflags = tf->tf_eflags;
+	utf->utf_esp = esp;
+	tf->tf_esp = (uint32_t)utf;
+	tf->tf_eip = (uint32_t)curenv->env_pgfault_upcall;
+	env_run(curenv);
+    }
+
+    // Destroy the environment that caused the fault.
+    cprintf("[%08x] user fault va %08x ip %08x\n",
+	    curenv->env_id, fault_va, tf->tf_eip);
+    print_trapframe(tf);
+    env_destroy(curenv);
 }
 
diff --git a/kern/trap.c~ b/kern/trap.c~
new file mode 100644
index 0000000..1f975c4
--- /dev/null
+++ b/kern/trap.c~
@@ -0,0 +1,229 @@
+#include <inc/mmu.h>
+#include <inc/x86.h>
+#include <inc/assert.h>
+
+#include <kern/pmap.h>
+#include <kern/trap.h>
+#include <kern/console.h>
+#include <kern/monitor.h>
+#include <kern/env.h>
+#include <kern/syscall.h>
+
+
+static struct Taskstate ts;
+
+/* For debugging, so print_trapframe can distinguish between printing
+ * a saved trapframe and printing the current trapframe and print some
+ * additional information in the latter case.
+ */
+static struct Trapframe *last_tf;
+
+/* Interrupt descriptor table.  (Must be built at run time because
+ * shifted function addresses can't be represented in relocation records.)
+ */
+struct Gatedesc idt[256] = { { 0 } };
+struct Pseudodesc idt_pd = {
+	sizeof(idt) - 1, (uint32_t) idt
+};
+
+
+static const char *trapname(int trapno)
+{
+	static const char * const excnames[] = {
+		"Divide error",
+		"Debug",
+		"Non-Maskable Interrupt",
+		"Breakpoint",
+		"Overflow",
+		"BOUND Range Exceeded",
+		"Invalid Opcode",
+		"Device Not Available",
+		"Double Fault",
+		"Coprocessor Segment Overrun",
+		"Invalid TSS",
+		"Segment Not Present",
+		"Stack Fault",
+		"General Protection",
+		"Page Fault",
+		"(unknown trap)",
+		"x87 FPU Floating-Point Error",
+		"Alignment Check",
+		"Machine-Check",
+		"SIMD Floating-Point Exception"
+	};
+
+	if (trapno < ARRAY_SIZE(excnames))
+		return excnames[trapno];
+	if (trapno == T_SYSCALL)
+		return "System call";
+	return "(unknown trap)";
+}
+
+
+void
+trap_init(void)
+{
+	extern struct Segdesc gdt[];
+	extern long* vectors;
+	int i;
+
+	// LAB 3: Your code here.
+	for (i = 0; i <= 0x30; ++i) {
+	    switch (i) {
+		case T_BRKPT:
+		case T_SYSCALL:
+		    SETGATE(idt[i], 0, GD_KT, vectors[i], 3);
+		    break;
+		default:
+		    SETGATE(idt[i], 0, GD_KT, vectors[i], 0);
+	    }
+	}
+	// Per-CPU setup 
+	trap_init_percpu();
+}
+
+// Initialize and load the per-CPU TSS and IDT
+void
+trap_init_percpu(void)
+{
+	// Setup a TSS so that we get the right stack
+	// when we trap to the kernel.
+	ts.ts_esp0 = KSTACKTOP;
+	ts.ts_ss0 = GD_KD;
+
+	// Initialize the TSS slot of the gdt.
+	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
+					sizeof(struct Taskstate) - 1, 0);
+	gdt[GD_TSS0 >> 3].sd_s = 0;
+
+	// Load the TSS selector (like other segment selectors, the
+	// bottom three bits are special; we leave them 0)
+	ltr(GD_TSS0);
+
+	// Load the IDT
+	lidt(&idt_pd);
+}
+
+void
+print_trapframe(struct Trapframe *tf)
+{
+	cprintf("TRAP frame at %p\n", tf);
+	print_regs(&tf->tf_regs);
+	cprintf("  es   0x----%04x\n", tf->tf_es);
+	cprintf("  ds   0x----%04x\n", tf->tf_ds);
+	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+	// If this trap was a page fault that just happened
+	// (so %cr2 is meaningful), print the faulting linear address.
+	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
+		cprintf("  cr2  0x%08x\n", rcr2());
+	cprintf("  err  0x%08x", tf->tf_err);
+	// For page faults, print decoded fault error code:
+	// U/K=fault occurred in user/kernel mode
+	// W/R=a write/read caused the fault
+	// PR=a protection violation caused the fault (NP=page not present).
+	if (tf->tf_trapno == T_PGFLT)
+		cprintf(" [%s, %s, %s]\n",
+			tf->tf_err & 4 ? "user" : "kernel",
+			tf->tf_err & 2 ? "write" : "read",
+			tf->tf_err & 1 ? "protection" : "not-present");
+	else
+		cprintf("\n");
+	cprintf("  eip  0x%08x\n", tf->tf_eip);
+	cprintf("  cs   0x----%04x\n", tf->tf_cs);
+	cprintf("  flag 0x%08x\n", tf->tf_eflags);
+	if ((tf->tf_cs & 3) != 0) {
+		cprintf("  esp  0x%08x\n", tf->tf_esp);
+		cprintf("  ss   0x----%04x\n", tf->tf_ss);
+	}
+}
+
+void
+print_regs(struct PushRegs *regs)
+{
+	cprintf("  edi  0x%08x\n", regs->reg_edi);
+	cprintf("  esi  0x%08x\n", regs->reg_esi);
+	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+	cprintf("  edx  0x%08x\n", regs->reg_edx);
+	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+	cprintf("  eax  0x%08x\n", regs->reg_eax);
+}
+
+static void
+trap_dispatch(struct Trapframe *tf)
+{
+	// Handle processor exceptions.
+	// LAB 3: Your code here.
+
+	// Unexpected trap: The user process or the kernel has a bug.
+	print_trapframe(tf);
+	if (tf->tf_cs == GD_KT)
+		panic("unhandled trap in kernel");
+	else {
+		env_destroy(curenv);
+		return;
+	}
+}
+
+void
+trap(struct Trapframe *tf)
+{
+	// The environment may have set DF and some versions
+	// of GCC rely on DF being clear
+	asm volatile("cld" ::: "cc");
+
+	// Check that interrupts are disabled.  If this assertion
+	// fails, DO NOT be tempted to fix it by inserting a "cli" in
+	// the interrupt path.
+	assert(!(read_eflags() & FL_IF));
+
+	cprintf("Incoming TRAP frame at %p\n", tf);
+
+	if ((tf->tf_cs & 3) == 3) {
+		// Trapped from user mode.
+		assert(curenv);
+
+		// Copy trap frame (which is currently on the stack)
+		// into 'curenv->env_tf', so that running the environment
+		// will restart at the trap point.
+		curenv->env_tf = *tf;
+		// The trapframe on the stack should be ignored from here on.
+		tf = &curenv->env_tf;
+	}
+
+	// Record that tf is the last real trapframe so
+	// print_trapframe can print some additional information.
+	last_tf = tf;
+
+	// Dispatch based on what type of trap occurred
+	trap_dispatch(tf);
+
+	// Return to the current environment, which should be running.
+	assert(curenv && curenv->env_status == ENV_RUNNING);
+	env_run(curenv);
+}
+
+
+void
+page_fault_handler(struct Trapframe *tf)
+{
+	uint32_t fault_va;
+
+	// Read processor's CR2 register to find the faulting address
+	fault_va = rcr2();
+
+	// Handle kernel-mode page faults.
+
+	// LAB 3: Your code here.
+
+	// We've already handled kernel-mode exceptions, so if we get here,
+	// the page fault happened in user mode.
+
+	// Destroy the environment that caused the fault.
+	cprintf("[%08x] user fault va %08x ip %08x\n",
+		curenv->env_id, fault_va, tf->tf_eip);
+	print_trapframe(tf);
+	env_destroy(curenv);
+}
+
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 2dbeeca..5737c0a 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -21,36 +21,94 @@
  *   void NAME();
  * where NAME is the argument passed to TRAPHANDLER.
  */
-#define TRAPHANDLER(name, num)						\
-	.globl name;		/* define global symbol for 'name' */	\
-	.type name, @function;	/* symbol type is function */		\
-	.align 2;		/* align function definition */		\
-	name:			/* function starts here */		\
-	pushl $(num);							\
-	jmp _alltraps
-
-/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
- * It pushes a 0 in place of the error code, so the trap frame has the same
- * format in either case.
- */
-#define TRAPHANDLER_NOEC(name, num)					\
-	.globl name;							\
-	.type name, @function;						\
-	.align 2;							\
-	name:								\
-	pushl $0;							\
-	pushl $(num);							\
-	jmp _alltraps
+#define TRAPHANDLER(name, num)			    \
+	.text;				    \
+    .globl name;	/* define global symbol for 'name' */	\
+    .type name, @function;  /* symbol type is function */	\
+    .align 2;	    /* align function definition */	\
+    name:	    /* function starts here */	    \
+    .if !(num == 8 || num >= 10 && num <= 14 || num == 17); \
+    pushl $0; \
+    .endif; \
+    pushl $(num);			    \
+    jmp _alltraps;			    \
+    .data;				\
+    .long name;
+
+
+
 
-.text
 
 /*
  * Lab 3: Your code here for generating entry points for the different traps.
- */
+     * Lab 3: Your code here for _alltraps
+     */
+.data
+.global vectors
+vectors:
+TRAPHANDLER(vector0, 0)
+    TRAPHANDLER(vector1, 1)
+    TRAPHANDLER(vector2, 2)
+    TRAPHANDLER(vector3, 3)
+    TRAPHANDLER(vector4, 4)
+    TRAPHANDLER(vector5, 5)
+    TRAPHANDLER(vector6, 6)
+    TRAPHANDLER(vector7, 7)
+    TRAPHANDLER(vector8, 8)
+    TRAPHANDLER(vector9, 9)
+    TRAPHANDLER(vector10, 10)
+    TRAPHANDLER(vector11, 11)
+    TRAPHANDLER(vector12, 12)
+    TRAPHANDLER(vector13, 13)
+    TRAPHANDLER(vector14, 14)
+    TRAPHANDLER(vector15, 15)
+    TRAPHANDLER(vector16, 16)
+    TRAPHANDLER(vector17, 17)
+    TRAPHANDLER(vector18, 18)
+    TRAPHANDLER(vector19, 19)
+    TRAPHANDLER(vector20, 20)
+    TRAPHANDLER(vector21, 21)
+    TRAPHANDLER(vector22, 22)
+    TRAPHANDLER(vector23, 23)
+    TRAPHANDLER(vector24, 24)
+    TRAPHANDLER(vector25, 25)
+    TRAPHANDLER(vector26, 26)
+    TRAPHANDLER(vector27, 27)
+    TRAPHANDLER(vector28, 28)
+    TRAPHANDLER(vector29, 29)
+    TRAPHANDLER(vector30, 30)
+    TRAPHANDLER(vector31, 31)
+    TRAPHANDLER(vector32, 32)
+    TRAPHANDLER(vector33, 33)
+    TRAPHANDLER(vector34, 34)
+    TRAPHANDLER(vector35, 35)
+    TRAPHANDLER(vector36, 36)
+    TRAPHANDLER(vector37, 37)
+    TRAPHANDLER(vector38, 38)
+    TRAPHANDLER(vector39, 39)
+    TRAPHANDLER(vector40, 40)
+    TRAPHANDLER(vector41, 41)
+    TRAPHANDLER(vector42, 42)
+    TRAPHANDLER(vector43, 43)
+    TRAPHANDLER(vector44, 44)
+    TRAPHANDLER(vector45, 45)
+    TRAPHANDLER(vector46, 46)
+    TRAPHANDLER(vector47, 47)
+    TRAPHANDLER(vector48, 48)
 
+    .text
+    _alltraps:
+    pushw $0x0
+    pushw %ds
+    pushw $0x0
+    pushw %es
+    pushal
+
+    movw $GD_KD, %ax
+    movw %ax, %ds
+    movw %ax, %es
+    pushl %esp
+    call trap
 
 
-/*
- * Lab 3: Your code here for _alltraps
- */
 
diff --git a/kern/trapentry.S~ b/kern/trapentry.S~
new file mode 100644
index 0000000..8379271
--- /dev/null
+++ b/kern/trapentry.S~
@@ -0,0 +1,109 @@
+/* See COPYRIGHT for copyright information. */
+
+#include <inc/mmu.h>
+#include <inc/memlayout.h>
+#include <inc/trap.h>
+
+
+
+###################################################################
+# exceptions/interrupts
+###################################################################
+
+/* TRAPHANDLER defines a globally-visible function for handling a trap.
+ * It pushes a trap number onto the stack, then jumps to _alltraps.
+ * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
+ *
+ * You shouldn't call a TRAPHANDLER function from C, but you may
+ * need to _declare_ one in C (for instance, to get a function pointer
+ * during IDT setup).  You can declare the function with
+ *   void NAME();
+ * where NAME is the argument passed to TRAPHANDLER.
+ */
+#define TRAPHANDLER(name, num)						\
+	.globl name;		/* define global symbol for 'name' */	\
+	.type name, @function;	/* symbol type is function */		\
+	.align 2;		/* align function definition */		\
+	name:			/* function starts here */		\
+	pushl $(num);							\
+	jmp _alltraps
+
+/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
+ * It pushes a 0 in place of the error code, so the trap frame has the same
+ * format in either case.
+ */
+#define TRAPHANDLER_NOEC(name, num)					\
+	.globl name;							\
+	.type name, @function;						\
+	.align 2;							\
+	name:								\
+	pushl $0;							\
+	pushl $(num);							\
+	jmp _alltraps
+
+.text
+
+/*
+ * Lab 3: Your code here for generating entry points for the different traps.
+ */
+.data
+.global vectors
+vectors:
+.long vector0
+.long vector1
+.long vector2
+.long vector3
+.long vector4
+.long vector5
+.long vector6
+.long vector7
+.long vector8
+.long vector9
+.long vector10
+.long vector11
+.long vector12
+.long vector13
+.long vector14
+.long vector15
+.long vector16
+
+TRAPHANDLER_NOEC(vector0, 0)
+TRAPHANDLER_NOEC(vector1, 1)
+TRAPHANDLER_NOEC(vector2, 2)
+TRAPHANDLER_NOEC(vector3, 3)
+TRAPHANDLER_NOEC(vector4, 4)
+TRAPHANDLER_NOEC(vector5, 5)
+TRAPHANDLER_NOEC(vector6, 6)
+TRAPHANDLER_NOEC(vector7, 7)
+TRAPHANDLER(vector8, 8)
+TRAPHANDLER(vector9, 9)
+TRAPHANDLER(vector10, 10)
+TRAPHANDLER(vector11, 11)
+TRAPHANDLER(vector12, 12)
+TRAPHANDLER(vector13, 13)
+TRAPHANDLER(vector14, 14)
+TRAPHANDLER(vector15, 15)
+TRAPHANDLER_NOEC(vector16, 16)
+TRAPHANDLER(vector17, 17)
+TRAPHANDLER_NOEC(vector18, 18)
+TRAPHANDLER_NOEC(vector19, 19)
+
+
+/*
+ * Lab 3: Your code here for _alltraps
+ */
+.text
+_alltraps:
+pushw $0x0
+pushw %ds
+pushw $0x0
+pushl %es
+pushal
+
+movw $GD_KD, %ax
+movw %ax, %ds
+movw %ax, %es
+pushl %esp
+call trap
+
+
diff --git a/lab.tar.gz b/lab.tar.gz
new file mode 100644
index 0000000..e4699bc
Binary files /dev/null and b/lab.tar.gz differ
diff --git a/lib/file.c b/lib/file.c
index 39025b2..5934ea4 100644
--- a/lib/file.c
+++ b/lib/file.c
@@ -84,7 +84,6 @@ open(const char *path, int mode)
 		fd_close(fd, 0);
 		return r;
 	}
-
 	return fd2num(fd);
 }
 
@@ -141,7 +140,17 @@ devfile_write(struct Fd *fd, const void *buf, size_t n)
 	// remember that write is always allowed to write *fewer*
 	// bytes than requested.
 	// LAB 5: Your code here
-	panic("devfile_write not implemented");
+	
+	if (n > sizeof (fsipcbuf.write.req_buf))
+	   n = sizeof (fsipcbuf.write.req_buf);
+
+	fsipcbuf.write.req_fileid = fd->fd_file.id;
+	fsipcbuf.write.req_n = n;
+	memmove(fsipcbuf.write.req_buf,buf,n);
+	int r;
+	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
+	   return r;
+	return r;
 }
 
 static int
diff --git a/lib/fork.c b/lib/fork.c
index 61264da..532491d 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -11,30 +11,33 @@
 // Custom page fault handler - if faulting page is copy-on-write,
 // map in our own private writable copy.
 //
-static void
+    static void
 pgfault(struct UTrapframe *utf)
 {
-	void *addr = (void *) utf->utf_fault_va;
-	uint32_t err = utf->utf_err;
-	int r;
-
-	// Check that the faulting access was (1) a write, and (2) to a
-	// copy-on-write page.  If not, panic.
-	// Hint:
-	//   Use the read-only page table mappings at uvpt
-	//   (see <inc/memlayout.h>).
-
-	// LAB 4: Your code here.
-
-	// Allocate a new page, map it at a temporary location (PFTEMP),
-	// copy the data from the old page to the new page, then move the new
-	// page to the old page's address.
-	// Hint:
-	//   You should make three system calls.
-
-	// LAB 4: Your code here.
-
-	panic("pgfault not implemented");
+    void *addr = (void *) utf->utf_fault_va;
+    uint32_t err = utf->utf_err;
+    int r;
+    pte_t pte;
+    // Check that the faulting access was (1) a write, and (2) to a
+    // copy-on-write page.  If not, panic.
+    // Hint:
+    //   Use the read-only page table mappings at uvpt
+    //   (see <inc/memlayout.h>).
+    // LAB 4: Your code here.
+    if (!(utf->utf_err & FEC_WR)) panic("pgfault(): FEC_WR\n");
+    if (!uvpd[((uintptr_t)addr >> 22)]) panic("pgfault(): page not mapped");
+    if (!(pte = uvpt[(uintptr_t)addr >> 12])) panic("pgfault(): page not mapped");
+    if (!(pte & PTE_COW)) panic("pgfault: PTE_COW\n");
+    // Allocate a new page, map it at a temporary location (PFTEMP),
+    // copy the data from the old page to the new page, then move the new
+    // page to the old page's address.
+    // Hint:
+    //   You should make three system calls.
+    // LAB 4: Your code here.
+    sys_page_alloc(0, (void*)PFTEMP, PTE_P | PTE_U | PTE_W);
+    memcpy((void*)PFTEMP, (void*)ROUNDDOWN((uintptr_t)addr, PGSIZE), PGSIZE);
+    sys_page_map(0, (void*)PFTEMP, 0, (void*)ROUNDDOWN((uintptr_t)addr, PGSIZE), PTE_P | PTE_U | PTE_W);
+    sys_page_unmap(0, (void*)PFTEMP);
 }
 
 //
@@ -48,14 +51,30 @@ pgfault(struct UTrapframe *utf)
 // Returns: 0 on success, < 0 on error.
 // It is also OK to panic on error.
 //
-static int
+    static int
 duppage(envid_t envid, unsigned pn)
 {
-	int r;
+    int r;
+
+    // LAB 4: Your code here.
+    int perm = uvpt[pn] & 0xfff;
 
-	// LAB 4: Your code here.
-	panic("duppage not implemented");
+    if (perm & PTE_SHARE) {
+	if ((r = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void*)(pn * PGSIZE), perm)))
+	    return r;
 	return 0;
+    }
+    if (perm & (PTE_W | PTE_COW)) {
+	if ((r = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void*)(pn * PGSIZE), (perm & ~PTE_W) | PTE_COW)))
+	    return r;
+	if ((perm & PTE_W)&&(r = sys_page_map(0, (void*)(pn * PGSIZE), 0, (void*)(pn * PGSIZE), (perm & ~PTE_W) | PTE_COW)))
+	    return r;
+    }
+    else {
+	if ((r = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void*)(pn * PGSIZE), perm)))
+	    return r;
+    }
+    return 0;
 }
 
 //
@@ -74,17 +93,39 @@ duppage(envid_t envid, unsigned pn)
 //   Neither user exception stack should ever be marked copy-on-write,
 //   so you must allocate a new page for the child's user exception stack.
 //
-envid_t
+    envid_t
 fork(void)
 {
-	// LAB 4: Your code here.
-	panic("fork not implemented");
+    // LAB 4: Your code here.
+    extern void _pgfault_upcall(void);
+    uintptr_t p = 0;
+    envid_t envid;
+    set_pgfault_handler(pgfault);
+
+    envid = sys_exofork();
+    if (envid < 0) return envid;
+    if (envid == 0) {
+	thisenv = &envs[ENVX(sys_getenvid())];
+	return 0;
+    }
+    while (p < UTOP) {
+	if (!uvpd[p >> 22]) {
+	    p += PGSIZE << 10;
+	    continue;
+	}
+	if (p != UXSTACKTOP - PGSIZE && uvpt[p >> 12]) duppage(envid, p >> 12);
+	p += PGSIZE;
+    }
+    if (sys_page_alloc(envid, (void*)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W) < 0) panic("fork(): 111111\n");
+    if (sys_env_set_pgfault_upcall(envid, _pgfault_upcall) < 0) panic("fork(): 22222222\n");
+    if (sys_env_set_status(envid, ENV_RUNNABLE) < 0) panic("fork(): 3333333\n");
+    return envid;
 }
 
 // Challenge!
-int
+    int
 sfork(void)
 {
-	panic("sfork not implemented");
-	return -E_INVAL;
+    panic("sfork not implemented");
+    return -E_INVAL;
 }
diff --git a/lib/fork.c~ b/lib/fork.c~
new file mode 100644
index 0000000..3712b82
--- /dev/null
+++ b/lib/fork.c~
@@ -0,0 +1,126 @@
+// implement fork from user space
+
+#include <inc/string.h>
+#include <inc/lib.h>
+
+// PTE_COW marks copy-on-write page table entries.
+// It is one of the bits explicitly allocated to user processes (PTE_AVAIL).
+#define PTE_COW		0x800
+
+//
+// Custom page fault handler - if faulting page is copy-on-write,
+// map in our own private writable copy.
+//
+    static void
+pgfault(struct UTrapframe *utf)
+{
+    void *addr = (void *) utf->utf_fault_va;
+    uint32_t err = utf->utf_err;
+    int r;
+    pte_t pte;
+    // Check that the faulting access was (1) a write, and (2) to a
+    // copy-on-write page.  If not, panic.
+    // Hint:
+    //   Use the read-only page table mappings at uvpt
+    //   (see <inc/memlayout.h>).
+    // LAB 4: Your code here.
+    if (!(utf->utf_err & FEC_WR)) panic("pgfault(): FEC_WR\n");
+    if (!uvpd[((uintptr_t)addr >> 22)]) panic("pgfault(): page not mapped");
+    if (!(pte = uvpt[(uintptr_t)addr >> 12])) panic("pgfault(): page not mapped");
+    if (!(pte & PTE_COW)) panic("pgfault: PTE_COW\n");
+    // Allocate a new page, map it at a temporary location (PFTEMP),
+    // copy the data from the old page to the new page, then move the new
+    // page to the old page's address.
+    // Hint:
+    //   You should make three system calls.
+    // LAB 4: Your code here.
+    sys_page_alloc(0, (void*)PFTEMP, PTE_P | PTE_U | PTE_W);
+    memcpy((void*)PFTEMP, (void*)ROUNDDOWN((uintptr_t)addr, PGSIZE), PGSIZE);
+    sys_page_map(0, (void*)PFTEMP, 0, (void*)ROUNDDOWN((uintptr_t)addr, PGSIZE), PTE_P | PTE_U | PTE_W);
+    sys_page_unmap(0, (void*)PFTEMP);
+}
+
+//
+// Map our virtual page pn (address pn*PGSIZE) into the target envid
+// at the same virtual address.  If the page is writable or copy-on-write,
+// the new mapping must be created copy-on-write, and then our mapping must be
+// marked copy-on-write as well.  (Exercise: Why do we need to mark ours
+// copy-on-write again if it was already copy-on-write at the beginning of
+// this function?)
+//
+// Returns: 0 on success, < 0 on error.
+// It is also OK to panic on error.
+//
+    static int
+duppage(envid_t envid, unsigned pn)
+{
+    int r;
+
+    // LAB 4: Your code here.
+    int perm = uvpt[pn] & 0xfff;
+
+    if (perm & (PTE_W | PTE_COW)) {
+	if ((r = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void*)(pn * PGSIZE), (perm & ~PTE_W) | PTE_COW)))
+	    return r;
+	if ((perm & PTE_W)&&(r = sys_page_map(0, (void*)(pn * PGSIZE), 0, (void*)(pn * PGSIZE), (perm & ~PTE_W) | PTE_COW)))
+	    return r;
+    }
+    else {
+	if ((r = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void*)(pn * PGSIZE), perm)))
+	    return r;
+    }
+    return 0;
+}
+
+//
+// User-level fork with copy-on-write.
+// Set up our page fault handler appropriately.
+// Create a child.
+// Copy our address space and page fault handler setup to the child.
+// Then mark the child as runnable and return.
+//
+// Returns: child's envid to the parent, 0 to the child, < 0 on error.
+// It is also OK to panic on error.
+//
+// Hint:
+//   Use uvpd, uvpt, and duppage.
+//   Remember to fix "thisenv" in the child process.
+//   Neither user exception stack should ever be marked copy-on-write,
+//   so you must allocate a new page for the child's user exception stack.
+//
+    envid_t
+fork(void)
+{
+    // LAB 4: Your code here.
+    extern void _pgfault_upcall(void);
+    uintptr_t p = 0;
+    envid_t envid;
+    set_pgfault_handler(pgfault);
+
+    envid = sys_exofork();
+    if (envid < 0) return envid;
+    if (envid == 0) {
+	thisenv = &envs[ENVX(sys_getenvid())];
+	return 0;
+    }
+    while (p < UTOP) {
+	if (!uvpd[p >> 22]) {
+	    p += PGSIZE << 10;
+	    continue;
+	}
+	if (p != UXSTACKTOP - PGSIZE && uvpt[p >> 12]) duppage(envid, p >> 12);
+	p += PGSIZE;
+    }
+    if (sys_page_alloc(envid, (void*)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W) < 0) panic("fork(): 111111\n");
+    if (sys_env_set_pgfault_upcall(envid, _pgfault_upcall) < 0) panic("fork(): 22222222\n");
+    if (sys_env_set_status(envid, ENV_RUNNABLE) < 0) panic("fork(): 3333333\n");
+    return envid;
+}
+
+// Challenge!
+    int
+sfork(void)
+{
+    panic("sfork not implemented");
+    return -E_INVAL;
+}
diff --git a/lib/ipc.c b/lib/ipc.c
index 2e222b9..3975404 100644
--- a/lib/ipc.c
+++ b/lib/ipc.c
@@ -19,12 +19,20 @@
 //   If 'pg' is null, pass sys_ipc_recv a value that it will understand
 //   as meaning "no page".  (Zero is not the right value, since that's
 //   a perfectly valid place to map a page.)
-int32_t
+    int32_t
 ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 {
-	// LAB 4: Your code here.
-	panic("ipc_recv not implemented");
-	return 0;
+    // LAB 4: Your code here.
+    int r;
+    if (!pg) pg = (void*)UTOP;
+    if ((r = sys_ipc_recv(pg)) < 0) {
+	if (from_env_store) *from_env_store = 0;
+	if (perm_store) *perm_store = 0;
+	return r;
+    }
+    if (from_env_store) *from_env_store = thisenv->env_ipc_from;
+    if (perm_store) *perm_store = thisenv->env_ipc_perm;
+    return thisenv->env_ipc_value;
 }
 
 // Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
@@ -35,22 +43,27 @@ ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 //   Use sys_yield() to be CPU-friendly.
 //   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
 //   as meaning "no page".  (Zero is not the right value.)
-void
+    void
 ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
 {
-	// LAB 4: Your code here.
-	panic("ipc_send not implemented");
+    // LAB 4: Your code here.
+    int r;
+    while ((r = sys_ipc_try_send(to_env, val, (pg ? pg : (void*)UTOP), perm))) {
+	if (r != -E_IPC_NOT_RECV) panic("ipc_send()\n");
+	sys_yield();
+    }
+
 }
 
 // Find the first environment of the given type.  We'll use this to
 // find special environments.
 // Returns 0 if no such environment exists.
-envid_t
+    envid_t
 ipc_find_env(enum EnvType type)
 {
-	int i;
-	for (i = 0; i < NENV; i++)
-		if (envs[i].env_type == type)
-			return envs[i].env_id;
-	return 0;
+    int i;
+    for (i = 0; i < NENV; i++)
+	if (envs[i].env_type == type)
+	    return envs[i].env_id;
+    return 0;
 }
diff --git a/lib/libmain.c b/lib/libmain.c
index 8a14b29..a5aa1e1 100644
--- a/lib/libmain.c
+++ b/lib/libmain.c
@@ -13,8 +13,8 @@ libmain(int argc, char **argv)
 {
 	// set thisenv to point at our Env structure in envs[].
 	// LAB 3: Your code here.
-	thisenv = 0;
-
+        thisenv = envs + ENVX(sys_getenvid());
+    
 	// save the name of the program so that panic() can use it
 	if (argc > 0)
 		binaryname = argv[0];
diff --git a/lib/pfentry.S b/lib/pfentry.S
index f40aeeb..e29c0ec 100644
--- a/lib/pfentry.S
+++ b/lib/pfentry.S
@@ -32,51 +32,63 @@
 .text
 .globl _pgfault_upcall
 _pgfault_upcall:
-	// Call the C page fault handler.
-	pushl %esp			// function argument: pointer to UTF
-	movl _pgfault_handler, %eax
-	call *%eax
-	addl $4, %esp			// pop function argument
-	
-	// Now the C page fault handler has returned and you must return
-	// to the trap time state.
-	// Push trap-time %eip onto the trap-time stack.
-	//
-	// Explanation:
-	//   We must prepare the trap-time stack for our eventual return to
-	//   re-execute the instruction that faulted.
-	//   Unfortunately, we can't return directly from the exception stack:
-	//   We can't call 'jmp', since that requires that we load the address
-	//   into a register, and all registers must have their trap-time
-	//   values after the return.
-	//   We can't call 'ret' from the exception stack either, since if we
-	//   did, %esp would have the wrong value.
-	//   So instead, we push the trap-time %eip onto the *trap-time* stack!
-	//   Below we'll switch to that stack and call 'ret', which will
-	//   restore %eip to its pre-fault value.
-	//
-	//   In the case of a recursive fault on the exception stack,
-	//   note that the word we're pushing now will fit in the
-	//   blank word that the kernel reserved for us.
-	//
-	// Throughout the remaining code, think carefully about what
-	// registers are available for intermediate calculations.  You
-	// may find that you have to rearrange your code in non-obvious
-	// ways as registers become unavailable as scratch space.
-	//
-	// LAB 4: Your code here.
+// Call the C page fault handler.
+pushl %esp			// function argument: pointer to UTF
+movl _pgfault_handler, %eax
+call *%eax
+addl $4, %esp			// pop function argument
 
-	// Restore the trap-time registers.  After you do this, you
-	// can no longer modify any general-purpose registers.
-	// LAB 4: Your code here.
+// Now the C page fault handler has returned and you must return
+// to the trap time state.
+// Push trap-time %eip onto the trap-time stack.
+//
+// Explanation:
+//   We must prepare the trap-time stack for our eventual return to
+//   re-execute the instruction that faulted.
+//   Unfortunately, we can't return directly from the exception stack:
+//   We can't call 'jmp', since that requires that we load the address
+//   into a register, and all registers must have their trap-time
+//   values after the return.
+//   We can't call 'ret' from the exception stack either, since if we
+//   did, %esp would have the wrong value.
+//   So instead, we push the trap-time %eip onto the *trap-time* stack!
+//   Below we'll switch to that stack and call 'ret', which will
+//   restore %eip to its pre-fault value.
+//
+//   In the case of a recursive fault on the exception stack,
+//   note that the word we're pushing now will fit in the
+//   blank word that the kernel reserved for us.
+//
+// Throughout the remaining code, think carefully about what
+// registers are available for intermediate calculations.  You
+// may find that you have to rearrange your code in non-obvious
+// ways as registers become unavailable as scratch space.
+//
+// LAB 4: Your code here.
+
+subl $4, 48(%esp)
+    movl 48(%esp), %eax
+    movl 40(%esp), %edx
+movl %edx, (%eax)
+
+    // Restore the trap-time registers.  After you do this, you
+    // can no longer modify any general-purpose registers.
+    // LAB 4: Your code here.
+    addl $8, %esp
+    popal
+
+    // Restore eflags from the stack.  After you do this, you can
+    // no longer use arithmetic operations or anything else that
+    // modifies eflags.
+    // LAB 4: Your code here.
+    addl $4, %esp
+    popfl
 
-	// Restore eflags from the stack.  After you do this, you can
-	// no longer use arithmetic operations or anything else that
-	// modifies eflags.
-	// LAB 4: Your code here.
+    // Switch back to the adjusted trap-time stack.
+    // LAB 4: Your code here.
+    popl %esp
 
-	// Switch back to the adjusted trap-time stack.
-	// LAB 4: Your code here.
+    // Return to re-execute the instruction that faulted.
+    // LAB 4: Your code here.
 
-	// Return to re-execute the instruction that faulted.
-	// LAB 4: Your code here.
+    ret
diff --git a/lib/pgfault.c b/lib/pgfault.c
index a975518..c4bdd94 100644
--- a/lib/pgfault.c
+++ b/lib/pgfault.c
@@ -21,17 +21,19 @@ void (*_pgfault_handler)(struct UTrapframe *utf);
 // at UXSTACKTOP), and tell the kernel to call the assembly-language
 // _pgfault_upcall routine when a page fault occurs.
 //
-void
+    void
 set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
 {
-	int r;
+    int r;
 
-	if (_pgfault_handler == 0) {
-		// First time through!
-		// LAB 4: Your code here.
-		panic("set_pgfault_handler not implemented");
-	}
+    if (_pgfault_handler == 0) {
+	// First time through!
+	// LAB 4: Your code here.
+	sys_page_alloc(0, (void*)(UXSTACKTOP - PGSIZE), PTE_U | PTE_W | PTE_P);
+	sys_env_set_pgfault_upcall(0, (void*)_pgfault_upcall);
 
-	// Save handler pointer for assembly to call.
-	_pgfault_handler = handler;
+    }
+
+    // Save handler pointer for assembly to call.
+    _pgfault_handler = handler;
 }
diff --git a/lib/printfmt.c b/lib/printfmt.c
index 8cea2f8..25a3280 100644
--- a/lib/printfmt.c
+++ b/lib/printfmt.c
@@ -7,6 +7,7 @@
 #include <inc/string.h>
 #include <inc/stdarg.h>
 #include <inc/error.h>
+#include <inc/color.h>
 
 /*
  * Space or zero padding and a field width are supported for the numeric
@@ -101,6 +102,33 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 		while ((ch = *(unsigned char *) fmt++) != '%') {
 			if (ch == '\0')
 				return;
+			else if(ch == '\033'){
+				if((ch = *(unsigned char *) fmt++) != '[') {
+				    putch(ch, putdat);
+				    continue;
+				}
+				BG_COLOR = *(unsigned char *) fmt++;
+				FG_COLOR = *(unsigned char *) fmt++;
+
+				if(BG_COLOR >= '0' && BG_COLOR <= '9')
+				    BG_COLOR -= '0';
+				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
+				    BG_COLOR = BG_COLOR - 'a' + 10;
+				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
+				    BG_COLOR = BG_COLOR - 'A' + 10;
+				else BG_COLOR = 0;
+
+				if(FG_COLOR >= '0' && FG_COLOR <= '9')
+				    FG_COLOR -= '0';
+				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
+				    FG_COLOR = FG_COLOR - 'a' + 10;
+				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
+				    FG_COLOR = FG_COLOR - 'A' + 10;
+				else BG_COLOR = 7;
+
+				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
+				continue;
+			}	
 			putch(ch, putdat);
 		}
 
@@ -214,11 +242,9 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 
 		// (unsigned) octal
 		case 'o':
-			// Replace this with your code.
-			putch('X', putdat);
-			putch('X', putdat);
-			putch('X', putdat);
-			break;
+			num = getuint(&ap,lflag);
+			base = 8;
+			goto number;
 
 		// pointer
 		case 'p':
@@ -240,7 +266,7 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 		// escaped '%' character
 		case '%':
 			putch(ch, putdat);
-			break;
+			break;			
 
 		// unrecognized escape sequence - just print it literally
 		default:
diff --git a/lib/spawn.c b/lib/spawn.c
index 9d0eb07..cef2311 100644
--- a/lib/spawn.c
+++ b/lib/spawn.c
@@ -8,7 +8,7 @@
 // Helper functions for spawn.
 static int init_stack(envid_t child, const char **argv, uintptr_t *init_esp);
 static int map_segment(envid_t child, uintptr_t va, size_t memsz,
-		       int fd, size_t filesz, off_t fileoffset, int perm);
+	int fd, size_t filesz, off_t fileoffset, int perm);
 static int copy_shared_pages(envid_t child);
 
 // Spawn a child process from a program image loaded from the file system.
@@ -16,163 +16,163 @@ static int copy_shared_pages(envid_t child);
 // argv: pointer to null-terminated array of pointers to strings,
 // 	 which will be passed to the child as its command-line arguments.
 // Returns child envid on success, < 0 on failure.
-int
+    int
 spawn(const char *prog, const char **argv)
 {
-	unsigned char elf_buf[512];
-	struct Trapframe child_tf;
-	envid_t child;
-
-	int fd, i, r;
-	struct Elf *elf;
-	struct Proghdr *ph;
-	int perm;
-
-	// This code follows this procedure:
-	//
-	//   - Open the program file.
-	//
-	//   - Read the ELF header, as you have before, and sanity check its
-	//     magic number.  (Check out your load_icode!)
-	//
-	//   - Use sys_exofork() to create a new environment.
-	//
-	//   - Set child_tf to an initial struct Trapframe for the child.
-	//
-	//   - Call the init_stack() function above to set up
-	//     the initial stack page for the child environment.
-	//
-	//   - Map all of the program's segments that are of p_type
-	//     ELF_PROG_LOAD into the new environment's address space.
-	//     Use the p_flags field in the Proghdr for each segment
-	//     to determine how to map the segment:
-	//
-	//	* If the ELF flags do not include ELF_PROG_FLAG_WRITE,
-	//	  then the segment contains text and read-only data.
-	//	  Use read_map() to read the contents of this segment,
-	//	  and map the pages it returns directly into the child
-	//        so that multiple instances of the same program
-	//	  will share the same copy of the program text.
-	//        Be sure to map the program text read-only in the child.
-	//        Read_map is like read but returns a pointer to the data in
-	//        *blk rather than copying the data into another buffer.
-	//
-	//	* If the ELF segment flags DO include ELF_PROG_FLAG_WRITE,
-	//	  then the segment contains read/write data and bss.
-	//	  As with load_icode() in Lab 3, such an ELF segment
-	//	  occupies p_memsz bytes in memory, but only the FIRST
-	//	  p_filesz bytes of the segment are actually loaded
-	//	  from the executable file - you must clear the rest to zero.
-	//        For each page to be mapped for a read/write segment,
-	//        allocate a page in the parent temporarily at UTEMP,
-	//        read() the appropriate portion of the file into that page
-	//	  and/or use memset() to zero non-loaded portions.
-	//	  (You can avoid calling memset(), if you like, if
-	//	  page_alloc() returns zeroed pages already.)
-	//        Then insert the page mapping into the child.
-	//        Look at init_stack() for inspiration.
-	//        Be sure you understand why you can't use read_map() here.
-	//
-	//     Note: None of the segment addresses or lengths above
-	//     are guaranteed to be page-aligned, so you must deal with
-	//     these non-page-aligned values appropriately.
-	//     The ELF linker does, however, guarantee that no two segments
-	//     will overlap on the same page; and it guarantees that
-	//     PGOFF(ph->p_offset) == PGOFF(ph->p_va).
-	//
-	//   - Call sys_env_set_trapframe(child, &child_tf) to set up the
-	//     correct initial eip and esp values in the child.
-	//
-	//   - Start the child process running with sys_env_set_status().
-
-	if ((r = open(prog, O_RDONLY)) < 0)
-		return r;
-	fd = r;
+    unsigned char elf_buf[512];
+    struct Trapframe child_tf;
+    envid_t child;
+
+    int fd, i, r;
+    struct Elf *elf;
+    struct Proghdr *ph;
+    int perm;
+
+    // This code follows this procedure:
+    //
+    //   - Open the program file.
+    //
+    //   - Read the ELF header, as you have before, and sanity check its
+    //     magic number.  (Check out your load_icode!)
+    //
+    //   - Use sys_exofork() to create a new environment.
+    //
+    //   - Set child_tf to an initial struct Trapframe for the child.
+    //
+    //   - Call the init_stack() function above to set up
+    //     the initial stack page for the child environment.
+    //
+    //   - Map all of the program's segments that are of p_type
+    //     ELF_PROG_LOAD into the new environment's address space.
+    //     Use the p_flags field in the Proghdr for each segment
+    //     to determine how to map the segment:
+    //
+    //	* If the ELF flags do not include ELF_PROG_FLAG_WRITE,
+    //	  then the segment contains text and read-only data.
+    //	  Use read_map() to read the contents of this segment,
+    //	  and map the pages it returns directly into the child
+    //        so that multiple instances of the same program
+    //	  will share the same copy of the program text.
+    //        Be sure to map the program text read-only in the child.
+    //        Read_map is like read but returns a pointer to the data in
+    //        *blk rather than copying the data into another buffer.
+    //
+    //	* If the ELF segment flags DO include ELF_PROG_FLAG_WRITE,
+    //	  then the segment contains read/write data and bss.
+    //	  As with load_icode() in Lab 3, such an ELF segment
+    //	  occupies p_memsz bytes in memory, but only the FIRST
+    //	  p_filesz bytes of the segment are actually loaded
+    //	  from the executable file - you must clear the rest to zero.
+    //        For each page to be mapped for a read/write segment,
+    //        allocate a page in the parent temporarily at UTEMP,
+    //        read() the appropriate portion of the file into that page
+    //	  and/or use memset() to zero non-loaded portions.
+    //	  (You can avoid calling memset(), if you like, if
+    //	  page_alloc() returns zeroed pages already.)
+    //        Then insert the page mapping into the child.
+    //        Look at init_stack() for inspiration.
+    //        Be sure you understand why you can't use read_map() here.
+    //
+    //     Note: None of the segment addresses or lengths above
+    //     are guaranteed to be page-aligned, so you must deal with
+    //     these non-page-aligned values appropriately.
+    //     The ELF linker does, however, guarantee that no two segments
+    //     will overlap on the same page; and it guarantees that
+    //     PGOFF(ph->p_offset) == PGOFF(ph->p_va).
+    //
+    //   - Call sys_env_set_trapframe(child, &child_tf) to set up the
+    //     correct initial eip and esp values in the child.
+    //
+    //   - Start the child process running with sys_env_set_status().
+
+    if ((r = open(prog, O_RDONLY)) < 0)
+	return r;
+    fd = r;
 
-	// Read elf header
-	elf = (struct Elf*) elf_buf;
-	if (readn(fd, elf_buf, sizeof(elf_buf)) != sizeof(elf_buf)
+    // Read elf header
+    elf = (struct Elf*) elf_buf;
+    if (readn(fd, elf_buf, sizeof(elf_buf)) != sizeof(elf_buf)
 	    || elf->e_magic != ELF_MAGIC) {
-		close(fd);
-		cprintf("elf magic %08x want %08x\n", elf->e_magic, ELF_MAGIC);
-		return -E_NOT_EXEC;
-	}
-
-	// Create new child environment
-	if ((r = sys_exofork()) < 0)
-		return r;
-	child = r;
-
-	// Set up trap frame, including initial stack.
-	child_tf = envs[ENVX(child)].env_tf;
-	child_tf.tf_eip = elf->e_entry;
-
-	if ((r = init_stack(child, argv, &child_tf.tf_esp)) < 0)
-		return r;
-
-	// Set up program segments as defined in ELF header.
-	ph = (struct Proghdr*) (elf_buf + elf->e_phoff);
-	for (i = 0; i < elf->e_phnum; i++, ph++) {
-		if (ph->p_type != ELF_PROG_LOAD)
-			continue;
-		perm = PTE_P | PTE_U;
-		if (ph->p_flags & ELF_PROG_FLAG_WRITE)
-			perm |= PTE_W;
-		if ((r = map_segment(child, ph->p_va, ph->p_memsz,
-				     fd, ph->p_filesz, ph->p_offset, perm)) < 0)
-			goto error;
-	}
 	close(fd);
-	fd = -1;
+	cprintf("elf magic %08x want %08x\n", elf->e_magic, ELF_MAGIC);
+	return -E_NOT_EXEC;
+    }
 
-	// Copy shared library state.
-	if ((r = copy_shared_pages(child)) < 0)
-		panic("copy_shared_pages: %e", r);
+    // Create new child environment
+    if ((r = sys_exofork()) < 0)
+	return r;
+    child = r;
 
-	child_tf.tf_eflags |= FL_IOPL_3;   // devious: see user/faultio.c
-	if ((r = sys_env_set_trapframe(child, &child_tf)) < 0)
-		panic("sys_env_set_trapframe: %e", r);
+    // Set up trap frame, including initial stack.
+    child_tf = envs[ENVX(child)].env_tf;
+    child_tf.tf_eip = elf->e_entry;
 
-	if ((r = sys_env_set_status(child, ENV_RUNNABLE)) < 0)
-		panic("sys_env_set_status: %e", r);
+    if ((r = init_stack(child, argv, &child_tf.tf_esp)) < 0)
+	return r;
 
-	return child;
+    // Set up program segments as defined in ELF header.
+    ph = (struct Proghdr*) (elf_buf + elf->e_phoff);
+    for (i = 0; i < elf->e_phnum; i++, ph++) {
+	if (ph->p_type != ELF_PROG_LOAD)
+	    continue;
+	perm = PTE_P | PTE_U;
+	if (ph->p_flags & ELF_PROG_FLAG_WRITE)
+	    perm |= PTE_W;
+	if ((r = map_segment(child, ph->p_va, ph->p_memsz,
+			fd, ph->p_filesz, ph->p_offset, perm)) < 0)
+	    goto error;
+    }
+    close(fd);
+    fd = -1;
+
+    // Copy shared library state.
+    if ((r = copy_shared_pages(child)) < 0)
+	panic("copy_shared_pages: %e", r);
+
+     child_tf.tf_eflags |= FL_IOPL_3;   // devious: see user/faultio.c
+    if ((r = sys_env_set_trapframe(child, &child_tf)) < 0)
+	panic("sys_env_set_trapframe: %e", r);
+
+    if ((r = sys_env_set_status(child, ENV_RUNNABLE)) < 0)
+	panic("sys_env_set_status: %e", r);
+
+    return child;
 
 error:
-	sys_env_destroy(child);
-	close(fd);
-	return r;
+    sys_env_destroy(child);
+    close(fd);
+    return r;
 }
 
 // Spawn, taking command-line arguments array directly on the stack.
 // NOTE: Must have a sentinal of NULL at the end of the args
 // (none of the args may be NULL).
-int
+    int
 spawnl(const char *prog, const char *arg0, ...)
 {
-	// We calculate argc by advancing the args until we hit NULL.
-	// The contract of the function guarantees that the last
-	// argument will always be NULL, and that none of the other
-	// arguments will be NULL.
-	int argc=0;
-	va_list vl;
-	va_start(vl, arg0);
-	while(va_arg(vl, void *) != NULL)
-		argc++;
-	va_end(vl);
-
-	// Now that we have the size of the args, do a second pass
-	// and store the values in a VLA, which has the format of argv
-	const char *argv[argc+2];
-	argv[0] = arg0;
-	argv[argc+1] = NULL;
-
-	va_start(vl, arg0);
-	unsigned i;
-	for(i=0;i<argc;i++)
-		argv[i+1] = va_arg(vl, const char *);
-	va_end(vl);
-	return spawn(prog, argv);
+    // We calculate argc by advancing the args until we hit NULL.
+    // The contract of the function guarantees that the last
+    // argument will always be NULL, and that none of the other
+    // arguments will be NULL.
+    int argc=0;
+    va_list vl;
+    va_start(vl, arg0);
+    while(va_arg(vl, void *) != NULL)
+	argc++;
+    va_end(vl);
+
+    // Now that we have the size of the args, do a second pass
+    // and store the values in a VLA, which has the format of argv
+    const char *argv[argc+2];
+    argv[0] = arg0;
+    argv[argc+1] = NULL;
+
+    va_start(vl, arg0);
+    unsigned i;
+    for(i=0;i<argc;i++)
+	argv[i+1] = va_arg(vl, const char *);
+    va_end(vl);
+    return spawn(prog, argv);
 }
 
 
@@ -183,125 +183,138 @@ spawnl(const char *prog, const char *arg0, ...)
 // On success, returns 0 and sets *init_esp
 // to the initial stack pointer with which the child should start.
 // Returns < 0 on failure.
-static int
+    static int
 init_stack(envid_t child, const char **argv, uintptr_t *init_esp)
 {
-	size_t string_size;
-	int argc, i, r;
-	char *string_store;
-	uintptr_t *argv_store;
-
-	// Count the number of arguments (argc)
-	// and the total amount of space needed for strings (string_size).
-	string_size = 0;
-	for (argc = 0; argv[argc] != 0; argc++)
-		string_size += strlen(argv[argc]) + 1;
-
-	// Determine where to place the strings and the argv array.
-	// Set up pointers into the temporary page 'UTEMP'; we'll map a page
-	// there later, then remap that page into the child environment
-	// at (USTACKTOP - PGSIZE).
-	// strings is the topmost thing on the stack.
-	string_store = (char*) UTEMP + PGSIZE - string_size;
-	// argv is below that.  There's one argument pointer per argument, plus
-	// a null pointer.
-	argv_store = (uintptr_t*) (ROUNDDOWN(string_store, 4) - 4 * (argc + 1));
-
-	// Make sure that argv, strings, and the 2 words that hold 'argc'
-	// and 'argv' themselves will all fit in a single stack page.
-	if ((void*) (argv_store - 2) < (void*) UTEMP)
-		return -E_NO_MEM;
-
-	// Allocate the single stack page at UTEMP.
-	if ((r = sys_page_alloc(0, (void*) UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
-		return r;
-
-
-	//	* Initialize 'argv_store[i]' to point to argument string i,
-	//	  for all 0 <= i < argc.
-	//	  Also, copy the argument strings from 'argv' into the
-	//	  newly-allocated stack page.
-	//
-	//	* Set 'argv_store[argc]' to 0 to null-terminate the args array.
-	//
-	//	* Push two more words onto the child's stack below 'args',
-	//	  containing the argc and argv parameters to be passed
-	//	  to the child's umain() function.
-	//	  argv should be below argc on the stack.
-	//	  (Again, argv should use an address valid in the child's
-	//	  environment.)
-	//
-	//	* Set *init_esp to the initial stack pointer for the child,
-	//	  (Again, use an address valid in the child's environment.)
-	for (i = 0; i < argc; i++) {
-		argv_store[i] = UTEMP2USTACK(string_store);
-		strcpy(string_store, argv[i]);
-		string_store += strlen(argv[i]) + 1;
-	}
-	argv_store[argc] = 0;
-	assert(string_store == (char*)UTEMP + PGSIZE);
-
-	argv_store[-1] = UTEMP2USTACK(argv_store);
-	argv_store[-2] = argc;
-
-	*init_esp = UTEMP2USTACK(&argv_store[-2]);
+    size_t string_size;
+    int argc, i, r;
+    char *string_store;
+    uintptr_t *argv_store;
+
+    // Count the number of arguments (argc)
+    // and the total amount of space needed for strings (string_size).
+    string_size = 0;
+    for (argc = 0; argv[argc] != 0; argc++)
+	string_size += strlen(argv[argc]) + 1;
+
+    // Determine where to place the strings and the argv array.
+    // Set up pointers into the temporary page 'UTEMP'; we'll map a page
+    // there later, then remap that page into the child environment
+    // at (USTACKTOP - PGSIZE).
+    // strings is the topmost thing on the stack.
+    string_store = (char*) UTEMP + PGSIZE - string_size;
+    // argv is below that.  There's one argument pointer per argument, plus
+    // a null pointer.
+    argv_store = (uintptr_t*) (ROUNDDOWN(string_store, 4) - 4 * (argc + 1));
+
+    // Make sure that argv, strings, and the 2 words that hold 'argc'
+    // and 'argv' themselves will all fit in a single stack page.
+    if ((void*) (argv_store - 2) < (void*) UTEMP)
+	return -E_NO_MEM;
+
+    // Allocate the single stack page at UTEMP.
+    if ((r = sys_page_alloc(0, (void*) UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
+	return r;
 
-	// After completing the stack, map it into the child's address space
-	// and unmap it from ours!
-	if ((r = sys_page_map(0, UTEMP, child, (void*) (USTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
-		goto error;
-	if ((r = sys_page_unmap(0, UTEMP)) < 0)
-		goto error;
 
-	return 0;
+    //	* Initialize 'argv_store[i]' to point to argument string i,
+    //	  for all 0 <= i < argc.
+    //	  Also, copy the argument strings from 'argv' into the
+    //	  newly-allocated stack page.
+    //
+    //	* Set 'argv_store[argc]' to 0 to null-terminate the args array.
+    //
+    //	* Push two more words onto the child's stack below 'args',
+    //	  containing the argc and argv parameters to be passed
+    //	  to the child's umain() function.
+    //	  argv should be below argc on the stack.
+    //	  (Again, argv should use an address valid in the child's
+    //	  environment.)
+    //
+    //	* Set *init_esp to the initial stack pointer for the child,
+    //	  (Again, use an address valid in the child's environment.)
+    for (i = 0; i < argc; i++) {
+	argv_store[i] = UTEMP2USTACK(string_store);
+	strcpy(string_store, argv[i]);
+	string_store += strlen(argv[i]) + 1;
+    }
+    argv_store[argc] = 0;
+    assert(string_store == (char*)UTEMP + PGSIZE);
+
+    argv_store[-1] = UTEMP2USTACK(argv_store);
+    argv_store[-2] = argc;
+
+    *init_esp = UTEMP2USTACK(&argv_store[-2]);
+
+    // After completing the stack, map it into the child's address space
+    // and unmap it from ours!
+    if ((r = sys_page_map(0, UTEMP, child, (void*) (USTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
+	goto error;
+    if ((r = sys_page_unmap(0, UTEMP)) < 0)
+	goto error;
+
+    return 0;
 
 error:
-	sys_page_unmap(0, UTEMP);
-	return r;
+    sys_page_unmap(0, UTEMP);
+    return r;
 }
 
-static int
+    static int
 map_segment(envid_t child, uintptr_t va, size_t memsz,
 	int fd, size_t filesz, off_t fileoffset, int perm)
 {
-	int i, r;
-	void *blk;
-
-	//cprintf("map_segment %x+%x\n", va, memsz);
-
-	if ((i = PGOFF(va))) {
-		va -= i;
-		memsz += i;
-		filesz += i;
-		fileoffset -= i;
-	}
-
-	for (i = 0; i < memsz; i += PGSIZE) {
-		if (i >= filesz) {
-			// allocate a blank page
-			if ((r = sys_page_alloc(child, (void*) (va + i), perm)) < 0)
-				return r;
-		} else {
-			// from file
-			if ((r = sys_page_alloc(0, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
-				return r;
-			if ((r = seek(fd, fileoffset + i)) < 0)
-				return r;
-			if ((r = readn(fd, UTEMP, MIN(PGSIZE, filesz-i))) < 0)
-				return r;
-			if ((r = sys_page_map(0, UTEMP, child, (void*) (va + i), perm)) < 0)
-				panic("spawn: sys_page_map data: %e", r);
-			sys_page_unmap(0, UTEMP);
-		}
+    int i, r;
+    void *blk;
+
+    //cprintf("map_segment %x+%x\n", va, memsz);
+
+    if ((i = PGOFF(va))) {
+	va -= i;
+	memsz += i;
+	filesz += i;
+	fileoffset -= i;
+    }
+
+    for (i = 0; i < memsz; i += PGSIZE) {
+	if (i >= filesz) {
+	    // allocate a blank page
+	    if ((r = sys_page_alloc(child, (void*) (va + i), perm)) < 0)
+		return r;
+	} else {
+	    // from file
+	    if ((r = sys_page_alloc(0, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
+		return r;
+	    if ((r = seek(fd, fileoffset + i)) < 0)
+		return r;
+	    if ((r = readn(fd, UTEMP, MIN(PGSIZE, filesz-i))) < 0)
+		return r;
+	    if ((r = sys_page_map(0, UTEMP, child, (void*) (va + i), perm)) < 0)
+		panic("spawn: sys_page_map data: %e", r);
+	    sys_page_unmap(0, UTEMP);
 	}
-	return 0;
+    }
+    return 0;
 }
 
 // Copy the mappings for shared pages into the child address space.
-static int
+    static int
 copy_shared_pages(envid_t child)
 {
-	// LAB 5: Your code here.
-	return 0;
+    // LAB 5: Your code here.
+    uintptr_t p = 0;
+    while (p < UTOP) {
+	if (!uvpd[p >> 22]) {
+	    p += PGSIZE << 10;
+	    continue;
+	}
+	if (p != UXSTACKTOP - PGSIZE && uvpt[p >> 12]) {
+	    int perm = uvpt[p >> 12] & 0xfff;
+	    if (perm & PTE_SHARE)
+		sys_page_map(0, (void*)p, child, (void*)p, perm);
+	}
+	p += PGSIZE;
+    }
+    return 0;
 }
 
diff --git a/tmp/lab1diff.patch b/tmp/lab1diff.patch
new file mode 100644
index 0000000..5964317
--- /dev/null
+++ b/tmp/lab1diff.patch
@@ -0,0 +1,150 @@
+diff --git a/inc/color.h b/inc/color.h
+new file mode 100644
+index 0000000..ed09ec1
+--- /dev/null
++++ b/inc/color.h
+@@ -0,0 +1,3 @@
++int FG_COLOR;
++int BG_COLOR;
++int COLOR;
+diff --git a/kern/console.c b/kern/console.c
+index 7d312a7..aba428e 100644
+--- a/kern/console.c
++++ b/kern/console.c
+@@ -5,6 +5,7 @@
+ #include <inc/kbdreg.h>
+ #include <inc/string.h>
+ #include <inc/assert.h>
++#include <inc/color.h>
+ 
+ #include <kern/console.h>
+ 
+@@ -164,8 +165,7 @@ cga_putc(int c)
+ {
+ 	// if no attribute given, then use black on white
+ 	if (!(c & ~0xFF))
+-		c |= 0x0700;
+-
++	   	c |= COLOR;
+ 	switch (c & 0xff) {
+ 	case '\b':
+ 		if (crt_pos > 0) {
+diff --git a/kern/kdebug.c b/kern/kdebug.c
+index 9547143..a573a6c 100644
+--- a/kern/kdebug.c
++++ b/kern/kdebug.c
+@@ -179,6 +179,9 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
+ 	//	Look at the STABS documentation and <inc/stab.h> to find
+ 	//	which one.
+ 	// Your code here.
++		stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
++		if (lline <= rline) info->eip_line = lline - lfun;
++		else return -1;
+ 
+ 
+ 	// Search backwards from the line number for the relevant filename
+diff --git a/kern/monitor.c b/kern/monitor.c
+index e137e92..db7917c 100644
+--- a/kern/monitor.c
++++ b/kern/monitor.c
+@@ -57,7 +57,29 @@ mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
+ int
+ mon_backtrace(int argc, char **argv, struct Trapframe *tf)
+ {
+-	// Your code here.
++	int *ebp, eip, *old_ebp;
++	int ary[5]={};
++
++	cprintf("Stack backtrace:\n");
++	
++	ebp=(int *)read_ebp();
++	while((int)ebp!=0)
++	{
++		old_ebp=(int *)*(ebp);
++		eip=*(ebp+1);
++		for(int i=0;i<5;++i)
++		{
++			int j=i+2;
++			ary[i]=*(ebp+j);
++		}
++		struct Eipdebuginfo eip_info;
++		debuginfo_eip((uintptr_t)eip, &eip_info);
++		cprintf("\033[16ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,ary[0],ary[1],ary[2],ary[3],ary[4]);
++		cprintf("\033[28	%s:%d:", eip_info.eip_file, eip_info.eip_line);
++		cprintf("\033[3a %.*s+%d\n", eip_info.eip_fn_namelen, eip_info.eip_fn_name, eip - eip_info.eip_fn_addr);
++		ebp=old_ebp;
++	}
++	
+ 	return 0;
+ }
+ 
+diff --git a/lib/printfmt.c b/lib/printfmt.c
+index 28e01c9..50b0aa9 100644
+--- a/lib/printfmt.c
++++ b/lib/printfmt.c
+@@ -7,6 +7,7 @@
+ #include <inc/string.h>
+ #include <inc/stdarg.h>
+ #include <inc/error.h>
++#include <inc/color.h>
+ 
+ /*
+  * Space or zero padding and a field width are supported for the numeric
+@@ -92,6 +93,33 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+ 		while ((ch = *(unsigned char *) fmt++) != '%') {
+ 			if (ch == '\0')
+ 				return;
++			else if(ch == '\033'){
++				if((ch = *(unsigned char *) fmt++) != '[') {
++				    putch(ch, putdat);
++				    continue;
++				}
++				BG_COLOR = *(unsigned char *) fmt++;
++				FG_COLOR = *(unsigned char *) fmt++;
++
++				if(BG_COLOR >= '0' && BG_COLOR <= '9')
++				    BG_COLOR -= '0';
++				else if(BG_COLOR >= 'a' && BG_COLOR <= 'f')
++				    BG_COLOR = BG_COLOR - 'a' + 10;
++				else if(BG_COLOR >= 'A' && BG_COLOR <= 'F')
++				    BG_COLOR = BG_COLOR - 'A' + 10;
++				else BG_COLOR = 0;
++
++				if(FG_COLOR >= '0' && FG_COLOR <= '9')
++				    FG_COLOR -= '0';
++				else if(FG_COLOR >= 'a' && FG_COLOR <= 'f')
++				    FG_COLOR = FG_COLOR - 'a' + 10;
++				else if(FG_COLOR >= 'A' && FG_COLOR <= 'F')
++				    FG_COLOR = FG_COLOR - 'A' + 10;
++				else BG_COLOR = 7;
++
++				COLOR = (BG_COLOR << 12) | (FG_COLOR << 8);
++				continue;
++			}	
+ 			putch(ch, putdat);
+ 		}
+ 
+@@ -205,11 +233,9 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+ 
+ 		// (unsigned) octal
+ 		case 'o':
+-			// Replace this with your code.
+-			putch('X', putdat);
+-			putch('X', putdat);
+-			putch('X', putdat);
+-			break;
++			num = getuint(&ap,lflag);
++			base = 8;
++			goto number;
+ 
+ 		// pointer
+ 		case 'p':
+@@ -231,7 +257,7 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+ 		// escaped '%' character
+ 		case '%':
+ 			putch(ch, putdat);
+-			break;
++			break;			
+ 
+ 		// unrecognized escape sequence - just print it literally
+ 		default:
diff --git a/user/breakpoint.c b/user/breakpoint.c
index 47e4cb2..f122d6b 100644
--- a/user/breakpoint.c
+++ b/user/breakpoint.c
@@ -2,9 +2,16 @@
 
 #include <inc/lib.h>
 
-void
+    void
 umain(int argc, char **argv)
 {
-	asm volatile("int $3");
+    asm volatile("int $3");
+    asm volatile("movl $0, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+    asm volatile("addl $1, %eax");
+
 }
 
diff --git a/user/faultio.c b/user/faultio.c
index 4308a65..3a33579 100644
--- a/user/faultio.c
+++ b/user/faultio.c
@@ -11,8 +11,8 @@ umain(int argc, char **argv)
 	int secno = 0;
 	int diskno = 1;
 
-	if (read_eflags() & FL_IOPL_3)
-		cprintf("eflags wrong\n");
+	if (read_eflags() & FL_IOPL_3){
+	    cprintf("eflags wrong\n");}
 
 	// this outb to select disk 1 should result in a general protection
 	// fault, because user-level code shouldn't be able to use the io space.
diff --git a/user/sh.c b/user/sh.c
index 26f501a..95bf71e 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -18,157 +18,164 @@ int gettoken(char *s, char **token);
 // runcmd() is called in a forked child,
 // so it's OK to manipulate file descriptor state.
 #define MAXARGS 16
-void
+    void
 runcmd(char* s)
 {
-	char *argv[MAXARGS], *t, argv0buf[BUFSIZ];
-	int argc, c, i, r, p[2], fd, pipe_child;
+    char *argv[MAXARGS], *t, argv0buf[BUFSIZ];
+    int argc, c, i, r, p[2], fd, pipe_child;
 
-	pipe_child = 0;
-	gettoken(s, 0);
+    pipe_child = 0;
+    gettoken(s, 0);
 
 again:
-	argc = 0;
-	while (1) {
-		switch ((c = gettoken(0, &t))) {
-
-		case 'w':	// Add an argument
-			if (argc == MAXARGS) {
-				cprintf("too many arguments\n");
-				exit();
-			}
-			argv[argc++] = t;
-			break;
-
-		case '<':	// Input redirection
-			// Grab the filename from the argument list
-			if (gettoken(0, &t) != 'w') {
-				cprintf("syntax error: < not followed by word\n");
-				exit();
-			}
-			// Open 't' for reading as file descriptor 0
-			// (which environments use as standard input).
-			// We can't open a file onto a particular descriptor,
-			// so open the file as 'fd',
-			// then check whether 'fd' is 0.
-			// If not, dup 'fd' onto file descriptor 0,
-			// then close the original 'fd'.
-
-			// LAB 5: Your code here.
-			panic("< redirection not implemented");
-			break;
-
-		case '>':	// Output redirection
-			// Grab the filename from the argument list
-			if (gettoken(0, &t) != 'w') {
-				cprintf("syntax error: > not followed by word\n");
-				exit();
-			}
-			if ((fd = open(t, O_WRONLY|O_CREAT|O_TRUNC)) < 0) {
-				cprintf("open %s for write: %e", t, fd);
-				exit();
-			}
-			if (fd != 1) {
-				dup(fd, 1);
-				close(fd);
-			}
-			break;
-
-		case '|':	// Pipe
-			if ((r = pipe(p)) < 0) {
-				cprintf("pipe: %e", r);
-				exit();
-			}
-			if (debug)
-				cprintf("PIPE: %d %d\n", p[0], p[1]);
-			if ((r = fork()) < 0) {
-				cprintf("fork: %e", r);
-				exit();
-			}
-			if (r == 0) {
-				if (p[0] != 0) {
-					dup(p[0], 0);
-					close(p[0]);
-				}
-				close(p[1]);
-				goto again;
-			} else {
-				pipe_child = r;
-				if (p[1] != 1) {
-					dup(p[1], 1);
-					close(p[1]);
-				}
-				close(p[0]);
-				goto runit;
-			}
-			panic("| not implemented");
-			break;
-
-		case 0:		// String is complete
-			// Run the current command!
-			goto runit;
-
-		default:
-			panic("bad return %d from gettoken", c);
-			break;
+    argc = 0;
+    while (1) {
+	switch ((c = gettoken(0, &t))) {
+
+	    case 'w':	// Add an argument
+		if (argc == MAXARGS) {
+		    cprintf("too many arguments\n");
+		    exit();
+		}
+		argv[argc++] = t;
+		break;
+
+	    case '<':	// Input redirection
+		// Grab the filename from the argument list
+		if (gettoken(0, &t) != 'w') {
+		    cprintf("syntax error: < not followed by word\n");
+		    exit();
+		}
+		// Open 't' for reading as file descriptor 0
+		// (which environments use as standard input).
+		// We can't open a file onto a particular descriptor,
+		// so open the file as 'fd',
+		// then check whether 'fd' is 0.
+		// If not, dup 'fd' onto file descriptor 0,
+		// then close the original 'fd'.
+
+		// LAB 5: Your code here.
+		if ((fd = open(t, O_RDONLY)) < 0) {
+		    cprintf("open %s for read: %e", t, fd);
+		    exit();
+		}
+		if (fd != 0) {
+		    dup(fd, 0);
+		    close(fd);
+		}
+		break;
 
+	    case '>':	// Output redirection
+		// Grab the filename from the argument list
+		if (gettoken(0, &t) != 'w') {
+		    cprintf("syntax error: > not followed by word\n");
+		    exit();
 		}
-	}
+		if ((fd = open(t, O_WRONLY|O_CREAT|O_TRUNC)) < 0) {
+		    cprintf("open %s for write: %e", t, fd);
+		    exit();
+		}
+		if (fd != 1) {
+		    dup(fd, 1);
+		    close(fd);
+		}
+		break;
 
-runit:
-	// Return immediately if command line was empty.
-	if(argc == 0) {
+	    case '|':	// Pipe
+		if ((r = pipe(p)) < 0) {
+		    cprintf("pipe: %e", r);
+		    exit();
+		}
 		if (debug)
-			cprintf("EMPTY COMMAND\n");
-		return;
-	}
-
-	// Clean up command line.
-	// Read all commands from the filesystem: add an initial '/' to
-	// the command name.
-	// This essentially acts like 'PATH=/'.
-	if (argv[0][0] != '/') {
-		argv0buf[0] = '/';
-		strcpy(argv0buf + 1, argv[0]);
-		argv[0] = argv0buf;
-	}
-	argv[argc] = 0;
-
-	// Print the command.
-	if (debug) {
-		cprintf("[%08x] SPAWN:", thisenv->env_id);
-		for (i = 0; argv[i]; i++)
-			cprintf(" %s", argv[i]);
-		cprintf("\n");
-	}
+		    cprintf("PIPE: %d %d\n", p[0], p[1]);
+		if ((r = fork()) < 0) {
+		    cprintf("fork: %e", r);
+		    exit();
+		}
+		if (r == 0) {
+		    if (p[0] != 0) {
+			dup(p[0], 0);
+			close(p[0]);
+		    }
+		    close(p[1]);
+		    goto again;
+		} else {
+		    pipe_child = r;
+		    if (p[1] != 1) {
+			dup(p[1], 1);
+			close(p[1]);
+		    }
+		    close(p[0]);
+		    goto runit;
+		}
+		panic("| not implemented");
+		break;
 
-	// Spawn the command!
-	if ((r = spawn(argv[0], (const char**) argv)) < 0)
-		cprintf("spawn %s: %e\n", argv[0], r);
+	    case 0:		// String is complete
+		// Run the current command!
+		goto runit;
 
-	// In the parent, close all file descriptors and wait for the
-	// spawned command to exit.
-	close_all();
-	if (r >= 0) {
-		if (debug)
-			cprintf("[%08x] WAIT %s %08x\n", thisenv->env_id, argv[0], r);
-		wait(r);
-		if (debug)
-			cprintf("[%08x] wait finished\n", thisenv->env_id);
-	}
+	    default:
+		panic("bad return %d from gettoken", c);
+		break;
 
-	// If we were the left-hand part of a pipe,
-	// wait for the right-hand part to finish.
-	if (pipe_child) {
-		if (debug)
-			cprintf("[%08x] WAIT pipe_child %08x\n", thisenv->env_id, pipe_child);
-		wait(pipe_child);
-		if (debug)
-			cprintf("[%08x] wait finished\n", thisenv->env_id);
 	}
+    }
 
-	// Done!
-	exit();
+runit:
+    // Return immediately if command line was empty.
+    if(argc == 0) {
+	if (debug)
+	    cprintf("EMPTY COMMAND\n");
+	return;
+    }
+
+    // Clean up command line.
+    // Read all commands from the filesystem: add an initial '/' to
+    // the command name.
+    // This essentially acts like 'PATH=/'.
+    if (argv[0][0] != '/') {
+	argv0buf[0] = '/';
+	strcpy(argv0buf + 1, argv[0]);
+	argv[0] = argv0buf;
+    }
+    argv[argc] = 0;
+
+    // Print the command.
+    if (debug) {
+	cprintf("[%08x] SPAWN:", thisenv->env_id);
+	for (i = 0; argv[i]; i++)
+	    cprintf(" %s", argv[i]);
+	cprintf("\n");
+    }
+
+    // Spawn the command!
+    if ((r = spawn(argv[0], (const char**) argv)) < 0)
+	cprintf("spawn %s: %e\n", argv[0], r);
+
+    // In the parent, close all file descriptors and wait for the
+    // spawned command to exit.
+    close_all();
+    if (r >= 0) {
+	if (debug)
+	    cprintf("[%08x] WAIT %s %08x\n", thisenv->env_id, argv[0], r);
+	wait(r);
+	if (debug)
+	    cprintf("[%08x] wait finished\n", thisenv->env_id);
+    }
+
+    // If we were the left-hand part of a pipe,
+    // wait for the right-hand part to finish.
+    if (pipe_child) {
+	if (debug)
+	    cprintf("[%08x] WAIT pipe_child %08x\n", thisenv->env_id, pipe_child);
+	wait(pipe_child);
+	if (debug)
+	    cprintf("[%08x] wait finished\n", thisenv->env_id);
+    }
+
+    // Done!
+    exit();
 }
 
 
@@ -186,137 +193,137 @@ runit:
 #define WHITESPACE " \t\r\n"
 #define SYMBOLS "<|>&;()"
 
-int
+    int
 _gettoken(char *s, char **p1, char **p2)
 {
-	int t;
-
-	if (s == 0) {
-		if (debug > 1)
-			cprintf("GETTOKEN NULL\n");
-		return 0;
-	}
+    int t;
 
+    if (s == 0) {
 	if (debug > 1)
-		cprintf("GETTOKEN: %s\n", s);
+	    cprintf("GETTOKEN NULL\n");
+	return 0;
+    }
 
-	*p1 = 0;
-	*p2 = 0;
+    if (debug > 1)
+	cprintf("GETTOKEN: %s\n", s);
 
-	while (strchr(WHITESPACE, *s))
-		*s++ = 0;
-	if (*s == 0) {
-		if (debug > 1)
-			cprintf("EOL\n");
-		return 0;
-	}
-	if (strchr(SYMBOLS, *s)) {
-		t = *s;
-		*p1 = s;
-		*s++ = 0;
-		*p2 = s;
-		if (debug > 1)
-			cprintf("TOK %c\n", t);
-		return t;
-	}
+    *p1 = 0;
+    *p2 = 0;
+
+    while (strchr(WHITESPACE, *s))
+	*s++ = 0;
+    if (*s == 0) {
+	if (debug > 1)
+	    cprintf("EOL\n");
+	return 0;
+    }
+    if (strchr(SYMBOLS, *s)) {
+	t = *s;
 	*p1 = s;
-	while (*s && !strchr(WHITESPACE SYMBOLS, *s))
-		s++;
+	*s++ = 0;
 	*p2 = s;
-	if (debug > 1) {
-		t = **p2;
-		**p2 = 0;
-		cprintf("WORD: %s\n", *p1);
-		**p2 = t;
-	}
-	return 'w';
+	if (debug > 1)
+	    cprintf("TOK %c\n", t);
+	return t;
+    }
+    *p1 = s;
+    while (*s && !strchr(WHITESPACE SYMBOLS, *s))
+	s++;
+    *p2 = s;
+    if (debug > 1) {
+	t = **p2;
+	**p2 = 0;
+	cprintf("WORD: %s\n", *p1);
+	**p2 = t;
+    }
+    return 'w';
 }
 
-int
+    int
 gettoken(char *s, char **p1)
 {
-	static int c, nc;
-	static char* np1, *np2;
-
-	if (s) {
-		nc = _gettoken(s, &np1, &np2);
-		return 0;
-	}
-	c = nc;
-	*p1 = np1;
-	nc = _gettoken(np2, &np1, &np2);
-	return c;
+    static int c, nc;
+    static char* np1, *np2;
+
+    if (s) {
+	nc = _gettoken(s, &np1, &np2);
+	return 0;
+    }
+    c = nc;
+    *p1 = np1;
+    nc = _gettoken(np2, &np1, &np2);
+    return c;
 }
 
 
-void
+    void
 usage(void)
 {
-	cprintf("usage: sh [-dix] [command-file]\n");
-	exit();
+    cprintf("usage: sh [-dix] [command-file]\n");
+    exit();
 }
 
-void
+    void
 umain(int argc, char **argv)
 {
-	int r, interactive, echocmds;
-	struct Argstate args;
-
-	interactive = '?';
-	echocmds = 0;
-	argstart(&argc, argv, &args);
-	while ((r = argnext(&args)) >= 0)
-		switch (r) {
-		case 'd':
-			debug++;
-			break;
-		case 'i':
-			interactive = 1;
-			break;
-		case 'x':
-			echocmds = 1;
-			break;
-		default:
-			usage();
-		}
-
-	if (argc > 2)
+    int r, interactive, echocmds;
+    struct Argstate args;
+
+    interactive = '?';
+    echocmds = 0;
+    argstart(&argc, argv, &args);
+    while ((r = argnext(&args)) >= 0)
+	switch (r) {
+	    case 'd':
+		debug++;
+		break;
+	    case 'i':
+		interactive = 1;
+		break;
+	    case 'x':
+		echocmds = 1;
+		break;
+	    default:
 		usage();
-	if (argc == 2) {
-		close(0);
-		if ((r = open(argv[1], O_RDONLY)) < 0)
-			panic("open %s: %e", argv[1], r);
-		assert(r == 0);
 	}
-	if (interactive == '?')
-		interactive = iscons(0);
-
-	while (1) {
-		char *buf;
 
-		buf = readline(interactive ? "$ " : NULL);
-		if (buf == NULL) {
-			if (debug)
-				cprintf("EXITING\n");
-			exit();	// end of file
-		}
-		if (debug)
-			cprintf("LINE: %s\n", buf);
-		if (buf[0] == '#')
-			continue;
-		if (echocmds)
-			printf("# %s\n", buf);
-		if (debug)
-			cprintf("BEFORE FORK\n");
-		if ((r = fork()) < 0)
-			panic("fork: %e", r);
-		if (debug)
-			cprintf("FORK: %d\n", r);
-		if (r == 0) {
-			runcmd(buf);
-			exit();
-		} else
-			wait(r);
+    if (argc > 2)
+	usage();
+    if (argc == 2) {
+	close(0);
+	if ((r = open(argv[1], O_RDONLY)) < 0)
+	    panic("open %s: %e", argv[1], r);
+	assert(r == 0);
+    }
+    if (interactive == '?')
+	interactive = iscons(0);
+
+    while (1) {
+	char *buf;
+
+	buf = readline(interactive ? "$ " : NULL);
+	if (buf == NULL) {
+	    if (debug)
+		cprintf("EXITING\n");
+	    exit();	// end of file
 	}
+	if (debug)
+	    cprintf("LINE: %s\n", buf);
+	if (buf[0] == '#')
+	    continue;
+	if (echocmds)
+	    printf("# %s\n", buf);
+	if (debug)
+	    cprintf("BEFORE FORK\n");
+	if ((r = fork()) < 0)
+	    panic("fork: %e", r);
+	if (debug)
+	    cprintf("FORK: %d\n", r);
+	if (r == 0) {
+	    runcmd(buf);
+	    exit();
+	} else
+	    wait(r);
+    }
 }
 
